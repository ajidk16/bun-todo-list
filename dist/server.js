// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
}

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  StreamReader = class StreamReader extends AbstractStreamReader {
    constructor(s) {
      super();
      this.s = s;
      this.deferred = null;
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.resolve(0);
        }
      });
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.abort());
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const readBuffer = this.s.read(buffer.length);
      if (readBuffer) {
        buffer.set(readBuffer);
        return readBuffer.length;
      }
      const request = {
        buffer,
        mayBeLess,
        deferred: new Deferred
      };
      this.deferred = request.deferred;
      this.s.once("readable", () => {
        this.readDeferred(request);
      });
      return request.deferred.promise;
    }
    readDeferred(request) {
      const readBuffer = this.s.read(request.buffer.length);
      if (readBuffer) {
        request.buffer.set(readBuffer);
        request.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request);
        });
      }
    }
    reject(err) {
      this.interrupted = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
    async abort() {
      this.reject(new AbortError);
    }
    async close() {
      return this.abort();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer, this.buffer);
      }
      while (totalBytesRead < buffer.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error) {
    if (error instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromStream(stream, options) {
  const streamReader = new StreamReader(stream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "fs/promises";
async function fromStream2(stream, options) {
  const rst = fromStream(stream, options);
  if (stream.path) {
    const stat = await fsStat(stream.path);
    rst.fileInfo.path = stream.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/@borewit/text-codec/lib/index.js
function textDecode(bytes, encoding = "utf-8") {
  switch (encoding.toLowerCase()) {
    case "utf-8":
    case "utf8":
      if (typeof globalThis.TextDecoder !== "undefined") {
        return new globalThis.TextDecoder("utf-8").decode(bytes);
      }
      return decodeUTF8(bytes);
    case "utf-16le":
      return decodeUTF16LE(bytes);
    case "ascii":
      return decodeASCII(bytes);
    case "latin1":
    case "iso-8859-1":
      return decodeLatin1(bytes);
    case "windows-1252":
      return decodeWindows1252(bytes);
    default:
      throw new RangeError(`Encoding '${encoding}' not supported`);
  }
}
function decodeUTF8(bytes) {
  let out = "";
  let i = 0;
  while (i < bytes.length) {
    const b1 = bytes[i++];
    if (b1 < 128) {
      out += String.fromCharCode(b1);
    } else if (b1 < 224) {
      const b2 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 31) << 6 | b2);
    } else if (b1 < 240) {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
    } else {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      const b4 = bytes[i++] & 63;
      let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
      cp -= 65536;
      out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
    }
  }
  return out;
}
function decodeUTF16LE(bytes) {
  let out = "";
  for (let i = 0;i < bytes.length; i += 2) {
    out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
  }
  return out;
}
function decodeASCII(bytes) {
  return String.fromCharCode(...bytes.map((b) => b & 127));
}
function decodeLatin1(bytes) {
  return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
  let out = "";
  for (const b of bytes) {
    if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
      out += WINDOWS_1252_EXTRA[b];
    } else {
      out += String.fromCharCode(b);
    }
  }
  return out;
}
var WINDOWS_1252_EXTRA, WINDOWS_1252_REVERSE;
var init_lib2 = __esm(() => {
  WINDOWS_1252_EXTRA = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  WINDOWS_1252_REVERSE = {};
  for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
  }
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}

class StringType2 {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return textDecode(bytes, this.encoding);
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib3 = __esm(() => {
  init_ieee754();
  init_lib2();
  UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
});

// node_modules/fflate/esm/index.mjs
import { createRequire } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm = __esm(() => {
  require2 = createRequire("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {}
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {}
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib3();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i2 = buffer.length - 4;i2 >= 0; i2--) {
      if (buffer[i2] === eocdSignatureBytes[0] && buffer[i2 + 1] === eocdSignatureBytes[1] && buffer[i2 + 2] === eocdSignatureBytes[2] && buffer[i2 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i2;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i2 = 0;i2 <= bufferLength - portionLength; i2++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i2 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i2;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib4 = __esm(() => {
  init_lib3();
  init_esm();
  import_debug = __toESM(require_src(), 1);
  init_ZipToken();
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib3();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
  return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
  return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error) {
          if (!(error instanceof EndOfStreamError)) {
            throw error;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {}
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib3();
  init_core();
  init_lib4();
  init_uint8array_extras();
  init_util();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => supportedMimeTypes,
  supportedExtensions: () => supportedExtensions,
  fileTypeStream: () => fileTypeStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromBlob: () => fileTypeFromBlob,
  FileTypeParser: () => FileTypeParser2
});
import { ReadableStream as WebReadableStream } from "stream/web";
import { pipeline, PassThrough, Readable } from "stream";
async function fileTypeFromFile(path, options) {
  return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream, options) {
  return new FileTypeParser2(options).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
  init_core2();
  FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
    async fromStream(stream) {
      const tokenizer = await (stream instanceof WebReadableStream ? fromWebStream(stream, this.tokenizerOptions) : fromStream2(stream, this.tokenizerOptions));
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async fromFile(path) {
      const tokenizer = await fromFile(path);
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(readableStream, options = {}) {
      if (!(readableStream instanceof Readable)) {
        return super.toDetectionStream(readableStream, options);
      }
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      return new Promise((resolve, reject) => {
        readableStream.on("error", reject);
        readableStream.once("readable", () => {
          (async () => {
            try {
              const pass = new PassThrough;
              const outputStream = pipeline ? pipeline(readableStream, pass, () => {}) : readableStream.pipe(pass);
              const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
              try {
                pass.fileType = await this.fromBuffer(chunk);
              } catch (error) {
                if (error instanceof EndOfStreamError) {
                  pass.fileType = undefined;
                } else {
                  reject(error);
                }
              }
              resolve(outputStream);
            } catch (error) {
              reject(error);
            }
          })();
        });
      });
    }
  };
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  (function() {
    function defineDeprecationWarning(methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function() {
          console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
        }
      });
    }
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function warnNoop(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
    }
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function ComponentDummy() {}
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    function noop3() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion(value);
      }
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE)
        return "<...>";
      try {
        var name = getComponentNameFromType(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config2) {
      if (hasOwnProperty.call(config2, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config2.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      newKey = ReactElement(oldElement.type, newKey, oldElement.props, oldElement._owner, oldElement._debugStack, oldElement._debugTask);
      oldElement._store && (newKey._store.validated = oldElement._store.validated);
      return newKey;
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object2) {
      return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape2(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    function getElementKey(element, index) {
      return typeof element === "object" && element !== null && element.key != null ? (checkKeyStringCoercion(element.key), escape2("" + element.key)) : index.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch (typeof thenable.status === "string" ? thenable.then(noop3, noop3) : (thenable.status = "pending", thenable.then(function(fulfilledValue) {
            thenable.status === "pending" && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          }, function(error40) {
            thenable.status === "pending" && (thenable.status = "rejected", thenable.reason = error40);
          })), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if (type === "undefined" || type === "boolean")
        children = null;
      var invokeCallback = false;
      if (children === null)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array2, escapedPrefix, nameSoFar, callback);
            }
        }
      if (invokeCallback) {
        invokeCallback = children;
        callback = callback(invokeCallback);
        var childKey = nameSoFar === "" ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
        isArrayImpl(callback) ? (escapedPrefix = "", childKey != null && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array2, escapedPrefix, "", function(c) {
          return c;
        })) : callback != null && (isValidElement(callback) && (callback.key != null && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (callback.key == null || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), nameSoFar !== "" && invokeCallback != null && isValidElement(invokeCallback) && invokeCallback.key == null && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array2.push(callback));
        return 1;
      }
      invokeCallback = 0;
      childKey = nameSoFar === "" ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i2 = 0;i2 < children.length; i2++)
          nameSoFar = children[i2], type = childKey + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(nameSoFar, array2, escapedPrefix, type, callback);
      else if (i2 = getIteratorFn(children), typeof i2 === "function")
        for (i2 === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true), children = i2.call(children), i2 = 0;!(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(nameSoFar, array2, escapedPrefix, type, callback);
      else if (type === "object") {
        if (typeof children.then === "function")
          return mapIntoArray(resolveThenable(children), array2, escapedPrefix, nameSoFar, callback);
        array2 = String(children);
        throw Error("Objects are not valid as a React child (found: " + (array2 === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : array2) + "). If you meant to render a collection of children, use an array instead.");
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (children == null)
        return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (payload._status === -1) {
        var ioInfo = payload._ioInfo;
        ioInfo != null && (ioInfo.start = ioInfo.end = performance.now());
        ioInfo = payload._result;
        var thenable = ioInfo();
        thenable.then(function(moduleObject) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 1;
            payload._result = moduleObject;
            var _ioInfo = payload._ioInfo;
            _ioInfo != null && (_ioInfo.end = performance.now());
            thenable.status === undefined && (thenable.status = "fulfilled", thenable.value = moduleObject);
          }
        }, function(error40) {
          if (payload._status === 0 || payload._status === -1) {
            payload._status = 2;
            payload._result = error40;
            var _ioInfo2 = payload._ioInfo;
            _ioInfo2 != null && (_ioInfo2.end = performance.now());
            thenable.status === undefined && (thenable.status = "rejected", thenable.reason = error40);
          }
        });
        ioInfo = payload._ioInfo;
        if (ioInfo != null) {
          ioInfo.value = thenable;
          var displayName = thenable.displayName;
          typeof displayName === "string" && (ioInfo.name = displayName);
        }
        payload._status === -1 && (payload._status = 0, payload._result = thenable);
      }
      if (payload._status === 1)
        return ioInfo = payload._result, ioInfo === undefined && console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, ioInfo), "default" in ioInfo || console.error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, ioInfo), ioInfo.default;
      throw payload._result;
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    function releaseAsyncTransition() {
      ReactSharedInternals.asyncTransitions--;
    }
    function enqueueTask(task) {
      if (enqueueTaskImpl === null)
        try {
          var requireString = ("require" + Math.random()).slice(0, 7);
          enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
        } catch (_err) {
          enqueueTaskImpl = function(callback) {
            didWarnAboutMessageChannel === false && (didWarnAboutMessageChannel = true, typeof MessageChannel === "undefined" && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
            var channel = new MessageChannel;
            channel.port1.onmessage = callback;
            channel.port2.postMessage(undefined);
          };
        }
      return enqueueTaskImpl(task);
    }
    function aggregateErrors(errors3) {
      return 1 < errors3.length && typeof AggregateError === "function" ? new AggregateError(errors3) : errors3[0];
    }
    function popActScope(prevActQueue, prevActScopeDepth) {
      prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
      actScopeDepth = prevActScopeDepth;
    }
    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
      var queue = ReactSharedInternals.actQueue;
      if (queue !== null)
        if (queue.length !== 0)
          try {
            flushActQueue(queue);
            enqueueTask(function() {
              return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            });
            return;
          } catch (error40) {
            ReactSharedInternals.thrownErrors.push(error40);
          }
        else
          ReactSharedInternals.actQueue = null;
      0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
    }
    function flushActQueue(queue) {
      if (!isFlushing) {
        isFlushing = true;
        var i2 = 0;
        try {
          for (;i2 < queue.length; i2++) {
            var callback = queue[i2];
            do {
              ReactSharedInternals.didUsePromise = false;
              var continuation = callback(false);
              if (continuation !== null) {
                if (ReactSharedInternals.didUsePromise) {
                  queue[i2] = callback;
                  queue.splice(0, i2);
                  return;
                }
                callback = continuation;
              } else
                break;
            } while (1);
          }
          queue.length = 0;
        } catch (error40) {
          queue.splice(0, i2 + 1), ReactSharedInternals.thrownErrors.push(error40);
        } finally {
          isFlushing = false;
        }
      }
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function(publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function(publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function(publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    }, assign = Object.assign, emptyObject = {};
    Object.freeze(emptyObject);
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    var deprecatedAPIs = {
      isMounted: [
        "isMounted",
        "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
      ],
      replaceState: [
        "replaceState",
        "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
      ]
    };
    for (fnName in deprecatedAPIs)
      deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    ComponentDummy.prototype = Component.prototype;
    deprecatedAPIs = PureComponent.prototype = new ComponentDummy;
    deprecatedAPIs.constructor = PureComponent;
    assign(deprecatedAPIs, Component.prototype);
    deprecatedAPIs.isPureReactComponent = true;
    var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      actQueue: null,
      asyncTransitions: 0,
      isBatchingLegacy: false,
      didScheduleLegacyUpdate: false,
      didUsePromise: false,
      thrownErrors: [],
      getCurrentStack: null,
      recentlyCreatedOwnerStacks: 0
    }, hasOwnProperty = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    deprecatedAPIs = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(deprecatedAPIs, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = typeof reportError === "function" ? reportError : function(error40) {
      if (typeof window === "object" && typeof window.ErrorEvent === "function") {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof error40 === "object" && error40 !== null && typeof error40.message === "string" ? String(error40.message) : String(error40),
          error: error40
        });
        if (!window.dispatchEvent(event))
          return;
      } else if (typeof process === "object" && typeof process.emit === "function") {
        process.emit("uncaughtException", error40);
        return;
      }
      console.error(error40);
    }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = typeof queueMicrotask === "function" ? function(callback) {
      queueMicrotask(function() {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
    deprecatedAPIs = Object.freeze({
      __proto__: null,
      c: function(size2) {
        return resolveDispatcher().useMemoCache(size2);
      }
    });
    var fnName = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error("React.Children.only expected to receive a single React element child.");
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = fnName;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = deprecatedAPIs;
    exports.act = function(callback) {
      var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
      actScopeDepth++;
      var queue = ReactSharedInternals.actQueue = prevActQueue !== null ? prevActQueue : [], didAwaitActCall = false;
      try {
        var result = callback();
      } catch (error40) {
        ReactSharedInternals.thrownErrors.push(error40);
      }
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      if (result !== null && typeof result === "object" && typeof result.then === "function") {
        var thenable = result;
        queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        });
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            thenable.then(function(returnValue) {
              popActScope(prevActQueue, prevActScopeDepth);
              if (prevActScopeDepth === 0) {
                try {
                  flushActQueue(queue), enqueueTask(function() {
                    return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  });
                } catch (error$0) {
                  ReactSharedInternals.thrownErrors.push(error$0);
                }
                if (0 < ReactSharedInternals.thrownErrors.length) {
                  var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                  ReactSharedInternals.thrownErrors.length = 0;
                  reject(_thrownError);
                }
              } else
                resolve(returnValue);
            }, function(error40) {
              popActScope(prevActQueue, prevActScopeDepth);
              0 < ReactSharedInternals.thrownErrors.length ? (error40 = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error40)) : reject(error40);
            });
          }
        };
      }
      var returnValue$jscomp$0 = result;
      popActScope(prevActQueue, prevActScopeDepth);
      prevActScopeDepth === 0 && (flushActQueue(queue), queue.length !== 0 && queueSeveralMicrotasks(function() {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), ReactSharedInternals.actQueue = null);
      if (0 < ReactSharedInternals.thrownErrors.length)
        throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
      return {
        then: function(resolve, reject) {
          didAwaitActCall = true;
          prevActScopeDepth === 0 ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
            return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
          })) : resolve(returnValue$jscomp$0);
        }
      };
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.captureOwnerStack = function() {
      var getCurrentStack = ReactSharedInternals.getCurrentStack;
      return getCurrentStack === null ? null : getCurrentStack();
    };
    exports.cloneElement = function(element, config2, children) {
      if (element === null || element === undefined)
        throw Error("The argument must be a React element, but you passed " + element + ".");
      var props = assign({}, element.props), key = element.key, owner = element._owner;
      if (config2 != null) {
        var JSCompiler_inline_result;
        a: {
          if (hasOwnProperty.call(config2, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config2, "ref").get) && JSCompiler_inline_result.isReactWarning) {
            JSCompiler_inline_result = false;
            break a;
          }
          JSCompiler_inline_result = config2.ref !== undefined;
        }
        JSCompiler_inline_result && (owner = getOwner());
        hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key);
        for (propName in config2)
          !hasOwnProperty.call(config2, propName) || propName === "key" || propName === "__self" || propName === "__source" || propName === "ref" && config2.ref === undefined || (props[propName] = config2[propName]);
      }
      var propName = arguments.length - 2;
      if (propName === 1)
        props.children = children;
      else if (1 < propName) {
        JSCompiler_inline_result = Array(propName);
        for (var i2 = 0;i2 < propName; i2++)
          JSCompiler_inline_result[i2] = arguments[i2 + 2];
        props.children = JSCompiler_inline_result;
      }
      props = ReactElement(element.type, key, props, owner, element._debugStack, element._debugTask);
      for (key = 2;key < arguments.length; key++)
        validateChildKeys(arguments[key]);
      return props;
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      defaultValue._currentRenderer = null;
      defaultValue._currentRenderer2 = null;
      return defaultValue;
    };
    exports.createElement = function(type, config2, children) {
      for (var i2 = 2;i2 < arguments.length; i2++)
        validateChildKeys(arguments[i2]);
      i2 = {};
      var key = null;
      if (config2 != null)
        for (propName in didWarnAboutOldJSXRuntime || !("__self" in config2) || "key" in config2 || (didWarnAboutOldJSXRuntime = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config2) && (checkKeyStringCoercion(config2.key), key = "" + config2.key), config2)
          hasOwnProperty.call(config2, propName) && propName !== "key" && propName !== "__self" && propName !== "__source" && (i2[propName] = config2[propName]);
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1)
        i2.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), _i = 0;_i < childrenLength; _i++)
          childArray[_i] = arguments[_i + 2];
        Object.freeze && Object.freeze(childArray);
        i2.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          i2[propName] === undefined && (i2[propName] = childrenLength[propName]);
      key && defineKeyPropWarningGetter(i2, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
      return ReactElement(type, key, i2, getOwner(), propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack, propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.createRef = function() {
      var refObject = { current: null };
      Object.seal(refObject);
      return refObject;
    };
    exports.forwardRef = function(render) {
      render != null && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof render !== "function" ? console.error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render) : render.length !== 0 && render.length !== 2 && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
      render != null && render.defaultProps != null && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
      Object.defineProperty(elementType, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
        }
      });
      return elementType;
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      ctor = { _status: -1, _result: ctor };
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _payload: ctor,
        _init: lazyInitializer
      }, ioInfo = {
        name: "lazy",
        start: -1,
        end: -1,
        value: null,
        owner: null,
        debugStack: Error("react-stack-top-frame"),
        debugTask: console.createTask ? console.createTask("lazy()") : null
      };
      ctor._ioInfo = ioInfo;
      lazyType._debugInfo = [{ awaited: ioInfo }];
      return lazyType;
    };
    exports.memo = function(type, compare) {
      type == null && console.error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
      compare = {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: compare === undefined ? null : compare
      };
      var ownName;
      Object.defineProperty(compare, "displayName", {
        enumerable: false,
        configurable: true,
        get: function() {
          return ownName;
        },
        set: function(name) {
          ownName = name;
          type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
        }
      });
      return compare;
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      currentTransition._updatedFibers = new Set;
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        onStartTransitionFinish !== null && onStartTransitionFinish(currentTransition, returnValue);
        typeof returnValue === "object" && returnValue !== null && typeof returnValue.then === "function" && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop3, reportGlobalError));
      } catch (error40) {
        reportGlobalError(error40);
      } finally {
        prevTransition === null && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), prevTransition !== null && currentTransition.types !== null && (prevTransition.types !== null && prevTransition.types !== currentTransition.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return resolveDispatcher().useCacheRefresh();
    };
    exports.use = function(usable) {
      return resolveDispatcher().use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return resolveDispatcher().useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return resolveDispatcher().useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      var dispatcher = resolveDispatcher();
      Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
      return dispatcher.useContext(Context);
    };
    exports.useDebugValue = function(value, formatterFn) {
      return resolveDispatcher().useDebugValue(value, formatterFn);
    };
    exports.useDeferredValue = function(value, initialValue) {
      return resolveDispatcher().useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create2, deps) {
      create2 == null && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useEffect(create2, deps);
    };
    exports.useEffectEvent = function(callback) {
      return resolveDispatcher().useEffectEvent(callback);
    };
    exports.useId = function() {
      return resolveDispatcher().useId();
    };
    exports.useImperativeHandle = function(ref, create2, deps) {
      return resolveDispatcher().useImperativeHandle(ref, create2, deps);
    };
    exports.useInsertionEffect = function(create2, deps) {
      create2 == null && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useInsertionEffect(create2, deps);
    };
    exports.useLayoutEffect = function(create2, deps) {
      create2 == null && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?");
      return resolveDispatcher().useLayoutEffect(create2, deps);
    };
    exports.useMemo = function(create2, deps) {
      return resolveDispatcher().useMemo(create2, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return resolveDispatcher().useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return resolveDispatcher().useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return resolveDispatcher().useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return resolveDispatcher().useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    };
    exports.useTransition = function() {
      return resolveDispatcher().useTransition();
    };
    exports.version = "19.2.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development(), 1);
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS((exports) => {
  var React = __toESM(require_react(), 1);
  (function() {
    function noop3() {}
    function testStringCoercion(value) {
      return "" + value;
    }
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && arguments[3] !== undefined ? arguments[3] : null;
      try {
        testStringCoercion(key);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", typeof Symbol === "function" && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: key == null ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    function getCrossOriginStringAs(as, input) {
      if (as === "font")
        return "";
      if (typeof input === "string")
        return input === "use-credentials" ? input : "";
    }
    function getValueDescriptorExpectingObjectForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : 'something with type "' + typeof thing + '"';
    }
    function getValueDescriptorExpectingEnumForWarning(thing) {
      return thing === null ? "`null`" : thing === undefined ? "`undefined`" : thing === "" ? "an empty string" : typeof thing === "string" ? JSON.stringify(thing) : typeof thing === "number" ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
    }
    function resolveDispatcher() {
      var dispatcher = ReactSharedInternals.H;
      dispatcher === null && console.error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      return dispatcher;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var Internals = {
      d: {
        f: noop3,
        r: function() {
          throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop3,
        C: noop3,
        L: noop3,
        m: noop3,
        X: noop3,
        S: noop3,
        M: noop3
      },
      p: 0,
      findDOMNode: null
    }, REACT_PORTAL_TYPE = Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    typeof Map === "function" && Map.prototype != null && typeof Map.prototype.forEach === "function" && typeof Set === "function" && Set.prototype != null && typeof Set.prototype.clear === "function" && typeof Set.prototype.forEach === "function" || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && arguments[2] !== undefined ? arguments[2] : null;
      if (!container || container.nodeType !== 1 && container.nodeType !== 9 && container.nodeType !== 11)
        throw Error("Target container is not a DOM element.");
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn)
          return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
      }
    };
    exports.preconnect = function(href, options) {
      typeof href === "string" && href ? options != null && typeof options !== "object" ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : options != null && typeof options.crossOrigin !== "string" && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      typeof href === "string" && (options ? (options = options.crossOrigin, options = typeof options === "string" ? options === "use-credentials" ? options : "" : undefined) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      if (typeof href !== "string" || !href)
        console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      else if (1 < arguments.length) {
        var options = arguments[1];
        typeof options === "object" && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
      }
      typeof href === "string" && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      typeof href === "string" && href ? options == null || typeof options !== "object" ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : options.as !== "style" && options.as !== "script" && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
      if (typeof href === "string" && options && typeof options.as === "string") {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = typeof options.integrity === "string" ? options.integrity : undefined, fetchPriority = typeof options.fetchPriority === "string" ? options.fetchPriority : undefined;
        as === "style" ? Internals.d.S(href, typeof options.precedence === "string" ? options.precedence : undefined, {
          crossOrigin,
          integrity,
          fetchPriority
        }) : as === "script" && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined
        });
      }
    };
    exports.preinitModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && options.as !== "script" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
      if (encountered)
        console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);
      else
        switch (encountered = options && typeof options.as === "string" ? options.as : "script", encountered) {
          case "script":
            break;
          default:
            encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
        }
      if (typeof href === "string")
        if (typeof options === "object" && options !== null) {
          if (options.as == null || options.as === "script")
            encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
              crossOrigin: encountered,
              integrity: typeof options.integrity === "string" ? options.integrity : undefined,
              nonce: typeof options.nonce === "string" ? options.nonce : undefined
            });
        } else
          options == null && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options == null || typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : typeof options.as === "string" && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
      if (typeof href === "string" && typeof options === "object" && options !== null && typeof options.as === "string") {
        encountered = options.as;
        var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
        Internals.d.L(href, encountered, {
          crossOrigin,
          integrity: typeof options.integrity === "string" ? options.integrity : undefined,
          nonce: typeof options.nonce === "string" ? options.nonce : undefined,
          type: typeof options.type === "string" ? options.type : undefined,
          fetchPriority: typeof options.fetchPriority === "string" ? options.fetchPriority : undefined,
          referrerPolicy: typeof options.referrerPolicy === "string" ? options.referrerPolicy : undefined,
          imageSrcSet: typeof options.imageSrcSet === "string" ? options.imageSrcSet : undefined,
          imageSizes: typeof options.imageSizes === "string" ? options.imageSizes : undefined,
          media: typeof options.media === "string" ? options.media : undefined
        });
      }
    };
    exports.preloadModule = function(href, options) {
      var encountered = "";
      typeof href === "string" && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
      options !== undefined && typeof options !== "object" ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && ("as" in options) && typeof options.as !== "string" && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
      encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
      typeof href === "string" && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
        as: typeof options.as === "string" && options.as !== "script" ? options.as : undefined,
        crossOrigin: encountered,
        integrity: typeof options.integrity === "string" ? options.integrity : undefined
      })) : Internals.d.m(href));
    };
    exports.requestFormReset = function(form2) {
      Internals.d.r(form2);
    };
    exports.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return resolveDispatcher().useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return resolveDispatcher().useHostTransitionStatus();
    };
    exports.version = "19.2.0";
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  var react_dom_development = __toESM(require_react_dom_development(), 1);
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// node_modules/react-dom/cjs/react-dom-server.bun.development.js
var exports_react_dom_server_bun_development = {};
__export(exports_react_dom_server_bun_development, {
  version: () => $version,
  renderToReadableStream: () => $renderToReadableStream
});
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== "object")
    return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return typeof maybeIterable === "function" ? maybeIterable : null;
}
function objectName(object2) {
  object2 = Object.prototype.toString.call(object2);
  return object2.slice(8, object2.length - 1);
}
function describeKeyForErrorMessage(key) {
  var encodedKey = JSON.stringify(key);
  return '"' + key + '"' === encodedKey ? key : encodedKey;
}
function describeValueForErrorMessage(value) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
    case "object":
      if (isArrayImpl(value))
        return "[...]";
      if (value !== null && value.$$typeof === CLIENT_REFERENCE_TAG)
        return "client";
      value = objectName(value);
      return value === "Object" ? "{...}" : value;
    case "function":
      return value.$$typeof === CLIENT_REFERENCE_TAG ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
    default:
      return String(value);
  }
}
function describeElementType(type) {
  if (typeof type === "string")
    return type;
  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
  }
  if (typeof type === "object")
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeElementType(type.render);
      case REACT_MEMO_TYPE:
        return describeElementType(type.type);
      case REACT_LAZY_TYPE:
        var payload = type._payload;
        type = type._init;
        try {
          return describeElementType(type(payload));
        } catch (x2) {}
    }
  return "";
}
function describeObjectForErrorMessage(objectOrArray, expandedName) {
  var objKind = objectName(objectOrArray);
  if (objKind !== "Object" && objKind !== "Array")
    return objKind;
  var start = -1, length = 0;
  if (isArrayImpl(objectOrArray))
    if (jsxChildrenParents.has(objectOrArray)) {
      var type = jsxChildrenParents.get(objectOrArray);
      objKind = "<" + describeElementType(type) + ">";
      for (var i2 = 0;i2 < objectOrArray.length; i2++) {
        var value = objectOrArray[i2];
        value = typeof value === "string" ? value : typeof value === "object" && value !== null ? "{" + describeObjectForErrorMessage(value) + "}" : "{" + describeValueForErrorMessage(value) + "}";
        "" + i2 === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
      }
      objKind += "</" + describeElementType(type) + ">";
    } else {
      objKind = "[";
      for (type = 0;type < objectOrArray.length; type++)
        0 < type && (objKind += ", "), i2 = objectOrArray[type], i2 = typeof i2 === "object" && i2 !== null ? describeObjectForErrorMessage(i2) : describeValueForErrorMessage(i2), "" + type === expandedName ? (start = objKind.length, length = i2.length, objKind += i2) : objKind = 10 > i2.length && 40 > objKind.length + i2.length ? objKind + i2 : objKind + "...";
      objKind += "]";
    }
  else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE)
    objKind = "<" + describeElementType(objectOrArray.type) + "/>";
  else {
    if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG)
      return "client";
    if (jsxPropsParents.has(objectOrArray)) {
      objKind = jsxPropsParents.get(objectOrArray);
      objKind = "<" + (describeElementType(objKind) || "...");
      type = Object.keys(objectOrArray);
      for (i2 = 0;i2 < type.length; i2++) {
        objKind += " ";
        value = type[i2];
        objKind += describeKeyForErrorMessage(value) + "=";
        var _value2 = objectOrArray[value];
        var _substr2 = value === expandedName && typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2);
        typeof _value2 !== "string" && (_substr2 = "{" + _substr2 + "}");
        value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
      }
      objKind += ">";
    } else {
      objKind = "{";
      type = Object.keys(objectOrArray);
      for (i2 = 0;i2 < type.length; i2++)
        0 < i2 && (objKind += ", "), value = type[i2], objKind += describeKeyForErrorMessage(value) + ": ", _value2 = objectOrArray[value], _value2 = typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage(_value2) : describeValueForErrorMessage(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
      objKind += "}";
    }
  }
  return expandedName === undefined ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), `
  ` + objKind + `
  ` + objectOrArray) : `
  ` + objKind;
}
function flushBuffered(destination) {
  typeof destination.flush === "function" && destination.flush();
}
function writeChunk(destination, chunk) {
  chunk.length !== 0 && destination.write(chunk);
}
function byteLengthOfChunk(chunk) {
  return Buffer.byteLength(chunk, "utf8");
}
function closeWithError(destination, error40) {
  typeof destination.error === "function" ? destination.error(error40) : destination.close();
}
function typeName(value) {
  return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
}
function willCoercionThrow(value) {
  try {
    return testStringCoercion(value), false;
  } catch (e) {
    return true;
  }
}
function testStringCoercion(value) {
  return "" + value;
}
function checkAttributeStringCoercion(value, attributeName) {
  if (willCoercionThrow(value))
    return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
}
function checkCSSPropertyStringCoercion(value, propName) {
  if (willCoercionThrow(value))
    return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
}
function checkHtmlStringCoercion(value) {
  if (willCoercionThrow(value))
    return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
}
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return true;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
    return false;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return validatedAttributeNameCache[attributeName] = true;
  illegalAttributeNameCache[attributeName] = true;
  console.error("Invalid attribute name: `%s`", attributeName);
  return false;
}
function checkControlledValueProps(tagName, props) {
  hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
  props.onChange || props.readOnly || props.disabled || props.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
}
function validateProperty$1(tagName, name) {
  if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
    return true;
  if (rARIACamel$1.test(name)) {
    tagName = "aria-" + name.slice(4).toLowerCase();
    tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
    if (tagName == null)
      return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = true;
    if (name !== tagName)
      return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true;
  }
  if (rARIA$1.test(name)) {
    tagName = name.toLowerCase();
    tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
    if (tagName == null)
      return warnedProperties$1[name] = true, false;
    name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = true);
  }
  return true;
}
function validateProperties$2(type, props) {
  var invalidProps = [], key;
  for (key in props)
    validateProperty$1(type, key) || invalidProps.push(key);
  props = invalidProps.map(function(prop) {
    return "`" + prop + "`";
  }).join(", ");
  invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
}
function validateProperty(tagName, name, value, eventRegistry) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
    return true;
  var lowerCasedName = name.toLowerCase();
  if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
    return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = true;
  if (typeof value === "function" && (tagName === "form" && name === "action" || tagName === "input" && name === "formAction" || tagName === "button" && name === "formAction"))
    return true;
  if (eventRegistry != null) {
    tagName = eventRegistry.possibleRegistrationNames;
    if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
      return true;
    eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
    if (eventRegistry != null)
      return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = true;
    if (EVENT_NAME_REGEX.test(name))
      return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = true;
  } else if (EVENT_NAME_REGEX.test(name))
    return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = true;
  if (rARIA.test(name) || rARIACamel.test(name))
    return true;
  if (lowerCasedName === "innerhtml")
    return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = true;
  if (lowerCasedName === "aria")
    return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = true;
  if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
    return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = true;
  if (typeof value === "number" && isNaN(value))
    return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = true;
  if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
    if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
      return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = true;
  } else if (name !== lowerCasedName)
    return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = true;
  switch (name) {
    case "dangerouslySetInnerHTML":
    case "children":
    case "style":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      return true;
    case "innerText":
    case "textContent":
      return true;
  }
  switch (typeof value) {
    case "boolean":
      switch (name) {
        case "autoFocus":
        case "checked":
        case "multiple":
        case "muted":
        case "selected":
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
        case "capture":
        case "download":
        case "inert":
          return true;
        default:
          lowerCasedName = name.toLowerCase().slice(0, 5);
          if (lowerCasedName === "data-" || lowerCasedName === "aria-")
            return true;
          value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
          return warnedProperties[name] = true;
      }
    case "function":
    case "symbol":
      return warnedProperties[name] = true, false;
    case "string":
      if (value === "false" || value === "true") {
        switch (name) {
          case "checked":
          case "selected":
          case "multiple":
          case "muted":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
          case "inert":
            break;
          default:
            return true;
        }
        console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
        warnedProperties[name] = true;
      }
  }
  return true;
}
function warnUnknownProperties(type, props, eventRegistry) {
  var unknownProps = [], key;
  for (key in props)
    validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
  props = unknownProps.map(function(prop) {
    return "`" + prop + "`";
  }).join(", ");
  unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
}
function camelize(string4) {
  return string4.replace(hyphenPattern, function(_2, character) {
    return character.toUpperCase();
  });
}
function escapeTextForBrowser(text2) {
  if (typeof text2 === "boolean" || typeof text2 === "number" || typeof text2 === "bigint")
    return "" + text2;
  checkHtmlStringCoercion(text2);
  text2 = "" + text2;
  var match = matchHtmlRegExp.exec(text2);
  if (match) {
    var html = "", index, lastIndex = 0;
    for (index = match.index;index < text2.length; index++) {
      switch (text2.charCodeAt(index)) {
        case 34:
          match = "&quot;";
          break;
        case 38:
          match = "&amp;";
          break;
        case 39:
          match = "&#x27;";
          break;
        case 60:
          match = "&lt;";
          break;
        case 62:
          match = "&gt;";
          break;
        default:
          continue;
      }
      lastIndex !== index && (html += text2.slice(lastIndex, index));
      lastIndex = index + 1;
      html += match;
    }
    text2 = lastIndex !== index ? html + text2.slice(lastIndex, index) : html;
  }
  return text2;
}
function sanitizeURL(url2) {
  return isJavaScriptProtocol.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
}
function escapeEntireInlineScriptContent(scriptText) {
  checkHtmlStringCoercion(scriptText);
  return ("" + scriptText).replace(scriptRegex, scriptReplacer);
}
function scriptReplacer(match, prefix, s, suffix) {
  return "" + prefix + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
}
function createRenderState(resumableState, nonce, externalRuntimeConfig, importMap, onHeaders, maxHeadersLength) {
  externalRuntimeConfig = typeof nonce === "string" ? nonce : nonce && nonce.script;
  var inlineScriptWithNonce = externalRuntimeConfig === undefined ? "<script" : '<script nonce="' + escapeTextForBrowser(externalRuntimeConfig) + '"', nonceStyle = typeof nonce === "string" ? undefined : nonce && nonce.style, inlineStyleWithNonce = nonceStyle === undefined ? "<style" : '<style nonce="' + escapeTextForBrowser(nonceStyle) + '"', idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
  bootstrapScriptContent !== undefined && (bootstrapChunks.push(inlineScriptWithNonce), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag, escapeEntireInlineScriptContent(bootstrapScriptContent), endInlineScript));
  bootstrapScriptContent = [];
  importMap !== undefined && (bootstrapScriptContent.push('<script type="importmap">'), bootstrapScriptContent.push(escapeEntireInlineScriptContent(JSON.stringify(importMap))), bootstrapScriptContent.push("</script>"));
  onHeaders && typeof maxHeadersLength === "number" && 0 >= maxHeadersLength && console.error("React expected a positive non-zero `maxHeadersLength` option but found %s instead. When using the `onHeaders` option you may supply an optional `maxHeadersLength` option as well however, when setting this value to zero or less no headers will be captured.", maxHeadersLength === 0 ? "zero" : maxHeadersLength);
  importMap = onHeaders ? {
    preconnects: "",
    fontPreloads: "",
    highImagePreloads: "",
    remainingCapacity: 2 + (typeof maxHeadersLength === "number" ? maxHeadersLength : 2000)
  } : null;
  onHeaders = {
    placeholderPrefix: idPrefix + "P:",
    segmentPrefix: idPrefix + "S:",
    boundaryPrefix: idPrefix + "B:",
    startInlineScript: inlineScriptWithNonce,
    startInlineStyle: inlineStyleWithNonce,
    preamble: createPreambleState(),
    externalRuntimeScript: null,
    bootstrapChunks,
    importMapChunks: bootstrapScriptContent,
    onHeaders,
    headers: importMap,
    resets: {
      font: {},
      dns: {},
      connect: { default: {}, anonymous: {}, credentials: {} },
      image: {},
      style: {}
    },
    charsetChunks: [],
    viewportChunks: [],
    hoistableChunks: [],
    preconnects: new Set,
    fontPreloads: new Set,
    highImagePreloads: new Set,
    styles: new Map,
    bootstrapScripts: new Set,
    scripts: new Set,
    bulkPreloads: new Set,
    preloads: {
      images: new Map,
      stylesheets: new Map,
      scripts: new Map,
      moduleScripts: new Map
    },
    nonce: { script: externalRuntimeConfig, style: nonceStyle },
    hoistableState: null,
    stylesToHoist: false
  };
  if (bootstrapScripts !== undefined)
    for (importMap = 0;importMap < bootstrapScripts.length; importMap++)
      maxHeadersLength = bootstrapScripts[importMap], inlineStyleWithNonce = nonceStyle = undefined, idPrefix = {
        rel: "preload",
        as: "script",
        fetchPriority: "low",
        nonce
      }, typeof maxHeadersLength === "string" ? idPrefix.href = inlineScriptWithNonce = maxHeadersLength : (idPrefix.href = inlineScriptWithNonce = maxHeadersLength.src, idPrefix.integrity = inlineStyleWithNonce = typeof maxHeadersLength.integrity === "string" ? maxHeadersLength.integrity : undefined, idPrefix.crossOrigin = nonceStyle = typeof maxHeadersLength === "string" || maxHeadersLength.crossOrigin == null ? undefined : maxHeadersLength.crossOrigin === "use-credentials" ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, onHeaders, inlineScriptWithNonce, idPrefix), bootstrapChunks.push('<script src="', escapeTextForBrowser(inlineScriptWithNonce), attributeEnd), externalRuntimeConfig && bootstrapChunks.push(' nonce="', escapeTextForBrowser(externalRuntimeConfig), attributeEnd), typeof inlineStyleWithNonce === "string" && bootstrapChunks.push(' integrity="', escapeTextForBrowser(inlineStyleWithNonce), attributeEnd), typeof nonceStyle === "string" && bootstrapChunks.push(' crossorigin="', escapeTextForBrowser(nonceStyle), attributeEnd), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(' async=""></script>');
  if (bootstrapModules !== undefined)
    for (nonce = 0;nonce < bootstrapModules.length; nonce++)
      bootstrapScripts = bootstrapModules[nonce], inlineScriptWithNonce = maxHeadersLength = undefined, nonceStyle = {
        rel: "modulepreload",
        fetchPriority: "low",
        nonce: externalRuntimeConfig
      }, typeof bootstrapScripts === "string" ? nonceStyle.href = importMap = bootstrapScripts : (nonceStyle.href = importMap = bootstrapScripts.src, nonceStyle.integrity = inlineScriptWithNonce = typeof bootstrapScripts.integrity === "string" ? bootstrapScripts.integrity : undefined, nonceStyle.crossOrigin = maxHeadersLength = typeof bootstrapScripts === "string" || bootstrapScripts.crossOrigin == null ? undefined : bootstrapScripts.crossOrigin === "use-credentials" ? "use-credentials" : ""), preloadBootstrapScriptOrModule(resumableState, onHeaders, importMap, nonceStyle), bootstrapChunks.push('<script type="module" src="', escapeTextForBrowser(importMap), attributeEnd), externalRuntimeConfig && bootstrapChunks.push(' nonce="', escapeTextForBrowser(externalRuntimeConfig), attributeEnd), typeof inlineScriptWithNonce === "string" && bootstrapChunks.push(' integrity="', escapeTextForBrowser(inlineScriptWithNonce), attributeEnd), typeof maxHeadersLength === "string" && bootstrapChunks.push(' crossorigin="', escapeTextForBrowser(maxHeadersLength), attributeEnd), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(' async=""></script>');
  return onHeaders;
}
function createResumableState(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
  return {
    idPrefix: identifierPrefix === undefined ? "" : identifierPrefix,
    nextFormID: 0,
    streamingFormat: 0,
    bootstrapScriptContent,
    bootstrapScripts,
    bootstrapModules,
    instructions: NothingSent,
    hasBody: false,
    hasHtml: false,
    unknownResources: {},
    dnsResources: {},
    connectResources: { default: {}, anonymous: {}, credentials: {} },
    imageResources: {},
    styleResources: {},
    scriptResources: {},
    moduleUnknownResources: {},
    moduleScriptResources: {}
  };
}
function createPreambleState() {
  return { htmlChunks: null, headChunks: null, bodyChunks: null };
}
function createFormatContext(insertionMode, selectedValue, tagScope, viewTransition) {
  return {
    insertionMode,
    selectedValue,
    tagScope,
    viewTransition
  };
}
function createRootFormatContext(namespaceURI) {
  return createFormatContext(namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE, null, 0, null);
}
function getChildFormatContext(parentContext, type, props) {
  var subtreeScope = parentContext.tagScope & -25;
  switch (type) {
    case "noscript":
      return createFormatContext(HTML_MODE, null, subtreeScope | 1, null);
    case "select":
      return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue, subtreeScope, null);
    case "svg":
      return createFormatContext(SVG_MODE, null, subtreeScope, null);
    case "picture":
      return createFormatContext(HTML_MODE, null, subtreeScope | 2, null);
    case "math":
      return createFormatContext(MATHML_MODE, null, subtreeScope, null);
    case "foreignObject":
      return createFormatContext(HTML_MODE, null, subtreeScope, null);
    case "table":
      return createFormatContext(HTML_TABLE_MODE, null, subtreeScope, null);
    case "thead":
    case "tbody":
    case "tfoot":
      return createFormatContext(HTML_TABLE_BODY_MODE, null, subtreeScope, null);
    case "colgroup":
      return createFormatContext(HTML_COLGROUP_MODE, null, subtreeScope, null);
    case "tr":
      return createFormatContext(HTML_TABLE_ROW_MODE, null, subtreeScope, null);
    case "head":
      if (parentContext.insertionMode < HTML_MODE)
        return createFormatContext(HTML_HEAD_MODE, null, subtreeScope, null);
      break;
    case "html":
      if (parentContext.insertionMode === ROOT_HTML_MODE)
        return createFormatContext(HTML_HTML_MODE, null, subtreeScope, null);
  }
  return parentContext.insertionMode >= HTML_TABLE_MODE || parentContext.insertionMode < HTML_MODE ? createFormatContext(HTML_MODE, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
}
function getSuspenseViewTransition(parentViewTransition) {
  return parentViewTransition === null ? null : {
    update: parentViewTransition.update,
    enter: "none",
    exit: "none",
    share: parentViewTransition.update,
    name: parentViewTransition.autoName,
    autoName: parentViewTransition.autoName,
    nameIdx: 0
  };
}
function getSuspenseFallbackFormatContext(resumableState, parentContext) {
  parentContext.tagScope & 32 && (resumableState.instructions |= 128);
  return createFormatContext(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition(parentContext.viewTransition));
}
function getSuspenseContentFormatContext(resumableState, parentContext) {
  resumableState = getSuspenseViewTransition(parentContext.viewTransition);
  var subtreeScope = parentContext.tagScope | 16;
  resumableState !== null && resumableState.share !== "none" && (subtreeScope |= 64);
  return createFormatContext(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
}
function pushTextInstance(target, text2, renderState, textEmbedded) {
  if (text2 === "")
    return textEmbedded;
  textEmbedded && target.push("<!-- -->");
  target.push(escapeTextForBrowser(text2));
  return true;
}
function pushSegmentFinale(target, renderState, lastPushedText, textEmbedded) {
  lastPushedText && textEmbedded && target.push("<!-- -->");
}
function pushStyleAttribute(target, style) {
  if (typeof style !== "object")
    throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
  var isFirst = true, styleName;
  for (styleName in style)
    if (hasOwnProperty.call(style, styleName)) {
      var styleValue = style[styleName];
      if (styleValue != null && typeof styleValue !== "boolean" && styleValue !== "") {
        if (styleName.indexOf("--") === 0) {
          var nameChunk = escapeTextForBrowser(styleName);
          checkCSSPropertyStringCoercion(styleValue, styleName);
          styleValue = escapeTextForBrowser(("" + styleValue).trim());
        } else {
          nameChunk = styleName;
          var value = styleValue;
          if (-1 < nameChunk.indexOf("-")) {
            var name = nameChunk;
            warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-"))));
          } else if (badVendoredStyleNamePattern.test(nameChunk))
            name = nameChunk, warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name] || (warnedStyleNames[name] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
          else if (badStyleValueWithSemicolonPattern.test(value)) {
            name = nameChunk;
            var value$jscomp$0 = value;
            warnedStyleValues.hasOwnProperty(value$jscomp$0) && warnedStyleValues[value$jscomp$0] || (warnedStyleValues[value$jscomp$0] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value$jscomp$0.replace(badStyleValueWithSemicolonPattern, "")));
          }
          typeof value === "number" && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
          nameChunk = styleName;
          value = styleNameCache.get(nameChunk);
          value !== undefined ? nameChunk = value : (value = escapeTextForBrowser(nameChunk.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-")), styleNameCache.set(nameChunk, value), nameChunk = value);
          typeof styleValue === "number" ? styleValue = styleValue === 0 || unitlessNumbers.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion(styleValue, styleName), styleValue = escapeTextForBrowser(("" + styleValue).trim()));
        }
        isFirst ? (isFirst = false, target.push(styleAttributeStart, nameChunk, styleAssign, styleValue)) : target.push(styleSeparator, nameChunk, styleAssign, styleValue);
      }
    }
  isFirst || target.push(attributeEnd);
}
function pushBooleanAttribute(target, name, value) {
  value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name, attributeEmptyString);
}
function pushStringAttribute(target, name, value) {
  typeof value !== "function" && typeof value !== "symbol" && typeof value !== "boolean" && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
}
function pushAdditionalFormField(value, key) {
  this.push('<input type="hidden"');
  validateAdditionalFormField(value);
  pushStringAttribute(this, "name", key);
  pushStringAttribute(this, "value", value);
  this.push(endOfStartTagSelfClosing);
}
function validateAdditionalFormField(value) {
  if (typeof value !== "string")
    throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
}
function getCustomFormFields(resumableState, formAction) {
  if (typeof formAction.$$FORM_ACTION === "function") {
    var id = resumableState.nextFormID++;
    resumableState = resumableState.idPrefix + id;
    try {
      var customFields = formAction.$$FORM_ACTION(resumableState);
      if (customFields) {
        var formData = customFields.data;
        formData != null && formData.forEach(validateAdditionalFormField);
      }
      return customFields;
    } catch (x2) {
      if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function")
        throw x2;
      console.error(`Failed to serialize an action for progressive enhancement:
%s`, x2);
    }
  }
  return null;
}
function pushFormActionAttribute(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
  var formData = null;
  if (typeof formAction === "function") {
    name === null || didWarnFormActionName || (didWarnFormActionName = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'));
    formEncType === null && formMethod === null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
    formTarget === null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
    var customFields = getCustomFormFields(resumableState, formAction);
    customFields !== null ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator, "formAction", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime(resumableState, renderState));
  }
  name != null && pushAttribute(target, "name", name);
  formAction != null && pushAttribute(target, "formAction", formAction);
  formEncType != null && pushAttribute(target, "formEncType", formEncType);
  formMethod != null && pushAttribute(target, "formMethod", formMethod);
  formTarget != null && pushAttribute(target, "formTarget", formTarget);
  return formData;
}
function pushAttribute(target, name, value) {
  switch (name) {
    case "className":
      pushStringAttribute(target, "class", value);
      break;
    case "tabIndex":
      pushStringAttribute(target, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      pushStringAttribute(target, name, value);
      break;
    case "style":
      pushStyleAttribute(target, value);
      break;
    case "src":
    case "href":
      if (value === "") {
        name === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name, name) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name, name);
        break;
      }
    case "action":
    case "formAction":
      if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
        break;
      checkAttributeStringCoercion(value, name);
      value = sanitizeURL("" + value);
      target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "ref":
      break;
    case "autoFocus":
    case "multiple":
    case "muted":
      pushBooleanAttribute(target, name.toLowerCase(), value);
      break;
    case "xlinkHref":
      if (typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
        break;
      checkAttributeStringCoercion(value, name);
      value = sanitizeURL("" + value);
      target.push(attributeSeparator, "xlink:href", attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "inert":
      value !== "" || didWarnForNewBooleanPropsWithEmptyValue[name] || (didWarnForNewBooleanPropsWithEmptyValue[name] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name));
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name, attributeEmptyString);
      break;
    case "capture":
    case "download":
      value === true ? target.push(attributeSeparator, name, attributeEmptyString) : value !== false && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value && target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "rowSpan":
    case "start":
      typeof value === "function" || typeof value === "symbol" || isNaN(value) || target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
      break;
    case "xlinkActuate":
      pushStringAttribute(target, "xlink:actuate", value);
      break;
    case "xlinkArcrole":
      pushStringAttribute(target, "xlink:arcrole", value);
      break;
    case "xlinkRole":
      pushStringAttribute(target, "xlink:role", value);
      break;
    case "xlinkShow":
      pushStringAttribute(target, "xlink:show", value);
      break;
    case "xlinkTitle":
      pushStringAttribute(target, "xlink:title", value);
      break;
    case "xlinkType":
      pushStringAttribute(target, "xlink:type", value);
      break;
    case "xmlBase":
      pushStringAttribute(target, "xml:base", value);
      break;
    case "xmlLang":
      pushStringAttribute(target, "xml:lang", value);
      break;
    case "xmlSpace":
      pushStringAttribute(target, "xml:space", value);
      break;
    default:
      if (!(2 < name.length) || name[0] !== "o" && name[0] !== "O" || name[1] !== "n" && name[1] !== "N") {
        if (name = aliases.get(name) || name, isAttributeNameSafe(name)) {
          switch (typeof value) {
            case "function":
            case "symbol":
              return;
            case "boolean":
              var prefix = name.toLowerCase().slice(0, 5);
              if (prefix !== "data-" && prefix !== "aria-")
                return;
          }
          target.push(attributeSeparator, name, attributeAssign, escapeTextForBrowser(value), attributeEnd);
        }
      }
  }
}
function pushInnerHTML(target, innerHTML, children) {
  if (innerHTML != null) {
    if (children != null)
      throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
    if (typeof innerHTML !== "object" || !("__html" in innerHTML))
      throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
    innerHTML = innerHTML.__html;
    innerHTML !== null && innerHTML !== undefined && (checkHtmlStringCoercion(innerHTML), target.push("" + innerHTML));
  }
}
function checkSelectProp(props, propName) {
  var value = props[propName];
  value != null && (value = isArrayImpl(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
}
function flattenOptionChildren(children) {
  var content = "";
  React.Children.forEach(children, function(child) {
    child != null && (content += child, didWarnInvalidOptionChildren || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || (didWarnInvalidOptionChildren = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
  });
  return content;
}
function injectFormReplayingRuntime(resumableState, renderState) {
  if ((resumableState.instructions & 16) === NothingSent) {
    resumableState.instructions |= 16;
    var { preamble, bootstrapChunks } = renderState;
    (preamble.htmlChunks || preamble.headChunks) && bootstrapChunks.length === 0 ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag, formReplayingRuntimeScript, endInlineScript)) : bootstrapChunks.unshift(renderState.startInlineScript, endOfStartTag, formReplayingRuntimeScript, endInlineScript);
  }
}
function pushLinkImpl(target, props) {
  target.push(startChunkForTag("link"));
  for (var propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTagSelfClosing);
  return null;
}
function escapeStyleTextContent(styleText) {
  checkHtmlStringCoercion(styleText);
  return ("" + styleText).replace(styleRegex, styleReplacer);
}
function styleReplacer(match, prefix, s, suffix) {
  return "" + prefix + (s === "s" ? "\\73 " : "\\53 ") + suffix;
}
function pushSelfClosing(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  for (var propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(tag2 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTagSelfClosing);
  return null;
}
function pushTitleImpl(target, props) {
  target.push(startChunkForTag("title"));
  var children = null, innerHTML = null, propKey;
  for (propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            children = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
  typeof props !== "function" && typeof props !== "symbol" && props !== null && props !== undefined && target.push(escapeTextForBrowser("" + props));
  pushInnerHTML(target, innerHTML, children);
  target.push(endChunkForTag("title"));
  return null;
}
function pushScriptImpl(target, props) {
  target.push(startChunkForTag("script"));
  var children = null, innerHTML = null, propKey;
  for (propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            children = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  children != null && typeof children !== "string" && (props = typeof children === "number" ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
  pushInnerHTML(target, innerHTML, children);
  typeof children === "string" && target.push(escapeEntireInlineScriptContent(children));
  target.push(endChunkForTag("script"));
  return null;
}
function pushStartSingletonElement(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  var innerHTML = tag2 = null, propKey;
  for (propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            tag2 = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  pushInnerHTML(target, innerHTML, tag2);
  return tag2;
}
function pushStartGenericElement(target, props, tag2) {
  target.push(startChunkForTag(tag2));
  var innerHTML = tag2 = null, propKey;
  for (propKey in props)
    if (hasOwnProperty.call(props, propKey)) {
      var propValue = props[propKey];
      if (propValue != null)
        switch (propKey) {
          case "children":
            tag2 = propValue;
            break;
          case "dangerouslySetInnerHTML":
            innerHTML = propValue;
            break;
          default:
            pushAttribute(target, propKey, propValue);
        }
    }
  target.push(endOfStartTag);
  pushInnerHTML(target, innerHTML, tag2);
  return typeof tag2 === "string" ? (target.push(escapeTextForBrowser(tag2)), null) : tag2;
}
function startChunkForTag(tag2) {
  var tagStartChunk = validatedTagCache.get(tag2);
  if (tagStartChunk === undefined) {
    if (!VALID_TAG_REGEX.test(tag2))
      throw Error("Invalid tag: " + tag2);
    tagStartChunk = "<" + tag2;
    validatedTagCache.set(tag2, tagStartChunk);
  }
  return tagStartChunk;
}
function pushStartInstance(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
  validateProperties$2(type, props);
  type !== "input" && type !== "textarea" && type !== "select" || props == null || props.value !== null || didWarnValueNull || (didWarnValueNull = true, type === "select" && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
  b:
    if (type.indexOf("-") === -1)
      var JSCompiler_inline_result = false;
    else
      switch (type) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          JSCompiler_inline_result = false;
          break b;
        default:
          JSCompiler_inline_result = true;
      }
  JSCompiler_inline_result || typeof props.is === "string" || warnUnknownProperties(type, props, null);
  !props.suppressContentEditableWarning && props.contentEditable && props.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
  formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE && type.indexOf("-") === -1 && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
  switch (type) {
    case "div":
    case "span":
    case "svg":
    case "path":
      break;
    case "a":
      target$jscomp$0.push(startChunkForTag("a"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              case "href":
                propValue === "" ? pushStringAttribute(target$jscomp$0, "href", "") : pushAttribute(target$jscomp$0, propKey, propValue);
                break;
              default:
                pushAttribute(target$jscomp$0, propKey, propValue);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML, children);
      if (typeof children === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children));
        var JSCompiler_inline_result$jscomp$0 = null;
      } else
        JSCompiler_inline_result$jscomp$0 = children;
      return JSCompiler_inline_result$jscomp$0;
    case "g":
    case "p":
    case "li":
      break;
    case "select":
      checkControlledValueProps("select", props);
      checkSelectProp(props, "value");
      checkSelectProp(props, "defaultValue");
      props.value === undefined || props.defaultValue === undefined || didWarnDefaultSelectValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue = true);
      target$jscomp$0.push(startChunkForTag("select"));
      var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
      for (propKey$jscomp$0 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$0)) {
          var propValue$jscomp$0 = props[propKey$jscomp$0];
          if (propValue$jscomp$0 != null)
            switch (propKey$jscomp$0) {
              case "children":
                children$jscomp$0 = propValue$jscomp$0;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$0 = propValue$jscomp$0;
                break;
              case "defaultValue":
              case "value":
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
      return children$jscomp$0;
    case "option":
      var selectedValue = formatContext.selectedValue;
      target$jscomp$0.push(startChunkForTag("option"));
      var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
      for (propKey$jscomp$1 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$1)) {
          var propValue$jscomp$1 = props[propKey$jscomp$1];
          if (propValue$jscomp$1 != null)
            switch (propKey$jscomp$1) {
              case "children":
                children$jscomp$1 = propValue$jscomp$1;
                break;
              case "selected":
                selected = propValue$jscomp$1;
                didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = true);
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$1 = propValue$jscomp$1;
                break;
              case "value":
                value = propValue$jscomp$1;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
            }
        }
      if (selectedValue != null) {
        if (value !== null) {
          checkAttributeStringCoercion(value, "value");
          var stringValue = "" + value;
        } else
          innerHTML$jscomp$1 === null || didWarnInvalidOptionInnerHTML || (didWarnInvalidOptionInnerHTML = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren(children$jscomp$1);
        if (isArrayImpl(selectedValue))
          for (var i2 = 0;i2 < selectedValue.length; i2++) {
            if (checkAttributeStringCoercion(selectedValue[i2], "value"), "" + selectedValue[i2] === stringValue) {
              target$jscomp$0.push(' selected=""');
              break;
            }
          }
        else
          checkAttributeStringCoercion(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
      } else
        selected && target$jscomp$0.push(' selected=""');
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
      return children$jscomp$1;
    case "textarea":
      checkControlledValueProps("textarea", props);
      props.value === undefined || props.defaultValue === undefined || didWarnDefaultTextareaValue || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue = true);
      target$jscomp$0.push(startChunkForTag("textarea"));
      var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
      for (propKey$jscomp$2 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$2)) {
          var propValue$jscomp$2 = props[propKey$jscomp$2];
          if (propValue$jscomp$2 != null)
            switch (propKey$jscomp$2) {
              case "children":
                children$jscomp$2 = propValue$jscomp$2;
                break;
              case "value":
                value$jscomp$0 = propValue$jscomp$2;
                break;
              case "defaultValue":
                defaultValue = propValue$jscomp$2;
                break;
              case "dangerouslySetInnerHTML":
                throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
            }
        }
      value$jscomp$0 === null && defaultValue !== null && (value$jscomp$0 = defaultValue);
      target$jscomp$0.push(endOfStartTag);
      if (children$jscomp$2 != null) {
        console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
        if (value$jscomp$0 != null)
          throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (isArrayImpl(children$jscomp$2)) {
          if (1 < children$jscomp$2.length)
            throw Error("<textarea> can only have at most one child.");
          checkHtmlStringCoercion(children$jscomp$2[0]);
          value$jscomp$0 = "" + children$jscomp$2[0];
        }
        checkHtmlStringCoercion(children$jscomp$2);
        value$jscomp$0 = "" + children$jscomp$2;
      }
      typeof value$jscomp$0 === "string" && value$jscomp$0[0] === `
` && target$jscomp$0.push(`
`);
      value$jscomp$0 !== null && (checkAttributeStringCoercion(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser("" + value$jscomp$0)));
      return null;
    case "input":
      checkControlledValueProps("input", props);
      target$jscomp$0.push(startChunkForTag("input"));
      var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
      for (propKey$jscomp$3 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$3)) {
          var propValue$jscomp$3 = props[propKey$jscomp$3];
          if (propValue$jscomp$3 != null)
            switch (propKey$jscomp$3) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              case "name":
                name = propValue$jscomp$3;
                break;
              case "formAction":
                formAction = propValue$jscomp$3;
                break;
              case "formEncType":
                formEncType = propValue$jscomp$3;
                break;
              case "formMethod":
                formMethod = propValue$jscomp$3;
                break;
              case "formTarget":
                formTarget = propValue$jscomp$3;
                break;
              case "defaultChecked":
                defaultChecked = propValue$jscomp$3;
                break;
              case "defaultValue":
                defaultValue$jscomp$0 = propValue$jscomp$3;
                break;
              case "checked":
                checked = propValue$jscomp$3;
                break;
              case "value":
                value$jscomp$1 = propValue$jscomp$3;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
            }
        }
      formAction === null || props.type === "image" || props.type === "submit" || didWarnFormActionType || (didWarnFormActionType = true, console.error('An input can only specify a formAction along with type="submit" or type="image".'));
      var formData = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
      checked === null || defaultChecked === null || didWarnDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked = true);
      value$jscomp$1 === null || defaultValue$jscomp$0 === null || didWarnDefaultInputValue || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue = true);
      checked !== null ? pushBooleanAttribute(target$jscomp$0, "checked", checked) : defaultChecked !== null && pushBooleanAttribute(target$jscomp$0, "checked", defaultChecked);
      value$jscomp$1 !== null ? pushAttribute(target$jscomp$0, "value", value$jscomp$1) : defaultValue$jscomp$0 !== null && pushAttribute(target$jscomp$0, "value", defaultValue$jscomp$0);
      target$jscomp$0.push(endOfStartTagSelfClosing);
      formData != null && formData.forEach(pushAdditionalFormField, target$jscomp$0);
      return null;
    case "button":
      target$jscomp$0.push(startChunkForTag("button"));
      var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
      for (propKey$jscomp$4 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$4)) {
          var propValue$jscomp$4 = props[propKey$jscomp$4];
          if (propValue$jscomp$4 != null)
            switch (propKey$jscomp$4) {
              case "children":
                children$jscomp$3 = propValue$jscomp$4;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$2 = propValue$jscomp$4;
                break;
              case "name":
                name$jscomp$0 = propValue$jscomp$4;
                break;
              case "formAction":
                formAction$jscomp$0 = propValue$jscomp$4;
                break;
              case "formEncType":
                formEncType$jscomp$0 = propValue$jscomp$4;
                break;
              case "formMethod":
                formMethod$jscomp$0 = propValue$jscomp$4;
                break;
              case "formTarget":
                formTarget$jscomp$0 = propValue$jscomp$4;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
            }
        }
      formAction$jscomp$0 === null || props.type == null || props.type === "submit" || didWarnFormActionType || (didWarnFormActionType = true, console.error('A button can only specify a formAction along with type="submit" or no type.'));
      var formData$jscomp$0 = pushFormActionAttribute(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
      target$jscomp$0.push(endOfStartTag);
      formData$jscomp$0 != null && formData$jscomp$0.forEach(pushAdditionalFormField, target$jscomp$0);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
      if (typeof children$jscomp$3 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$3));
        var JSCompiler_inline_result$jscomp$1 = null;
      } else
        JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
      return JSCompiler_inline_result$jscomp$1;
    case "form":
      target$jscomp$0.push(startChunkForTag("form"));
      var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
      for (propKey$jscomp$5 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$5)) {
          var propValue$jscomp$5 = props[propKey$jscomp$5];
          if (propValue$jscomp$5 != null)
            switch (propKey$jscomp$5) {
              case "children":
                children$jscomp$4 = propValue$jscomp$5;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$3 = propValue$jscomp$5;
                break;
              case "action":
                formAction$jscomp$1 = propValue$jscomp$5;
                break;
              case "encType":
                formEncType$jscomp$1 = propValue$jscomp$5;
                break;
              case "method":
                formMethod$jscomp$1 = propValue$jscomp$5;
                break;
              case "target":
                formTarget$jscomp$1 = propValue$jscomp$5;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
            }
        }
      var formData$jscomp$1 = null, formActionName = null;
      if (typeof formAction$jscomp$1 === "function") {
        formEncType$jscomp$1 === null && formMethod$jscomp$1 === null || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
        formTarget$jscomp$1 === null || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
        var customFields = getCustomFormFields(resumableState, formAction$jscomp$1);
        customFields !== null ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator, "action", attributeAssign, actionJavaScriptURL, attributeEnd), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime(resumableState, renderState));
      }
      formAction$jscomp$1 != null && pushAttribute(target$jscomp$0, "action", formAction$jscomp$1);
      formEncType$jscomp$1 != null && pushAttribute(target$jscomp$0, "encType", formEncType$jscomp$1);
      formMethod$jscomp$1 != null && pushAttribute(target$jscomp$0, "method", formMethod$jscomp$1);
      formTarget$jscomp$1 != null && pushAttribute(target$jscomp$0, "target", formTarget$jscomp$1);
      target$jscomp$0.push(endOfStartTag);
      formActionName !== null && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing), formData$jscomp$1 != null && formData$jscomp$1.forEach(pushAdditionalFormField, target$jscomp$0));
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
      if (typeof children$jscomp$4 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$4));
        var JSCompiler_inline_result$jscomp$2 = null;
      } else
        JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
      return JSCompiler_inline_result$jscomp$2;
    case "menuitem":
      target$jscomp$0.push(startChunkForTag("menuitem"));
      for (var propKey$jscomp$6 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$6)) {
          var propValue$jscomp$6 = props[propKey$jscomp$6];
          if (propValue$jscomp$6 != null)
            switch (propKey$jscomp$6) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      return null;
    case "object":
      target$jscomp$0.push(startChunkForTag("object"));
      var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
      for (propKey$jscomp$7 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$7)) {
          var propValue$jscomp$7 = props[propKey$jscomp$7];
          if (propValue$jscomp$7 != null)
            switch (propKey$jscomp$7) {
              case "children":
                children$jscomp$5 = propValue$jscomp$7;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$4 = propValue$jscomp$7;
                break;
              case "data":
                checkAttributeStringCoercion(propValue$jscomp$7, "data");
                var sanitizedValue = sanitizeURL("" + propValue$jscomp$7);
                if (sanitizedValue === "") {
                  console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', propKey$jscomp$7, propKey$jscomp$7);
                  break;
                }
                target$jscomp$0.push(attributeSeparator, "data", attributeAssign, escapeTextForBrowser(sanitizedValue), attributeEnd);
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      pushInnerHTML(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
      if (typeof children$jscomp$5 === "string") {
        target$jscomp$0.push(escapeTextForBrowser(children$jscomp$5));
        var JSCompiler_inline_result$jscomp$3 = null;
      } else
        JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
      return JSCompiler_inline_result$jscomp$3;
    case "title":
      var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
      if (hasOwnProperty.call(props, "children")) {
        var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
        Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : typeof child === "function" || typeof child === "symbol" ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", typeof child === "function" ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (child.$$typeof != null ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
      }
      if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$4 = pushTitleImpl(target$jscomp$0, props);
      else
        isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = undefined);
      return JSCompiler_inline_result$jscomp$4;
    case "link":
      var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
      if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$0 || props.itemProp != null || typeof rel !== "string" || typeof href !== "string" || href === "") {
        rel === "stylesheet" && typeof props.precedence === "string" && (typeof href === "string" && href || console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', href === null ? "`null`" : href === undefined ? "`undefined`" : href === "" ? "an empty string" : 'something with type "' + typeof href + '"'));
        pushLinkImpl(target$jscomp$0, props);
        var JSCompiler_inline_result$jscomp$5 = null;
      } else if (props.rel === "stylesheet")
        if (typeof precedence !== "string" || props.disabled != null || props.onLoad || props.onError) {
          if (typeof precedence === "string") {
            if (props.disabled != null)
              console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');
            else if (props.onLoad || props.onError) {
              var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
              console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);
            }
          }
          JSCompiler_inline_result$jscomp$5 = pushLinkImpl(target$jscomp$0, props);
        } else {
          var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
          if (resourceState !== EXISTS) {
            resumableState.styleResources[href] = EXISTS;
            styleQueue || (styleQueue = {
              precedence: escapeTextForBrowser(precedence),
              rules: [],
              hrefs: [],
              sheets: new Map
            }, renderState.styles.set(precedence, styleQueue));
            var resource = {
              state: PENDING$1,
              props: assign({}, props, {
                "data-precedence": props.precedence,
                precedence: null
              })
            };
            if (resourceState) {
              resourceState.length === 2 && adoptPreloadCredentials(resource.props, resourceState);
              var preloadResource = renderState.preloads.stylesheets.get(href);
              preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED;
            }
            styleQueue.sheets.set(href, resource);
            hoistableState && hoistableState.stylesheets.add(resource);
          } else if (styleQueue) {
            var _resource = styleQueue.sheets.get(href);
            _resource && hoistableState && hoistableState.stylesheets.add(_resource);
          }
          textEmbedded && target$jscomp$0.push("<!-- -->");
          JSCompiler_inline_result$jscomp$5 = null;
        }
      else
        props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl(renderState.hoistableChunks, props));
      return JSCompiler_inline_result$jscomp$5;
    case "script":
      var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
      if (typeof props.src !== "string" || !props.src || !asyncProp || typeof asyncProp === "function" || typeof asyncProp === "symbol" || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$1 || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$6 = pushScriptImpl(target$jscomp$0, props);
      else {
        var key = props.src;
        if (props.type === "module") {
          var resources = resumableState.moduleScriptResources;
          var preloads = renderState.preloads.moduleScripts;
        } else
          resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
        var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : undefined;
        if (resourceState$jscomp$0 !== EXISTS) {
          resources[key] = EXISTS;
          var scriptProps = props;
          if (resourceState$jscomp$0) {
            resourceState$jscomp$0.length === 2 && (scriptProps = assign({}, props), adoptPreloadCredentials(scriptProps, resourceState$jscomp$0));
            var preloadResource$jscomp$0 = preloads.get(key);
            preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
          }
          var resource$jscomp$0 = [];
          renderState.scripts.add(resource$jscomp$0);
          pushScriptImpl(resource$jscomp$0, scriptProps);
        }
        textEmbedded && target$jscomp$0.push("<!-- -->");
        JSCompiler_inline_result$jscomp$6 = null;
      }
      return JSCompiler_inline_result$jscomp$6;
    case "style":
      var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
      if (hasOwnProperty.call(props, "children")) {
        var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
        (typeof child$jscomp$0 === "function" || typeof child$jscomp$0 === "symbol" || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", typeof child$jscomp$0 === "function" ? "a Function" : typeof child$jscomp$0 === "symbol" ? "a Sybmol" : "an Array");
      }
      var { precedence: precedence$jscomp$0, href: href$jscomp$0, nonce } = props;
      if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$2 || props.itemProp != null || typeof precedence$jscomp$0 !== "string" || typeof href$jscomp$0 !== "string" || href$jscomp$0 === "") {
        target$jscomp$0.push(startChunkForTag("style"));
        var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
        for (propKey$jscomp$8 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$8)) {
            var propValue$jscomp$8 = props[propKey$jscomp$8];
            if (propValue$jscomp$8 != null)
              switch (propKey$jscomp$8) {
                case "children":
                  children$jscomp$8 = propValue$jscomp$8;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$5 = propValue$jscomp$8;
                  break;
                default:
                  pushAttribute(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
              }
          }
        target$jscomp$0.push(endOfStartTag);
        var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
        typeof child$jscomp$1 !== "function" && typeof child$jscomp$1 !== "symbol" && child$jscomp$1 !== null && child$jscomp$1 !== undefined && target$jscomp$0.push(escapeStyleTextContent(child$jscomp$1));
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
        target$jscomp$0.push(endChunkForTag("style"));
        var JSCompiler_inline_result$jscomp$7 = null;
      } else {
        href$jscomp$0.includes(" ") && console.error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".', href$jscomp$0);
        var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : undefined;
        if (resourceState$jscomp$1 !== EXISTS) {
          resumableState.styleResources[href$jscomp$0] = EXISTS;
          resourceState$jscomp$1 && console.error('React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.', href$jscomp$0);
          styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
            precedence: escapeTextForBrowser(precedence$jscomp$0),
            rules: [],
            hrefs: [],
            sheets: new Map
          }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
          var nonceStyle = renderState.nonce.style;
          if (nonceStyle && nonceStyle !== nonce)
            console.error('React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce "%s" that was included with this render.', precedence$jscomp$0, nonce, nonceStyle);
          else {
            !nonceStyle && nonce && console.error('React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.', precedence$jscomp$0, nonce);
            styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser(href$jscomp$0));
            var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
            for (propKey$jscomp$9 in props)
              if (hasOwnProperty.call(props, propKey$jscomp$9)) {
                var propValue$jscomp$9 = props[propKey$jscomp$9];
                if (propValue$jscomp$9 != null)
                  switch (propKey$jscomp$9) {
                    case "children":
                      children$jscomp$9 = propValue$jscomp$9;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$6 = propValue$jscomp$9;
                  }
              }
            var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
            typeof child$jscomp$2 !== "function" && typeof child$jscomp$2 !== "symbol" && child$jscomp$2 !== null && child$jscomp$2 !== undefined && target.push(escapeStyleTextContent(child$jscomp$2));
            pushInnerHTML(target, innerHTML$jscomp$6, children$jscomp$9);
          }
        }
        styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
        textEmbedded && target$jscomp$0.push("<!-- -->");
        JSCompiler_inline_result$jscomp$7 = undefined;
      }
      return JSCompiler_inline_result$jscomp$7;
    case "meta":
      var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
      if (formatContext.insertionMode === SVG_MODE || noscriptTagInScope$jscomp$3 || props.itemProp != null)
        var JSCompiler_inline_result$jscomp$8 = pushSelfClosing(target$jscomp$0, props, "meta");
      else
        textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : typeof props.charSet === "string" ? pushSelfClosing(renderState.charsetChunks, props, "meta") : props.name === "viewport" ? pushSelfClosing(renderState.viewportChunks, props, "meta") : pushSelfClosing(renderState.hoistableChunks, props, "meta");
      return JSCompiler_inline_result$jscomp$8;
    case "listing":
    case "pre":
      target$jscomp$0.push(startChunkForTag(type));
      var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
      for (propKey$jscomp$10 in props)
        if (hasOwnProperty.call(props, propKey$jscomp$10)) {
          var propValue$jscomp$10 = props[propKey$jscomp$10];
          if (propValue$jscomp$10 != null)
            switch (propKey$jscomp$10) {
              case "children":
                children$jscomp$10 = propValue$jscomp$10;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML$jscomp$7 = propValue$jscomp$10;
                break;
              default:
                pushAttribute(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
            }
        }
      target$jscomp$0.push(endOfStartTag);
      if (innerHTML$jscomp$7 != null) {
        if (children$jscomp$10 != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof innerHTML$jscomp$7 !== "object" || !("__html" in innerHTML$jscomp$7))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
        var html = innerHTML$jscomp$7.__html;
        html !== null && html !== undefined && (typeof html === "string" && 0 < html.length && html[0] === `
` ? target$jscomp$0.push(`
`, html) : (checkHtmlStringCoercion(html), target$jscomp$0.push("" + html)));
      }
      typeof children$jscomp$10 === "string" && children$jscomp$10[0] === `
` && target$jscomp$0.push(`
`);
      return children$jscomp$10;
    case "img":
      var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
      if (!(props.loading === "lazy" || !src && !srcSet || typeof src !== "string" && src != null || typeof srcSet !== "string" && srcSet != null || props.fetchPriority === "low" || pictureOrNoScriptTagInScope) && (typeof src !== "string" || src[4] !== ":" || src[0] !== "d" && src[0] !== "D" || src[1] !== "a" && src[1] !== "A" || src[2] !== "t" && src[2] !== "T" || src[3] !== "a" && src[3] !== "A") && (typeof srcSet !== "string" || srcSet[4] !== ":" || srcSet[0] !== "d" && srcSet[0] !== "D" || srcSet[1] !== "a" && srcSet[1] !== "A" || srcSet[2] !== "t" && srcSet[2] !== "T" || srcSet[3] !== "a" && srcSet[3] !== "A")) {
        hoistableState !== null && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
        var sizes = typeof props.sizes === "string" ? props.sizes : undefined, key$jscomp$0 = srcSet ? srcSet + `
` + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
        if (resource$jscomp$1) {
          if (props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size)
            promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
        } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
          resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS;
          var input = props.crossOrigin;
          var crossOrigin = typeof input === "string" ? input === "use-credentials" ? input : "" : undefined;
          var headers = renderState.headers, header;
          headers && 0 < headers.remainingCapacity && typeof props.srcSet !== "string" && (props.fetchPriority === "high" || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader(src, "image", {
            imageSrcSet: props.srcSet,
            imageSizes: props.sizes,
            crossOrigin,
            integrity: props.integrity,
            nonce: props.nonce,
            type: props.type,
            fetchPriority: props.fetchPriority,
            referrerPolicy: props.refererPolicy
          }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl(resource$jscomp$1, {
            rel: "preload",
            as: "image",
            href: srcSet ? undefined : src,
            imageSrcSet: srcSet,
            imageSizes: sizes,
            crossOrigin,
            integrity: props.integrity,
            type: props.type,
            fetchPriority: props.fetchPriority,
            referrerPolicy: props.referrerPolicy
          }), props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
        }
      }
      return pushSelfClosing(target$jscomp$0, props, "img");
    case "base":
    case "area":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "param":
    case "source":
    case "track":
    case "wbr":
      return pushSelfClosing(target$jscomp$0, props, type);
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      break;
    case "head":
      if (formatContext.insertionMode < HTML_MODE) {
        var preamble = preambleState || renderState.preamble;
        if (preamble.headChunks)
          throw Error("The `<head>` tag may only be rendered once.");
        preambleState !== null && target$jscomp$0.push("<!--head-->");
        preamble.headChunks = [];
        var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement(preamble.headChunks, props, "head");
      } else
        JSCompiler_inline_result$jscomp$9 = pushStartGenericElement(target$jscomp$0, props, "head");
      return JSCompiler_inline_result$jscomp$9;
    case "body":
      if (formatContext.insertionMode < HTML_MODE) {
        var preamble$jscomp$0 = preambleState || renderState.preamble;
        if (preamble$jscomp$0.bodyChunks)
          throw Error("The `<body>` tag may only be rendered once.");
        preambleState !== null && target$jscomp$0.push("<!--body-->");
        preamble$jscomp$0.bodyChunks = [];
        var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement(preamble$jscomp$0.bodyChunks, props, "body");
      } else
        JSCompiler_inline_result$jscomp$10 = pushStartGenericElement(target$jscomp$0, props, "body");
      return JSCompiler_inline_result$jscomp$10;
    case "html":
      if (formatContext.insertionMode === ROOT_HTML_MODE) {
        var preamble$jscomp$1 = preambleState || renderState.preamble;
        if (preamble$jscomp$1.htmlChunks)
          throw Error("The `<html>` tag may only be rendered once.");
        preambleState !== null && target$jscomp$0.push("<!--html-->");
        preamble$jscomp$1.htmlChunks = ["<!DOCTYPE html>"];
        var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement(preamble$jscomp$1.htmlChunks, props, "html");
      } else
        JSCompiler_inline_result$jscomp$11 = pushStartGenericElement(target$jscomp$0, props, "html");
      return JSCompiler_inline_result$jscomp$11;
    default:
      if (type.indexOf("-") !== -1) {
        target$jscomp$0.push(startChunkForTag(type));
        var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
        for (propKey$jscomp$11 in props)
          if (hasOwnProperty.call(props, propKey$jscomp$11)) {
            var propValue$jscomp$11 = props[propKey$jscomp$11];
            if (propValue$jscomp$11 != null) {
              var attributeName = propKey$jscomp$11;
              switch (propKey$jscomp$11) {
                case "children":
                  children$jscomp$11 = propValue$jscomp$11;
                  break;
                case "dangerouslySetInnerHTML":
                  innerHTML$jscomp$8 = propValue$jscomp$11;
                  break;
                case "style":
                  pushStyleAttribute(target$jscomp$0, propValue$jscomp$11);
                  break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "ref":
                  break;
                case "className":
                  attributeName = "class";
                default:
                  if (isAttributeNameSafe(propKey$jscomp$11) && typeof propValue$jscomp$11 !== "function" && typeof propValue$jscomp$11 !== "symbol" && propValue$jscomp$11 !== false) {
                    if (propValue$jscomp$11 === true)
                      propValue$jscomp$11 = "";
                    else if (typeof propValue$jscomp$11 === "object")
                      continue;
                    target$jscomp$0.push(attributeSeparator, attributeName, attributeAssign, escapeTextForBrowser(propValue$jscomp$11), attributeEnd);
                  }
              }
            }
          }
        target$jscomp$0.push(endOfStartTag);
        pushInnerHTML(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
        return children$jscomp$11;
      }
  }
  return pushStartGenericElement(target$jscomp$0, props, type);
}
function endChunkForTag(tag2) {
  var chunk = endTagCache.get(tag2);
  chunk === undefined && (chunk = "</" + tag2 + ">", endTagCache.set(tag2, chunk));
  return chunk;
}
function hoistPreambleState(renderState, preambleState) {
  renderState = renderState.preamble;
  renderState.htmlChunks === null && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
  renderState.headChunks === null && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
  renderState.bodyChunks === null && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
}
function writeBootstrap(destination, renderState) {
  renderState = renderState.bootstrapChunks;
  for (var i2 = 0;i2 < renderState.length - 1; i2++)
    writeChunk(destination, renderState[i2]);
  return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, !!destination.write(i2)) : true;
}
function writeStartPendingSuspenseBoundary(destination, renderState, id) {
  writeChunk(destination, startPendingSuspenseBoundary1);
  if (id === null)
    throw Error("An ID must have been assigned before we can complete the boundary.");
  writeChunk(destination, renderState.boundaryPrefix);
  writeChunk(destination, id.toString(16));
  return !!destination.write(startPendingSuspenseBoundary2);
}
function writeStartSegment(destination, renderState, formatContext, id) {
  switch (formatContext.insertionMode) {
    case ROOT_HTML_MODE:
    case HTML_HTML_MODE:
    case HTML_HEAD_MODE:
    case HTML_MODE:
      return writeChunk(destination, startSegmentHTML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentHTML2);
    case SVG_MODE:
      return writeChunk(destination, startSegmentSVG), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentSVG2);
    case MATHML_MODE:
      return writeChunk(destination, startSegmentMathML), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentMathML2);
    case HTML_TABLE_MODE:
      return writeChunk(destination, startSegmentTable), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTable2);
    case HTML_TABLE_BODY_MODE:
      return writeChunk(destination, startSegmentTableBody), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTableBody2);
    case HTML_TABLE_ROW_MODE:
      return writeChunk(destination, startSegmentTableRow), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentTableRow2);
    case HTML_COLGROUP_MODE:
      return writeChunk(destination, startSegmentColGroup), writeChunk(destination, renderState.segmentPrefix), writeChunk(destination, id.toString(16)), !!destination.write(startSegmentColGroup2);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function writeEndSegment(destination, formatContext) {
  switch (formatContext.insertionMode) {
    case ROOT_HTML_MODE:
    case HTML_HTML_MODE:
    case HTML_HEAD_MODE:
    case HTML_MODE:
      return !!destination.write(endSegmentHTML);
    case SVG_MODE:
      return !!destination.write(endSegmentSVG);
    case MATHML_MODE:
      return !!destination.write(endSegmentMathML);
    case HTML_TABLE_MODE:
      return !!destination.write(endSegmentTable);
    case HTML_TABLE_BODY_MODE:
      return !!destination.write(endSegmentTableBody);
    case HTML_TABLE_ROW_MODE:
      return !!destination.write(endSegmentTableRow);
    case HTML_COLGROUP_MODE:
      return !!destination.write(endSegmentColGroup);
    default:
      throw Error("Unknown insertion mode. This is a bug in React.");
  }
}
function escapeJSStringsForInstructionScripts(input) {
  return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts, function(match) {
    switch (match) {
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function escapeJSObjectForInstructionScripts(input) {
  return JSON.stringify(input).replace(regexForJSStringsInScripts, function(match) {
    switch (match) {
      case "&":
        return "\\u0026";
      case ">":
        return "\\u003e";
      case "<":
        return "\\u003c";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
    }
  });
}
function flushStyleTagsLateForBoundary(styleQueue) {
  var { rules, hrefs } = styleQueue;
  0 < rules.length && hrefs.length === 0 && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
  var i2 = 0;
  if (hrefs.length) {
    writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
    writeChunk(this, lateStyleTagResourceOpen1);
    writeChunk(this, styleQueue.precedence);
    for (writeChunk(this, lateStyleTagResourceOpen2);i2 < hrefs.length - 1; i2++)
      writeChunk(this, hrefs[i2]), writeChunk(this, spaceSeparator);
    writeChunk(this, hrefs[i2]);
    writeChunk(this, lateStyleTagResourceOpen3);
    for (i2 = 0;i2 < rules.length; i2++)
      writeChunk(this, rules[i2]);
    destinationHasCapacity = !!this.write(lateStyleTagTemplateClose);
    currentlyRenderingBoundaryHasStylesToHoist = true;
    rules.length = 0;
    hrefs.length = 0;
  }
}
function hasStylesToHoist(stylesheet) {
  return stylesheet.state !== PREAMBLE ? currentlyRenderingBoundaryHasStylesToHoist = true : false;
}
function writeHoistablesForBoundary(destination, hoistableState, renderState) {
  currentlyRenderingBoundaryHasStylesToHoist = false;
  destinationHasCapacity = true;
  currentlyFlushingRenderState = renderState;
  hoistableState.styles.forEach(flushStyleTagsLateForBoundary, destination);
  currentlyFlushingRenderState = null;
  hoistableState.stylesheets.forEach(hasStylesToHoist);
  currentlyRenderingBoundaryHasStylesToHoist && (renderState.stylesToHoist = true);
  return destinationHasCapacity;
}
function flushResource(resource) {
  for (var i2 = 0;i2 < resource.length; i2++)
    writeChunk(this, resource[i2]);
  resource.length = 0;
}
function flushStyleInPreamble(stylesheet) {
  pushLinkImpl(stylesheetFlushingQueue, stylesheet.props);
  for (var i2 = 0;i2 < stylesheetFlushingQueue.length; i2++)
    writeChunk(this, stylesheetFlushingQueue[i2]);
  stylesheetFlushingQueue.length = 0;
  stylesheet.state = PREAMBLE;
}
function flushStylesInPreamble(styleQueue) {
  var hasStylesheets = 0 < styleQueue.sheets.size;
  styleQueue.sheets.forEach(flushStyleInPreamble, this);
  styleQueue.sheets.clear();
  var { rules, hrefs } = styleQueue;
  if (!hasStylesheets || hrefs.length) {
    writeChunk(this, currentlyFlushingRenderState.startInlineStyle);
    writeChunk(this, styleTagResourceOpen1);
    writeChunk(this, styleQueue.precedence);
    styleQueue = 0;
    if (hrefs.length) {
      for (writeChunk(this, styleTagResourceOpen2);styleQueue < hrefs.length - 1; styleQueue++)
        writeChunk(this, hrefs[styleQueue]), writeChunk(this, spaceSeparator);
      writeChunk(this, hrefs[styleQueue]);
    }
    writeChunk(this, styleTagResourceOpen3);
    for (styleQueue = 0;styleQueue < rules.length; styleQueue++)
      writeChunk(this, rules[styleQueue]);
    writeChunk(this, styleTagResourceClose);
    rules.length = 0;
    hrefs.length = 0;
  }
}
function preloadLateStyle(stylesheet) {
  if (stylesheet.state === PENDING$1) {
    stylesheet.state = PRELOADED;
    var props = stylesheet.props;
    pushLinkImpl(stylesheetFlushingQueue, {
      rel: "preload",
      as: "style",
      href: stylesheet.props.href,
      crossOrigin: props.crossOrigin,
      fetchPriority: props.fetchPriority,
      integrity: props.integrity,
      media: props.media,
      hrefLang: props.hrefLang,
      referrerPolicy: props.referrerPolicy
    });
    for (stylesheet = 0;stylesheet < stylesheetFlushingQueue.length; stylesheet++)
      writeChunk(this, stylesheetFlushingQueue[stylesheet]);
    stylesheetFlushingQueue.length = 0;
  }
}
function preloadLateStyles(styleQueue) {
  styleQueue.sheets.forEach(preloadLateStyle, this);
  styleQueue.sheets.clear();
}
function pushCompletedShellIdAttribute(target, resumableState) {
  (resumableState.instructions & SentCompletedShellId) === NothingSent && (resumableState.instructions |= SentCompletedShellId, target.push(completedShellIdAttributeStart, escapeTextForBrowser("_" + resumableState.idPrefix + "R_"), attributeEnd));
}
function writeStyleResourceDependenciesInJS(destination, hoistableState) {
  writeChunk(destination, arrayFirstOpenBracket);
  var nextArrayOpenBrackChunk = arrayFirstOpenBracket;
  hoistableState.stylesheets.forEach(function(resource) {
    if (resource.state !== PREAMBLE)
      if (resource.state === LATE)
        writeChunk(destination, nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion(resource, "href"), writeChunk(destination, escapeJSObjectForInstructionScripts("" + resource)), writeChunk(destination, arrayCloseBracket), nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
      else {
        writeChunk(destination, nextArrayOpenBrackChunk);
        var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL("" + resource.props.href);
        writeChunk(destination, escapeJSObjectForInstructionScripts(coercedHref));
        checkAttributeStringCoercion(precedence, "precedence");
        precedence = "" + precedence;
        writeChunk(destination, arrayInterstitial);
        writeChunk(destination, escapeJSObjectForInstructionScripts(precedence));
        for (var propKey in props)
          if (hasOwnProperty.call(props, propKey) && (precedence = props[propKey], precedence != null))
            switch (propKey) {
              case "href":
              case "rel":
              case "precedence":
              case "data-precedence":
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                writeStyleResourceAttributeInJS(destination, propKey, precedence);
            }
        writeChunk(destination, arrayCloseBracket);
        nextArrayOpenBrackChunk = arraySubsequentOpenBracket;
        resource.state = LATE;
      }
  });
  writeChunk(destination, arrayCloseBracket);
}
function writeStyleResourceAttributeInJS(destination, name, value) {
  var attributeName = name.toLowerCase();
  switch (typeof value) {
    case "function":
    case "symbol":
      return;
  }
  switch (name) {
    case "innerHTML":
    case "dangerouslySetInnerHTML":
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "style":
    case "ref":
      return;
    case "className":
      attributeName = "class";
      checkAttributeStringCoercion(value, attributeName);
      name = "" + value;
      break;
    case "hidden":
      if (value === false)
        return;
      name = "";
      break;
    case "src":
    case "href":
      value = sanitizeURL(value);
      checkAttributeStringCoercion(value, attributeName);
      name = "" + value;
      break;
    default:
      if (2 < name.length && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N") || !isAttributeNameSafe(name))
        return;
      checkAttributeStringCoercion(value, attributeName);
      name = "" + value;
  }
  writeChunk(destination, arrayInterstitial);
  writeChunk(destination, escapeJSObjectForInstructionScripts(attributeName));
  writeChunk(destination, arrayInterstitial);
  writeChunk(destination, escapeJSObjectForInstructionScripts(name));
}
function createHoistableState() {
  return { styles: new Set, stylesheets: new Set, suspenseyImages: false };
}
function prefetchDNS(href) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (typeof href === "string" && href) {
      if (!resumableState.dnsResources.hasOwnProperty(href)) {
        resumableState.dnsResources[href] = EXISTS;
        resumableState = renderState.headers;
        var header, JSCompiler_temp;
        if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
          JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
        JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.D(href);
}
function preconnect(href, crossOrigin) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (typeof href === "string" && href) {
      var bucket = crossOrigin === "use-credentials" ? "credentials" : typeof crossOrigin === "string" ? "anonymous" : "default";
      if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
        resumableState.connectResources[bucket][href] = EXISTS;
        resumableState = renderState.headers;
        var header, JSCompiler_temp;
        if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
          JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext(href) + ">; rel=preconnect";
          if (typeof crossOrigin === "string") {
            var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext(crossOrigin, "crossOrigin");
            JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
          }
          JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
        }
        JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl(bucket, {
          rel: "preconnect",
          href,
          crossOrigin
        }), renderState.preconnects.add(bucket));
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.C(href, crossOrigin);
}
function preload(href, as, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (as && href) {
      switch (as) {
        case "image":
          if (options) {
            var imageSrcSet = options.imageSrcSet;
            var imageSizes = options.imageSizes;
            var fetchPriority = options.fetchPriority;
          }
          var key = imageSrcSet ? imageSrcSet + `
` + (imageSizes || "") : href;
          if (resumableState.imageResources.hasOwnProperty(key))
            return;
          resumableState.imageResources[key] = PRELOAD_NO_CREDS;
          resumableState = renderState.headers;
          var header;
          resumableState && 0 < resumableState.remainingCapacity && typeof imageSrcSet !== "string" && fetchPriority === "high" && (header = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl(resumableState, assign({ rel: "preload", href: imageSrcSet ? undefined : href, as }, options)), fetchPriority === "high" ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
          break;
        case "style":
          if (resumableState.styleResources.hasOwnProperty(href))
            return;
          imageSrcSet = [];
          pushLinkImpl(imageSrcSet, assign({ rel: "preload", href, as }, options));
          resumableState.styleResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          renderState.preloads.stylesheets.set(href, imageSrcSet);
          renderState.bulkPreloads.add(imageSrcSet);
          break;
        case "script":
          if (resumableState.scriptResources.hasOwnProperty(href))
            return;
          imageSrcSet = [];
          renderState.preloads.scripts.set(href, imageSrcSet);
          renderState.bulkPreloads.add(imageSrcSet);
          pushLinkImpl(imageSrcSet, assign({ rel: "preload", href, as }, options));
          resumableState.scriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          break;
        default:
          if (resumableState.unknownResources.hasOwnProperty(as)) {
            if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
              return;
          } else
            imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
          imageSrcSet[href] = PRELOAD_NO_CREDS;
          if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && as === "font" && (key = getPreloadAsHeader(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
            renderState.resets.font[href] = PRELOAD_NO_CREDS, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
          else
            switch (resumableState = [], href = assign({ rel: "preload", href, as }, options), pushLinkImpl(resumableState, href), as) {
              case "font":
                renderState.fontPreloads.add(resumableState);
                break;
              default:
                renderState.bulkPreloads.add(resumableState);
            }
      }
      enqueueFlush(request);
    }
  } else
    previousDispatcher.L(href, as, options);
}
function preloadModule(href, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (href) {
      var as = options && typeof options.as === "string" ? options.as : "script";
      switch (as) {
        case "script":
          if (resumableState.moduleScriptResources.hasOwnProperty(href))
            return;
          as = [];
          resumableState.moduleScriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS : [options.crossOrigin, options.integrity];
          renderState.preloads.moduleScripts.set(href, as);
          break;
        default:
          if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
            var resources = resumableState.unknownResources[as];
            if (resources.hasOwnProperty(href))
              return;
          } else
            resources = {}, resumableState.moduleUnknownResources[as] = resources;
          as = [];
          resources[href] = PRELOAD_NO_CREDS;
      }
      pushLinkImpl(as, assign({ rel: "modulepreload", href }, options));
      renderState.bulkPreloads.add(as);
      enqueueFlush(request);
    }
  } else
    previousDispatcher.m(href, options);
}
function preinitStyle(href, precedence, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (href) {
      precedence = precedence || "default";
      var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
      resourceState !== EXISTS && (resumableState.styleResources[href] = EXISTS, styleQueue || (styleQueue = {
        precedence: escapeTextForBrowser(precedence),
        rules: [],
        hrefs: [],
        sheets: new Map
      }, renderState.styles.set(precedence, styleQueue)), precedence = {
        state: PENDING$1,
        props: assign({ rel: "stylesheet", href, "data-precedence": precedence }, options)
      }, resourceState && (resourceState.length === 2 && adoptPreloadCredentials(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED), styleQueue.sheets.set(href, precedence), enqueueFlush(request));
    }
  } else
    previousDispatcher.S(href, precedence, options);
}
function preinitScript(src, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (src) {
      var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : undefined;
      resourceState !== EXISTS && (resumableState.scriptResources[src] = EXISTS, options = assign({ src, async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
    }
  } else
    previousDispatcher.X(src, options);
}
function preinitModuleScript(src, options) {
  var request = currentRequest ? currentRequest : null;
  if (request) {
    var { resumableState, renderState } = request;
    if (src) {
      var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : undefined;
      resourceState !== EXISTS && (resumableState.moduleScriptResources[src] = EXISTS, options = assign({ src, type: "module", async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl(src, options), enqueueFlush(request));
    }
  } else
    previousDispatcher.M(src, options);
}
function preloadBootstrapScriptOrModule(resumableState, renderState, href, props) {
  (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error('Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue', href);
  resumableState.scriptResources[href] = EXISTS;
  resumableState.moduleScriptResources[href] = EXISTS;
  resumableState = [];
  pushLinkImpl(resumableState, props);
  renderState.bootstrapScripts.add(resumableState);
}
function adoptPreloadCredentials(target, preloadState) {
  target.crossOrigin == null && (target.crossOrigin = preloadState[0]);
  target.integrity == null && (target.integrity = preloadState[1]);
}
function getPreloadAsHeader(href, as, params) {
  href = escapeHrefForLinkHeaderURLContext(href);
  as = escapeStringForLinkHeaderQuotedParamValueContext(as, "as");
  as = "<" + href + '>; rel=preload; as="' + as + '"';
  for (var paramName in params)
    hasOwnProperty.call(params, paramName) && (href = params[paramName], typeof href === "string" && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext(href, paramName) + '"'));
  return as;
}
function escapeHrefForLinkHeaderURLContext(hrefInput) {
  checkAttributeStringCoercion(hrefInput, "href");
  return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext, escapeHrefForLinkHeaderURLContextReplacer);
}
function escapeHrefForLinkHeaderURLContextReplacer(match) {
  switch (match) {
    case "<":
      return "%3C";
    case ">":
      return "%3E";
    case `
`:
      return "%0A";
    case "\r":
      return "%0D";
    default:
      throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
  }
}
function escapeStringForLinkHeaderQuotedParamValueContext(value, name) {
  willCoercionThrow(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name, typeName(value)), testStringCoercion(value));
  return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext, escapeStringForLinkHeaderQuotedParamValueContextReplacer);
}
function escapeStringForLinkHeaderQuotedParamValueContextReplacer(match) {
  switch (match) {
    case '"':
      return "%22";
    case "'":
      return "%27";
    case ";":
      return "%3B";
    case ",":
      return "%2C";
    case `
`:
      return "%0A";
    case "\r":
      return "%0D";
    default:
      throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
  }
}
function hoistStyleQueueDependency(styleQueue) {
  this.styles.add(styleQueue);
}
function hoistStylesheetDependency(stylesheet) {
  this.stylesheets.add(stylesheet);
}
function hoistHoistables(parentState, childState) {
  childState.styles.forEach(hoistStyleQueueDependency, parentState);
  childState.stylesheets.forEach(hoistStylesheetDependency, parentState);
  childState.suspenseyImages && (parentState.suspenseyImages = true);
}
function hasSuspenseyContent(hoistableState) {
  return 0 < hoistableState.stylesheets.size || hoistableState.suspenseyImages;
}
function getComponentNameFromType(type) {
  if (type == null)
    return null;
  if (typeof type === "function")
    return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
  if (typeof type === "string")
    return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if (typeof type === "object")
    switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return type.displayName || "Context";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x2) {}
    }
  return null;
}
function popToNearestCommonAncestor(prev, next) {
  if (prev !== next) {
    prev.context._currentValue = prev.parentValue;
    prev = prev.parent;
    var parentNext = next.parent;
    if (prev === null) {
      if (parentNext !== null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
    } else {
      if (parentNext === null)
        throw Error("The stacks must reach the root at the same time. This is a bug in React.");
      popToNearestCommonAncestor(prev, parentNext);
    }
    next.context._currentValue = next.value;
  }
}
function popAllPrevious(prev) {
  prev.context._currentValue = prev.parentValue;
  prev = prev.parent;
  prev !== null && popAllPrevious(prev);
}
function pushAllNext(next) {
  var parentNext = next.parent;
  parentNext !== null && pushAllNext(parentNext);
  next.context._currentValue = next.value;
}
function popPreviousToCommonLevel(prev, next) {
  prev.context._currentValue = prev.parentValue;
  prev = prev.parent;
  if (prev === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  prev.depth === next.depth ? popToNearestCommonAncestor(prev, next) : popPreviousToCommonLevel(prev, next);
}
function popNextToCommonLevel(prev, next) {
  var parentNext = next.parent;
  if (parentNext === null)
    throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
  prev.depth === parentNext.depth ? popToNearestCommonAncestor(prev, parentNext) : popNextToCommonLevel(prev, parentNext);
  next.context._currentValue = next.value;
}
function switchContext(newSnapshot) {
  var prev = currentActiveSnapshot;
  prev !== newSnapshot && (prev === null ? pushAllNext(newSnapshot) : newSnapshot === null ? popAllPrevious(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel(prev, newSnapshot) : popNextToCommonLevel(prev, newSnapshot), currentActiveSnapshot = newSnapshot);
}
function warnOnInvalidCallback(callback) {
  if (callback !== null && typeof callback !== "function") {
    var key = String(callback);
    didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
  }
}
function warnNoop(publicInstance, callerName) {
  publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType(publicInstance) || "ReactClass";
  var warningKey = publicInstance + "." + callerName;
  didWarnAboutNoopUpdateForComponent[warningKey] || (console.error(`Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, publicInstance), didWarnAboutNoopUpdateForComponent[warningKey] = true);
}
function pushTreeContext(baseContext, totalChildren, index) {
  var baseIdWithLeadingBit = baseContext.id;
  baseContext = baseContext.overflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - baseLength % 5;
    length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    return {
      id: 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
      overflow: length + baseContext
    };
  }
  return {
    id: 1 << length | index << baseLength | baseIdWithLeadingBit,
    overflow: baseContext
  };
}
function clz32Fallback(x2) {
  x2 >>>= 0;
  return x2 === 0 ? 32 : 31 - (log(x2) / LN2 | 0) | 0;
}
function noop3() {}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  index === undefined ? thenableState.push(thenable) : index !== thenable && (thenable.then(noop3, noop3), thenable = index);
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      typeof thenable.status === "string" ? thenable.then(noop3, noop3) : (thenableState = thenable, thenableState.status = "pending", thenableState.then(function(fulfilledValue) {
        if (thenable.status === "pending") {
          var fulfilledThenable = thenable;
          fulfilledThenable.status = "fulfilled";
          fulfilledThenable.value = fulfilledValue;
        }
      }, function(error40) {
        if (thenable.status === "pending") {
          var rejectedThenable = thenable;
          rejectedThenable.status = "rejected";
          rejectedThenable.reason = error40;
        }
      }));
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function getSuspendedThenable() {
  if (suspendedThenable === null)
    throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function is2(x2, y) {
  return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
}
function resolveCurrentlyRenderingComponent() {
  if (currentlyRenderingComponent === null)
    throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
  isInHookUserCodeInDev && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
  return currentlyRenderingComponent;
}
function createHook() {
  if (0 < numberOfReRenders)
    throw Error("Rendered more hooks than during the previous render");
  return { memoizedState: null, queue: null, next: null };
}
function createWorkInProgressHook() {
  workInProgressHook === null ? firstWorkInProgressHook === null ? (isReRender = false, firstWorkInProgressHook = workInProgressHook = createHook()) : (isReRender = true, workInProgressHook = firstWorkInProgressHook) : workInProgressHook.next === null ? (isReRender = false, workInProgressHook = workInProgressHook.next = createHook()) : (isReRender = true, workInProgressHook = workInProgressHook.next);
  return workInProgressHook;
}
function getThenableStateAfterSuspending() {
  var state = thenableState;
  thenableState = null;
  return state;
}
function resetHooksState() {
  isInHookUserCodeInDev = false;
  currentlyRenderingKeyPath = currentlyRenderingRequest = currentlyRenderingTask = currentlyRenderingComponent = null;
  didScheduleRenderPhaseUpdate = false;
  firstWorkInProgressHook = null;
  numberOfReRenders = 0;
  workInProgressHook = renderPhaseUpdates = null;
}
function readContext(context) {
  isInHookUserCodeInDev && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
  return context._currentValue;
}
function basicStateReducer(state, action) {
  return typeof action === "function" ? action(state) : action;
}
function useReducer(reducer, initialArg, init) {
  reducer !== basicStateReducer && (currentHookNameInDev = "useReducer");
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  if (isReRender) {
    init = workInProgressHook.queue;
    initialArg = init.dispatch;
    if (renderPhaseUpdates !== null) {
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(init);
      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(init);
        init = workInProgressHook.memoizedState;
        do {
          var action = firstRenderPhaseUpdate.action;
          isInHookUserCodeInDev = true;
          init = reducer(init, action);
          isInHookUserCodeInDev = false;
          firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
        } while (firstRenderPhaseUpdate !== null);
        workInProgressHook.memoizedState = init;
        return [init, initialArg];
      }
    }
    return [workInProgressHook.memoizedState, initialArg];
  }
  isInHookUserCodeInDev = true;
  reducer = reducer === basicStateReducer ? typeof initialArg === "function" ? initialArg() : initialArg : init !== undefined ? init(initialArg) : initialArg;
  isInHookUserCodeInDev = false;
  workInProgressHook.memoizedState = reducer;
  reducer = workInProgressHook.queue = { last: null, dispatch: null };
  reducer = reducer.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, reducer);
  return [workInProgressHook.memoizedState, reducer];
}
function useMemo(nextCreate, deps) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  deps = deps === undefined ? null : deps;
  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;
    if (prevState !== null && deps !== null) {
      a: {
        var JSCompiler_inline_result = prevState[1];
        if (JSCompiler_inline_result === null)
          console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), JSCompiler_inline_result = false;
        else {
          deps.length !== JSCompiler_inline_result.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
          for (var i2 = 0;i2 < JSCompiler_inline_result.length && i2 < deps.length; i2++)
            if (!objectIs(deps[i2], JSCompiler_inline_result[i2])) {
              JSCompiler_inline_result = false;
              break a;
            }
          JSCompiler_inline_result = true;
        }
      }
      if (JSCompiler_inline_result)
        return prevState[0];
    }
  }
  isInHookUserCodeInDev = true;
  nextCreate = nextCreate();
  isInHookUserCodeInDev = false;
  workInProgressHook.memoizedState = [nextCreate, deps];
  return nextCreate;
}
function dispatchAction(componentIdentity, queue, action) {
  if (25 <= numberOfReRenders)
    throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
  if (componentIdentity === currentlyRenderingComponent)
    if (didScheduleRenderPhaseUpdate = true, componentIdentity = { action, next: null }, renderPhaseUpdates === null && (renderPhaseUpdates = new Map), action = renderPhaseUpdates.get(queue), action === undefined)
      renderPhaseUpdates.set(queue, componentIdentity);
    else {
      for (queue = action;queue.next !== null; )
        queue = queue.next;
      queue.next = componentIdentity;
    }
}
function throwOnUseEffectEventCall() {
  throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
}
function unsupportedStartTransition() {
  throw Error("startTransition cannot be called during server rendering.");
}
function unsupportedSetOptimisticState() {
  throw Error("Cannot update optimistic state while rendering.");
}
function useActionState(action, initialState, permalink) {
  resolveCurrentlyRenderingComponent();
  var actionStateHookIndex = actionStateCounter++, request = currentlyRenderingRequest;
  if (typeof action.$$FORM_ACTION === "function") {
    var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath;
    request = request.formState;
    var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
    if (request !== null && typeof isSignatureEqual === "function") {
      var postbackKey = request[1];
      isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + Bun.hash(JSON.stringify([componentKeyPath, null, actionStateHookIndex])), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex = actionStateHookIndex, initialState = request[0]));
    }
    var boundAction = action.bind(null, initialState);
    action = function(payload) {
      boundAction(payload);
    };
    typeof boundAction.$$FORM_ACTION === "function" && (action.$$FORM_ACTION = function(prefix) {
      prefix = boundAction.$$FORM_ACTION(prefix);
      permalink !== undefined && (checkAttributeStringCoercion(permalink, "target"), permalink += "", prefix.action = permalink);
      var formData = prefix.data;
      formData && (nextPostbackStateKey === null && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + Bun.hash(JSON.stringify([
        componentKeyPath,
        null,
        actionStateHookIndex
      ]))), formData.append("$ACTION_KEY", nextPostbackStateKey));
      return prefix;
    });
    return [initialState, action, false];
  }
  var _boundAction = action.bind(null, initialState);
  return [
    initialState,
    function(payload) {
      _boundAction(payload);
    },
    false
  ];
}
function unwrapThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  thenableState === null && (thenableState = []);
  return trackUsedThenable(thenableState, thenable, index);
}
function unsupportedRefresh() {
  throw Error("Cache cannot be refreshed during server rendering.");
}
function disabledLog() {}
function disableLogs() {
  if (disabledDepth === 0) {
    prevLog = console.log;
    prevInfo = console.info;
    prevWarn = console.warn;
    prevError = console.error;
    prevGroup = console.group;
    prevGroupCollapsed = console.groupCollapsed;
    prevGroupEnd = console.groupEnd;
    var props = {
      configurable: true,
      enumerable: true,
      value: disabledLog,
      writable: true
    };
    Object.defineProperties(console, {
      info: props,
      log: props,
      warn: props,
      error: props,
      group: props,
      groupCollapsed: props,
      groupEnd: props
    });
  }
  disabledDepth++;
}
function reenableLogs() {
  disabledDepth--;
  if (disabledDepth === 0) {
    var props = { configurable: true, enumerable: true, writable: true };
    Object.defineProperties(console, {
      log: assign({}, props, { value: prevLog }),
      info: assign({}, props, { value: prevInfo }),
      warn: assign({}, props, { value: prevWarn }),
      error: assign({}, props, { value: prevError }),
      group: assign({}, props, { value: prevGroup }),
      groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
      groupEnd: assign({}, props, { value: prevGroupEnd })
    });
  }
  0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
}
function formatOwnerStack(error40) {
  var prevPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = undefined;
  error40 = error40.stack;
  Error.prepareStackTrace = prevPrepareStackTrace;
  error40.startsWith(`Error: react-stack-top-frame
`) && (error40 = error40.slice(29));
  prevPrepareStackTrace = error40.indexOf(`
`);
  prevPrepareStackTrace !== -1 && (error40 = error40.slice(prevPrepareStackTrace + 1));
  prevPrepareStackTrace = error40.indexOf("react_stack_bottom_frame");
  prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error40.lastIndexOf(`
`, prevPrepareStackTrace));
  if (prevPrepareStackTrace !== -1)
    error40 = error40.slice(0, prevPrepareStackTrace);
  else
    return "";
  return error40;
}
function describeBuiltInComponentFrame(name) {
  if (prefix === undefined)
    try {
      throw Error();
    } catch (x2) {
      var match = x2.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x2.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
  return `
` + prefix + name + suffix;
}
function describeNativeComponentFrame(fn, construct2) {
  if (!fn || reentry)
    return "";
  var frame = componentFrameCache.get(fn);
  if (frame !== undefined)
    return frame;
  reentry = true;
  frame = Error.prepareStackTrace;
  Error.prepareStackTrace = undefined;
  var previousDispatcher2 = null;
  previousDispatcher2 = ReactSharedInternals.H;
  ReactSharedInternals.H = null;
  disableLogs();
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function() {
        try {
          if (construct2) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x2) {
                var control = x2;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$0) {
                control = x$0;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$1) {
              control = x$1;
            }
            (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {});
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string")
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
    namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
      for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
        namePropDescriptor++;
      for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
        _RunInRootFrame$Deter++;
      if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
        for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
          _RunInRootFrame$Deter--;
      for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
        if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
          if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
            do
              if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                typeof fn === "function" && componentFrameCache.set(fn, _frame);
                return _frame;
              }
            while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
          }
          break;
        }
    }
  } finally {
    reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
  }
  sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
  typeof fn === "function" && componentFrameCache.set(fn, sampleLines);
  return sampleLines;
}
function describeComponentStackByType(type) {
  if (typeof type === "string")
    return describeBuiltInComponentFrame(type);
  if (typeof type === "function")
    return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame(type, true) : describeNativeComponentFrame(type, false);
  if (typeof type === "object" && type !== null) {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeNativeComponentFrame(type.render, false);
      case REACT_MEMO_TYPE:
        return describeNativeComponentFrame(type.type, false);
      case REACT_LAZY_TYPE:
        var lazyComponent = type, payload = lazyComponent._payload;
        lazyComponent = lazyComponent._init;
        try {
          type = lazyComponent(payload);
        } catch (x2) {
          return describeBuiltInComponentFrame("Lazy");
        }
        return describeComponentStackByType(type);
    }
    if (typeof type.name === "string") {
      a: {
        payload = type.name;
        lazyComponent = type.env;
        type = type.debugLocation;
        if (type != null) {
          type = formatOwnerStack(type);
          var idx = type.lastIndexOf(`
`);
          type = idx === -1 ? type : type.slice(idx + 1);
          if (type.indexOf(payload) !== -1) {
            payload = `
` + type;
            break a;
          }
        }
        payload = describeBuiltInComponentFrame(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
      }
      return payload;
    }
  }
  switch (type) {
    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame("SuspenseList");
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame("Suspense");
  }
  return "";
}
function isEligibleForOutlining(request, boundary) {
  return (500 < boundary.byteSize || hasSuspenseyContent(boundary.contentState)) && boundary.contentPreamble === null;
}
function defaultErrorHandler(error40) {
  if (typeof error40 === "object" && error40 !== null && typeof error40.environmentName === "string") {
    var JSCompiler_inline_result = error40.environmentName;
    error40 = [error40].slice(0);
    typeof error40[0] === "string" ? error40.splice(0, 1, "%c%s%c " + error40[0], "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "") : error40.splice(0, 0, "%c%s%c", "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", " " + JSCompiler_inline_result + " ", "");
    error40.unshift(console);
    JSCompiler_inline_result = bind.apply(console.error, error40);
    JSCompiler_inline_result();
  } else
    console.error(error40);
  return null;
}
function RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
  var abortSet = new Set;
  this.destination = null;
  this.flushScheduled = false;
  this.resumableState = resumableState;
  this.renderState = renderState;
  this.rootFormatContext = rootFormatContext;
  this.progressiveChunkSize = progressiveChunkSize === undefined ? 12800 : progressiveChunkSize;
  this.status = 10;
  this.fatalError = null;
  this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
  this.completedPreambleSegments = this.completedRootSegment = null;
  this.byteSize = 0;
  this.abortableTasks = abortSet;
  this.pingedTasks = [];
  this.clientRenderedBoundaries = [];
  this.completedBoundaries = [];
  this.partialBoundaries = [];
  this.trackedPostpones = null;
  this.onError = onError === undefined ? defaultErrorHandler : onError;
  this.onPostpone = onPostpone === undefined ? noop3 : onPostpone;
  this.onAllReady = onAllReady === undefined ? noop3 : onAllReady;
  this.onShellReady = onShellReady === undefined ? noop3 : onShellReady;
  this.onShellError = onShellError === undefined ? noop3 : onShellError;
  this.onFatalError = onFatalError === undefined ? noop3 : onFatalError;
  this.formState = formState === undefined ? null : formState;
  this.didWarnForKey = null;
}
function createRequest(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
  var now = getCurrentTime();
  1000 < now - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = now);
  resumableState = new RequestInstance(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
  renderState = createPendingSegment(resumableState, 0, null, rootFormatContext, false, false);
  renderState.parentFlushed = true;
  children = createRenderTask(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext, null, null, emptyContextObject, null);
  pushComponentStack(children);
  resumableState.pingedTasks.push(children);
  return resumableState;
}
function pingTask(request, task) {
  request.pingedTasks.push(task);
  request.pingedTasks.length === 1 && (request.flushScheduled = request.destination !== null, request.trackedPostpones !== null || request.status === 10 ? scheduleMicrotask(function() {
    return performWork(request);
  }) : setTimeout(function() {
    return performWork(request);
  }, 0));
}
function createSuspenseBoundary(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
  fallbackAbortableTasks = {
    status: PENDING,
    rootSegmentID: -1,
    parentFlushed: false,
    pendingTasks: 0,
    row,
    completedSegments: [],
    byteSize: 0,
    fallbackAbortableTasks,
    errorDigest: null,
    contentState: createHoistableState(),
    fallbackState: createHoistableState(),
    contentPreamble,
    fallbackPreamble,
    trackedContentKeyPath: null,
    trackedFallbackNode: null,
    errorMessage: null,
    errorStack: null,
    errorComponentStack: null
  };
  row !== null && (row.pendingTasks++, contentPreamble = row.boundaries, contentPreamble !== null && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, request !== null && hoistHoistables(fallbackAbortableTasks.contentState, request));
  return fallbackAbortableTasks;
}
function createRenderTask(request, thenableState2, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
  request.allPendingTasks++;
  blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
  row !== null && row.pendingTasks++;
  var task = {
    replay: null,
    node,
    childIndex,
    ping: function() {
      return pingTask(request, task);
    },
    blockedBoundary,
    blockedSegment,
    blockedPreamble,
    hoistableState,
    abortSet,
    keyPath,
    formatContext,
    context,
    treeContext,
    row,
    componentStack,
    thenableState: thenableState2
  };
  task.debugTask = debugTask;
  abortSet.add(task);
  return task;
}
function createReplayTask(request, thenableState2, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
  request.allPendingTasks++;
  blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
  row !== null && row.pendingTasks++;
  replay.pendingTasks++;
  var task = {
    replay,
    node,
    childIndex,
    ping: function() {
      return pingTask(request, task);
    },
    blockedBoundary,
    blockedSegment: null,
    blockedPreamble: null,
    hoistableState,
    abortSet,
    keyPath,
    formatContext,
    context,
    treeContext,
    row,
    componentStack,
    thenableState: thenableState2
  };
  task.debugTask = debugTask;
  abortSet.add(task);
  return task;
}
function createPendingSegment(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
  return {
    status: PENDING,
    parentFlushed: false,
    id: -1,
    index,
    chunks: [],
    children: [],
    preambleChildren: [],
    parentFormatContext,
    boundary,
    lastPushedText,
    textEmbedded
  };
}
function getCurrentStackInDEV() {
  if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null)
    return "";
  var componentStack = currentTaskInDEV.componentStack;
  try {
    var info = "";
    if (typeof componentStack.type === "string")
      info += describeBuiltInComponentFrame(componentStack.type);
    else if (typeof componentStack.type === "function") {
      if (!componentStack.owner) {
        var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
        var JSCompiler_inline_result = name ? describeBuiltInComponentFrame(name) : "";
        info = JSCompiler_temp_const + JSCompiler_inline_result;
      }
    } else
      componentStack.owner || (info += describeComponentStackByType(componentStack.type));
    for (;componentStack; )
      JSCompiler_temp_const = null, componentStack.debugStack != null ? JSCompiler_temp_const = formatOwnerStack(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, JSCompiler_inline_result.stack != null && (JSCompiler_temp_const = typeof JSCompiler_inline_result.stack !== "string" ? JSCompiler_inline_result.stack = formatOwnerStack(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += `
` + JSCompiler_temp_const);
    var JSCompiler_inline_result$jscomp$0 = info;
  } catch (x2) {
    JSCompiler_inline_result$jscomp$0 = `
Error generating stack: ` + x2.message + `
` + x2.stack;
  }
  return JSCompiler_inline_result$jscomp$0;
}
function pushHaltedAwaitOnComponentStack(task, debugInfo) {
  if (debugInfo != null)
    for (var i2 = debugInfo.length - 1;0 <= i2; i2--) {
      var info = debugInfo[i2];
      if (typeof info.name === "string")
        break;
      if (typeof info.time === "number")
        break;
      if (info.awaited != null) {
        var bestStack = info.debugStack == null ? info.awaited : info;
        if (bestStack.debugStack !== undefined) {
          task.componentStack = {
            parent: task.componentStack,
            type: info,
            owner: bestStack.owner,
            stack: bestStack.debugStack
          };
          task.debugTask = bestStack.debugTask;
          break;
        }
      }
    }
}
function pushServerComponentStack(task, debugInfo) {
  if (debugInfo != null)
    for (var i2 = 0;i2 < debugInfo.length; i2++) {
      var componentInfo = debugInfo[i2];
      typeof componentInfo.name === "string" && componentInfo.debugStack !== undefined && (task.componentStack = {
        parent: task.componentStack,
        type: componentInfo,
        owner: componentInfo.owner,
        stack: componentInfo.debugStack
      }, task.debugTask = componentInfo.debugTask);
    }
}
function pushComponentStack(task) {
  var node = task.node;
  if (typeof node === "object" && node !== null)
    switch (node.$$typeof) {
      case REACT_ELEMENT_TYPE:
        var { type, _owner: owner, _debugStack: stack } = node;
        pushServerComponentStack(task, node._debugInfo);
        task.debugTask = node._debugTask;
        task.componentStack = {
          parent: task.componentStack,
          type,
          owner,
          stack
        };
        break;
      case REACT_LAZY_TYPE:
        pushServerComponentStack(task, node._debugInfo);
        break;
      default:
        typeof node.then === "function" && pushServerComponentStack(task, node._debugInfo);
    }
}
function replaceSuspenseComponentStackWithSuspenseFallbackStack(componentStack) {
  return componentStack === null ? null : {
    parent: componentStack.parent,
    type: "Suspense Fallback",
    owner: componentStack.owner,
    stack: componentStack.stack
  };
}
function getThrownInfo(node$jscomp$0) {
  var errorInfo = {};
  node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
    configurable: true,
    enumerable: true,
    get: function() {
      try {
        var info = "", node = node$jscomp$0;
        do
          info += describeComponentStackByType(node.type), node = node.parent;
        while (node);
        var stack = info;
      } catch (x2) {
        stack = `
Error generating stack: ` + x2.message + `
` + x2.stack;
      }
      Object.defineProperty(errorInfo, "componentStack", { value: stack });
      return stack;
    }
  });
  return errorInfo;
}
function encodeErrorForBoundary(boundary, digest, error40, thrownInfo, wasAborted) {
  boundary.errorDigest = digest;
  error40 instanceof Error ? (digest = String(error40.message), error40 = String(error40.stack)) : (digest = typeof error40 === "object" && error40 !== null ? describeObjectForErrorMessage(error40) : String(error40), error40 = null);
  wasAborted = wasAborted ? `Switched to client rendering because the server rendering aborted due to:

` : `Switched to client rendering because the server rendering errored:

`;
  boundary.errorMessage = wasAborted + digest;
  boundary.errorStack = error40 !== null ? wasAborted + error40 : null;
  boundary.errorComponentStack = thrownInfo.componentStack;
}
function logRecoverableError(request, error40, errorInfo, debugTask) {
  request = request.onError;
  error40 = debugTask ? debugTask.run(request.bind(null, error40, errorInfo)) : request(error40, errorInfo);
  if (error40 != null && typeof error40 !== "string")
    console.error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead', typeof error40);
  else
    return error40;
}
function fatalError(request, error40, errorInfo, debugTask) {
  errorInfo = request.onShellError;
  var onFatalError = request.onFatalError;
  debugTask ? (debugTask.run(errorInfo.bind(null, error40)), debugTask.run(onFatalError.bind(null, error40))) : (errorInfo(error40), onFatalError(error40));
  request.destination !== null ? (request.status = CLOSED, closeWithError(request.destination, error40)) : (request.status = 13, request.fatalError = error40);
}
function finishSuspenseListRow(request, row) {
  unblockSuspenseListRow(request, row.next, row.hoistables);
}
function unblockSuspenseListRow(request, unblockedRow, inheritedHoistables) {
  for (;unblockedRow !== null; ) {
    inheritedHoistables !== null && (hoistHoistables(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
    var unblockedBoundaries = unblockedRow.boundaries;
    if (unblockedBoundaries !== null) {
      unblockedRow.boundaries = null;
      for (var i2 = 0;i2 < unblockedBoundaries.length; i2++) {
        var unblockedBoundary = unblockedBoundaries[i2];
        inheritedHoistables !== null && hoistHoistables(unblockedBoundary.contentState, inheritedHoistables);
        finishedTask(request, unblockedBoundary, null, null);
      }
    }
    unblockedRow.pendingTasks--;
    if (0 < unblockedRow.pendingTasks)
      break;
    inheritedHoistables = unblockedRow.hoistables;
    unblockedRow = unblockedRow.next;
  }
}
function tryToResolveTogetherRow(request, togetherRow) {
  var boundaries = togetherRow.boundaries;
  if (boundaries !== null && togetherRow.pendingTasks === boundaries.length) {
    for (var allCompleteAndInlinable = true, i2 = 0;i2 < boundaries.length; i2++) {
      var rowBoundary = boundaries[i2];
      if (rowBoundary.pendingTasks !== 1 || rowBoundary.parentFlushed || isEligibleForOutlining(request, rowBoundary)) {
        allCompleteAndInlinable = false;
        break;
      }
    }
    allCompleteAndInlinable && unblockSuspenseListRow(request, togetherRow, togetherRow.hoistables);
  }
}
function createSuspenseListRow(previousRow) {
  var newRow = {
    pendingTasks: 1,
    boundaries: null,
    hoistables: createHoistableState(),
    inheritedHoistables: null,
    together: false,
    next: null
  };
  previousRow !== null && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
  return newRow;
}
function renderSuspenseListRows(request, task, keyPath, rows, revealOrder) {
  var { keyPath: prevKeyPath, treeContext: prevTreeContext, row: prevRow, componentStack: previousComponentStack } = task;
  var previousDebugTask = task.debugTask;
  pushServerComponentStack(task, task.node.props.children._debugInfo);
  task.keyPath = keyPath;
  keyPath = rows.length;
  var previousSuspenseListRow = null;
  if (task.replay !== null) {
    var resumeSlots = task.replay.slots;
    if (resumeSlots !== null && typeof resumeSlots === "object")
      for (var n = 0;n < keyPath; n++) {
        var i2 = revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" ? n : keyPath - 1 - n, node = rows[i2];
        task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow);
        task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
        var resumeSegmentID = resumeSlots[i2];
        typeof resumeSegmentID === "number" ? (resumeNode(request, task, resumeSegmentID, node, i2), delete resumeSlots[i2]) : renderNode(request, task, node, i2);
        --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow(request, previousSuspenseListRow);
      }
    else
      for (resumeSlots = 0;resumeSlots < keyPath; resumeSlots++)
        n = revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" ? resumeSlots : keyPath - 1 - resumeSlots, i2 = rows[n], warnForMissingKey(request, task, i2), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, n), renderNode(request, task, i2, n), --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow(request, previousSuspenseListRow);
  } else if (revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards")
    for (revealOrder = 0;revealOrder < keyPath; revealOrder++)
      resumeSlots = rows[revealOrder], warnForMissingKey(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow), task.treeContext = pushTreeContext(prevTreeContext, keyPath, revealOrder), renderNode(request, task, resumeSlots, revealOrder), --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow(request, previousSuspenseListRow);
  else {
    revealOrder = task.blockedSegment;
    resumeSlots = revealOrder.children.length;
    n = revealOrder.chunks.length;
    for (i2 = keyPath - 1;0 <= i2; i2--) {
      node = rows[i2];
      task.row = previousSuspenseListRow = createSuspenseListRow(previousSuspenseListRow);
      task.treeContext = pushTreeContext(prevTreeContext, keyPath, i2);
      resumeSegmentID = createPendingSegment(request, n, null, task.formatContext, i2 === 0 ? revealOrder.lastPushedText : true, true);
      revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
      task.blockedSegment = resumeSegmentID;
      warnForMissingKey(request, task, node);
      try {
        renderNode(request, task, node, i2), pushSegmentFinale(resumeSegmentID.chunks, request.renderState, resumeSegmentID.lastPushedText, resumeSegmentID.textEmbedded), resumeSegmentID.status = COMPLETED, finishedSegment(request, task.blockedBoundary, resumeSegmentID), --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow(request, previousSuspenseListRow);
      } catch (thrownValue) {
        throw resumeSegmentID.status = request.status === 12 ? ABORTED : ERRORED, thrownValue;
      }
    }
    task.blockedSegment = revealOrder;
    revealOrder.lastPushedText = false;
  }
  prevRow !== null && previousSuspenseListRow !== null && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
  task.treeContext = prevTreeContext;
  task.row = prevRow;
  task.keyPath = prevKeyPath;
  task.componentStack = previousComponentStack;
  task.debugTask = previousDebugTask;
}
function renderWithHooks(request, task, keyPath, Component, props, secondArg) {
  var prevThenableState = task.thenableState;
  task.thenableState = null;
  currentlyRenderingComponent = {};
  currentlyRenderingTask = task;
  currentlyRenderingRequest = request;
  currentlyRenderingKeyPath = keyPath;
  isInHookUserCodeInDev = false;
  actionStateCounter = localIdCounter = 0;
  actionStateMatchingIndex = -1;
  thenableIndexCounter = 0;
  thenableState = prevThenableState;
  for (request = callComponentInDEV(Component, props, secondArg);didScheduleRenderPhaseUpdate; )
    didScheduleRenderPhaseUpdate = false, actionStateCounter = localIdCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, numberOfReRenders += 1, workInProgressHook = null, request = Component(props, secondArg);
  resetHooksState();
  return request;
}
function finishFunctionComponent(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex2) {
  var didEmitActionStateMarkers = false;
  if (actionStateCount !== 0 && request.formState !== null) {
    var segment = task.blockedSegment;
    if (segment !== null) {
      didEmitActionStateMarkers = true;
      segment = segment.chunks;
      for (var i2 = 0;i2 < actionStateCount; i2++)
        i2 === actionStateMatchingIndex2 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
    }
  }
  actionStateCount = task.keyPath;
  task.keyPath = keyPath;
  hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext(keyPath, 1, 0), renderNode(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode(request, task, children, -1) : renderNodeDestructive(request, task, children, -1);
  task.keyPath = actionStateCount;
}
function renderElement(request, task, keyPath, type, props, ref) {
  if (typeof type === "function")
    if (type.prototype && type.prototype.isReactComponent) {
      var newProps = props;
      if ("ref" in props) {
        newProps = {};
        for (var propName in props)
          propName !== "ref" && (newProps[propName] = props[propName]);
      }
      var defaultProps = type.defaultProps;
      if (defaultProps) {
        newProps === props && (newProps = assign({}, newProps, props));
        for (var _propName in defaultProps)
          newProps[_propName] === undefined && (newProps[_propName] = defaultProps[_propName]);
      }
      var resolvedProps = newProps;
      var context = emptyContextObject, contextType = type.contextType;
      if ("contextType" in type && contextType !== null && (contextType === undefined || contextType.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(type)) {
        didWarnAboutInvalidateContextType.add(type);
        var addendum = contextType === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType !== "object" ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
        console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(type) || "Component", addendum);
      }
      typeof contextType === "object" && contextType !== null && (context = contextType._currentValue);
      var instance = new type(resolvedProps, context);
      if (typeof type.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
        var componentName = getComponentNameFromType(type) || "Component";
        didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
      }
      if (typeof type.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
        var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
        typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount === "function" && (foundWillMountName = "UNSAFE_componentWillMount");
        typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps === "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
        typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
        if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
          var _componentName = getComponentNameFromType(type) || "Component", newApiName = typeof type.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
          didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
        }
      }
      var name = getComponentNameFromType(type) || "Component";
      instance.render || (type.prototype && typeof type.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name));
      !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
      instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
      instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
      type.childContextTypes && !didWarnAboutChildContextTypes.has(type) && (didWarnAboutChildContextTypes.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name));
      type.contextTypes && !didWarnAboutContextTypes$1.has(type) && (didWarnAboutContextTypes$1.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name));
      typeof instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
      type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(type) || "A pure component");
      typeof instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
      typeof instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
      typeof instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
      typeof instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
      var hasMutatedProps = instance.props !== resolvedProps;
      instance.props !== undefined && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name);
      instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
      typeof instance.getSnapshotBeforeUpdate !== "function" || typeof instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(type)));
      typeof instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
      typeof instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
      typeof type.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
      var state = instance.state;
      state && (typeof state !== "object" || isArrayImpl(state)) && console.error("%s.state: must be set to an object or null", name);
      typeof instance.getChildContext === "function" && typeof type.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
      var initialState = instance.state !== undefined ? instance.state : null;
      instance.updater = classComponentUpdater;
      instance.props = resolvedProps;
      instance.state = initialState;
      var internalInstance = { queue: [], replace: false };
      instance._reactInternals = internalInstance;
      var contextType$jscomp$0 = type.contextType;
      instance.context = typeof contextType$jscomp$0 === "object" && contextType$jscomp$0 !== null ? contextType$jscomp$0._currentValue : emptyContextObject;
      if (instance.state === resolvedProps) {
        var componentName$jscomp$0 = getComponentNameFromType(type) || "Component";
        didWarnAboutDirectlyAssigningPropsToState.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
      }
      var getDerivedStateFromProps = type.getDerivedStateFromProps;
      if (typeof getDerivedStateFromProps === "function") {
        var partialState = getDerivedStateFromProps(resolvedProps, initialState);
        if (partialState === undefined) {
          var componentName$jscomp$1 = getComponentNameFromType(type) || "Component";
          didWarnAboutUndefinedDerivedState.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
        }
        var JSCompiler_inline_result = partialState === null || partialState === undefined ? initialState : assign({}, initialState, partialState);
        instance.state = JSCompiler_inline_result;
      }
      if (typeof type.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
            var componentName$jscomp$2 = getComponentNameFromType(type) || "Unknown";
            didWarnAboutDeprecatedWillMount[componentName$jscomp$2] || (console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`, componentName$jscomp$2), didWarnAboutDeprecatedWillMount[componentName$jscomp$2] = true);
          }
          instance.componentWillMount();
        }
        typeof instance.UNSAFE_componentWillMount === "function" && instance.UNSAFE_componentWillMount();
        oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
        if (internalInstance.queue !== null && 0 < internalInstance.queue.length) {
          var { queue: oldQueue, replace: oldReplace } = internalInstance;
          internalInstance.queue = null;
          internalInstance.replace = false;
          if (oldReplace && oldQueue.length === 1)
            instance.state = oldQueue[0];
          else {
            for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i2 = oldReplace ? 1 : 0;i2 < oldQueue.length; i2++) {
              var partial2 = oldQueue[i2], partialState$jscomp$0 = typeof partial2 === "function" ? partial2.call(instance, nextState, resolvedProps, undefined) : partial2;
              partialState$jscomp$0 != null && (dontMutate ? (dontMutate = false, nextState = assign({}, nextState, partialState$jscomp$0)) : assign(nextState, partialState$jscomp$0));
            }
            instance.state = nextState;
          }
        } else
          internalInstance.queue = null;
      }
      var nextChildren = callRenderInDEV(instance);
      if (request.status === 12)
        throw null;
      instance.props !== resolvedProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(type) || "a component"), didWarnAboutReassigningProps = true);
      var prevKeyPath = task.keyPath;
      task.keyPath = keyPath;
      renderNodeDestructive(request, task, nextChildren, -1);
      task.keyPath = prevKeyPath;
    } else {
      if (type.prototype && typeof type.prototype.render === "function") {
        var componentName$jscomp$3 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutBadClass[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass[componentName$jscomp$3] = true);
      }
      var value = renderWithHooks(request, task, keyPath, type, props, undefined);
      if (request.status === 12)
        throw null;
      var hasId = localIdCounter !== 0, actionStateCount = actionStateCounter, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex;
      if (type.contextTypes) {
        var _componentName$jscomp$0 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutContextTypes[_componentName$jscomp$0] || (didWarnAboutContextTypes[_componentName$jscomp$0] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
      }
      type && type.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, type.displayName || type.name || "Component");
      if (typeof type.getDerivedStateFromProps === "function") {
        var componentName$jscomp$4 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", componentName$jscomp$4), didWarnAboutGetDerivedStateOnFunctionComponent[componentName$jscomp$4] = true);
      }
      if (typeof type.contextType === "object" && type.contextType !== null) {
        var _componentName2 = getComponentNameFromType(type) || "Unknown";
        didWarnAboutContextTypeOnFunctionComponent[_componentName2] || (console.error("%s: Function components do not support contextType.", _componentName2), didWarnAboutContextTypeOnFunctionComponent[_componentName2] = true);
      }
      finishFunctionComponent(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
    }
  else if (typeof type === "string") {
    var segment = task.blockedSegment;
    if (segment === null) {
      var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
      task.formatContext = getChildFormatContext(prevContext, type, props);
      task.keyPath = keyPath;
      renderNode(request, task, children, -1);
      task.formatContext = prevContext;
      task.keyPath = prevKeyPath$jscomp$0;
    } else {
      var _children = pushStartInstance(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText);
      segment.lastPushedText = false;
      var { formatContext: _prevContext2, keyPath: _prevKeyPath3 } = task;
      task.keyPath = keyPath;
      if ((task.formatContext = getChildFormatContext(_prevContext2, type, props)).insertionMode === HTML_HEAD_MODE) {
        var preambleSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
        segment.preambleChildren.push(preambleSegment);
        task.blockedSegment = preambleSegment;
        try {
          preambleSegment.status = 6, renderNode(request, task, _children, -1), pushSegmentFinale(preambleSegment.chunks, request.renderState, preambleSegment.lastPushedText, preambleSegment.textEmbedded), preambleSegment.status = COMPLETED, finishedSegment(request, task.blockedBoundary, preambleSegment);
        } finally {
          task.blockedSegment = segment;
        }
      } else
        renderNode(request, task, _children, -1);
      task.formatContext = _prevContext2;
      task.keyPath = _prevKeyPath3;
      a: {
        var target = segment.chunks, resumableState = request.resumableState;
        switch (type) {
          case "title":
          case "style":
          case "script":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "img":
          case "input":
          case "keygen":
          case "link":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
            break a;
          case "body":
            if (_prevContext2.insertionMode <= HTML_HTML_MODE) {
              resumableState.hasBody = true;
              break a;
            }
            break;
          case "html":
            if (_prevContext2.insertionMode === ROOT_HTML_MODE) {
              resumableState.hasHtml = true;
              break a;
            }
            break;
          case "head":
            if (_prevContext2.insertionMode <= HTML_HTML_MODE)
              break a;
        }
        target.push(endChunkForTag(type));
      }
      segment.lastPushedText = false;
    }
  } else {
    switch (type) {
      case REACT_LEGACY_HIDDEN_TYPE:
      case REACT_STRICT_MODE_TYPE:
      case REACT_PROFILER_TYPE:
      case REACT_FRAGMENT_TYPE:
        var prevKeyPath$jscomp$1 = task.keyPath;
        task.keyPath = keyPath;
        renderNodeDestructive(request, task, props.children, -1);
        task.keyPath = prevKeyPath$jscomp$1;
        return;
      case REACT_ACTIVITY_TYPE:
        var segment$jscomp$0 = task.blockedSegment;
        if (segment$jscomp$0 === null) {
          if (props.mode !== "hidden") {
            var prevKeyPath$jscomp$2 = task.keyPath;
            task.keyPath = keyPath;
            renderNode(request, task, props.children, -1);
            task.keyPath = prevKeyPath$jscomp$2;
          }
        } else if (props.mode !== "hidden") {
          segment$jscomp$0.chunks.push("<!--&-->");
          segment$jscomp$0.lastPushedText = false;
          var _prevKeyPath4 = task.keyPath;
          task.keyPath = keyPath;
          renderNode(request, task, props.children, -1);
          task.keyPath = _prevKeyPath4;
          segment$jscomp$0.chunks.push("<!--/&-->");
          segment$jscomp$0.lastPushedText = false;
        }
        return;
      case REACT_SUSPENSE_LIST_TYPE:
        a: {
          var { children: children$jscomp$0, revealOrder } = props;
          if (revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards") {
            if (isArrayImpl(children$jscomp$0)) {
              renderSuspenseListRows(request, task, keyPath, children$jscomp$0, revealOrder);
              break a;
            }
            var iteratorFn = getIteratorFn(children$jscomp$0);
            if (iteratorFn) {
              var iterator = iteratorFn.call(children$jscomp$0);
              if (iterator) {
                validateIterable(task, children$jscomp$0, -1, iterator, iteratorFn);
                var step = iterator.next();
                if (!step.done) {
                  var rows = [];
                  do
                    rows.push(step.value), step = iterator.next();
                  while (!step.done);
                  renderSuspenseListRows(request, task, keyPath, children$jscomp$0, revealOrder);
                }
                break a;
              }
            }
          }
          if (revealOrder === "together") {
            var { keyPath: _prevKeyPath2, row: prevRow } = task, newRow = task.row = createSuspenseListRow(null);
            newRow.boundaries = [];
            newRow.together = true;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, children$jscomp$0, -1);
            --newRow.pendingTasks === 0 && finishSuspenseListRow(request, newRow);
            task.keyPath = _prevKeyPath2;
            task.row = prevRow;
            prevRow !== null && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
          } else {
            var prevKeyPath$jscomp$3 = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive(request, task, children$jscomp$0, -1);
            task.keyPath = prevKeyPath$jscomp$3;
          }
        }
        return;
      case REACT_VIEW_TRANSITION_TYPE:
      case REACT_SCOPE_TYPE:
        throw Error("ReactDOMServer does not yet support scope components.");
      case REACT_SUSPENSE_TYPE:
        a:
          if (task.replay !== null) {
            var { keyPath: _prevKeyPath, formatContext: _prevContext, row: _prevRow } = task;
            task.keyPath = keyPath;
            task.formatContext = getSuspenseContentFormatContext(request.resumableState, _prevContext);
            task.row = null;
            var _content = props.children;
            try {
              renderNode(request, task, _content, -1);
            } finally {
              task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
            }
          } else {
            var { keyPath: prevKeyPath$jscomp$4, formatContext: prevContext$jscomp$0, row: prevRow$jscomp$0, blockedBoundary: parentBoundary, blockedPreamble: parentPreamble, hoistableState: parentHoistableState, blockedSegment: parentSegment } = task, fallback = props.fallback, content = props.children, fallbackAbortSet = new Set;
            var newBoundary = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(request, task.row, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, task.row, fallbackAbortSet, null, null);
            request.trackedPostpones !== null && (newBoundary.trackedContentKeyPath = keyPath);
            var boundarySegment = createPendingSegment(request, parentSegment.chunks.length, newBoundary, task.formatContext, false, false);
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
            contentRootSegment.parentFlushed = true;
            if (request.trackedPostpones !== null) {
              var suspenseComponentStack = task.componentStack, fallbackKeyPath = [keyPath[0], "Suspense Fallback", keyPath[2]], fallbackReplayNode = [
                fallbackKeyPath[1],
                fallbackKeyPath[2],
                [],
                null
              ];
              request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
              newBoundary.trackedFallbackNode = fallbackReplayNode;
              task.blockedSegment = boundarySegment;
              task.blockedPreamble = newBoundary.fallbackPreamble;
              task.keyPath = fallbackKeyPath;
              task.formatContext = getSuspenseFallbackFormatContext(request.resumableState, prevContext$jscomp$0);
              task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack(suspenseComponentStack);
              boundarySegment.status = 6;
              try {
                renderNode(request, task, fallback, -1), pushSegmentFinale(boundarySegment.chunks, request.renderState, boundarySegment.lastPushedText, boundarySegment.textEmbedded), boundarySegment.status = COMPLETED, finishedSegment(request, parentBoundary, boundarySegment);
              } catch (thrownValue) {
                throw boundarySegment.status = request.status === 12 ? ABORTED : ERRORED, thrownValue;
              } finally {
                task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
              }
              var suspendedPrimaryTask = createRenderTask(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, null, suspenseComponentStack, emptyContextObject, task.debugTask);
              pushComponentStack(suspendedPrimaryTask);
              request.pingedTasks.push(suspendedPrimaryTask);
            } else {
              task.blockedBoundary = newBoundary;
              task.blockedPreamble = newBoundary.contentPreamble;
              task.hoistableState = newBoundary.contentState;
              task.blockedSegment = contentRootSegment;
              task.keyPath = keyPath;
              task.formatContext = getSuspenseContentFormatContext(request.resumableState, prevContext$jscomp$0);
              task.row = null;
              contentRootSegment.status = 6;
              try {
                if (renderNode(request, task, content, -1), pushSegmentFinale(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED, finishedSegment(request, newBoundary, contentRootSegment), queueCompletedSegment(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0 && newBoundary.status === PENDING) {
                  if (newBoundary.status = COMPLETED, !isEligibleForOutlining(request, newBoundary)) {
                    prevRow$jscomp$0 !== null && --prevRow$jscomp$0.pendingTasks === 0 && finishSuspenseListRow(request, prevRow$jscomp$0);
                    request.pendingRootTasks === 0 && task.blockedPreamble && preparePreamble(request);
                    break a;
                  }
                } else
                  prevRow$jscomp$0 !== null && prevRow$jscomp$0.together && tryToResolveTogetherRow(request, prevRow$jscomp$0);
              } catch (thrownValue$2) {
                newBoundary.status = CLIENT_RENDERED;
                if (request.status === 12) {
                  contentRootSegment.status = ABORTED;
                  var error40 = request.fatalError;
                } else
                  contentRootSegment.status = ERRORED, error40 = thrownValue$2;
                var thrownInfo = getThrownInfo(task.componentStack);
                var errorDigest = logRecoverableError(request, error40, thrownInfo, task.debugTask);
                encodeErrorForBoundary(newBoundary, errorDigest, error40, thrownInfo, false);
                untrackBoundary(request, newBoundary);
              } finally {
                task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
              }
              var suspendedFallbackTask = createRenderTask(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], getSuspenseFallbackFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack(task.componentStack), emptyContextObject, task.debugTask);
              pushComponentStack(suspendedFallbackTask);
              request.pingedTasks.push(suspendedFallbackTask);
            }
          }
        return;
    }
    if (typeof type === "object" && type !== null)
      switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          if ("ref" in props) {
            var propsWithoutRef = {};
            for (var key in props)
              key !== "ref" && (propsWithoutRef[key] = props[key]);
          } else
            propsWithoutRef = props;
          var children$jscomp$1 = renderWithHooks(request, task, keyPath, type.render, propsWithoutRef, ref);
          finishFunctionComponent(request, task, keyPath, children$jscomp$1, localIdCounter !== 0, actionStateCounter, actionStateMatchingIndex);
          return;
        case REACT_MEMO_TYPE:
          renderElement(request, task, keyPath, type.type, props, ref);
          return;
        case REACT_CONTEXT_TYPE:
          var { value: value$jscomp$0, children: children$jscomp$2 } = props;
          var prevSnapshot = task.context;
          var prevKeyPath$jscomp$5 = task.keyPath;
          var prevValue = type._currentValue;
          type._currentValue = value$jscomp$0;
          type._currentRenderer !== undefined && type._currentRenderer !== null && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
          type._currentRenderer = rendererSigil;
          var prevNode = currentActiveSnapshot, newNode = {
            parent: prevNode,
            depth: prevNode === null ? 0 : prevNode.depth + 1,
            context: type,
            parentValue: prevValue,
            value: value$jscomp$0
          };
          currentActiveSnapshot = newNode;
          task.context = newNode;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, children$jscomp$2, -1);
          var prevSnapshot$jscomp$0 = currentActiveSnapshot;
          if (prevSnapshot$jscomp$0 === null)
            throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
          prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
          prevSnapshot$jscomp$0.context._currentValue = prevSnapshot$jscomp$0.parentValue;
          type._currentRenderer !== undefined && type._currentRenderer !== null && type._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
          type._currentRenderer = rendererSigil;
          var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot = prevSnapshot$jscomp$0.parent;
          task.context = JSCompiler_inline_result$jscomp$0;
          task.keyPath = prevKeyPath$jscomp$5;
          prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
          return;
        case REACT_CONSUMER_TYPE:
          var context$jscomp$0 = type._context, render = props.children;
          typeof render !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
          var newChildren = render(context$jscomp$0._currentValue), prevKeyPath$jscomp$6 = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive(request, task, newChildren, -1);
          task.keyPath = prevKeyPath$jscomp$6;
          return;
        case REACT_LAZY_TYPE:
          var Component = callLazyInitInDEV(type);
          if (request.status === 12)
            throw null;
          renderElement(request, task, keyPath, Component, props, ref);
          return;
      }
    var info = "";
    if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
      info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
    throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((type == null ? type : typeof type) + "." + info));
  }
}
function resumeNode(request, task, segmentId, node, childIndex) {
  var { replay: prevReplay, blockedBoundary } = task, resumedSegment = createPendingSegment(request, 0, null, task.formatContext, false, false);
  resumedSegment.id = segmentId;
  resumedSegment.parentFlushed = true;
  try {
    task.replay = null, task.blockedSegment = resumedSegment, renderNode(request, task, node, childIndex), resumedSegment.status = COMPLETED, finishedSegment(request, blockedBoundary, resumedSegment), blockedBoundary === null ? request.completedRootSegment = resumedSegment : (queueCompletedSegment(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
  } finally {
    task.replay = prevReplay, task.blockedSegment = null;
  }
}
function replayElement(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
  childIndex = replay.nodes;
  for (var i2 = 0;i2 < childIndex.length; i2++) {
    var node = childIndex[i2];
    if (keyOrIndex === node[1]) {
      if (node.length === 4) {
        if (name !== null && name !== node[0])
          throw Error("Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
        var childNodes = node[2];
        name = node[3];
        keyOrIndex = task.node;
        task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };
        try {
          renderElement(request, task, keyPath, type, props, ref);
          if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
            throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
          task.replay.pendingTasks--;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException || typeof x2.then === "function"))
            throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i2, 1), x2;
          task.replay.pendingTasks--;
          type = getThrownInfo(task.componentStack);
          props = request;
          request = task.blockedBoundary;
          keyPath = x2;
          ref = name;
          name = logRecoverableError(props, keyPath, type, task.debugTask);
          abortRemainingReplayNodes(props, request, childNodes, ref, keyPath, name, type, false);
        }
        task.replay = replay;
      } else {
        if (type !== REACT_SUSPENSE_TYPE)
          throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
        a: {
          replay = undefined;
          name = node[5];
          type = node[2];
          ref = node[3];
          keyOrIndex = node[4] === null ? [] : node[4][2];
          node = node[4] === null ? null : node[4][3];
          var { keyPath: prevKeyPath, formatContext: prevContext, row: prevRow, replay: previousReplaySet, blockedBoundary: parentBoundary, hoistableState: parentHoistableState } = task, content = props.children, fallback = props.fallback, fallbackAbortSet = new Set;
          props = task.formatContext.insertionMode < HTML_MODE ? createSuspenseBoundary(request, task.row, fallbackAbortSet, createPreambleState(), createPreambleState()) : createSuspenseBoundary(request, task.row, fallbackAbortSet, null, null);
          props.parentFlushed = true;
          props.rootSegmentID = name;
          task.blockedBoundary = props;
          task.hoistableState = props.contentState;
          task.keyPath = keyPath;
          task.formatContext = getSuspenseContentFormatContext(request.resumableState, prevContext);
          task.row = null;
          task.replay = { nodes: type, slots: ref, pendingTasks: 1 };
          try {
            renderNode(request, task, content, -1);
            if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
              throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
            task.replay.pendingTasks--;
            if (props.pendingTasks === 0 && props.status === PENDING) {
              props.status = COMPLETED;
              request.completedBoundaries.push(props);
              break a;
            }
          } catch (error40) {
            props.status = CLIENT_RENDERED, childNodes = getThrownInfo(task.componentStack), replay = logRecoverableError(request, error40, childNodes, task.debugTask), encodeErrorForBoundary(props, replay, error40, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
          } finally {
            task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
          }
          props = createReplayTask(request, null, { nodes: keyOrIndex, slots: node, pendingTasks: 0 }, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], getSuspenseFallbackFormatContext(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack(task.componentStack), emptyContextObject, task.debugTask);
          pushComponentStack(props);
          request.pingedTasks.push(props);
        }
      }
      childIndex.splice(i2, 1);
      break;
    }
  }
}
function validateIterable(task, iterable, childIndex, iterator, iteratorFn) {
  if (iterator === iterable) {
    if (childIndex !== -1 || task.componentStack === null || typeof task.componentStack.type !== "function" || Object.prototype.toString.call(task.componentStack.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(iterator) !== "[object Generator]")
      didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = true;
  } else
    iterable.entries !== iteratorFn || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = true);
}
function renderNodeDestructive(request, task, node, childIndex) {
  task.replay !== null && typeof task.replay.slots === "number" ? resumeNode(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack(task), retryNode(request, task), task.componentStack = node, task.debugTask = childIndex);
}
function retryNode(request, task) {
  var { node, childIndex } = task;
  if (node !== null) {
    if (typeof node === "object") {
      switch (node.$$typeof) {
        case REACT_ELEMENT_TYPE:
          var { type, key } = node;
          node = node.props;
          var refProp = node.ref;
          refProp = refProp !== undefined ? refProp : null;
          var debugTask = task.debugTask, name = getComponentNameFromType(type);
          key = key == null ? childIndex === -1 ? 0 : childIndex : key;
          var keyPath = [task.keyPath, name, key];
          task.replay !== null ? debugTask ? debugTask.run(replayElement.bind(null, request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay)) : replayElement(request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay) : debugTask ? debugTask.run(renderElement.bind(null, request, task, keyPath, type, node, refProp)) : renderElement(request, task, keyPath, type, node, refProp);
          return;
        case REACT_PORTAL_TYPE:
          throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
        case REACT_LAZY_TYPE:
          type = callLazyInitInDEV(node);
          if (request.status === 12)
            throw null;
          renderNodeDestructive(request, task, type, childIndex);
          return;
      }
      if (isArrayImpl(node)) {
        renderChildrenArray(request, task, node, childIndex);
        return;
      }
      if (key = getIteratorFn(node)) {
        if (type = key.call(node)) {
          validateIterable(task, node, childIndex, type, key);
          node = type.next();
          if (!node.done) {
            key = [];
            do
              key.push(node.value), node = type.next();
            while (!node.done);
            renderChildrenArray(request, task, key, childIndex);
          }
          return;
        }
      }
      if (typeof node.then === "function")
        return task.thenableState = null, renderNodeDestructive(request, task, unwrapThenable(node), childIndex);
      if (node.$$typeof === REACT_CONTEXT_TYPE)
        return renderNodeDestructive(request, task, node._currentValue, childIndex);
      request = Object.prototype.toString.call(node);
      throw Error("Objects are not valid as a React child (found: " + (request === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
    }
    typeof node === "string" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance(task.chunks, node, request.renderState, task.lastPushedText))) : typeof node === "number" || typeof node === "bigint" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance(task.chunks, "" + node, request.renderState, task.lastPushedText))) : (typeof node === "function" && (request = node.displayName || node.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), typeof node === "symbol" && console.error(`Symbols are not valid as a React child.
  %s`, String(node)));
  }
}
function warnForMissingKey(request, task, child) {
  if (child !== null && typeof child === "object" && (child.$$typeof === REACT_ELEMENT_TYPE || child.$$typeof === REACT_PORTAL_TYPE) && child._store && (!child._store.validated && child.key == null || child._store.validated === 2)) {
    if (typeof child._store !== "object")
      throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
    child._store.validated = 1;
    var didWarnForKey = request.didWarnForKey;
    didWarnForKey == null && (didWarnForKey = request.didWarnForKey = new WeakSet);
    request = task.componentStack;
    if (request !== null && !didWarnForKey.has(request)) {
      didWarnForKey.add(request);
      var componentName = getComponentNameFromType(child.type);
      didWarnForKey = child._owner;
      var parentOwner = request.owner;
      request = "";
      if (parentOwner && typeof parentOwner.type !== "undefined") {
        var name = getComponentNameFromType(parentOwner.type);
        name && (request = `

Check the render method of \`` + name + "`.");
      }
      request || componentName && (request = `

Check the top-level render call using <` + componentName + ">.");
      componentName = "";
      didWarnForKey != null && parentOwner !== didWarnForKey && (parentOwner = null, typeof didWarnForKey.type !== "undefined" ? parentOwner = getComponentNameFromType(didWarnForKey.type) : typeof didWarnForKey.name === "string" && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
      didWarnForKey = task.componentStack;
      task.componentStack = {
        parent: task.componentStack,
        type: child.type,
        owner: child._owner,
        stack: child._debugStack
      };
      console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', request, componentName);
      task.componentStack = didWarnForKey;
    }
  }
}
function renderChildrenArray(request, task, children, childIndex) {
  var { keyPath: prevKeyPath, componentStack: previousComponentStack } = task;
  var previousDebugTask = task.debugTask;
  pushServerComponentStack(task, task.node._debugInfo);
  if (childIndex !== -1 && (task.keyPath = [task.keyPath, "Fragment", childIndex], task.replay !== null)) {
    for (var replay = task.replay, replayNodes = replay.nodes, j = 0;j < replayNodes.length; j++) {
      var node = replayNodes[j];
      if (node[1] === childIndex) {
        childIndex = node[2];
        node = node[3];
        task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
        try {
          renderChildrenArray(request, task, children, -1);
          if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
            throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
          task.replay.pendingTasks--;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException || typeof x2.then === "function"))
            throw x2;
          task.replay.pendingTasks--;
          var thrownInfo = getThrownInfo(task.componentStack);
          children = task.blockedBoundary;
          var error40 = x2, resumeSlots = node;
          node = logRecoverableError(request, error40, thrownInfo, task.debugTask);
          abortRemainingReplayNodes(request, children, childIndex, resumeSlots, error40, node, thrownInfo, false);
        }
        task.replay = replay;
        replayNodes.splice(j, 1);
        break;
      }
    }
    task.keyPath = prevKeyPath;
    task.componentStack = previousComponentStack;
    task.debugTask = previousDebugTask;
    return;
  }
  replay = task.treeContext;
  replayNodes = children.length;
  if (task.replay !== null && (j = task.replay.slots, j !== null && typeof j === "object")) {
    for (childIndex = 0;childIndex < replayNodes; childIndex++)
      node = children[childIndex], task.treeContext = pushTreeContext(replay, replayNodes, childIndex), error40 = j[childIndex], typeof error40 === "number" ? (resumeNode(request, task, error40, node, childIndex), delete j[childIndex]) : renderNode(request, task, node, childIndex);
    task.treeContext = replay;
    task.keyPath = prevKeyPath;
    task.componentStack = previousComponentStack;
    task.debugTask = previousDebugTask;
    return;
  }
  for (j = 0;j < replayNodes; j++)
    childIndex = children[j], warnForMissingKey(request, task, childIndex), task.treeContext = pushTreeContext(replay, replayNodes, j), renderNode(request, task, childIndex, j);
  task.treeContext = replay;
  task.keyPath = prevKeyPath;
  task.componentStack = previousComponentStack;
  task.debugTask = previousDebugTask;
}
function trackPostponedBoundary(request, trackedPostpones, boundary) {
  boundary.status = POSTPONED;
  boundary.rootSegmentID = request.nextSegmentId++;
  request = boundary.trackedContentKeyPath;
  if (request === null)
    throw Error("It should not be possible to postpone at the root. This is a bug in React.");
  var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
  if (boundaryNode === undefined)
    return boundary = [
      request[1],
      request[2],
      children,
      null,
      fallbackReplayNode,
      boundary.rootSegmentID
    ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent(boundary, request[0], trackedPostpones), boundary;
  boundaryNode[4] = fallbackReplayNode;
  boundaryNode[5] = boundary.rootSegmentID;
  return boundaryNode;
}
function trackPostpone(request, trackedPostpones, task, segment) {
  segment.status = POSTPONED;
  var { keyPath, blockedBoundary: boundary } = task;
  if (boundary === null)
    segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, request.completedRootSegment !== null && (request.completedRootSegment.status = POSTPONED);
  else {
    if (boundary !== null && boundary.status === PENDING) {
      var boundaryNode = trackPostponedBoundary(request, trackedPostpones, boundary);
      if (boundary.trackedContentKeyPath === keyPath && task.childIndex === -1) {
        segment.id === -1 && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
        boundaryNode[3] = segment.id;
        return;
      }
    }
    segment.id === -1 && (segment.id = segment.parentFlushed && boundary !== null ? boundary.rootSegmentID : request.nextSegmentId++);
    if (task.childIndex === -1)
      keyPath === null ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), task === undefined ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
    else {
      if (keyPath === null)
        if (request = trackedPostpones.rootSlots, request === null)
          request = trackedPostpones.rootSlots = {};
        else {
          if (typeof request === "number")
            throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
        }
      else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), boundaryNode === undefined)
        request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);
      else if (request = boundaryNode[3], request === null)
        request = boundaryNode[3] = {};
      else if (typeof request === "number")
        throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
      request[task.childIndex] = segment.id;
    }
  }
}
function untrackBoundary(request, boundary) {
  request = request.trackedPostpones;
  request !== null && (boundary = boundary.trackedContentKeyPath, boundary !== null && (boundary = request.workingMap.get(boundary), boundary !== undefined && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
}
function spawnNewSuspendedReplayTask(request, task, thenableState2) {
  return createReplayTask(request, thenableState2, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject, task.debugTask);
}
function spawnNewSuspendedRenderTask(request, task, thenableState2) {
  var segment = task.blockedSegment, newSegment = createPendingSegment(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, true);
  segment.children.push(newSegment);
  segment.lastPushedText = false;
  return createRenderTask(request, thenableState2, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject, task.debugTask);
}
function renderNode(request, task, node, childIndex) {
  var { formatContext: previousFormatContext, context: previousContext, keyPath: previousKeyPath, treeContext: previousTreeContext, componentStack: previousComponentStack, debugTask: previousDebugTask, blockedSegment: segment } = task;
  if (segment === null) {
    segment = task.replay;
    try {
      return renderNodeDestructive(request, task, node, childIndex);
    } catch (thrownValue) {
      if (resetHooksState(), node = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue, request.status !== 12 && typeof node === "object" && node !== null) {
        if (typeof node.then === "function") {
          childIndex = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
          request = spawnNewSuspendedReplayTask(request, task, childIndex).ping;
          node.then(request, request);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.replay = segment;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
        if (node.message === "Maximum call stack size exceeded") {
          node = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
          node = spawnNewSuspendedReplayTask(request, task, node);
          request.pingedTasks.push(node);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.replay = segment;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
      }
    }
  } else {
    var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
    try {
      return renderNodeDestructive(request, task, node, childIndex);
    } catch (thrownValue$3) {
      if (resetHooksState(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException ? getSuspendedThenable() : thrownValue$3, request.status !== 12 && typeof node === "object" && node !== null) {
        if (typeof node.then === "function") {
          segment = node;
          node = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
          request = spawnNewSuspendedRenderTask(request, task, node).ping;
          segment.then(request, request);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
        if (node.message === "Maximum call stack size exceeded") {
          segment = thrownValue$3 === SuspenseException ? getThenableStateAfterSuspending() : null;
          segment = spawnNewSuspendedRenderTask(request, task, segment);
          request.pingedTasks.push(segment);
          task.formatContext = previousFormatContext;
          task.context = previousContext;
          task.keyPath = previousKeyPath;
          task.treeContext = previousTreeContext;
          task.componentStack = previousComponentStack;
          task.debugTask = previousDebugTask;
          switchContext(previousContext);
          return;
        }
      }
    }
  }
  task.formatContext = previousFormatContext;
  task.context = previousContext;
  task.keyPath = previousKeyPath;
  task.treeContext = previousTreeContext;
  switchContext(previousContext);
  throw node;
}
function abortTaskSoft(task) {
  var { blockedBoundary: boundary, blockedSegment: segment } = task;
  segment !== null && (segment.status = ABORTED, finishedTask(this, boundary, task.row, segment));
}
function abortRemainingReplayNodes(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted2) {
  for (var i2 = 0;i2 < nodes.length; i2++) {
    var node = nodes[i2];
    if (node.length === 4)
      abortRemainingReplayNodes(request$jscomp$0, boundary, node[2], node[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted2);
    else {
      var request = request$jscomp$0;
      node = node[5];
      var error40 = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted2, resumedBoundary = createSuspenseBoundary(request, null, new Set, null, null);
      resumedBoundary.parentFlushed = true;
      resumedBoundary.rootSegmentID = node;
      resumedBoundary.status = CLIENT_RENDERED;
      encodeErrorForBoundary(resumedBoundary, errorDigest, error40, errorInfo, wasAborted);
      resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
    }
  }
  nodes.length = 0;
  if (slots !== null) {
    if (boundary === null)
      throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
    boundary.status !== CLIENT_RENDERED && (boundary.status = CLIENT_RENDERED, encodeErrorForBoundary(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted2), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
    if (typeof slots === "object")
      for (var index in slots)
        delete slots[index];
  }
}
function abortTask(task, request, error40) {
  var { blockedBoundary: boundary, blockedSegment: segment } = task;
  if (segment !== null) {
    if (segment.status === 6)
      return;
    segment.status = ABORTED;
  }
  var errorInfo = getThrownInfo(task.componentStack), node = task.node;
  node !== null && typeof node === "object" && pushHaltedAwaitOnComponentStack(task, node._debugInfo);
  if (boundary === null) {
    if (request.status !== 13 && request.status !== CLOSED) {
      boundary = task.replay;
      if (boundary === null) {
        request.trackedPostpones !== null && segment !== null ? (boundary = request.trackedPostpones, logRecoverableError(request, error40, errorInfo, task.debugTask), trackPostpone(request, boundary, task, segment), finishedTask(request, null, task.row, segment)) : (logRecoverableError(request, error40, errorInfo, task.debugTask), fatalError(request, error40, errorInfo, task.debugTask));
        return;
      }
      boundary.pendingTasks--;
      boundary.pendingTasks === 0 && 0 < boundary.nodes.length && (segment = logRecoverableError(request, error40, errorInfo, null), abortRemainingReplayNodes(request, null, boundary.nodes, boundary.slots, error40, segment, errorInfo, true));
      request.pendingRootTasks--;
      request.pendingRootTasks === 0 && completeShell(request);
    }
  } else {
    node = request.trackedPostpones;
    if (boundary.status !== CLIENT_RENDERED) {
      if (node !== null && segment !== null)
        return logRecoverableError(request, error40, errorInfo, task.debugTask), trackPostpone(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
          return abortTask(fallbackTask, request, error40);
        }), boundary.fallbackAbortableTasks.clear(), finishedTask(request, boundary, task.row, segment);
      boundary.status = CLIENT_RENDERED;
      segment = logRecoverableError(request, error40, errorInfo, task.debugTask);
      boundary.status = CLIENT_RENDERED;
      encodeErrorForBoundary(boundary, segment, error40, errorInfo, true);
      untrackBoundary(request, boundary);
      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
    }
    boundary.pendingTasks--;
    errorInfo = boundary.row;
    errorInfo !== null && --errorInfo.pendingTasks === 0 && finishSuspenseListRow(request, errorInfo);
    boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
      return abortTask(fallbackTask, request, error40);
    });
    boundary.fallbackAbortableTasks.clear();
  }
  task = task.row;
  task !== null && --task.pendingTasks === 0 && finishSuspenseListRow(request, task);
  request.allPendingTasks--;
  request.allPendingTasks === 0 && completeAll(request);
}
function safelyEmitEarlyPreloads(request, shellComplete) {
  try {
    var renderState = request.renderState, onHeaders = renderState.onHeaders;
    if (onHeaders) {
      var headers = renderState.headers;
      if (headers) {
        renderState.headers = null;
        var linkHeader = headers.preconnects;
        headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
        headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
        if (!shellComplete) {
          var queueIter = renderState.styles.values(), queueStep = queueIter.next();
          b:
            for (;0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
              for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next();0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                var header = getPreloadAsHeader(props$jscomp$0.href, "style", {
                  crossOrigin: props$jscomp$0.crossOrigin,
                  integrity: props$jscomp$0.integrity,
                  nonce: props$jscomp$0.nonce,
                  type: props$jscomp$0.type,
                  fetchPriority: props$jscomp$0.fetchPriority,
                  referrerPolicy: props$jscomp$0.referrerPolicy,
                  media: props$jscomp$0.media
                });
                if (0 <= (headers.remainingCapacity -= header.length + 2))
                  renderState.resets.style[key] = PRELOAD_NO_CREDS, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = typeof props.crossOrigin === "string" || typeof props.integrity === "string" ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS;
                else
                  break b;
              }
        }
        linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
      }
    }
  } catch (error40) {
    logRecoverableError(request, error40, {}, null);
  }
}
function completeShell(request) {
  request.trackedPostpones === null && safelyEmitEarlyPreloads(request, true);
  request.trackedPostpones === null && preparePreamble(request);
  request.onShellError = noop3;
  request = request.onShellReady;
  request();
}
function completeAll(request) {
  safelyEmitEarlyPreloads(request, request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED);
  preparePreamble(request);
  request = request.onAllReady;
  request();
}
function queueCompletedSegment(boundary, segment) {
  if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {
    var childSegment = segment.children[0];
    childSegment.id = segment.id;
    childSegment.parentFlushed = true;
    childSegment.status !== COMPLETED && childSegment.status !== ABORTED && childSegment.status !== ERRORED || queueCompletedSegment(boundary, childSegment);
  } else
    boundary.completedSegments.push(segment);
}
function finishedSegment(request, boundary, segment) {
  if (byteLengthOfChunk !== null) {
    segment = segment.chunks;
    for (var segmentByteSize = 0, i2 = 0;i2 < segment.length; i2++)
      segmentByteSize += byteLengthOfChunk(segment[i2]);
    boundary === null ? request.byteSize += segmentByteSize : boundary.byteSize += segmentByteSize;
  }
}
function finishedTask(request, boundary, row, segment) {
  row !== null && (--row.pendingTasks === 0 ? finishSuspenseListRow(request, row) : row.together && tryToResolveTogetherRow(request, row));
  request.allPendingTasks--;
  if (boundary === null) {
    if (segment !== null && segment.parentFlushed) {
      if (request.completedRootSegment !== null)
        throw Error("There can only be one root segment. This is a bug in React.");
      request.completedRootSegment = segment;
    }
    request.pendingRootTasks--;
    request.pendingRootTasks === 0 && completeShell(request);
  } else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED)
    if (boundary.pendingTasks === 0)
      if (boundary.status === PENDING && (boundary.status = COMPLETED), segment !== null && segment.parentFlushed && (segment.status === COMPLETED || segment.status === ABORTED) && queueCompletedSegment(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED)
        row = boundary.row, row !== null && hoistHoistables(row.hoistables, boundary.contentState), isEligibleForOutlining(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request), boundary.fallbackAbortableTasks.clear(), row !== null && --row.pendingTasks === 0 && finishSuspenseListRow(request, row)), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary.contentPreamble !== null && preparePreamble(request);
      else {
        if (boundary.status === POSTPONED && (boundary = boundary.row, boundary !== null)) {
          if (request.trackedPostpones !== null) {
            row = request.trackedPostpones;
            var postponedRow = boundary.next;
            if (postponedRow !== null && (segment = postponedRow.boundaries, segment !== null))
              for (postponedRow.boundaries = null, postponedRow = 0;postponedRow < segment.length; postponedRow++) {
                var postponedBoundary = segment[postponedRow];
                trackPostponedBoundary(request, row, postponedBoundary);
                finishedTask(request, postponedBoundary, null, null);
              }
          }
          --boundary.pendingTasks === 0 && finishSuspenseListRow(request, boundary);
        }
      }
    else
      segment === null || !segment.parentFlushed || segment.status !== COMPLETED && segment.status !== ABORTED || (queueCompletedSegment(boundary, segment), boundary.completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, boundary !== null && boundary.together && tryToResolveTogetherRow(request, boundary);
  request.allPendingTasks === 0 && completeAll(request);
}
function performWork(request$jscomp$2) {
  if (request$jscomp$2.status !== CLOSED && request$jscomp$2.status !== 13) {
    var prevContext = currentActiveSnapshot, prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = HooksDispatcher;
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    var prevRequest = currentRequest;
    currentRequest = request$jscomp$2;
    var prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
    ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
    var prevResumableState = currentResumableState;
    currentResumableState = request$jscomp$2.resumableState;
    try {
      var pingedTasks = request$jscomp$2.pingedTasks, i2;
      for (i2 = 0;i2 < pingedTasks.length; i2++) {
        var request = request$jscomp$2, task = pingedTasks[i2], segment = task.blockedSegment;
        if (segment === null) {
          var prevTaskInDEV = undefined, request$jscomp$0 = request;
          request = task;
          if (request.replay.pendingTasks !== 0) {
            switchContext(request.context);
            prevTaskInDEV = currentTaskInDEV;
            currentTaskInDEV = request;
            try {
              typeof request.replay.slots === "number" ? resumeNode(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode(request$jscomp$0, request);
              if (request.replay.pendingTasks === 1 && 0 < request.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              request.replay.pendingTasks--;
              request.abortSet.delete(request);
              finishedTask(request$jscomp$0, request.blockedBoundary, request.row, null);
            } catch (thrownValue) {
              resetHooksState();
              var x2 = thrownValue === SuspenseException ? getSuspendedThenable() : thrownValue;
              if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function") {
                var ping = request.ping;
                x2.then(ping, ping);
                request.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
              } else {
                request.replay.pendingTasks--;
                request.abortSet.delete(request);
                var errorInfo = getThrownInfo(request.componentStack), errorDigest = undefined, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = request$jscomp$0.status === 12 ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                errorDigest = logRecoverableError(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
                abortRemainingReplayNodes(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, false);
                request$jscomp$0.pendingRootTasks--;
                request$jscomp$0.pendingRootTasks === 0 && completeShell(request$jscomp$0);
                request$jscomp$0.allPendingTasks--;
                request$jscomp$0.allPendingTasks === 0 && completeAll(request$jscomp$0);
              }
            } finally {
              currentTaskInDEV = prevTaskInDEV;
            }
          }
        } else if (request$jscomp$0 = prevTaskInDEV = undefined, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING) {
          request$jscomp$1.status = 6;
          switchContext(errorDigest.context);
          request$jscomp$0 = currentTaskInDEV;
          currentTaskInDEV = errorDigest;
          var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
          try {
            retryNode(request, errorDigest), pushSegmentFinale(request$jscomp$1.chunks, request.renderState, request$jscomp$1.lastPushedText, request$jscomp$1.textEmbedded), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED, finishedSegment(request, errorDigest.blockedBoundary, request$jscomp$1), finishedTask(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
          } catch (thrownValue) {
            resetHooksState();
            request$jscomp$1.children.length = childrenLength;
            request$jscomp$1.chunks.length = chunkLength;
            var x$jscomp$0 = thrownValue === SuspenseException ? getSuspendedThenable() : request.status === 12 ? request.fatalError : thrownValue;
            if (request.status === 12 && request.trackedPostpones !== null) {
              var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo(errorDigest.componentStack);
              errorDigest.abortSet.delete(errorDigest);
              logRecoverableError(request, x$jscomp$0, thrownInfo, errorDigest.debugTask);
              trackPostpone(request, trackedPostpones, errorDigest, request$jscomp$1);
              finishedTask(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
            } else if (typeof x$jscomp$0 === "object" && x$jscomp$0 !== null && typeof x$jscomp$0.then === "function") {
              request$jscomp$1.status = PENDING;
              errorDigest.thenableState = thrownValue === SuspenseException ? getThenableStateAfterSuspending() : null;
              var ping$jscomp$0 = errorDigest.ping;
              x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
            } else {
              var errorInfo$jscomp$1 = getThrownInfo(errorDigest.componentStack);
              errorDigest.abortSet.delete(errorDigest);
              request$jscomp$1.status = ERRORED;
              var { blockedBoundary: boundary$jscomp$0, row, debugTask } = errorDigest;
              row !== null && --row.pendingTasks === 0 && finishSuspenseListRow(request, row);
              request.allPendingTasks--;
              prevTaskInDEV = logRecoverableError(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
              if (boundary$jscomp$0 === null)
                fatalError(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
              else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED) {
                boundary$jscomp$0.status = CLIENT_RENDERED;
                encodeErrorForBoundary(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, false);
                untrackBoundary(request, boundary$jscomp$0);
                var boundaryRow = boundary$jscomp$0.row;
                boundaryRow !== null && --boundaryRow.pendingTasks === 0 && finishSuspenseListRow(request, boundaryRow);
                boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary$jscomp$0.contentPreamble !== null && preparePreamble(request);
              }
              request.allPendingTasks === 0 && completeAll(request);
            }
          } finally {
            currentTaskInDEV = request$jscomp$0;
          }
        }
      }
      pingedTasks.splice(0, i2);
      request$jscomp$2.destination !== null && flushCompletedQueues(request$jscomp$2, request$jscomp$2.destination);
    } catch (error40) {
      pingedTasks = {}, logRecoverableError(request$jscomp$2, error40, pingedTasks, null), fatalError(request$jscomp$2, error40, pingedTasks, null);
    } finally {
      currentResumableState = prevResumableState, ReactSharedInternals.H = prevDispatcher, ReactSharedInternals.A = prevAsyncDispatcher, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher && switchContext(prevContext), currentRequest = prevRequest;
    }
  }
}
function preparePreambleFromSubtree(request, segment, collectedPreambleSegments) {
  segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
  for (var pendingPreambles = false, i2 = 0;i2 < segment.children.length; i2++)
    pendingPreambles = preparePreambleFromSegment(request, segment.children[i2], collectedPreambleSegments) || pendingPreambles;
  return pendingPreambles;
}
function preparePreambleFromSegment(request, segment, collectedPreambleSegments) {
  var boundary = segment.boundary;
  if (boundary === null)
    return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
  var { contentPreamble: preamble, fallbackPreamble } = boundary;
  if (preamble === null || fallbackPreamble === null)
    return false;
  switch (boundary.status) {
    case COMPLETED:
      hoistPreambleState(request.renderState, preamble);
      request.byteSize += boundary.byteSize;
      segment = boundary.completedSegments[0];
      if (!segment)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      return preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
    case POSTPONED:
      if (request.trackedPostpones !== null)
        return true;
    case CLIENT_RENDERED:
      if (segment.status === COMPLETED)
        return hoistPreambleState(request.renderState, fallbackPreamble), preparePreambleFromSubtree(request, segment, collectedPreambleSegments);
    default:
      return true;
  }
}
function preparePreamble(request) {
  if (request.completedRootSegment && request.completedPreambleSegments === null) {
    var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
    hasPendingPreambles === false || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
  }
}
function flushSubtree(request, destination, segment, hoistableState) {
  segment.parentFlushed = true;
  switch (segment.status) {
    case PENDING:
      segment.id = request.nextSegmentId++;
    case POSTPONED:
      return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, writeChunk(destination, placeholder1), writeChunk(destination, request.placeholderPrefix), request = hoistableState.toString(16), writeChunk(destination, request), !!destination.write(placeholder2);
    case COMPLETED:
      segment.status = FLUSHED;
      var r = true, chunks = segment.chunks, chunkIdx = 0;
      segment = segment.children;
      for (var childIdx = 0;childIdx < segment.length; childIdx++) {
        for (r = segment[childIdx];chunkIdx < r.index; chunkIdx++)
          writeChunk(destination, chunks[chunkIdx]);
        r = flushSegment(request, destination, r, hoistableState);
      }
      for (;chunkIdx < chunks.length - 1; chunkIdx++)
        writeChunk(destination, chunks[chunkIdx]);
      chunkIdx < chunks.length && (r = !!destination.write(chunks[chunkIdx]));
      return r;
    case ABORTED:
      return true;
    default:
      throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
  }
}
function flushSegment(request, destination, segment, hoistableState) {
  var boundary = segment.boundary;
  if (boundary === null)
    return flushSubtree(request, destination, segment, hoistableState);
  boundary.parentFlushed = true;
  if (boundary.status === CLIENT_RENDERED) {
    var row = boundary.row;
    row !== null && --row.pendingTasks === 0 && finishSuspenseListRow(request, row);
    row = boundary.errorDigest;
    var { errorMessage, errorStack } = boundary;
    boundary = boundary.errorComponentStack;
    destination.write(startClientRenderedSuspenseBoundary);
    writeChunk(destination, clientRenderedSuspenseBoundaryError1);
    row && (writeChunk(destination, clientRenderedSuspenseBoundaryError1A), writeChunk(destination, escapeTextForBrowser(row)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    errorMessage && (writeChunk(destination, clientRenderedSuspenseBoundaryError1B), writeChunk(destination, escapeTextForBrowser(errorMessage)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    errorStack && (writeChunk(destination, clientRenderedSuspenseBoundaryError1C), writeChunk(destination, escapeTextForBrowser(errorStack)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    boundary && (writeChunk(destination, clientRenderedSuspenseBoundaryError1D), writeChunk(destination, escapeTextForBrowser(boundary)), writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial));
    destination.write(clientRenderedSuspenseBoundaryError2);
    flushSubtree(request, destination, segment, hoistableState);
  } else if (boundary.status !== COMPLETED)
    boundary.status === PENDING && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables(hoistableState, boundary.fallbackState), flushSubtree(request, destination, segment, hoistableState);
  else if (!flushingPartialBoundaries && isEligibleForOutlining(request, boundary) && (flushedByteSize + boundary.byteSize > request.progressiveChunkSize || hasSuspenseyContent(boundary.contentState)))
    boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary(destination, request.renderState, boundary.rootSegmentID), flushSubtree(request, destination, segment, hoistableState);
  else {
    flushedByteSize += boundary.byteSize;
    hoistableState && hoistHoistables(hoistableState, boundary.contentState);
    segment = boundary.row;
    segment !== null && isEligibleForOutlining(request, boundary) && --segment.pendingTasks === 0 && finishSuspenseListRow(request, segment);
    destination.write(startCompletedSuspenseBoundary);
    segment = boundary.completedSegments;
    if (segment.length !== 1)
      throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
    flushSegment(request, destination, segment[0], hoistableState);
  }
  return !!destination.write(endSuspenseBoundary);
}
function flushSegmentContainer(request, destination, segment, hoistableState) {
  writeStartSegment(destination, request.renderState, segment.parentFormatContext, segment.id);
  flushSegment(request, destination, segment, hoistableState);
  return writeEndSegment(destination, segment.parentFormatContext);
}
function flushCompletedBoundary(request, destination, boundary) {
  flushedByteSize = boundary.byteSize;
  for (var completedSegments = boundary.completedSegments, i2 = 0;i2 < completedSegments.length; i2++)
    flushPartiallyCompletedSegment(request, destination, boundary, completedSegments[i2]);
  completedSegments.length = 0;
  completedSegments = boundary.row;
  completedSegments !== null && isEligibleForOutlining(request, boundary) && --completedSegments.pendingTasks === 0 && finishSuspenseListRow(request, completedSegments);
  writeHoistablesForBoundary(destination, boundary.contentState, request.renderState);
  completedSegments = request.resumableState;
  request = request.renderState;
  i2 = boundary.rootSegmentID;
  boundary = boundary.contentState;
  var requiresStyleInsertion = request.stylesToHoist;
  request.stylesToHoist = false;
  writeChunk(destination, request.startInlineScript);
  writeChunk(destination, endOfStartTag);
  requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction) === NothingSent && (completedSegments.instructions |= SentClientRenderFunction, writeChunk(destination, clientRenderScriptFunctionOnly)), (completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScriptFunctionOnly)), (completedSegments.instructions & SentStyleInsertionFunction) === NothingSent ? (completedSegments.instructions |= SentStyleInsertionFunction, writeChunk(destination, completeBoundaryWithStylesScript1FullPartial)) : writeChunk(destination, completeBoundaryWithStylesScript1Partial)) : ((completedSegments.instructions & SentCompleteBoundaryFunction) === NothingSent && (completedSegments.instructions |= SentCompleteBoundaryFunction, writeChunk(destination, completeBoundaryScriptFunctionOnly)), writeChunk(destination, completeBoundaryScript1Partial));
  completedSegments = i2.toString(16);
  writeChunk(destination, request.boundaryPrefix);
  writeChunk(destination, completedSegments);
  writeChunk(destination, completeBoundaryScript2);
  writeChunk(destination, request.segmentPrefix);
  writeChunk(destination, completedSegments);
  requiresStyleInsertion ? (writeChunk(destination, completeBoundaryScript3a), writeStyleResourceDependenciesInJS(destination, boundary)) : writeChunk(destination, completeBoundaryScript3b);
  boundary = !!destination.write(completeBoundaryScriptEnd);
  return writeBootstrap(destination, request) && boundary;
}
function flushPartiallyCompletedSegment(request, destination, boundary, segment) {
  if (segment.status === FLUSHED)
    return true;
  var hoistableState = boundary.contentState, segmentID = segment.id;
  if (segmentID === -1) {
    if ((segment.id = boundary.rootSegmentID) === -1)
      throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
    return flushSegmentContainer(request, destination, segment, hoistableState);
  }
  if (segmentID === boundary.rootSegmentID)
    return flushSegmentContainer(request, destination, segment, hoistableState);
  flushSegmentContainer(request, destination, segment, hoistableState);
  boundary = request.resumableState;
  request = request.renderState;
  writeChunk(destination, request.startInlineScript);
  writeChunk(destination, endOfStartTag);
  (boundary.instructions & SentCompleteSegmentFunction) === NothingSent ? (boundary.instructions |= SentCompleteSegmentFunction, writeChunk(destination, completeSegmentScript1Full)) : writeChunk(destination, completeSegmentScript1Partial);
  writeChunk(destination, request.segmentPrefix);
  segmentID = segmentID.toString(16);
  writeChunk(destination, segmentID);
  writeChunk(destination, completeSegmentScript2);
  writeChunk(destination, request.placeholderPrefix);
  writeChunk(destination, segmentID);
  destination = !!destination.write(completeSegmentScriptEnd);
  return destination;
}
function flushCompletedQueues(request, destination) {
  try {
    if (!(0 < request.pendingRootTasks)) {
      var i2, completedRootSegment = request.completedRootSegment;
      if (completedRootSegment !== null) {
        if (completedRootSegment.status === POSTPONED)
          return;
        var completedPreambleSegments = request.completedPreambleSegments;
        if (completedPreambleSegments === null)
          return;
        flushedByteSize = request.byteSize;
        var { resumableState, renderState } = request, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
        if (htmlChunks) {
          for (i$jscomp$0 = 0;i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
            writeChunk(destination, htmlChunks[i$jscomp$0]);
          if (headChunks)
            for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
              writeChunk(destination, headChunks[i$jscomp$0]);
          else
            writeChunk(destination, startChunkForTag("head")), writeChunk(destination, endOfStartTag);
        } else if (headChunks)
          for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
            writeChunk(destination, headChunks[i$jscomp$0]);
        var charsetChunks = renderState.charsetChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
          writeChunk(destination, charsetChunks[i$jscomp$0]);
        charsetChunks.length = 0;
        renderState.preconnects.forEach(flushResource, destination);
        renderState.preconnects.clear();
        var viewportChunks = renderState.viewportChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
          writeChunk(destination, viewportChunks[i$jscomp$0]);
        viewportChunks.length = 0;
        renderState.fontPreloads.forEach(flushResource, destination);
        renderState.fontPreloads.clear();
        renderState.highImagePreloads.forEach(flushResource, destination);
        renderState.highImagePreloads.clear();
        currentlyFlushingRenderState = renderState;
        renderState.styles.forEach(flushStylesInPreamble, destination);
        currentlyFlushingRenderState = null;
        var importMapChunks = renderState.importMapChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
          writeChunk(destination, importMapChunks[i$jscomp$0]);
        importMapChunks.length = 0;
        renderState.bootstrapScripts.forEach(flushResource, destination);
        renderState.scripts.forEach(flushResource, destination);
        renderState.scripts.clear();
        renderState.bulkPreloads.forEach(flushResource, destination);
        renderState.bulkPreloads.clear();
        htmlChunks || headChunks || (resumableState.instructions |= SentCompletedShellId);
        var hoistableChunks = renderState.hoistableChunks;
        for (i$jscomp$0 = 0;i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
          writeChunk(destination, hoistableChunks[i$jscomp$0]);
        for (resumableState = hoistableChunks.length = 0;resumableState < completedPreambleSegments.length; resumableState++) {
          var segments = completedPreambleSegments[resumableState];
          for (renderState = 0;renderState < segments.length; renderState++)
            flushSegment(request, destination, segments[renderState], null);
        }
        var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
        (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) && writeChunk(destination, endChunkForTag("head"));
        var bodyChunks = preamble$jscomp$0.bodyChunks;
        if (bodyChunks)
          for (completedPreambleSegments = 0;completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
            writeChunk(destination, bodyChunks[completedPreambleSegments]);
        flushSegment(request, destination, completedRootSegment, null);
        request.completedRootSegment = null;
        var renderState$jscomp$0 = request.renderState;
        if (request.allPendingTasks !== 0 || request.clientRenderedBoundaries.length !== 0 || request.completedBoundaries.length !== 0 || request.trackedPostpones !== null && (request.trackedPostpones.rootNodes.length !== 0 || request.trackedPostpones.rootSlots !== null)) {
          var resumableState$jscomp$0 = request.resumableState;
          if ((resumableState$jscomp$0.instructions & SentMarkShellTime) === NothingSent) {
            resumableState$jscomp$0.instructions |= SentMarkShellTime;
            writeChunk(destination, renderState$jscomp$0.startInlineScript);
            if ((resumableState$jscomp$0.instructions & SentCompletedShellId) === NothingSent) {
              resumableState$jscomp$0.instructions |= SentCompletedShellId;
              var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
              writeChunk(destination, completedShellIdAttributeStart);
              writeChunk(destination, escapeTextForBrowser(shellId));
              writeChunk(destination, attributeEnd);
            }
            writeChunk(destination, endOfStartTag);
            writeChunk(destination, shellTimeRuntimeScript);
            destination.write(endInlineScript);
          }
        }
        writeBootstrap(destination, renderState$jscomp$0);
      }
      var renderState$jscomp$1 = request.renderState;
      completedRootSegment = 0;
      var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
      for (completedRootSegment = 0;completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
        writeChunk(destination, viewportChunks$jscomp$0[completedRootSegment]);
      viewportChunks$jscomp$0.length = 0;
      renderState$jscomp$1.preconnects.forEach(flushResource, destination);
      renderState$jscomp$1.preconnects.clear();
      renderState$jscomp$1.fontPreloads.forEach(flushResource, destination);
      renderState$jscomp$1.fontPreloads.clear();
      renderState$jscomp$1.highImagePreloads.forEach(flushResource, destination);
      renderState$jscomp$1.highImagePreloads.clear();
      renderState$jscomp$1.styles.forEach(preloadLateStyles, destination);
      renderState$jscomp$1.scripts.forEach(flushResource, destination);
      renderState$jscomp$1.scripts.clear();
      renderState$jscomp$1.bulkPreloads.forEach(flushResource, destination);
      renderState$jscomp$1.bulkPreloads.clear();
      var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
      for (completedRootSegment = 0;completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
        writeChunk(destination, hoistableChunks$jscomp$0[completedRootSegment]);
      hoistableChunks$jscomp$0.length = 0;
      var clientRenderedBoundaries = request.clientRenderedBoundaries;
      for (i2 = 0;i2 < clientRenderedBoundaries.length; i2++) {
        var boundary = clientRenderedBoundaries[i2];
        renderState$jscomp$1 = destination;
        var { resumableState: resumableState$jscomp$1, renderState: renderState$jscomp$2 } = request, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
        writeChunk(renderState$jscomp$1, renderState$jscomp$2.startInlineScript);
        writeChunk(renderState$jscomp$1, endOfStartTag);
        (resumableState$jscomp$1.instructions & SentClientRenderFunction) === NothingSent ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction, writeChunk(renderState$jscomp$1, clientRenderScript1Full)) : writeChunk(renderState$jscomp$1, clientRenderScript1Partial);
        writeChunk(renderState$jscomp$1, renderState$jscomp$2.boundaryPrefix);
        writeChunk(renderState$jscomp$1, id.toString(16));
        writeChunk(renderState$jscomp$1, clientRenderScript1A);
        if (errorDigest || errorMessage || errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$1, escapeJSStringsForInstructionScripts(errorDigest || ""));
        if (errorMessage || errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$1, escapeJSStringsForInstructionScripts(errorMessage || ""));
        if (errorStack || errorComponentStack)
          writeChunk(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$1, escapeJSStringsForInstructionScripts(errorStack || ""));
        errorComponentStack && (writeChunk(renderState$jscomp$1, clientRenderErrorScriptArgInterstitial), writeChunk(renderState$jscomp$1, escapeJSStringsForInstructionScripts(errorComponentStack)));
        var JSCompiler_inline_result = !!renderState$jscomp$1.write(clientRenderScriptEnd);
        if (!JSCompiler_inline_result) {
          request.destination = null;
          i2++;
          clientRenderedBoundaries.splice(0, i2);
          return;
        }
      }
      clientRenderedBoundaries.splice(0, i2);
      var completedBoundaries = request.completedBoundaries;
      for (i2 = 0;i2 < completedBoundaries.length; i2++)
        if (!flushCompletedBoundary(request, destination, completedBoundaries[i2])) {
          request.destination = null;
          i2++;
          completedBoundaries.splice(0, i2);
          return;
        }
      completedBoundaries.splice(0, i2);
      flushingPartialBoundaries = true;
      var partialBoundaries = request.partialBoundaries;
      for (i2 = 0;i2 < partialBoundaries.length; i2++) {
        a: {
          clientRenderedBoundaries = request;
          boundary = destination;
          var boundary$jscomp$0 = partialBoundaries[i2];
          flushedByteSize = boundary$jscomp$0.byteSize;
          var completedSegments = boundary$jscomp$0.completedSegments;
          for (JSCompiler_inline_result = 0;JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
            if (!flushPartiallyCompletedSegment(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
              JSCompiler_inline_result++;
              completedSegments.splice(0, JSCompiler_inline_result);
              var JSCompiler_inline_result$jscomp$0 = false;
              break a;
            }
          completedSegments.splice(0, JSCompiler_inline_result);
          var row = boundary$jscomp$0.row;
          row !== null && row.together && boundary$jscomp$0.pendingTasks === 1 && (row.pendingTasks === 1 ? unblockSuspenseListRow(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
          JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
        }
        if (!JSCompiler_inline_result$jscomp$0) {
          request.destination = null;
          i2++;
          partialBoundaries.splice(0, i2);
          return;
        }
      }
      partialBoundaries.splice(0, i2);
      flushingPartialBoundaries = false;
      var largeBoundaries = request.completedBoundaries;
      for (i2 = 0;i2 < largeBoundaries.length; i2++)
        if (!flushCompletedBoundary(request, destination, largeBoundaries[i2])) {
          request.destination = null;
          i2++;
          largeBoundaries.splice(0, i2);
          return;
        }
      largeBoundaries.splice(0, i2);
    }
  } finally {
    flushingPartialBoundaries = false, request.allPendingTasks === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 ? (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && writeChunk(destination, endChunkForTag("body")), i2.hasHtml && writeChunk(destination, endChunkForTag("html")), flushBuffered(destination), request.abortableTasks.size !== 0 && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED, destination.end(), request.destination = null) : flushBuffered(destination);
  }
}
function startWork(request) {
  request.flushScheduled = request.destination !== null;
  scheduleMicrotask(function() {
    return performWork(request);
  });
  setTimeout(function() {
    request.status === 10 && (request.status = 11);
    request.trackedPostpones === null && safelyEmitEarlyPreloads(request, request.pendingRootTasks === 0);
  }, 0);
}
function enqueueFlush(request) {
  request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null && (request.flushScheduled = true, setTimeout(function() {
    var destination = request.destination;
    destination ? flushCompletedQueues(request, destination) : request.flushScheduled = false;
  }, 0));
}
function abort(request, reason) {
  if (request.status === 11 || request.status === 10)
    request.status = 12;
  try {
    var abortableTasks = request.abortableTasks;
    if (0 < abortableTasks.size) {
      var error40 = reason === undefined ? Error("The render was aborted by the server without a reason.") : typeof reason === "object" && reason !== null && typeof reason.then === "function" ? Error("The render was aborted by the server with a promise.") : reason;
      request.fatalError = error40;
      abortableTasks.forEach(function(task) {
        var prevTaskInDEV = currentTaskInDEV, prevGetCurrentStackImpl = ReactSharedInternals.getCurrentStack;
        currentTaskInDEV = task;
        ReactSharedInternals.getCurrentStack = getCurrentStackInDEV;
        try {
          abortTask(task, request, error40);
        } finally {
          currentTaskInDEV = prevTaskInDEV, ReactSharedInternals.getCurrentStack = prevGetCurrentStackImpl;
        }
      });
      abortableTasks.clear();
    }
    request.destination !== null && flushCompletedQueues(request, request.destination);
  } catch (error$4) {
    reason = {}, logRecoverableError(request, error$4, reason, null), fatalError(request, error$4, reason, null);
  }
}
function addToReplayParent(node, parentKeyPath, trackedPostpones) {
  if (parentKeyPath === null)
    trackedPostpones.rootNodes.push(node);
  else {
    var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
    parentNode === undefined && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent(parentNode, parentKeyPath[0], trackedPostpones));
    parentNode[2].push(node);
  }
}
var React, ReactDOM, REACT_ELEMENT_TYPE, REACT_PORTAL_TYPE, REACT_FRAGMENT_TYPE, REACT_STRICT_MODE_TYPE, REACT_PROFILER_TYPE, REACT_CONSUMER_TYPE, REACT_CONTEXT_TYPE, REACT_FORWARD_REF_TYPE, REACT_SUSPENSE_TYPE, REACT_SUSPENSE_LIST_TYPE, REACT_MEMO_TYPE, REACT_LAZY_TYPE, REACT_SCOPE_TYPE, REACT_ACTIVITY_TYPE, REACT_LEGACY_HIDDEN_TYPE, REACT_MEMO_CACHE_SENTINEL, REACT_VIEW_TRANSITION_TYPE, MAYBE_ITERATOR_SYMBOL, isArrayImpl, jsxPropsParents, jsxChildrenParents, CLIENT_REFERENCE_TAG, scheduleMicrotask, assign, hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX, illegalAttributeNameCache, validatedAttributeNameCache, unitlessNumbers, aliases, hasReadOnlyValue, ariaProperties, warnedProperties$1, rARIA$1, rARIACamel$1, didWarnValueNull = false, possibleStandardNames, warnedProperties, EVENT_NAME_REGEX, INVALID_EVENT_NAME_REGEX, rARIA, rARIACamel, badVendoredStyleNamePattern, msPattern$1, hyphenPattern, badStyleValueWithSemicolonPattern, warnedStyleNames, warnedStyleValues, warnedForNaNValue = false, warnedForInfinityValue = false, matchHtmlRegExp, uppercasePattern, msPattern, isJavaScriptProtocol, ReactSharedInternals, ReactDOMSharedInternals, NotPending, previousDispatcher, NothingSent = 0, SentCompleteSegmentFunction = 1, SentCompleteBoundaryFunction = 2, SentClientRenderFunction = 4, SentStyleInsertionFunction = 8, SentCompletedShellId = 32, SentMarkShellTime = 64, EXISTS = null, PRELOAD_NO_CREDS, currentlyFlushingRenderState = null, endInlineScript = "</script>", scriptRegex, didWarnForNewBooleanPropsWithEmptyValue, ROOT_HTML_MODE = 0, HTML_HTML_MODE = 1, HTML_MODE = 2, HTML_HEAD_MODE = 3, SVG_MODE = 4, MATHML_MODE = 5, HTML_TABLE_MODE = 6, HTML_TABLE_BODY_MODE = 7, HTML_TABLE_ROW_MODE = 8, HTML_COLGROUP_MODE = 9, styleNameCache, styleAttributeStart = ' style="', styleAssign = ":", styleSeparator = ";", attributeSeparator = " ", attributeAssign = '="', attributeEnd = '"', attributeEmptyString = '=""', actionJavaScriptURL, endOfStartTag = ">", endOfStartTagSelfClosing = "/>", didWarnDefaultInputValue = false, didWarnDefaultChecked = false, didWarnDefaultSelectValue = false, didWarnDefaultTextareaValue = false, didWarnInvalidOptionChildren = false, didWarnInvalidOptionInnerHTML = false, didWarnSelectedSetOnOption = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, formReplayingRuntimeScript = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex, VALID_TAG_REGEX, validatedTagCache, endTagCache, shellTimeRuntimeScript = "requestAnimationFrame(function(){$RT=performance.now()});", placeholder1 = '<template id="', placeholder2 = '"></template>', startCompletedSuspenseBoundary = "<!--$-->", startPendingSuspenseBoundary1 = '<!--$?--><template id="', startPendingSuspenseBoundary2 = '"></template>', startClientRenderedSuspenseBoundary = "<!--$!-->", endSuspenseBoundary = "<!--/$-->", clientRenderedSuspenseBoundaryError1 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial = '"', clientRenderedSuspenseBoundaryError1A = ' data-dgst="', clientRenderedSuspenseBoundaryError1B = ' data-msg="', clientRenderedSuspenseBoundaryError1C = ' data-stck="', clientRenderedSuspenseBoundaryError1D = ' data-cstck="', clientRenderedSuspenseBoundaryError2 = "></template>", startSegmentHTML = '<div hidden id="', startSegmentHTML2 = '">', endSegmentHTML = "</div>", startSegmentSVG = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG2 = '">', endSegmentSVG = "</svg>", startSegmentMathML = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML2 = '">', endSegmentMathML = "</math>", startSegmentTable = '<table hidden id="', startSegmentTable2 = '">', endSegmentTable = "</table>", startSegmentTableBody = '<table hidden><tbody id="', startSegmentTableBody2 = '">', endSegmentTableBody = "</tbody></table>", startSegmentTableRow = '<table hidden><tr id="', startSegmentTableRow2 = '">', endSegmentTableRow = "</tr></table>", startSegmentColGroup = '<table hidden><colgroup id="', startSegmentColGroup2 = '">', endSegmentColGroup = "</colgroup></table>", completeSegmentScript1Full = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial = '$RS("', completeSegmentScript2 = '","', completeSegmentScriptEnd = '")</script>', completeBoundaryScriptFunctionOnly = `$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};`, completeBoundaryScript1Partial = '$RC("', completeBoundaryWithStylesScript1FullPartial = `$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=
"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=
"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("`, completeBoundaryWithStylesScript1Partial = '$RR("', completeBoundaryScript2 = '","', completeBoundaryScript3a = '",', completeBoundaryScript3b = '"', completeBoundaryScriptEnd = ")</script>", clientRenderScriptFunctionOnly = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};', clientRenderScript1Full = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial = '$RX("', clientRenderScript1A = '"', clientRenderErrorScriptArgInterstitial = ",", clientRenderScriptEnd = ")</script>", regexForJSStringsInInstructionScripts, regexForJSStringsInScripts, lateStyleTagResourceOpen1 = ' media="not all" data-precedence="', lateStyleTagResourceOpen2 = '" data-href="', lateStyleTagResourceOpen3 = '">', lateStyleTagTemplateClose = "</style>", currentlyRenderingBoundaryHasStylesToHoist = false, destinationHasCapacity = true, stylesheetFlushingQueue, styleTagResourceOpen1 = ' data-precedence="', styleTagResourceOpen2 = '" data-href="', spaceSeparator = " ", styleTagResourceOpen3 = '">', styleTagResourceClose = "</style>", completedShellIdAttributeStart = ' id="', arrayFirstOpenBracket = "[", arraySubsequentOpenBracket = ",[", arrayInterstitial = ",", arrayCloseBracket = "]", PENDING$1 = 0, PRELOADED = 1, PREAMBLE = 2, LATE = 3, regexForHrefInLinkHeaderURLContext, regexForLinkHeaderQuotedParamValueContext, bind, REACT_CLIENT_REFERENCE, emptyContextObject, rendererSigil, currentActiveSnapshot = null, didWarnAboutNoopUpdateForComponent, didWarnAboutDeprecatedWillMount, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypes$1, didWarnAboutChildContextTypes, didWarnAboutInvalidateContextType, didWarnOnInvalidCallback, classComponentUpdater, emptyTreeContext, clz32, log, LN2, SuspenseException, suspendedThenable = null, objectIs, currentlyRenderingComponent = null, currentlyRenderingTask = null, currentlyRenderingRequest = null, currentlyRenderingKeyPath = null, firstWorkInProgressHook = null, workInProgressHook = null, isReRender = false, didScheduleRenderPhaseUpdate = false, localIdCounter = 0, actionStateCounter = 0, actionStateMatchingIndex = -1, thenableIndexCounter = 0, thenableState = null, renderPhaseUpdates = null, numberOfReRenders = 0, isInHookUserCodeInDev = false, currentHookNameInDev, HooksDispatcher, currentResumableState = null, currentTaskInDEV = null, DefaultAsyncDispatcher, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd, prefix, suffix, reentry = false, componentFrameCache, callComponent, callComponentInDEV, callRender, callRenderInDEV, callLazyInit, callLazyInitInDEV, lastResetTime = 0, getCurrentTime, localPerformance, localDate, CLIENT_RENDERED = 4, PENDING = 0, COMPLETED = 1, FLUSHED = 2, ABORTED = 3, ERRORED = 4, POSTPONED = 5, CLOSED = 14, currentRequest = null, didWarnAboutBadClass, didWarnAboutContextTypes, didWarnAboutContextTypeOnFunctionComponent, didWarnAboutGetDerivedStateOnFunctionComponent, didWarnAboutReassigningProps = false, didWarnAboutGenerators = false, didWarnAboutMaps = false, flushedByteSize = 0, flushingPartialBoundaries = false, isomorphicReactPackageVersion$jscomp$inline_766, $renderToReadableStream = function(children, options) {
  return new Promise(function(resolve, reject) {
    var onFatalError, onAllReady, allReady = new Promise(function(res, rej) {
      onAllReady = res;
      onFatalError = rej;
    }), onHeaders = options ? options.onHeaders : undefined, onHeadersImpl;
    onHeaders && (onHeadersImpl = function(headersDescriptor) {
      onHeaders(new Headers(headersDescriptor));
    });
    var resumableState = createResumableState(options ? options.identifierPrefix : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.bootstrapScriptContent : undefined, options ? options.bootstrapScripts : undefined, options ? options.bootstrapModules : undefined), request$jscomp$0 = createRequest(children, resumableState, createRenderState(resumableState, options ? options.nonce : undefined, options ? options.unstable_externalRuntimeSrc : undefined, options ? options.importMap : undefined, onHeadersImpl, options ? options.maxHeadersLength : undefined), createRootFormatContext(options ? options.namespaceURI : undefined), options ? options.progressiveChunkSize : undefined, options ? options.onError : undefined, onAllReady, function() {
      var stream = new ReadableStream({
        type: "direct",
        pull: function(controller) {
          var request = request$jscomp$0;
          if (request.status === 13)
            request.status = CLOSED, closeWithError(controller, request.fatalError);
          else if (request.status !== CLOSED && request.destination === null) {
            request.destination = controller;
            try {
              flushCompletedQueues(request, controller);
            } catch (error40) {
              controller = {}, logRecoverableError(request, error40, controller, null), fatalError(request, error40, controller, null);
            }
          }
        },
        cancel: function(reason) {
          request$jscomp$0.destination = null;
          abort(request$jscomp$0, reason);
        }
      }, { highWaterMark: 2048 });
      stream.allReady = allReady;
      resolve(stream);
    }, function(error40) {
      allReady.catch(function() {});
      reject(error40);
    }, onFatalError, options ? options.onPostpone : undefined, options ? options.formState : undefined);
    if (options && options.signal) {
      var signal = options.signal;
      if (signal.aborted)
        abort(request$jscomp$0, signal.reason);
      else {
        var listener = function() {
          abort(request$jscomp$0, signal.reason);
          signal.removeEventListener("abort", listener);
        };
        signal.addEventListener("abort", listener);
      }
    }
    startWork(request$jscomp$0);
  });
}, $version = "19.2.0";
var init_react_dom_server_bun_development = __esm(() => {
  React = __toESM(require_react(), 1);
  ReactDOM = __toESM(require_react_dom(), 1);
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
  REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
  REACT_CONTEXT_TYPE = Symbol.for("react.context");
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
  REACT_MEMO_TYPE = Symbol.for("react.memo");
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
  REACT_SCOPE_TYPE = Symbol.for("react.scope");
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
  REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  isArrayImpl = Array.isArray;
  jsxPropsParents = new WeakMap;
  jsxChildrenParents = new WeakMap;
  CLIENT_REFERENCE_TAG = Symbol.for("react.client.reference");
  scheduleMicrotask = queueMicrotask;
  assign = Object.assign;
  hasOwnProperty = Object.prototype.hasOwnProperty;
  VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  illegalAttributeNameCache = {};
  validatedAttributeNameCache = {};
  unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
  aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]);
  hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };
  ariaProperties = {
    "aria-current": 0,
    "aria-description": 0,
    "aria-details": 0,
    "aria-disabled": 0,
    "aria-hidden": 0,
    "aria-invalid": 0,
    "aria-keyshortcuts": 0,
    "aria-label": 0,
    "aria-roledescription": 0,
    "aria-autocomplete": 0,
    "aria-checked": 0,
    "aria-expanded": 0,
    "aria-haspopup": 0,
    "aria-level": 0,
    "aria-modal": 0,
    "aria-multiline": 0,
    "aria-multiselectable": 0,
    "aria-orientation": 0,
    "aria-placeholder": 0,
    "aria-pressed": 0,
    "aria-readonly": 0,
    "aria-required": 0,
    "aria-selected": 0,
    "aria-sort": 0,
    "aria-valuemax": 0,
    "aria-valuemin": 0,
    "aria-valuenow": 0,
    "aria-valuetext": 0,
    "aria-atomic": 0,
    "aria-busy": 0,
    "aria-live": 0,
    "aria-relevant": 0,
    "aria-dropeffect": 0,
    "aria-grabbed": 0,
    "aria-activedescendant": 0,
    "aria-colcount": 0,
    "aria-colindex": 0,
    "aria-colspan": 0,
    "aria-controls": 0,
    "aria-describedby": 0,
    "aria-errormessage": 0,
    "aria-flowto": 0,
    "aria-labelledby": 0,
    "aria-owns": 0,
    "aria-posinset": 0,
    "aria-rowcount": 0,
    "aria-rowindex": 0,
    "aria-rowspan": 0,
    "aria-setsize": 0,
    "aria-braillelabel": 0,
    "aria-brailleroledescription": 0,
    "aria-colindextext": 0,
    "aria-rowindextext": 0
  };
  warnedProperties$1 = {};
  rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  possibleStandardNames = {
    accept: "accept",
    acceptcharset: "acceptCharset",
    "accept-charset": "acceptCharset",
    accesskey: "accessKey",
    action: "action",
    allowfullscreen: "allowFullScreen",
    alt: "alt",
    as: "as",
    async: "async",
    autocapitalize: "autoCapitalize",
    autocomplete: "autoComplete",
    autocorrect: "autoCorrect",
    autofocus: "autoFocus",
    autoplay: "autoPlay",
    autosave: "autoSave",
    capture: "capture",
    cellpadding: "cellPadding",
    cellspacing: "cellSpacing",
    challenge: "challenge",
    charset: "charSet",
    checked: "checked",
    children: "children",
    cite: "cite",
    class: "className",
    classid: "classID",
    classname: "className",
    cols: "cols",
    colspan: "colSpan",
    content: "content",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    controls: "controls",
    controlslist: "controlsList",
    coords: "coords",
    crossorigin: "crossOrigin",
    dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
    data: "data",
    datetime: "dateTime",
    default: "default",
    defaultchecked: "defaultChecked",
    defaultvalue: "defaultValue",
    defer: "defer",
    dir: "dir",
    disabled: "disabled",
    disablepictureinpicture: "disablePictureInPicture",
    disableremoteplayback: "disableRemotePlayback",
    download: "download",
    draggable: "draggable",
    enctype: "encType",
    enterkeyhint: "enterKeyHint",
    fetchpriority: "fetchPriority",
    for: "htmlFor",
    form: "form",
    formmethod: "formMethod",
    formaction: "formAction",
    formenctype: "formEncType",
    formnovalidate: "formNoValidate",
    formtarget: "formTarget",
    frameborder: "frameBorder",
    headers: "headers",
    height: "height",
    hidden: "hidden",
    high: "high",
    href: "href",
    hreflang: "hrefLang",
    htmlfor: "htmlFor",
    httpequiv: "httpEquiv",
    "http-equiv": "httpEquiv",
    icon: "icon",
    id: "id",
    imagesizes: "imageSizes",
    imagesrcset: "imageSrcSet",
    inert: "inert",
    innerhtml: "innerHTML",
    inputmode: "inputMode",
    integrity: "integrity",
    is: "is",
    itemid: "itemID",
    itemprop: "itemProp",
    itemref: "itemRef",
    itemscope: "itemScope",
    itemtype: "itemType",
    keyparams: "keyParams",
    keytype: "keyType",
    kind: "kind",
    label: "label",
    lang: "lang",
    list: "list",
    loop: "loop",
    low: "low",
    manifest: "manifest",
    marginwidth: "marginWidth",
    marginheight: "marginHeight",
    max: "max",
    maxlength: "maxLength",
    media: "media",
    mediagroup: "mediaGroup",
    method: "method",
    min: "min",
    minlength: "minLength",
    multiple: "multiple",
    muted: "muted",
    name: "name",
    nomodule: "noModule",
    nonce: "nonce",
    novalidate: "noValidate",
    open: "open",
    optimum: "optimum",
    pattern: "pattern",
    placeholder: "placeholder",
    playsinline: "playsInline",
    poster: "poster",
    preload: "preload",
    profile: "profile",
    radiogroup: "radioGroup",
    readonly: "readOnly",
    referrerpolicy: "referrerPolicy",
    rel: "rel",
    required: "required",
    reversed: "reversed",
    role: "role",
    rows: "rows",
    rowspan: "rowSpan",
    sandbox: "sandbox",
    scope: "scope",
    scoped: "scoped",
    scrolling: "scrolling",
    seamless: "seamless",
    selected: "selected",
    shape: "shape",
    size: "size",
    sizes: "sizes",
    span: "span",
    spellcheck: "spellCheck",
    src: "src",
    srcdoc: "srcDoc",
    srclang: "srcLang",
    srcset: "srcSet",
    start: "start",
    step: "step",
    style: "style",
    summary: "summary",
    tabindex: "tabIndex",
    target: "target",
    title: "title",
    type: "type",
    usemap: "useMap",
    value: "value",
    width: "width",
    wmode: "wmode",
    wrap: "wrap",
    about: "about",
    accentheight: "accentHeight",
    "accent-height": "accentHeight",
    accumulate: "accumulate",
    additive: "additive",
    alignmentbaseline: "alignmentBaseline",
    "alignment-baseline": "alignmentBaseline",
    allowreorder: "allowReorder",
    alphabetic: "alphabetic",
    amplitude: "amplitude",
    arabicform: "arabicForm",
    "arabic-form": "arabicForm",
    ascent: "ascent",
    attributename: "attributeName",
    attributetype: "attributeType",
    autoreverse: "autoReverse",
    azimuth: "azimuth",
    basefrequency: "baseFrequency",
    baselineshift: "baselineShift",
    "baseline-shift": "baselineShift",
    baseprofile: "baseProfile",
    bbox: "bbox",
    begin: "begin",
    bias: "bias",
    by: "by",
    calcmode: "calcMode",
    capheight: "capHeight",
    "cap-height": "capHeight",
    clip: "clip",
    clippath: "clipPath",
    "clip-path": "clipPath",
    clippathunits: "clipPathUnits",
    cliprule: "clipRule",
    "clip-rule": "clipRule",
    color: "color",
    colorinterpolation: "colorInterpolation",
    "color-interpolation": "colorInterpolation",
    colorinterpolationfilters: "colorInterpolationFilters",
    "color-interpolation-filters": "colorInterpolationFilters",
    colorprofile: "colorProfile",
    "color-profile": "colorProfile",
    colorrendering: "colorRendering",
    "color-rendering": "colorRendering",
    contentscripttype: "contentScriptType",
    contentstyletype: "contentStyleType",
    cursor: "cursor",
    cx: "cx",
    cy: "cy",
    d: "d",
    datatype: "datatype",
    decelerate: "decelerate",
    descent: "descent",
    diffuseconstant: "diffuseConstant",
    direction: "direction",
    display: "display",
    divisor: "divisor",
    dominantbaseline: "dominantBaseline",
    "dominant-baseline": "dominantBaseline",
    dur: "dur",
    dx: "dx",
    dy: "dy",
    edgemode: "edgeMode",
    elevation: "elevation",
    enablebackground: "enableBackground",
    "enable-background": "enableBackground",
    end: "end",
    exponent: "exponent",
    externalresourcesrequired: "externalResourcesRequired",
    fill: "fill",
    fillopacity: "fillOpacity",
    "fill-opacity": "fillOpacity",
    fillrule: "fillRule",
    "fill-rule": "fillRule",
    filter: "filter",
    filterres: "filterRes",
    filterunits: "filterUnits",
    floodopacity: "floodOpacity",
    "flood-opacity": "floodOpacity",
    floodcolor: "floodColor",
    "flood-color": "floodColor",
    focusable: "focusable",
    fontfamily: "fontFamily",
    "font-family": "fontFamily",
    fontsize: "fontSize",
    "font-size": "fontSize",
    fontsizeadjust: "fontSizeAdjust",
    "font-size-adjust": "fontSizeAdjust",
    fontstretch: "fontStretch",
    "font-stretch": "fontStretch",
    fontstyle: "fontStyle",
    "font-style": "fontStyle",
    fontvariant: "fontVariant",
    "font-variant": "fontVariant",
    fontweight: "fontWeight",
    "font-weight": "fontWeight",
    format: "format",
    from: "from",
    fx: "fx",
    fy: "fy",
    g1: "g1",
    g2: "g2",
    glyphname: "glyphName",
    "glyph-name": "glyphName",
    glyphorientationhorizontal: "glyphOrientationHorizontal",
    "glyph-orientation-horizontal": "glyphOrientationHorizontal",
    glyphorientationvertical: "glyphOrientationVertical",
    "glyph-orientation-vertical": "glyphOrientationVertical",
    glyphref: "glyphRef",
    gradienttransform: "gradientTransform",
    gradientunits: "gradientUnits",
    hanging: "hanging",
    horizadvx: "horizAdvX",
    "horiz-adv-x": "horizAdvX",
    horizoriginx: "horizOriginX",
    "horiz-origin-x": "horizOriginX",
    ideographic: "ideographic",
    imagerendering: "imageRendering",
    "image-rendering": "imageRendering",
    in2: "in2",
    in: "in",
    inlist: "inlist",
    intercept: "intercept",
    k1: "k1",
    k2: "k2",
    k3: "k3",
    k4: "k4",
    k: "k",
    kernelmatrix: "kernelMatrix",
    kernelunitlength: "kernelUnitLength",
    kerning: "kerning",
    keypoints: "keyPoints",
    keysplines: "keySplines",
    keytimes: "keyTimes",
    lengthadjust: "lengthAdjust",
    letterspacing: "letterSpacing",
    "letter-spacing": "letterSpacing",
    lightingcolor: "lightingColor",
    "lighting-color": "lightingColor",
    limitingconeangle: "limitingConeAngle",
    local: "local",
    markerend: "markerEnd",
    "marker-end": "markerEnd",
    markerheight: "markerHeight",
    markermid: "markerMid",
    "marker-mid": "markerMid",
    markerstart: "markerStart",
    "marker-start": "markerStart",
    markerunits: "markerUnits",
    markerwidth: "markerWidth",
    mask: "mask",
    maskcontentunits: "maskContentUnits",
    maskunits: "maskUnits",
    mathematical: "mathematical",
    mode: "mode",
    numoctaves: "numOctaves",
    offset: "offset",
    opacity: "opacity",
    operator: "operator",
    order: "order",
    orient: "orient",
    orientation: "orientation",
    origin: "origin",
    overflow: "overflow",
    overlineposition: "overlinePosition",
    "overline-position": "overlinePosition",
    overlinethickness: "overlineThickness",
    "overline-thickness": "overlineThickness",
    paintorder: "paintOrder",
    "paint-order": "paintOrder",
    panose1: "panose1",
    "panose-1": "panose1",
    pathlength: "pathLength",
    patterncontentunits: "patternContentUnits",
    patterntransform: "patternTransform",
    patternunits: "patternUnits",
    pointerevents: "pointerEvents",
    "pointer-events": "pointerEvents",
    points: "points",
    pointsatx: "pointsAtX",
    pointsaty: "pointsAtY",
    pointsatz: "pointsAtZ",
    popover: "popover",
    popovertarget: "popoverTarget",
    popovertargetaction: "popoverTargetAction",
    prefix: "prefix",
    preservealpha: "preserveAlpha",
    preserveaspectratio: "preserveAspectRatio",
    primitiveunits: "primitiveUnits",
    property: "property",
    r: "r",
    radius: "radius",
    refx: "refX",
    refy: "refY",
    renderingintent: "renderingIntent",
    "rendering-intent": "renderingIntent",
    repeatcount: "repeatCount",
    repeatdur: "repeatDur",
    requiredextensions: "requiredExtensions",
    requiredfeatures: "requiredFeatures",
    resource: "resource",
    restart: "restart",
    result: "result",
    results: "results",
    rotate: "rotate",
    rx: "rx",
    ry: "ry",
    scale: "scale",
    security: "security",
    seed: "seed",
    shaperendering: "shapeRendering",
    "shape-rendering": "shapeRendering",
    slope: "slope",
    spacing: "spacing",
    specularconstant: "specularConstant",
    specularexponent: "specularExponent",
    speed: "speed",
    spreadmethod: "spreadMethod",
    startoffset: "startOffset",
    stddeviation: "stdDeviation",
    stemh: "stemh",
    stemv: "stemv",
    stitchtiles: "stitchTiles",
    stopcolor: "stopColor",
    "stop-color": "stopColor",
    stopopacity: "stopOpacity",
    "stop-opacity": "stopOpacity",
    strikethroughposition: "strikethroughPosition",
    "strikethrough-position": "strikethroughPosition",
    strikethroughthickness: "strikethroughThickness",
    "strikethrough-thickness": "strikethroughThickness",
    string: "string",
    stroke: "stroke",
    strokedasharray: "strokeDasharray",
    "stroke-dasharray": "strokeDasharray",
    strokedashoffset: "strokeDashoffset",
    "stroke-dashoffset": "strokeDashoffset",
    strokelinecap: "strokeLinecap",
    "stroke-linecap": "strokeLinecap",
    strokelinejoin: "strokeLinejoin",
    "stroke-linejoin": "strokeLinejoin",
    strokemiterlimit: "strokeMiterlimit",
    "stroke-miterlimit": "strokeMiterlimit",
    strokewidth: "strokeWidth",
    "stroke-width": "strokeWidth",
    strokeopacity: "strokeOpacity",
    "stroke-opacity": "strokeOpacity",
    suppresscontenteditablewarning: "suppressContentEditableWarning",
    suppresshydrationwarning: "suppressHydrationWarning",
    surfacescale: "surfaceScale",
    systemlanguage: "systemLanguage",
    tablevalues: "tableValues",
    targetx: "targetX",
    targety: "targetY",
    textanchor: "textAnchor",
    "text-anchor": "textAnchor",
    textdecoration: "textDecoration",
    "text-decoration": "textDecoration",
    textlength: "textLength",
    textrendering: "textRendering",
    "text-rendering": "textRendering",
    to: "to",
    transform: "transform",
    transformorigin: "transformOrigin",
    "transform-origin": "transformOrigin",
    typeof: "typeof",
    u1: "u1",
    u2: "u2",
    underlineposition: "underlinePosition",
    "underline-position": "underlinePosition",
    underlinethickness: "underlineThickness",
    "underline-thickness": "underlineThickness",
    unicode: "unicode",
    unicodebidi: "unicodeBidi",
    "unicode-bidi": "unicodeBidi",
    unicoderange: "unicodeRange",
    "unicode-range": "unicodeRange",
    unitsperem: "unitsPerEm",
    "units-per-em": "unitsPerEm",
    unselectable: "unselectable",
    valphabetic: "vAlphabetic",
    "v-alphabetic": "vAlphabetic",
    values: "values",
    vectoreffect: "vectorEffect",
    "vector-effect": "vectorEffect",
    version: "version",
    vertadvy: "vertAdvY",
    "vert-adv-y": "vertAdvY",
    vertoriginx: "vertOriginX",
    "vert-origin-x": "vertOriginX",
    vertoriginy: "vertOriginY",
    "vert-origin-y": "vertOriginY",
    vhanging: "vHanging",
    "v-hanging": "vHanging",
    videographic: "vIdeographic",
    "v-ideographic": "vIdeographic",
    viewbox: "viewBox",
    viewtarget: "viewTarget",
    visibility: "visibility",
    vmathematical: "vMathematical",
    "v-mathematical": "vMathematical",
    vocab: "vocab",
    widths: "widths",
    wordspacing: "wordSpacing",
    "word-spacing": "wordSpacing",
    writingmode: "writingMode",
    "writing-mode": "writingMode",
    x1: "x1",
    x2: "x2",
    x: "x",
    xchannelselector: "xChannelSelector",
    xheight: "xHeight",
    "x-height": "xHeight",
    xlinkactuate: "xlinkActuate",
    "xlink:actuate": "xlinkActuate",
    xlinkarcrole: "xlinkArcrole",
    "xlink:arcrole": "xlinkArcrole",
    xlinkhref: "xlinkHref",
    "xlink:href": "xlinkHref",
    xlinkrole: "xlinkRole",
    "xlink:role": "xlinkRole",
    xlinkshow: "xlinkShow",
    "xlink:show": "xlinkShow",
    xlinktitle: "xlinkTitle",
    "xlink:title": "xlinkTitle",
    xlinktype: "xlinkType",
    "xlink:type": "xlinkType",
    xmlbase: "xmlBase",
    "xml:base": "xmlBase",
    xmllang: "xmlLang",
    "xml:lang": "xmlLang",
    xmlns: "xmlns",
    "xml:space": "xmlSpace",
    xmlnsxlink: "xmlnsXlink",
    "xmlns:xlink": "xmlnsXlink",
    xmlspace: "xmlSpace",
    y1: "y1",
    y2: "y2",
    y: "y",
    ychannelselector: "yChannelSelector",
    z: "z",
    zoomandpan: "zoomAndPan"
  };
  warnedProperties = {};
  EVENT_NAME_REGEX = /^on./;
  INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
  badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  msPattern$1 = /^-ms-/;
  hyphenPattern = /-(.)/g;
  badStyleValueWithSemicolonPattern = /;\s*$/;
  warnedStyleNames = {};
  warnedStyleValues = {};
  matchHtmlRegExp = /["'&<>]/;
  uppercasePattern = /([A-Z])/g;
  msPattern = /^ms-/;
  isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  NotPending = Object.freeze({
    pending: false,
    data: null,
    method: null,
    action: null
  });
  previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: previousDispatcher.f,
    r: previousDispatcher.r,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  PRELOAD_NO_CREDS = [];
  Object.freeze(PRELOAD_NO_CREDS);
  scriptRegex = /(<\/|<)(s)(cript)/gi;
  didWarnForNewBooleanPropsWithEmptyValue = {};
  styleNameCache = new Map;
  actionJavaScriptURL = escapeTextForBrowser("javascript:throw new Error('React form unexpectedly submitted.')");
  styleRegex = /(<\/|<)(s)(tyle)/gi;
  VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
  validatedTagCache = new Map;
  endTagCache = new Map;
  regexForJSStringsInInstructionScripts = /[<\u2028\u2029]/g;
  regexForJSStringsInScripts = /[&><\u2028\u2029]/g;
  stylesheetFlushingQueue = [];
  regexForHrefInLinkHeaderURLContext = /[<>\r\n]/g;
  regexForLinkHeaderQuotedParamValueContext = /["';,\r\n]/g;
  bind = Function.prototype.bind;
  REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  emptyContextObject = {};
  Object.freeze(emptyContextObject);
  rendererSigil = {};
  didWarnAboutNoopUpdateForComponent = {};
  didWarnAboutDeprecatedWillMount = {};
  didWarnAboutUninitializedState = new Set;
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
  didWarnAboutDirectlyAssigningPropsToState = new Set;
  didWarnAboutUndefinedDerivedState = new Set;
  didWarnAboutContextTypes$1 = new Set;
  didWarnAboutChildContextTypes = new Set;
  didWarnAboutInvalidateContextType = new Set;
  didWarnOnInvalidCallback = new Set;
  classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      var internals = inst._reactInternals;
      internals.queue === null ? warnNoop(inst, "setState") : (internals.queue.push(payload), callback !== undefined && callback !== null && warnOnInvalidCallback(callback));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      inst.replace = true;
      inst.queue = [payload];
      callback !== undefined && callback !== null && warnOnInvalidCallback(callback);
    },
    enqueueForceUpdate: function(inst, callback) {
      inst._reactInternals.queue === null ? warnNoop(inst, "forceUpdate") : callback !== undefined && callback !== null && warnOnInvalidCallback(callback);
    }
  };
  emptyTreeContext = { id: 1, overflow: "" };
  clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
  log = Math.log;
  LN2 = Math.LN2;
  SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.");
  objectIs = typeof Object.is === "function" ? Object.is : is2;
  HooksDispatcher = {
    readContext,
    use: function(usable) {
      if (usable !== null && typeof usable === "object") {
        if (typeof usable.then === "function")
          return unwrapThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE)
          return readContext(usable);
      }
      throw Error("An unsupported type was passed to use(): " + String(usable));
    },
    useContext: function(context) {
      currentHookNameInDev = "useContext";
      resolveCurrentlyRenderingComponent();
      return context._currentValue;
    },
    useMemo,
    useReducer,
    useRef: function(initialValue) {
      currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
      workInProgressHook = createWorkInProgressHook();
      var previousRef = workInProgressHook.memoizedState;
      return previousRef === null ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook.memoizedState = initialValue) : previousRef;
    },
    useState: function(initialState) {
      currentHookNameInDev = "useState";
      return useReducer(basicStateReducer, initialState);
    },
    useInsertionEffect: noop3,
    useLayoutEffect: noop3,
    useCallback: function(callback, deps) {
      return useMemo(function() {
        return callback;
      }, deps);
    },
    useImperativeHandle: noop3,
    useEffect: noop3,
    useDebugValue: noop3,
    useDeferredValue: function(value, initialValue) {
      resolveCurrentlyRenderingComponent();
      return initialValue !== undefined ? initialValue : value;
    },
    useTransition: function() {
      resolveCurrentlyRenderingComponent();
      return [false, unsupportedStartTransition];
    },
    useId: function() {
      var treeId = currentlyRenderingTask.treeContext;
      var overflow = treeId.overflow;
      treeId = treeId.id;
      treeId = (treeId & ~(1 << 32 - clz32(treeId) - 1)).toString(32) + overflow;
      var resumableState = currentResumableState;
      if (resumableState === null)
        throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
      overflow = localIdCounter++;
      treeId = "_" + resumableState.idPrefix + "R_" + treeId;
      0 < overflow && (treeId += "H" + overflow.toString(32));
      return treeId + "_";
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      if (getServerSnapshot === undefined)
        throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      return getServerSnapshot();
    },
    useOptimistic: function(passthrough) {
      resolveCurrentlyRenderingComponent();
      return [passthrough, unsupportedSetOptimisticState];
    },
    useActionState,
    useFormState: useActionState,
    useHostTransitionStatus: function() {
      resolveCurrentlyRenderingComponent();
      return NotPending;
    },
    useMemoCache: function(size2) {
      for (var data = Array(size2), i2 = 0;i2 < size2; i2++)
        data[i2] = REACT_MEMO_CACHE_SENTINEL;
      return data;
    },
    useCacheRefresh: function() {
      return unsupportedRefresh;
    },
    useEffectEvent: function() {
      return throwOnUseEffectEventCall;
    }
  };
  DefaultAsyncDispatcher = {
    getCacheForType: function() {
      throw Error("Not implemented.");
    },
    cacheSignal: function() {
      throw Error("Not implemented.");
    },
    getOwner: function() {
      return currentTaskInDEV === null ? null : currentTaskInDEV.componentStack;
    }
  };
  disabledLog.__reactDisabledLog = true;
  componentFrameCache = new (typeof WeakMap === "function" ? WeakMap : Map);
  callComponent = {
    react_stack_bottom_frame: function(Component, props, secondArg) {
      return Component(props, secondArg);
    }
  };
  callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent);
  callRender = {
    react_stack_bottom_frame: function(instance) {
      return instance.render();
    }
  };
  callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender);
  callLazyInit = {
    react_stack_bottom_frame: function(lazy2) {
      var init = lazy2._init;
      return init(lazy2._payload);
    }
  };
  callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit);
  if (typeof performance === "object" && typeof performance.now === "function") {
    localPerformance = performance;
    getCurrentTime = function() {
      return localPerformance.now();
    };
  } else {
    localDate = Date;
    getCurrentTime = function() {
      return localDate.now();
    };
  }
  didWarnAboutBadClass = {};
  didWarnAboutContextTypes = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  isomorphicReactPackageVersion$jscomp$inline_766 = React.version;
  if (isomorphicReactPackageVersion$jscomp$inline_766 !== "19.2.0")
    throw Error(`Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:
  - react:      ` + (isomorphicReactPackageVersion$jscomp$inline_766 + `
  - react-dom:  19.2.0
Learn more: https://react.dev/warnings/version-mismatch`));
});

// node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
var require_react_dom_server_legacy_browser_development = __commonJS((exports) => {
  var React2 = __toESM(require_react(), 1);
  var ReactDOM2 = __toESM(require_react_dom(), 1);
  (function() {
    function styleReplacer2(match, prefix3, s, suffix3) {
      return "" + prefix3 + (s === "s" ? "\\73 " : "\\53 ") + suffix3;
    }
    function scriptReplacer2(match, prefix3, s, suffix3) {
      return "" + prefix3 + (s === "s" ? "\\u0073" : "\\u0053") + suffix3;
    }
    function getIteratorFn2(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== "object")
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL2 && maybeIterable[MAYBE_ITERATOR_SYMBOL2] || maybeIterable["@@iterator"];
      return typeof maybeIterable === "function" ? maybeIterable : null;
    }
    function objectName2(object2) {
      object2 = Object.prototype.toString.call(object2);
      return object2.slice(8, object2.length - 1);
    }
    function describeKeyForErrorMessage2(key) {
      var encodedKey = JSON.stringify(key);
      return '"' + key + '"' === encodedKey ? key : encodedKey;
    }
    function describeValueForErrorMessage2(value) {
      switch (typeof value) {
        case "string":
          return JSON.stringify(10 >= value.length ? value : value.slice(0, 10) + "...");
        case "object":
          if (isArrayImpl2(value))
            return "[...]";
          if (value !== null && value.$$typeof === CLIENT_REFERENCE_TAG2)
            return "client";
          value = objectName2(value);
          return value === "Object" ? "{...}" : value;
        case "function":
          return value.$$typeof === CLIENT_REFERENCE_TAG2 ? "client" : (value = value.displayName || value.name) ? "function " + value : "function";
        default:
          return String(value);
      }
    }
    function describeElementType2(type) {
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_SUSPENSE_TYPE2:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE2:
          return "SuspenseList";
      }
      if (typeof type === "object")
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE2:
            return describeElementType2(type.render);
          case REACT_MEMO_TYPE2:
            return describeElementType2(type.type);
          case REACT_LAZY_TYPE2:
            var payload = type._payload;
            type = type._init;
            try {
              return describeElementType2(type(payload));
            } catch (x2) {}
        }
      return "";
    }
    function describeObjectForErrorMessage2(objectOrArray, expandedName) {
      var objKind = objectName2(objectOrArray);
      if (objKind !== "Object" && objKind !== "Array")
        return objKind;
      var start = -1, length = 0;
      if (isArrayImpl2(objectOrArray))
        if (jsxChildrenParents2.has(objectOrArray)) {
          var type = jsxChildrenParents2.get(objectOrArray);
          objKind = "<" + describeElementType2(type) + ">";
          for (var i2 = 0;i2 < objectOrArray.length; i2++) {
            var value = objectOrArray[i2];
            value = typeof value === "string" ? value : typeof value === "object" && value !== null ? "{" + describeObjectForErrorMessage2(value) + "}" : "{" + describeValueForErrorMessage2(value) + "}";
            "" + i2 === expandedName ? (start = objKind.length, length = value.length, objKind += value) : objKind = 15 > value.length && 40 > objKind.length + value.length ? objKind + value : objKind + "{...}";
          }
          objKind += "</" + describeElementType2(type) + ">";
        } else {
          objKind = "[";
          for (type = 0;type < objectOrArray.length; type++)
            0 < type && (objKind += ", "), i2 = objectOrArray[type], i2 = typeof i2 === "object" && i2 !== null ? describeObjectForErrorMessage2(i2) : describeValueForErrorMessage2(i2), "" + type === expandedName ? (start = objKind.length, length = i2.length, objKind += i2) : objKind = 10 > i2.length && 40 > objKind.length + i2.length ? objKind + i2 : objKind + "...";
          objKind += "]";
        }
      else if (objectOrArray.$$typeof === REACT_ELEMENT_TYPE2)
        objKind = "<" + describeElementType2(objectOrArray.type) + "/>";
      else {
        if (objectOrArray.$$typeof === CLIENT_REFERENCE_TAG2)
          return "client";
        if (jsxPropsParents2.has(objectOrArray)) {
          objKind = jsxPropsParents2.get(objectOrArray);
          objKind = "<" + (describeElementType2(objKind) || "...");
          type = Object.keys(objectOrArray);
          for (i2 = 0;i2 < type.length; i2++) {
            objKind += " ";
            value = type[i2];
            objKind += describeKeyForErrorMessage2(value) + "=";
            var _value2 = objectOrArray[value];
            var _substr2 = value === expandedName && typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage2(_value2) : describeValueForErrorMessage2(_value2);
            typeof _value2 !== "string" && (_substr2 = "{" + _substr2 + "}");
            value === expandedName ? (start = objKind.length, length = _substr2.length, objKind += _substr2) : objKind = 10 > _substr2.length && 40 > objKind.length + _substr2.length ? objKind + _substr2 : objKind + "...";
          }
          objKind += ">";
        } else {
          objKind = "{";
          type = Object.keys(objectOrArray);
          for (i2 = 0;i2 < type.length; i2++)
            0 < i2 && (objKind += ", "), value = type[i2], objKind += describeKeyForErrorMessage2(value) + ": ", _value2 = objectOrArray[value], _value2 = typeof _value2 === "object" && _value2 !== null ? describeObjectForErrorMessage2(_value2) : describeValueForErrorMessage2(_value2), value === expandedName ? (start = objKind.length, length = _value2.length, objKind += _value2) : objKind = 10 > _value2.length && 40 > objKind.length + _value2.length ? objKind + _value2 : objKind + "...";
          objKind += "}";
        }
      }
      return expandedName === undefined ? objKind : -1 < start && 0 < length ? (objectOrArray = " ".repeat(start) + "^".repeat(length), `
  ` + objKind + `
  ` + objectOrArray) : `
  ` + objKind;
    }
    function murmurhash3_32_gc(key, seed) {
      var remainder = key.length & 3;
      var bytes = key.length - remainder;
      var h1 = seed;
      for (seed = 0;seed < bytes; ) {
        var k1 = key.charCodeAt(seed) & 255 | (key.charCodeAt(++seed) & 255) << 8 | (key.charCodeAt(++seed) & 255) << 16 | (key.charCodeAt(++seed) & 255) << 24;
        ++seed;
        k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = 5 * (h1 & 65535) + ((5 * (h1 >>> 16) & 65535) << 16) & 4294967295;
        h1 = (h1 & 65535) + 27492 + (((h1 >>> 16) + 58964 & 65535) << 16);
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(seed + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(seed + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(seed) & 255, k1 = 3432918353 * (k1 & 65535) + ((3432918353 * (k1 >>> 16) & 65535) << 16) & 4294967295, k1 = k1 << 15 | k1 >>> 17, h1 ^= 461845907 * (k1 & 65535) + ((461845907 * (k1 >>> 16) & 65535) << 16) & 4294967295;
      }
      h1 ^= key.length;
      h1 ^= h1 >>> 16;
      h1 = 2246822507 * (h1 & 65535) + ((2246822507 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      h1 ^= h1 >>> 13;
      h1 = 3266489909 * (h1 & 65535) + ((3266489909 * (h1 >>> 16) & 65535) << 16) & 4294967295;
      return (h1 ^ h1 >>> 16) >>> 0;
    }
    function typeName2(value) {
      return typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
    }
    function willCoercionThrow2(value) {
      try {
        return testStringCoercion2(value), false;
      } catch (e) {
        return true;
      }
    }
    function testStringCoercion2(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion2(value, attributeName) {
      if (willCoercionThrow2(value))
        return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName2(value)), testStringCoercion2(value);
    }
    function checkCSSPropertyStringCoercion2(value, propName) {
      if (willCoercionThrow2(value))
        return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName2(value)), testStringCoercion2(value);
    }
    function checkHtmlStringCoercion2(value) {
      if (willCoercionThrow2(value))
        return console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName2(value)), testStringCoercion2(value);
    }
    function isAttributeNameSafe2(attributeName) {
      if (hasOwnProperty2.call(validatedAttributeNameCache2, attributeName))
        return true;
      if (hasOwnProperty2.call(illegalAttributeNameCache2, attributeName))
        return false;
      if (VALID_ATTRIBUTE_NAME_REGEX2.test(attributeName))
        return validatedAttributeNameCache2[attributeName] = true;
      illegalAttributeNameCache2[attributeName] = true;
      console.error("Invalid attribute name: `%s`", attributeName);
      return false;
    }
    function checkControlledValueProps2(tagName, props) {
      hasReadOnlyValue2[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || (tagName === "select" ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
      props.onChange || props.readOnly || props.disabled || props.checked == null || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function validateProperty$12(tagName, name) {
      if (hasOwnProperty2.call(warnedProperties$12, name) && warnedProperties$12[name])
        return true;
      if (rARIACamel$12.test(name)) {
        tagName = "aria-" + name.slice(4).toLowerCase();
        tagName = ariaProperties2.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$12[name] = true;
        if (name !== tagName)
          return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$12[name] = true;
      }
      if (rARIA$12.test(name)) {
        tagName = name.toLowerCase();
        tagName = ariaProperties2.hasOwnProperty(tagName) ? tagName : null;
        if (tagName == null)
          return warnedProperties$12[name] = true, false;
        name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$12[name] = true);
      }
      return true;
    }
    function validateProperties$22(type, props) {
      var invalidProps = [], key;
      for (key in props)
        validateProperty$12(type, key) || invalidProps.push(key);
      props = invalidProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      invalidProps.length === 1 ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
    }
    function validateProperty2(tagName, name, value, eventRegistry) {
      if (hasOwnProperty2.call(warnedProperties2, name) && warnedProperties2[name])
        return true;
      var lowerCasedName = name.toLowerCase();
      if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
        return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties2[name] = true;
      if (typeof value === "function" && (tagName === "form" && name === "action" || tagName === "input" && name === "formAction" || tagName === "button" && name === "formAction"))
        return true;
      if (eventRegistry != null) {
        tagName = eventRegistry.possibleRegistrationNames;
        if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
          return true;
        eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
        if (eventRegistry != null)
          return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties2[name] = true;
        if (EVENT_NAME_REGEX2.test(name))
          return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties2[name] = true;
      } else if (EVENT_NAME_REGEX2.test(name))
        return INVALID_EVENT_NAME_REGEX2.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties2[name] = true;
      if (rARIA2.test(name) || rARIACamel2.test(name))
        return true;
      if (lowerCasedName === "innerhtml")
        return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties2[name] = true;
      if (lowerCasedName === "aria")
        return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties2[name] = true;
      if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string")
        return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties2[name] = true;
      if (typeof value === "number" && isNaN(value))
        return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties2[name] = true;
      if (possibleStandardNames2.hasOwnProperty(lowerCasedName)) {
        if (lowerCasedName = possibleStandardNames2[lowerCasedName], lowerCasedName !== name)
          return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties2[name] = true;
      } else if (name !== lowerCasedName)
        return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties2[name] = true;
      switch (name) {
        case "dangerouslySetInnerHTML":
        case "children":
        case "style":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          return true;
        case "innerText":
        case "textContent":
          return true;
      }
      switch (typeof value) {
        case "boolean":
          switch (name) {
            case "autoFocus":
            case "checked":
            case "multiple":
            case "muted":
            case "selected":
            case "contentEditable":
            case "spellCheck":
            case "draggable":
            case "value":
            case "autoReverse":
            case "externalResourcesRequired":
            case "focusable":
            case "preserveAlpha":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "capture":
            case "download":
            case "inert":
              return true;
            default:
              lowerCasedName = name.toLowerCase().slice(0, 5);
              if (lowerCasedName === "data-" || lowerCasedName === "aria-")
                return true;
              value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              return warnedProperties2[name] = true;
          }
        case "function":
        case "symbol":
          return warnedProperties2[name] = true, false;
        case "string":
          if (value === "false" || value === "true") {
            switch (name) {
              case "checked":
              case "selected":
              case "multiple":
              case "muted":
              case "allowFullScreen":
              case "async":
              case "autoPlay":
              case "controls":
              case "default":
              case "defer":
              case "disabled":
              case "disablePictureInPicture":
              case "disableRemotePlayback":
              case "formNoValidate":
              case "hidden":
              case "loop":
              case "noModule":
              case "noValidate":
              case "open":
              case "playsInline":
              case "readOnly":
              case "required":
              case "reversed":
              case "scoped":
              case "seamless":
              case "itemScope":
              case "inert":
                break;
              default:
                return true;
            }
            console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties2[name] = true;
          }
      }
      return true;
    }
    function warnUnknownProperties2(type, props, eventRegistry) {
      var unknownProps = [], key;
      for (key in props)
        validateProperty2(type, key, props[key], eventRegistry) || unknownProps.push(key);
      props = unknownProps.map(function(prop) {
        return "`" + prop + "`";
      }).join(", ");
      unknownProps.length === 1 ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
    }
    function camelize2(string4) {
      return string4.replace(hyphenPattern2, function(_2, character) {
        return character.toUpperCase();
      });
    }
    function escapeTextForBrowser2(text2) {
      if (typeof text2 === "boolean" || typeof text2 === "number" || typeof text2 === "bigint")
        return "" + text2;
      checkHtmlStringCoercion2(text2);
      text2 = "" + text2;
      var match = matchHtmlRegExp2.exec(text2);
      if (match) {
        var html = "", index, lastIndex = 0;
        for (index = match.index;index < text2.length; index++) {
          switch (text2.charCodeAt(index)) {
            case 34:
              match = "&quot;";
              break;
            case 38:
              match = "&amp;";
              break;
            case 39:
              match = "&#x27;";
              break;
            case 60:
              match = "&lt;";
              break;
            case 62:
              match = "&gt;";
              break;
            default:
              continue;
          }
          lastIndex !== index && (html += text2.slice(lastIndex, index));
          lastIndex = index + 1;
          html += match;
        }
        text2 = lastIndex !== index ? html + text2.slice(lastIndex, index) : html;
      }
      return text2;
    }
    function sanitizeURL2(url2) {
      return isJavaScriptProtocol2.test("" + url2) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url2;
    }
    function escapeEntireInlineScriptContent2(scriptText) {
      checkHtmlStringCoercion2(scriptText);
      return ("" + scriptText).replace(scriptRegex2, scriptReplacer2);
    }
    function createResumableState2(identifierPrefix, externalRuntimeConfig, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
      return {
        idPrefix: identifierPrefix === undefined ? "" : identifierPrefix,
        nextFormID: 0,
        streamingFormat: 0,
        bootstrapScriptContent,
        bootstrapScripts,
        bootstrapModules,
        instructions: NothingSent2,
        hasBody: false,
        hasHtml: false,
        unknownResources: {},
        dnsResources: {},
        connectResources: { default: {}, anonymous: {}, credentials: {} },
        imageResources: {},
        styleResources: {},
        scriptResources: {},
        moduleUnknownResources: {},
        moduleScriptResources: {}
      };
    }
    function createFormatContext2(insertionMode, selectedValue, tagScope, viewTransition) {
      return {
        insertionMode,
        selectedValue,
        tagScope,
        viewTransition
      };
    }
    function getChildFormatContext2(parentContext, type, props) {
      var subtreeScope = parentContext.tagScope & -25;
      switch (type) {
        case "noscript":
          return createFormatContext2(HTML_MODE2, null, subtreeScope | 1, null);
        case "select":
          return createFormatContext2(HTML_MODE2, props.value != null ? props.value : props.defaultValue, subtreeScope, null);
        case "svg":
          return createFormatContext2(SVG_MODE2, null, subtreeScope, null);
        case "picture":
          return createFormatContext2(HTML_MODE2, null, subtreeScope | 2, null);
        case "math":
          return createFormatContext2(MATHML_MODE2, null, subtreeScope, null);
        case "foreignObject":
          return createFormatContext2(HTML_MODE2, null, subtreeScope, null);
        case "table":
          return createFormatContext2(HTML_TABLE_MODE2, null, subtreeScope, null);
        case "thead":
        case "tbody":
        case "tfoot":
          return createFormatContext2(HTML_TABLE_BODY_MODE2, null, subtreeScope, null);
        case "colgroup":
          return createFormatContext2(HTML_COLGROUP_MODE2, null, subtreeScope, null);
        case "tr":
          return createFormatContext2(HTML_TABLE_ROW_MODE2, null, subtreeScope, null);
        case "head":
          if (parentContext.insertionMode < HTML_MODE2)
            return createFormatContext2(HTML_HEAD_MODE2, null, subtreeScope, null);
          break;
        case "html":
          if (parentContext.insertionMode === ROOT_HTML_MODE2)
            return createFormatContext2(HTML_HTML_MODE2, null, subtreeScope, null);
      }
      return parentContext.insertionMode >= HTML_TABLE_MODE2 || parentContext.insertionMode < HTML_MODE2 ? createFormatContext2(HTML_MODE2, null, subtreeScope, null) : parentContext.tagScope !== subtreeScope ? createFormatContext2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, null) : parentContext;
    }
    function getSuspenseViewTransition2(parentViewTransition) {
      return parentViewTransition === null ? null : {
        update: parentViewTransition.update,
        enter: "none",
        exit: "none",
        share: parentViewTransition.update,
        name: parentViewTransition.autoName,
        autoName: parentViewTransition.autoName,
        nameIdx: 0
      };
    }
    function getSuspenseFallbackFormatContext2(resumableState, parentContext) {
      parentContext.tagScope & 32 && (resumableState.instructions |= 128);
      return createFormatContext2(parentContext.insertionMode, parentContext.selectedValue, parentContext.tagScope | 12, getSuspenseViewTransition2(parentContext.viewTransition));
    }
    function getSuspenseContentFormatContext2(resumableState, parentContext) {
      resumableState = getSuspenseViewTransition2(parentContext.viewTransition);
      var subtreeScope = parentContext.tagScope | 16;
      resumableState !== null && resumableState.share !== "none" && (subtreeScope |= 64);
      return createFormatContext2(parentContext.insertionMode, parentContext.selectedValue, subtreeScope, resumableState);
    }
    function pushStyleAttribute2(target, style) {
      if (typeof style !== "object")
        throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      var isFirst = true, styleName;
      for (styleName in style)
        if (hasOwnProperty2.call(style, styleName)) {
          var styleValue = style[styleName];
          if (styleValue != null && typeof styleValue !== "boolean" && styleValue !== "") {
            if (styleName.indexOf("--") === 0) {
              var nameChunk = escapeTextForBrowser2(styleName);
              checkCSSPropertyStringCoercion2(styleValue, styleName);
              styleValue = escapeTextForBrowser2(("" + styleValue).trim());
            } else {
              nameChunk = styleName;
              var value = styleValue;
              if (-1 < nameChunk.indexOf("-")) {
                var name = nameChunk;
                warnedStyleNames2.hasOwnProperty(name) && warnedStyleNames2[name] || (warnedStyleNames2[name] = true, console.error("Unsupported style property %s. Did you mean %s?", name, camelize2(name.replace(msPattern$12, "ms-"))));
              } else if (badVendoredStyleNamePattern2.test(nameChunk))
                name = nameChunk, warnedStyleNames2.hasOwnProperty(name) && warnedStyleNames2[name] || (warnedStyleNames2[name] = true, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1)));
              else if (badStyleValueWithSemicolonPattern2.test(value)) {
                name = nameChunk;
                var value$jscomp$0 = value;
                warnedStyleValues2.hasOwnProperty(value$jscomp$0) && warnedStyleValues2[value$jscomp$0] || (warnedStyleValues2[value$jscomp$0] = true, console.error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value$jscomp$0.replace(badStyleValueWithSemicolonPattern2, "")));
              }
              typeof value === "number" && (isNaN(value) ? warnedForNaNValue2 || (warnedForNaNValue2 = true, console.error("`NaN` is an invalid value for the `%s` css style property.", nameChunk)) : isFinite(value) || warnedForInfinityValue2 || (warnedForInfinityValue2 = true, console.error("`Infinity` is an invalid value for the `%s` css style property.", nameChunk)));
              nameChunk = styleName;
              value = styleNameCache2.get(nameChunk);
              value !== undefined ? nameChunk = value : (value = escapeTextForBrowser2(nameChunk.replace(uppercasePattern2, "-$1").toLowerCase().replace(msPattern2, "-ms-")), styleNameCache2.set(nameChunk, value), nameChunk = value);
              typeof styleValue === "number" ? styleValue = styleValue === 0 || unitlessNumbers2.has(styleName) ? "" + styleValue : styleValue + "px" : (checkCSSPropertyStringCoercion2(styleValue, styleName), styleValue = escapeTextForBrowser2(("" + styleValue).trim()));
            }
            isFirst ? (isFirst = false, target.push(styleAttributeStart2, nameChunk, styleAssign2, styleValue)) : target.push(styleSeparator2, nameChunk, styleAssign2, styleValue);
          }
        }
      isFirst || target.push(attributeEnd2);
    }
    function pushBooleanAttribute2(target, name, value) {
      value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name, attributeEmptyString2);
    }
    function pushStringAttribute2(target, name, value) {
      typeof value !== "function" && typeof value !== "symbol" && typeof value !== "boolean" && target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
    }
    function pushAdditionalFormField2(value, key) {
      this.push('<input type="hidden"');
      validateAdditionalFormField2(value);
      pushStringAttribute2(this, "name", key);
      pushStringAttribute2(this, "value", value);
      this.push(endOfStartTagSelfClosing2);
    }
    function validateAdditionalFormField2(value) {
      if (typeof value !== "string")
        throw Error("File/Blob fields are not yet supported in progressive forms. Will fallback to client hydration.");
    }
    function getCustomFormFields2(resumableState, formAction) {
      if (typeof formAction.$$FORM_ACTION === "function") {
        var id = resumableState.nextFormID++;
        resumableState = resumableState.idPrefix + id;
        try {
          var customFields = formAction.$$FORM_ACTION(resumableState);
          if (customFields) {
            var formData = customFields.data;
            formData != null && formData.forEach(validateAdditionalFormField2);
          }
          return customFields;
        } catch (x2) {
          if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function")
            throw x2;
          console.error(`Failed to serialize an action for progressive enhancement:
%s`, x2);
        }
      }
      return null;
    }
    function pushFormActionAttribute2(target, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name) {
      var formData = null;
      if (typeof formAction === "function") {
        name === null || didWarnFormActionName2 || (didWarnFormActionName2 = true, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'));
        formEncType === null && formMethod === null || didWarnFormActionMethod2 || (didWarnFormActionMethod2 = true, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."));
        formTarget === null || didWarnFormActionTarget2 || (didWarnFormActionTarget2 = true, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."));
        var customFields = getCustomFormFields2(resumableState, formAction);
        customFields !== null ? (name = customFields.name, formAction = customFields.action || "", formEncType = customFields.encType, formMethod = customFields.method, formTarget = customFields.target, formData = customFields.data) : (target.push(attributeSeparator2, "formAction", attributeAssign2, actionJavaScriptURL2, attributeEnd2), formTarget = formMethod = formEncType = formAction = name = null, injectFormReplayingRuntime2(resumableState, renderState));
      }
      name != null && pushAttribute2(target, "name", name);
      formAction != null && pushAttribute2(target, "formAction", formAction);
      formEncType != null && pushAttribute2(target, "formEncType", formEncType);
      formMethod != null && pushAttribute2(target, "formMethod", formMethod);
      formTarget != null && pushAttribute2(target, "formTarget", formTarget);
      return formData;
    }
    function pushAttribute2(target, name, value) {
      switch (name) {
        case "className":
          pushStringAttribute2(target, "class", value);
          break;
        case "tabIndex":
          pushStringAttribute2(target, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          pushStringAttribute2(target, name, value);
          break;
        case "style":
          pushStyleAttribute2(target, value);
          break;
        case "src":
        case "href":
          if (value === "") {
            name === "src" ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name, name) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', name, name);
            break;
          }
        case "action":
        case "formAction":
          if (value == null || typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
            break;
          checkAttributeStringCoercion2(value, name);
          value = sanitizeURL2("" + value);
          target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "ref":
          break;
        case "autoFocus":
        case "multiple":
        case "muted":
          pushBooleanAttribute2(target, name.toLowerCase(), value);
          break;
        case "xlinkHref":
          if (typeof value === "function" || typeof value === "symbol" || typeof value === "boolean")
            break;
          checkAttributeStringCoercion2(value, name);
          value = sanitizeURL2("" + value);
          target.push(attributeSeparator2, "xlink:href", attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "inert":
          value !== "" || didWarnForNewBooleanPropsWithEmptyValue2[name] || (didWarnForNewBooleanPropsWithEmptyValue2[name] = true, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", name));
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name, attributeEmptyString2);
          break;
        case "capture":
        case "download":
          value === true ? target.push(attributeSeparator2, name, attributeEmptyString2) : value !== false && typeof value !== "function" && typeof value !== "symbol" && target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          typeof value !== "function" && typeof value !== "symbol" && !isNaN(value) && 1 <= value && target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "rowSpan":
        case "start":
          typeof value === "function" || typeof value === "symbol" || isNaN(value) || target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
          break;
        case "xlinkActuate":
          pushStringAttribute2(target, "xlink:actuate", value);
          break;
        case "xlinkArcrole":
          pushStringAttribute2(target, "xlink:arcrole", value);
          break;
        case "xlinkRole":
          pushStringAttribute2(target, "xlink:role", value);
          break;
        case "xlinkShow":
          pushStringAttribute2(target, "xlink:show", value);
          break;
        case "xlinkTitle":
          pushStringAttribute2(target, "xlink:title", value);
          break;
        case "xlinkType":
          pushStringAttribute2(target, "xlink:type", value);
          break;
        case "xmlBase":
          pushStringAttribute2(target, "xml:base", value);
          break;
        case "xmlLang":
          pushStringAttribute2(target, "xml:lang", value);
          break;
        case "xmlSpace":
          pushStringAttribute2(target, "xml:space", value);
          break;
        default:
          if (!(2 < name.length) || name[0] !== "o" && name[0] !== "O" || name[1] !== "n" && name[1] !== "N") {
            if (name = aliases2.get(name) || name, isAttributeNameSafe2(name)) {
              switch (typeof value) {
                case "function":
                case "symbol":
                  return;
                case "boolean":
                  var prefix3 = name.toLowerCase().slice(0, 5);
                  if (prefix3 !== "data-" && prefix3 !== "aria-")
                    return;
              }
              target.push(attributeSeparator2, name, attributeAssign2, escapeTextForBrowser2(value), attributeEnd2);
            }
          }
      }
    }
    function pushInnerHTML2(target, innerHTML, children) {
      if (innerHTML != null) {
        if (children != null)
          throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
        if (typeof innerHTML !== "object" || !("__html" in innerHTML))
          throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
        innerHTML = innerHTML.__html;
        innerHTML !== null && innerHTML !== undefined && (checkHtmlStringCoercion2(innerHTML), target.push("" + innerHTML));
      }
    }
    function checkSelectProp2(props, propName) {
      var value = props[propName];
      value != null && (value = isArrayImpl2(value), props.multiple && !value ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName) : !props.multiple && value && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName));
    }
    function flattenOptionChildren2(children) {
      var content = "";
      React2.Children.forEach(children, function(child) {
        child != null && (content += child, didWarnInvalidOptionChildren2 || typeof child === "string" || typeof child === "number" || typeof child === "bigint" || (didWarnInvalidOptionChildren2 = true, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      });
      return content;
    }
    function injectFormReplayingRuntime2(resumableState, renderState) {
      if ((resumableState.instructions & 16) === NothingSent2) {
        resumableState.instructions |= 16;
        var { preamble, bootstrapChunks } = renderState;
        (preamble.htmlChunks || preamble.headChunks) && bootstrapChunks.length === 0 ? (bootstrapChunks.push(renderState.startInlineScript), pushCompletedShellIdAttribute2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag2, formReplayingRuntimeScript2, endInlineScript2)) : bootstrapChunks.unshift(renderState.startInlineScript, endOfStartTag2, formReplayingRuntimeScript2, endInlineScript2);
      }
    }
    function pushLinkImpl2(target, props) {
      target.push(startChunkForTag2("link"));
      for (var propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing2);
      return null;
    }
    function escapeStyleTextContent2(styleText) {
      checkHtmlStringCoercion2(styleText);
      return ("" + styleText).replace(styleRegex2, styleReplacer2);
    }
    function pushSelfClosing2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      for (var propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(tag2 + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTagSelfClosing2);
      return null;
    }
    function pushTitleImpl2(target, props) {
      target.push(startChunkForTag2("title"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      props = Array.isArray(children) ? 2 > children.length ? children[0] : null : children;
      typeof props !== "function" && typeof props !== "symbol" && props !== null && props !== undefined && target.push(escapeTextForBrowser2("" + props));
      pushInnerHTML2(target, innerHTML, children);
      target.push(endChunkForTag2("title"));
      return null;
    }
    function pushScriptImpl2(target, props) {
      target.push(startChunkForTag2("script"));
      var children = null, innerHTML = null, propKey;
      for (propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                children = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      children != null && typeof children !== "string" && (props = typeof children === "number" ? "a number for children" : Array.isArray(children) ? "an array for children" : "something unexpected for children", console.error("A script element was rendered with %s. If script element has children it must be a single string. Consider using dangerouslySetInnerHTML or passing a plain string as children.", props));
      pushInnerHTML2(target, innerHTML, children);
      typeof children === "string" && target.push(escapeEntireInlineScriptContent2(children));
      target.push(endChunkForTag2("script"));
      return null;
    }
    function pushStartSingletonElement2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      var innerHTML = tag2 = null, propKey;
      for (propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                tag2 = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      pushInnerHTML2(target, innerHTML, tag2);
      return tag2;
    }
    function pushStartGenericElement2(target, props, tag2) {
      target.push(startChunkForTag2(tag2));
      var innerHTML = tag2 = null, propKey;
      for (propKey in props)
        if (hasOwnProperty2.call(props, propKey)) {
          var propValue = props[propKey];
          if (propValue != null)
            switch (propKey) {
              case "children":
                tag2 = propValue;
                break;
              case "dangerouslySetInnerHTML":
                innerHTML = propValue;
                break;
              default:
                pushAttribute2(target, propKey, propValue);
            }
        }
      target.push(endOfStartTag2);
      pushInnerHTML2(target, innerHTML, tag2);
      return typeof tag2 === "string" ? (target.push(escapeTextForBrowser2(tag2)), null) : tag2;
    }
    function startChunkForTag2(tag2) {
      var tagStartChunk = validatedTagCache2.get(tag2);
      if (tagStartChunk === undefined) {
        if (!VALID_TAG_REGEX2.test(tag2))
          throw Error("Invalid tag: " + tag2);
        tagStartChunk = "<" + tag2;
        validatedTagCache2.set(tag2, tagStartChunk);
      }
      return tagStartChunk;
    }
    function pushStartInstance2(target$jscomp$0, type, props, resumableState, renderState, preambleState, hoistableState, formatContext, textEmbedded) {
      validateProperties$22(type, props);
      type !== "input" && type !== "textarea" && type !== "select" || props == null || props.value !== null || didWarnValueNull2 || (didWarnValueNull2 = true, type === "select" && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      b:
        if (type.indexOf("-") === -1)
          var JSCompiler_inline_result = false;
        else
          switch (type) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              JSCompiler_inline_result = false;
              break b;
            default:
              JSCompiler_inline_result = true;
          }
      JSCompiler_inline_result || typeof props.is === "string" || warnUnknownProperties2(type, props, null);
      !props.suppressContentEditableWarning && props.contentEditable && props.children != null && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
      formatContext.insertionMode !== SVG_MODE2 && formatContext.insertionMode !== MATHML_MODE2 && type.indexOf("-") === -1 && type.toLowerCase() !== type && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
      switch (type) {
        case "div":
        case "span":
        case "svg":
        case "path":
          break;
        case "a":
          target$jscomp$0.push(startChunkForTag2("a"));
          var children = null, innerHTML = null, propKey;
          for (propKey in props)
            if (hasOwnProperty2.call(props, propKey)) {
              var propValue = props[propKey];
              if (propValue != null)
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "href":
                    propValue === "" ? pushStringAttribute2(target$jscomp$0, "href", "") : pushAttribute2(target$jscomp$0, propKey, propValue);
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey, propValue);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML, children);
          if (typeof children === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children));
            var JSCompiler_inline_result$jscomp$0 = null;
          } else
            JSCompiler_inline_result$jscomp$0 = children;
          return JSCompiler_inline_result$jscomp$0;
        case "g":
        case "p":
        case "li":
          break;
        case "select":
          checkControlledValueProps2("select", props);
          checkSelectProp2(props, "value");
          checkSelectProp2(props, "defaultValue");
          props.value === undefined || props.defaultValue === undefined || didWarnDefaultSelectValue2 || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultSelectValue2 = true);
          target$jscomp$0.push(startChunkForTag2("select"));
          var children$jscomp$0 = null, innerHTML$jscomp$0 = null, propKey$jscomp$0;
          for (propKey$jscomp$0 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$0)) {
              var propValue$jscomp$0 = props[propKey$jscomp$0];
              if (propValue$jscomp$0 != null)
                switch (propKey$jscomp$0) {
                  case "children":
                    children$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$0 = propValue$jscomp$0;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$0, propValue$jscomp$0);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$0, children$jscomp$0);
          return children$jscomp$0;
        case "option":
          var selectedValue = formatContext.selectedValue;
          target$jscomp$0.push(startChunkForTag2("option"));
          var children$jscomp$1 = null, value = null, selected = null, innerHTML$jscomp$1 = null, propKey$jscomp$1;
          for (propKey$jscomp$1 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$1)) {
              var propValue$jscomp$1 = props[propKey$jscomp$1];
              if (propValue$jscomp$1 != null)
                switch (propKey$jscomp$1) {
                  case "children":
                    children$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "selected":
                    selected = propValue$jscomp$1;
                    didWarnSelectedSetOnOption2 || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption2 = true);
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$1 = propValue$jscomp$1;
                    break;
                  case "value":
                    value = propValue$jscomp$1;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$1, propValue$jscomp$1);
                }
            }
          if (selectedValue != null) {
            if (value !== null) {
              checkAttributeStringCoercion2(value, "value");
              var stringValue = "" + value;
            } else
              innerHTML$jscomp$1 === null || didWarnInvalidOptionInnerHTML2 || (didWarnInvalidOptionInnerHTML2 = true, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")), stringValue = flattenOptionChildren2(children$jscomp$1);
            if (isArrayImpl2(selectedValue))
              for (var i2 = 0;i2 < selectedValue.length; i2++) {
                if (checkAttributeStringCoercion2(selectedValue[i2], "value"), "" + selectedValue[i2] === stringValue) {
                  target$jscomp$0.push(' selected=""');
                  break;
                }
              }
            else
              checkAttributeStringCoercion2(selectedValue, "select.value"), "" + selectedValue === stringValue && target$jscomp$0.push(' selected=""');
          } else
            selected && target$jscomp$0.push(' selected=""');
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$1, children$jscomp$1);
          return children$jscomp$1;
        case "textarea":
          checkControlledValueProps2("textarea", props);
          props.value === undefined || props.defaultValue === undefined || didWarnDefaultTextareaValue2 || (console.error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnDefaultTextareaValue2 = true);
          target$jscomp$0.push(startChunkForTag2("textarea"));
          var value$jscomp$0 = null, defaultValue = null, children$jscomp$2 = null, propKey$jscomp$2;
          for (propKey$jscomp$2 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$2)) {
              var propValue$jscomp$2 = props[propKey$jscomp$2];
              if (propValue$jscomp$2 != null)
                switch (propKey$jscomp$2) {
                  case "children":
                    children$jscomp$2 = propValue$jscomp$2;
                    break;
                  case "value":
                    value$jscomp$0 = propValue$jscomp$2;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$jscomp$2;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$2, propValue$jscomp$2);
                }
            }
          value$jscomp$0 === null && defaultValue !== null && (value$jscomp$0 = defaultValue);
          target$jscomp$0.push(endOfStartTag2);
          if (children$jscomp$2 != null) {
            console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
            if (value$jscomp$0 != null)
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (isArrayImpl2(children$jscomp$2)) {
              if (1 < children$jscomp$2.length)
                throw Error("<textarea> can only have at most one child.");
              checkHtmlStringCoercion2(children$jscomp$2[0]);
              value$jscomp$0 = "" + children$jscomp$2[0];
            }
            checkHtmlStringCoercion2(children$jscomp$2);
            value$jscomp$0 = "" + children$jscomp$2;
          }
          typeof value$jscomp$0 === "string" && value$jscomp$0[0] === `
` && target$jscomp$0.push(leadingNewline);
          value$jscomp$0 !== null && (checkAttributeStringCoercion2(value$jscomp$0, "value"), target$jscomp$0.push(escapeTextForBrowser2("" + value$jscomp$0)));
          return null;
        case "input":
          checkControlledValueProps2("input", props);
          target$jscomp$0.push(startChunkForTag2("input"));
          var name = null, formAction = null, formEncType = null, formMethod = null, formTarget = null, value$jscomp$1 = null, defaultValue$jscomp$0 = null, checked = null, defaultChecked = null, propKey$jscomp$3;
          for (propKey$jscomp$3 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$3)) {
              var propValue$jscomp$3 = props[propKey$jscomp$3];
              if (propValue$jscomp$3 != null)
                switch (propKey$jscomp$3) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "name":
                    name = propValue$jscomp$3;
                    break;
                  case "formAction":
                    formAction = propValue$jscomp$3;
                    break;
                  case "formEncType":
                    formEncType = propValue$jscomp$3;
                    break;
                  case "formMethod":
                    formMethod = propValue$jscomp$3;
                    break;
                  case "formTarget":
                    formTarget = propValue$jscomp$3;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$jscomp$3;
                    break;
                  case "defaultValue":
                    defaultValue$jscomp$0 = propValue$jscomp$3;
                    break;
                  case "checked":
                    checked = propValue$jscomp$3;
                    break;
                  case "value":
                    value$jscomp$1 = propValue$jscomp$3;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$3, propValue$jscomp$3);
                }
            }
          formAction === null || props.type === "image" || props.type === "submit" || didWarnFormActionType2 || (didWarnFormActionType2 = true, console.error('An input can only specify a formAction along with type="submit" or type="image".'));
          var formData = pushFormActionAttribute2(target$jscomp$0, resumableState, renderState, formAction, formEncType, formMethod, formTarget, name);
          checked === null || defaultChecked === null || didWarnDefaultChecked2 || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultChecked2 = true);
          value$jscomp$1 === null || defaultValue$jscomp$0 === null || didWarnDefaultInputValue2 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", "A component", props.type), didWarnDefaultInputValue2 = true);
          checked !== null ? pushBooleanAttribute2(target$jscomp$0, "checked", checked) : defaultChecked !== null && pushBooleanAttribute2(target$jscomp$0, "checked", defaultChecked);
          value$jscomp$1 !== null ? pushAttribute2(target$jscomp$0, "value", value$jscomp$1) : defaultValue$jscomp$0 !== null && pushAttribute2(target$jscomp$0, "value", defaultValue$jscomp$0);
          target$jscomp$0.push(endOfStartTagSelfClosing2);
          formData != null && formData.forEach(pushAdditionalFormField2, target$jscomp$0);
          return null;
        case "button":
          target$jscomp$0.push(startChunkForTag2("button"));
          var children$jscomp$3 = null, innerHTML$jscomp$2 = null, name$jscomp$0 = null, formAction$jscomp$0 = null, formEncType$jscomp$0 = null, formMethod$jscomp$0 = null, formTarget$jscomp$0 = null, propKey$jscomp$4;
          for (propKey$jscomp$4 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$4)) {
              var propValue$jscomp$4 = props[propKey$jscomp$4];
              if (propValue$jscomp$4 != null)
                switch (propKey$jscomp$4) {
                  case "children":
                    children$jscomp$3 = propValue$jscomp$4;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$2 = propValue$jscomp$4;
                    break;
                  case "name":
                    name$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formAction":
                    formAction$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formEncType":
                    formEncType$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formMethod":
                    formMethod$jscomp$0 = propValue$jscomp$4;
                    break;
                  case "formTarget":
                    formTarget$jscomp$0 = propValue$jscomp$4;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$4, propValue$jscomp$4);
                }
            }
          formAction$jscomp$0 === null || props.type == null || props.type === "submit" || didWarnFormActionType2 || (didWarnFormActionType2 = true, console.error('A button can only specify a formAction along with type="submit" or no type.'));
          var formData$jscomp$0 = pushFormActionAttribute2(target$jscomp$0, resumableState, renderState, formAction$jscomp$0, formEncType$jscomp$0, formMethod$jscomp$0, formTarget$jscomp$0, name$jscomp$0);
          target$jscomp$0.push(endOfStartTag2);
          formData$jscomp$0 != null && formData$jscomp$0.forEach(pushAdditionalFormField2, target$jscomp$0);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$2, children$jscomp$3);
          if (typeof children$jscomp$3 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$3));
            var JSCompiler_inline_result$jscomp$1 = null;
          } else
            JSCompiler_inline_result$jscomp$1 = children$jscomp$3;
          return JSCompiler_inline_result$jscomp$1;
        case "form":
          target$jscomp$0.push(startChunkForTag2("form"));
          var children$jscomp$4 = null, innerHTML$jscomp$3 = null, formAction$jscomp$1 = null, formEncType$jscomp$1 = null, formMethod$jscomp$1 = null, formTarget$jscomp$1 = null, propKey$jscomp$5;
          for (propKey$jscomp$5 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$5)) {
              var propValue$jscomp$5 = props[propKey$jscomp$5];
              if (propValue$jscomp$5 != null)
                switch (propKey$jscomp$5) {
                  case "children":
                    children$jscomp$4 = propValue$jscomp$5;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$3 = propValue$jscomp$5;
                    break;
                  case "action":
                    formAction$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "encType":
                    formEncType$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "method":
                    formMethod$jscomp$1 = propValue$jscomp$5;
                    break;
                  case "target":
                    formTarget$jscomp$1 = propValue$jscomp$5;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$5, propValue$jscomp$5);
                }
            }
          var formData$jscomp$1 = null, formActionName = null;
          if (typeof formAction$jscomp$1 === "function") {
            formEncType$jscomp$1 === null && formMethod$jscomp$1 === null || didWarnFormActionMethod2 || (didWarnFormActionMethod2 = true, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."));
            formTarget$jscomp$1 === null || didWarnFormActionTarget2 || (didWarnFormActionTarget2 = true, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."));
            var customFields = getCustomFormFields2(resumableState, formAction$jscomp$1);
            customFields !== null ? (formAction$jscomp$1 = customFields.action || "", formEncType$jscomp$1 = customFields.encType, formMethod$jscomp$1 = customFields.method, formTarget$jscomp$1 = customFields.target, formData$jscomp$1 = customFields.data, formActionName = customFields.name) : (target$jscomp$0.push(attributeSeparator2, "action", attributeAssign2, actionJavaScriptURL2, attributeEnd2), formTarget$jscomp$1 = formMethod$jscomp$1 = formEncType$jscomp$1 = formAction$jscomp$1 = null, injectFormReplayingRuntime2(resumableState, renderState));
          }
          formAction$jscomp$1 != null && pushAttribute2(target$jscomp$0, "action", formAction$jscomp$1);
          formEncType$jscomp$1 != null && pushAttribute2(target$jscomp$0, "encType", formEncType$jscomp$1);
          formMethod$jscomp$1 != null && pushAttribute2(target$jscomp$0, "method", formMethod$jscomp$1);
          formTarget$jscomp$1 != null && pushAttribute2(target$jscomp$0, "target", formTarget$jscomp$1);
          target$jscomp$0.push(endOfStartTag2);
          formActionName !== null && (target$jscomp$0.push('<input type="hidden"'), pushStringAttribute2(target$jscomp$0, "name", formActionName), target$jscomp$0.push(endOfStartTagSelfClosing2), formData$jscomp$1 != null && formData$jscomp$1.forEach(pushAdditionalFormField2, target$jscomp$0));
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$3, children$jscomp$4);
          if (typeof children$jscomp$4 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$4));
            var JSCompiler_inline_result$jscomp$2 = null;
          } else
            JSCompiler_inline_result$jscomp$2 = children$jscomp$4;
          return JSCompiler_inline_result$jscomp$2;
        case "menuitem":
          target$jscomp$0.push(startChunkForTag2("menuitem"));
          for (var propKey$jscomp$6 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$6)) {
              var propValue$jscomp$6 = props[propKey$jscomp$6];
              if (propValue$jscomp$6 != null)
                switch (propKey$jscomp$6) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$6, propValue$jscomp$6);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          return null;
        case "object":
          target$jscomp$0.push(startChunkForTag2("object"));
          var children$jscomp$5 = null, innerHTML$jscomp$4 = null, propKey$jscomp$7;
          for (propKey$jscomp$7 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$7)) {
              var propValue$jscomp$7 = props[propKey$jscomp$7];
              if (propValue$jscomp$7 != null)
                switch (propKey$jscomp$7) {
                  case "children":
                    children$jscomp$5 = propValue$jscomp$7;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$4 = propValue$jscomp$7;
                    break;
                  case "data":
                    checkAttributeStringCoercion2(propValue$jscomp$7, "data");
                    var sanitizedValue = sanitizeURL2("" + propValue$jscomp$7);
                    if (sanitizedValue === "") {
                      console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', propKey$jscomp$7, propKey$jscomp$7);
                      break;
                    }
                    target$jscomp$0.push(attributeSeparator2, "data", attributeAssign2, escapeTextForBrowser2(sanitizedValue), attributeEnd2);
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$7, propValue$jscomp$7);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$4, children$jscomp$5);
          if (typeof children$jscomp$5 === "string") {
            target$jscomp$0.push(escapeTextForBrowser2(children$jscomp$5));
            var JSCompiler_inline_result$jscomp$3 = null;
          } else
            JSCompiler_inline_result$jscomp$3 = children$jscomp$5;
          return JSCompiler_inline_result$jscomp$3;
        case "title":
          var noscriptTagInScope = formatContext.tagScope & 1, isFallback = formatContext.tagScope & 4;
          if (hasOwnProperty2.call(props, "children")) {
            var children$jscomp$6 = props.children, child = Array.isArray(children$jscomp$6) ? 2 > children$jscomp$6.length ? children$jscomp$6[0] : null : children$jscomp$6;
            Array.isArray(children$jscomp$6) && 1 < children$jscomp$6.length ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an Array with length %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert `children` of <title> tags to a single string value which is why Arrays of length greater than 1 are not supported. When using JSX it can be common to combine text nodes and value nodes. For example: <title>hello {nameOfUser}</title>. While not immediately apparent, `children` in this case is an Array with length 2. If your `children` prop is using this form try rewriting it using a template string: <title>{`hello ${nameOfUser}`}</title>.", children$jscomp$6.length) : typeof child === "function" || typeof child === "symbol" ? console.error("React expect children of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found %s instead. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value.", typeof child === "function" ? "a Function" : "a Sybmol") : child && child.toString === {}.toString && (child.$$typeof != null ? console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that appears to be a React element which never implements a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value which is why rendering React elements is not supported. If the `children` of <title> is a React Component try moving the <title> tag into that component. If the `children` of <title> is some HTML markup change it to be Text only to be valid HTML.") : console.error("React expects the `children` prop of <title> tags to be a string, number, bigint, or object with a novel `toString` method but found an object that does not implement a suitable `toString` method. Browsers treat all child Nodes of <title> tags as Text content and React expects to be able to convert children of <title> tags to a single string value. Using the default `toString` method available on every object is almost certainly an error. Consider whether the `children` of this <title> is an object in error and change it to a string or number value if so. Otherwise implement a `toString` method that React can use to produce a valid <title>."));
          }
          if (formatContext.insertionMode === SVG_MODE2 || noscriptTagInScope || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$4 = pushTitleImpl2(target$jscomp$0, props);
          else
            isFallback ? JSCompiler_inline_result$jscomp$4 = null : (pushTitleImpl2(renderState.hoistableChunks, props), JSCompiler_inline_result$jscomp$4 = undefined);
          return JSCompiler_inline_result$jscomp$4;
        case "link":
          var noscriptTagInScope$jscomp$0 = formatContext.tagScope & 1, isFallback$jscomp$0 = formatContext.tagScope & 4, rel = props.rel, href = props.href, precedence = props.precedence;
          if (formatContext.insertionMode === SVG_MODE2 || noscriptTagInScope$jscomp$0 || props.itemProp != null || typeof rel !== "string" || typeof href !== "string" || href === "") {
            rel === "stylesheet" && typeof props.precedence === "string" && (typeof href === "string" && href || console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and expected the `href` prop to be a non-empty string but ecountered %s instead. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop ensure there is a non-empty string `href` prop as well, otherwise remove the `precedence` prop.', href === null ? "`null`" : href === undefined ? "`undefined`" : href === "" ? "an empty string" : 'something with type "' + typeof href + '"'));
            pushLinkImpl2(target$jscomp$0, props);
            var JSCompiler_inline_result$jscomp$5 = null;
          } else if (props.rel === "stylesheet")
            if (typeof precedence !== "string" || props.disabled != null || props.onLoad || props.onError) {
              if (typeof precedence === "string") {
                if (props.disabled != null)
                  console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and a `disabled` prop. The presence of the `disabled` prop indicates an intent to manage the stylesheet active state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the `disabled` prop, otherwise remove the `precedence` prop.');
                else if (props.onLoad || props.onError) {
                  var propDescription = props.onLoad && props.onError ? "`onLoad` and `onError` props" : props.onLoad ? "`onLoad` prop" : "`onError` prop";
                  console.error('React encountered a `<link rel="stylesheet" .../>` with a `precedence` prop and %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', propDescription, propDescription);
                }
              }
              JSCompiler_inline_result$jscomp$5 = pushLinkImpl2(target$jscomp$0, props);
            } else {
              var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
              if (resourceState !== EXISTS2) {
                resumableState.styleResources[href] = EXISTS2;
                styleQueue || (styleQueue = {
                  precedence: escapeTextForBrowser2(precedence),
                  rules: [],
                  hrefs: [],
                  sheets: new Map
                }, renderState.styles.set(precedence, styleQueue));
                var resource = {
                  state: PENDING$12,
                  props: assign2({}, props, {
                    "data-precedence": props.precedence,
                    precedence: null
                  })
                };
                if (resourceState) {
                  resourceState.length === 2 && adoptPreloadCredentials2(resource.props, resourceState);
                  var preloadResource = renderState.preloads.stylesheets.get(href);
                  preloadResource && 0 < preloadResource.length ? preloadResource.length = 0 : resource.state = PRELOADED2;
                }
                styleQueue.sheets.set(href, resource);
                hoistableState && hoistableState.stylesheets.add(resource);
              } else if (styleQueue) {
                var _resource = styleQueue.sheets.get(href);
                _resource && hoistableState && hoistableState.stylesheets.add(_resource);
              }
              textEmbedded && target$jscomp$0.push("<!-- -->");
              JSCompiler_inline_result$jscomp$5 = null;
            }
          else
            props.onLoad || props.onError ? JSCompiler_inline_result$jscomp$5 = pushLinkImpl2(target$jscomp$0, props) : (textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$5 = isFallback$jscomp$0 ? null : pushLinkImpl2(renderState.hoistableChunks, props));
          return JSCompiler_inline_result$jscomp$5;
        case "script":
          var noscriptTagInScope$jscomp$1 = formatContext.tagScope & 1, asyncProp = props.async;
          if (typeof props.src !== "string" || !props.src || !asyncProp || typeof asyncProp === "function" || typeof asyncProp === "symbol" || props.onLoad || props.onError || formatContext.insertionMode === SVG_MODE2 || noscriptTagInScope$jscomp$1 || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$6 = pushScriptImpl2(target$jscomp$0, props);
          else {
            var key = props.src;
            if (props.type === "module") {
              var resources = resumableState.moduleScriptResources;
              var preloads = renderState.preloads.moduleScripts;
            } else
              resources = resumableState.scriptResources, preloads = renderState.preloads.scripts;
            var resourceState$jscomp$0 = resources.hasOwnProperty(key) ? resources[key] : undefined;
            if (resourceState$jscomp$0 !== EXISTS2) {
              resources[key] = EXISTS2;
              var scriptProps = props;
              if (resourceState$jscomp$0) {
                resourceState$jscomp$0.length === 2 && (scriptProps = assign2({}, props), adoptPreloadCredentials2(scriptProps, resourceState$jscomp$0));
                var preloadResource$jscomp$0 = preloads.get(key);
                preloadResource$jscomp$0 && (preloadResource$jscomp$0.length = 0);
              }
              var resource$jscomp$0 = [];
              renderState.scripts.add(resource$jscomp$0);
              pushScriptImpl2(resource$jscomp$0, scriptProps);
            }
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$6 = null;
          }
          return JSCompiler_inline_result$jscomp$6;
        case "style":
          var noscriptTagInScope$jscomp$2 = formatContext.tagScope & 1;
          if (hasOwnProperty2.call(props, "children")) {
            var children$jscomp$7 = props.children, child$jscomp$0 = Array.isArray(children$jscomp$7) ? 2 > children$jscomp$7.length ? children$jscomp$7[0] : null : children$jscomp$7;
            (typeof child$jscomp$0 === "function" || typeof child$jscomp$0 === "symbol" || Array.isArray(child$jscomp$0)) && console.error("React expect children of <style> tags to be a string, number, or object with a `toString` method but found %s instead. In browsers style Elements can only have `Text` Nodes as children.", typeof child$jscomp$0 === "function" ? "a Function" : typeof child$jscomp$0 === "symbol" ? "a Sybmol" : "an Array");
          }
          var { precedence: precedence$jscomp$0, href: href$jscomp$0, nonce } = props;
          if (formatContext.insertionMode === SVG_MODE2 || noscriptTagInScope$jscomp$2 || props.itemProp != null || typeof precedence$jscomp$0 !== "string" || typeof href$jscomp$0 !== "string" || href$jscomp$0 === "") {
            target$jscomp$0.push(startChunkForTag2("style"));
            var children$jscomp$8 = null, innerHTML$jscomp$5 = null, propKey$jscomp$8;
            for (propKey$jscomp$8 in props)
              if (hasOwnProperty2.call(props, propKey$jscomp$8)) {
                var propValue$jscomp$8 = props[propKey$jscomp$8];
                if (propValue$jscomp$8 != null)
                  switch (propKey$jscomp$8) {
                    case "children":
                      children$jscomp$8 = propValue$jscomp$8;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$5 = propValue$jscomp$8;
                      break;
                    default:
                      pushAttribute2(target$jscomp$0, propKey$jscomp$8, propValue$jscomp$8);
                  }
              }
            target$jscomp$0.push(endOfStartTag2);
            var child$jscomp$1 = Array.isArray(children$jscomp$8) ? 2 > children$jscomp$8.length ? children$jscomp$8[0] : null : children$jscomp$8;
            typeof child$jscomp$1 !== "function" && typeof child$jscomp$1 !== "symbol" && child$jscomp$1 !== null && child$jscomp$1 !== undefined && target$jscomp$0.push(escapeStyleTextContent2(child$jscomp$1));
            pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$5, children$jscomp$8);
            target$jscomp$0.push(endChunkForTag2("style"));
            var JSCompiler_inline_result$jscomp$7 = null;
          } else {
            href$jscomp$0.includes(" ") && console.error('React expected the `href` prop for a <style> tag opting into hoisting semantics using the `precedence` prop to not have any spaces but ecountered spaces instead. using spaces in this prop will cause hydration of this style to fail on the client. The href for the <style> where this ocurred is "%s".', href$jscomp$0);
            var styleQueue$jscomp$0 = renderState.styles.get(precedence$jscomp$0), resourceState$jscomp$1 = resumableState.styleResources.hasOwnProperty(href$jscomp$0) ? resumableState.styleResources[href$jscomp$0] : undefined;
            if (resourceState$jscomp$1 !== EXISTS2) {
              resumableState.styleResources[href$jscomp$0] = EXISTS2;
              resourceState$jscomp$1 && console.error('React encountered a hoistable style tag for the same href as a preload: "%s". When using a style tag to inline styles you should not also preload it as a stylsheet.', href$jscomp$0);
              styleQueue$jscomp$0 || (styleQueue$jscomp$0 = {
                precedence: escapeTextForBrowser2(precedence$jscomp$0),
                rules: [],
                hrefs: [],
                sheets: new Map
              }, renderState.styles.set(precedence$jscomp$0, styleQueue$jscomp$0));
              var nonceStyle = renderState.nonce.style;
              if (nonceStyle && nonceStyle !== nonce)
                console.error('React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include rules if the nonce matches the style nonce "%s" that was included with this render.', precedence$jscomp$0, nonce, nonceStyle);
              else {
                !nonceStyle && nonce && console.error('React encountered a style tag with `precedence` "%s" and `nonce` "%s". When React manages style rules using `precedence` it will only include a nonce attributes if you also provide the same style nonce value as a render option.', precedence$jscomp$0, nonce);
                styleQueue$jscomp$0.hrefs.push(escapeTextForBrowser2(href$jscomp$0));
                var target = styleQueue$jscomp$0.rules, children$jscomp$9 = null, innerHTML$jscomp$6 = null, propKey$jscomp$9;
                for (propKey$jscomp$9 in props)
                  if (hasOwnProperty2.call(props, propKey$jscomp$9)) {
                    var propValue$jscomp$9 = props[propKey$jscomp$9];
                    if (propValue$jscomp$9 != null)
                      switch (propKey$jscomp$9) {
                        case "children":
                          children$jscomp$9 = propValue$jscomp$9;
                          break;
                        case "dangerouslySetInnerHTML":
                          innerHTML$jscomp$6 = propValue$jscomp$9;
                      }
                  }
                var child$jscomp$2 = Array.isArray(children$jscomp$9) ? 2 > children$jscomp$9.length ? children$jscomp$9[0] : null : children$jscomp$9;
                typeof child$jscomp$2 !== "function" && typeof child$jscomp$2 !== "symbol" && child$jscomp$2 !== null && child$jscomp$2 !== undefined && target.push(escapeStyleTextContent2(child$jscomp$2));
                pushInnerHTML2(target, innerHTML$jscomp$6, children$jscomp$9);
              }
            }
            styleQueue$jscomp$0 && hoistableState && hoistableState.styles.add(styleQueue$jscomp$0);
            textEmbedded && target$jscomp$0.push("<!-- -->");
            JSCompiler_inline_result$jscomp$7 = undefined;
          }
          return JSCompiler_inline_result$jscomp$7;
        case "meta":
          var noscriptTagInScope$jscomp$3 = formatContext.tagScope & 1, isFallback$jscomp$1 = formatContext.tagScope & 4;
          if (formatContext.insertionMode === SVG_MODE2 || noscriptTagInScope$jscomp$3 || props.itemProp != null)
            var JSCompiler_inline_result$jscomp$8 = pushSelfClosing2(target$jscomp$0, props, "meta");
          else
            textEmbedded && target$jscomp$0.push("<!-- -->"), JSCompiler_inline_result$jscomp$8 = isFallback$jscomp$1 ? null : typeof props.charSet === "string" ? pushSelfClosing2(renderState.charsetChunks, props, "meta") : props.name === "viewport" ? pushSelfClosing2(renderState.viewportChunks, props, "meta") : pushSelfClosing2(renderState.hoistableChunks, props, "meta");
          return JSCompiler_inline_result$jscomp$8;
        case "listing":
        case "pre":
          target$jscomp$0.push(startChunkForTag2(type));
          var children$jscomp$10 = null, innerHTML$jscomp$7 = null, propKey$jscomp$10;
          for (propKey$jscomp$10 in props)
            if (hasOwnProperty2.call(props, propKey$jscomp$10)) {
              var propValue$jscomp$10 = props[propKey$jscomp$10];
              if (propValue$jscomp$10 != null)
                switch (propKey$jscomp$10) {
                  case "children":
                    children$jscomp$10 = propValue$jscomp$10;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML$jscomp$7 = propValue$jscomp$10;
                    break;
                  default:
                    pushAttribute2(target$jscomp$0, propKey$jscomp$10, propValue$jscomp$10);
                }
            }
          target$jscomp$0.push(endOfStartTag2);
          if (innerHTML$jscomp$7 != null) {
            if (children$jscomp$10 != null)
              throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            if (typeof innerHTML$jscomp$7 !== "object" || !("__html" in innerHTML$jscomp$7))
              throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
            var html = innerHTML$jscomp$7.__html;
            html !== null && html !== undefined && (typeof html === "string" && 0 < html.length && html[0] === `
` ? target$jscomp$0.push(leadingNewline, html) : (checkHtmlStringCoercion2(html), target$jscomp$0.push("" + html)));
          }
          typeof children$jscomp$10 === "string" && children$jscomp$10[0] === `
` && target$jscomp$0.push(leadingNewline);
          return children$jscomp$10;
        case "img":
          var pictureOrNoScriptTagInScope = formatContext.tagScope & 3, src = props.src, srcSet = props.srcSet;
          if (!(props.loading === "lazy" || !src && !srcSet || typeof src !== "string" && src != null || typeof srcSet !== "string" && srcSet != null || props.fetchPriority === "low" || pictureOrNoScriptTagInScope) && (typeof src !== "string" || src[4] !== ":" || src[0] !== "d" && src[0] !== "D" || src[1] !== "a" && src[1] !== "A" || src[2] !== "t" && src[2] !== "T" || src[3] !== "a" && src[3] !== "A") && (typeof srcSet !== "string" || srcSet[4] !== ":" || srcSet[0] !== "d" && srcSet[0] !== "D" || srcSet[1] !== "a" && srcSet[1] !== "A" || srcSet[2] !== "t" && srcSet[2] !== "T" || srcSet[3] !== "a" && srcSet[3] !== "A")) {
            hoistableState !== null && formatContext.tagScope & 64 && (hoistableState.suspenseyImages = true);
            var sizes = typeof props.sizes === "string" ? props.sizes : undefined, key$jscomp$0 = srcSet ? srcSet + `
` + (sizes || "") : src, promotablePreloads = renderState.preloads.images, resource$jscomp$1 = promotablePreloads.get(key$jscomp$0);
            if (resource$jscomp$1) {
              if (props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size)
                promotablePreloads.delete(key$jscomp$0), renderState.highImagePreloads.add(resource$jscomp$1);
            } else if (!resumableState.imageResources.hasOwnProperty(key$jscomp$0)) {
              resumableState.imageResources[key$jscomp$0] = PRELOAD_NO_CREDS2;
              var input = props.crossOrigin;
              var crossOrigin = typeof input === "string" ? input === "use-credentials" ? input : "" : undefined;
              var headers = renderState.headers, header;
              headers && 0 < headers.remainingCapacity && typeof props.srcSet !== "string" && (props.fetchPriority === "high" || 500 > headers.highImagePreloads.length) && (header = getPreloadAsHeader2(src, "image", {
                imageSrcSet: props.srcSet,
                imageSizes: props.sizes,
                crossOrigin,
                integrity: props.integrity,
                nonce: props.nonce,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.refererPolicy
              }), 0 <= (headers.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key$jscomp$0] = PRELOAD_NO_CREDS2, headers.highImagePreloads && (headers.highImagePreloads += ", "), headers.highImagePreloads += header) : (resource$jscomp$1 = [], pushLinkImpl2(resource$jscomp$1, {
                rel: "preload",
                as: "image",
                href: srcSet ? undefined : src,
                imageSrcSet: srcSet,
                imageSizes: sizes,
                crossOrigin,
                integrity: props.integrity,
                type: props.type,
                fetchPriority: props.fetchPriority,
                referrerPolicy: props.referrerPolicy
              }), props.fetchPriority === "high" || 10 > renderState.highImagePreloads.size ? renderState.highImagePreloads.add(resource$jscomp$1) : (renderState.bulkPreloads.add(resource$jscomp$1), promotablePreloads.set(key$jscomp$0, resource$jscomp$1)));
            }
          }
          return pushSelfClosing2(target$jscomp$0, props, "img");
        case "base":
        case "area":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "param":
        case "source":
        case "track":
        case "wbr":
          return pushSelfClosing2(target$jscomp$0, props, type);
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          break;
        case "head":
          if (formatContext.insertionMode < HTML_MODE2) {
            var preamble = preambleState || renderState.preamble;
            if (preamble.headChunks)
              throw Error("The `<head>` tag may only be rendered once.");
            preambleState !== null && target$jscomp$0.push("<!--head-->");
            preamble.headChunks = [];
            var JSCompiler_inline_result$jscomp$9 = pushStartSingletonElement2(preamble.headChunks, props, "head");
          } else
            JSCompiler_inline_result$jscomp$9 = pushStartGenericElement2(target$jscomp$0, props, "head");
          return JSCompiler_inline_result$jscomp$9;
        case "body":
          if (formatContext.insertionMode < HTML_MODE2) {
            var preamble$jscomp$0 = preambleState || renderState.preamble;
            if (preamble$jscomp$0.bodyChunks)
              throw Error("The `<body>` tag may only be rendered once.");
            preambleState !== null && target$jscomp$0.push("<!--body-->");
            preamble$jscomp$0.bodyChunks = [];
            var JSCompiler_inline_result$jscomp$10 = pushStartSingletonElement2(preamble$jscomp$0.bodyChunks, props, "body");
          } else
            JSCompiler_inline_result$jscomp$10 = pushStartGenericElement2(target$jscomp$0, props, "body");
          return JSCompiler_inline_result$jscomp$10;
        case "html":
          if (formatContext.insertionMode === ROOT_HTML_MODE2) {
            var preamble$jscomp$1 = preambleState || renderState.preamble;
            if (preamble$jscomp$1.htmlChunks)
              throw Error("The `<html>` tag may only be rendered once.");
            preambleState !== null && target$jscomp$0.push("<!--html-->");
            preamble$jscomp$1.htmlChunks = [doctypeChunk];
            var JSCompiler_inline_result$jscomp$11 = pushStartSingletonElement2(preamble$jscomp$1.htmlChunks, props, "html");
          } else
            JSCompiler_inline_result$jscomp$11 = pushStartGenericElement2(target$jscomp$0, props, "html");
          return JSCompiler_inline_result$jscomp$11;
        default:
          if (type.indexOf("-") !== -1) {
            target$jscomp$0.push(startChunkForTag2(type));
            var children$jscomp$11 = null, innerHTML$jscomp$8 = null, propKey$jscomp$11;
            for (propKey$jscomp$11 in props)
              if (hasOwnProperty2.call(props, propKey$jscomp$11)) {
                var propValue$jscomp$11 = props[propKey$jscomp$11];
                if (propValue$jscomp$11 != null) {
                  var attributeName = propKey$jscomp$11;
                  switch (propKey$jscomp$11) {
                    case "children":
                      children$jscomp$11 = propValue$jscomp$11;
                      break;
                    case "dangerouslySetInnerHTML":
                      innerHTML$jscomp$8 = propValue$jscomp$11;
                      break;
                    case "style":
                      pushStyleAttribute2(target$jscomp$0, propValue$jscomp$11);
                      break;
                    case "suppressContentEditableWarning":
                    case "suppressHydrationWarning":
                    case "ref":
                      break;
                    case "className":
                      attributeName = "class";
                    default:
                      if (isAttributeNameSafe2(propKey$jscomp$11) && typeof propValue$jscomp$11 !== "function" && typeof propValue$jscomp$11 !== "symbol" && propValue$jscomp$11 !== false) {
                        if (propValue$jscomp$11 === true)
                          propValue$jscomp$11 = "";
                        else if (typeof propValue$jscomp$11 === "object")
                          continue;
                        target$jscomp$0.push(attributeSeparator2, attributeName, attributeAssign2, escapeTextForBrowser2(propValue$jscomp$11), attributeEnd2);
                      }
                  }
                }
              }
            target$jscomp$0.push(endOfStartTag2);
            pushInnerHTML2(target$jscomp$0, innerHTML$jscomp$8, children$jscomp$11);
            return children$jscomp$11;
          }
      }
      return pushStartGenericElement2(target$jscomp$0, props, type);
    }
    function endChunkForTag2(tag2) {
      var chunk = endTagCache2.get(tag2);
      chunk === undefined && (chunk = "</" + tag2 + ">", endTagCache2.set(tag2, chunk));
      return chunk;
    }
    function hoistPreambleState2(renderState, preambleState) {
      renderState = renderState.preamble;
      renderState.htmlChunks === null && preambleState.htmlChunks && (renderState.htmlChunks = preambleState.htmlChunks);
      renderState.headChunks === null && preambleState.headChunks && (renderState.headChunks = preambleState.headChunks);
      renderState.bodyChunks === null && preambleState.bodyChunks && (renderState.bodyChunks = preambleState.bodyChunks);
    }
    function writeBootstrap2(destination, renderState) {
      renderState = renderState.bootstrapChunks;
      for (var i2 = 0;i2 < renderState.length - 1; i2++)
        destination.push(renderState[i2]);
      return i2 < renderState.length ? (i2 = renderState[i2], renderState.length = 0, destination.push(i2)) : true;
    }
    function writeStartPendingSuspenseBoundary2(destination, renderState, id) {
      destination.push(startPendingSuspenseBoundary12);
      if (id === null)
        throw Error("An ID must have been assigned before we can complete the boundary.");
      destination.push(renderState.boundaryPrefix);
      renderState = id.toString(16);
      destination.push(renderState);
      return destination.push(startPendingSuspenseBoundary22);
    }
    function writeStartSegment2(destination, renderState, formatContext, id) {
      switch (formatContext.insertionMode) {
        case ROOT_HTML_MODE2:
        case HTML_HTML_MODE2:
        case HTML_HEAD_MODE2:
        case HTML_MODE2:
          return destination.push(startSegmentHTML3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentHTML22);
        case SVG_MODE2:
          return destination.push(startSegmentSVG3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentSVG22);
        case MATHML_MODE2:
          return destination.push(startSegmentMathML3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentMathML22);
        case HTML_TABLE_MODE2:
          return destination.push(startSegmentTable3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTable22);
        case HTML_TABLE_BODY_MODE2:
          return destination.push(startSegmentTableBody3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableBody22);
        case HTML_TABLE_ROW_MODE2:
          return destination.push(startSegmentTableRow3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentTableRow22);
        case HTML_COLGROUP_MODE2:
          return destination.push(startSegmentColGroup3), destination.push(renderState.segmentPrefix), renderState = id.toString(16), destination.push(renderState), destination.push(startSegmentColGroup22);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function writeEndSegment2(destination, formatContext) {
      switch (formatContext.insertionMode) {
        case ROOT_HTML_MODE2:
        case HTML_HTML_MODE2:
        case HTML_HEAD_MODE2:
        case HTML_MODE2:
          return destination.push(endSegmentHTML2);
        case SVG_MODE2:
          return destination.push(endSegmentSVG2);
        case MATHML_MODE2:
          return destination.push(endSegmentMathML2);
        case HTML_TABLE_MODE2:
          return destination.push(endSegmentTable2);
        case HTML_TABLE_BODY_MODE2:
          return destination.push(endSegmentTableBody2);
        case HTML_TABLE_ROW_MODE2:
          return destination.push(endSegmentTableRow2);
        case HTML_COLGROUP_MODE2:
          return destination.push(endSegmentColGroup2);
        default:
          throw Error("Unknown insertion mode. This is a bug in React.");
      }
    }
    function escapeJSStringsForInstructionScripts2(input) {
      return JSON.stringify(input).replace(regexForJSStringsInInstructionScripts2, function(match) {
        switch (match) {
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function escapeJSObjectForInstructionScripts2(input) {
      return JSON.stringify(input).replace(regexForJSStringsInScripts2, function(match) {
        switch (match) {
          case "&":
            return "\\u0026";
          case ">":
            return "\\u003e";
          case "<":
            return "\\u003c";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw Error("escapeJSObjectForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
        }
      });
    }
    function flushStyleTagsLateForBoundary2(styleQueue) {
      var { rules, hrefs } = styleQueue;
      0 < rules.length && hrefs.length === 0 && console.error("React expected to have at least one href for an a hoistable style but found none. This is a bug in React.");
      var i2 = 0;
      if (hrefs.length) {
        this.push(currentlyFlushingRenderState2.startInlineStyle);
        this.push(lateStyleTagResourceOpen12);
        this.push(styleQueue.precedence);
        for (this.push(lateStyleTagResourceOpen22);i2 < hrefs.length - 1; i2++)
          this.push(hrefs[i2]), this.push(spaceSeparator2);
        this.push(hrefs[i2]);
        this.push(lateStyleTagResourceOpen32);
        for (i2 = 0;i2 < rules.length; i2++)
          this.push(rules[i2]);
        destinationHasCapacity2 = this.push(lateStyleTagTemplateClose2);
        currentlyRenderingBoundaryHasStylesToHoist2 = true;
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function hasStylesToHoist2(stylesheet) {
      return stylesheet.state !== PREAMBLE2 ? currentlyRenderingBoundaryHasStylesToHoist2 = true : false;
    }
    function writeHoistablesForBoundary2(destination, hoistableState, renderState) {
      currentlyRenderingBoundaryHasStylesToHoist2 = false;
      destinationHasCapacity2 = true;
      currentlyFlushingRenderState2 = renderState;
      hoistableState.styles.forEach(flushStyleTagsLateForBoundary2, destination);
      currentlyFlushingRenderState2 = null;
      hoistableState.stylesheets.forEach(hasStylesToHoist2);
      currentlyRenderingBoundaryHasStylesToHoist2 && (renderState.stylesToHoist = true);
      return destinationHasCapacity2;
    }
    function flushResource2(resource) {
      for (var i2 = 0;i2 < resource.length; i2++)
        this.push(resource[i2]);
      resource.length = 0;
    }
    function flushStyleInPreamble2(stylesheet) {
      pushLinkImpl2(stylesheetFlushingQueue2, stylesheet.props);
      for (var i2 = 0;i2 < stylesheetFlushingQueue2.length; i2++)
        this.push(stylesheetFlushingQueue2[i2]);
      stylesheetFlushingQueue2.length = 0;
      stylesheet.state = PREAMBLE2;
    }
    function flushStylesInPreamble2(styleQueue) {
      var hasStylesheets = 0 < styleQueue.sheets.size;
      styleQueue.sheets.forEach(flushStyleInPreamble2, this);
      styleQueue.sheets.clear();
      var { rules, hrefs } = styleQueue;
      if (!hasStylesheets || hrefs.length) {
        this.push(currentlyFlushingRenderState2.startInlineStyle);
        this.push(styleTagResourceOpen12);
        this.push(styleQueue.precedence);
        styleQueue = 0;
        if (hrefs.length) {
          for (this.push(styleTagResourceOpen22);styleQueue < hrefs.length - 1; styleQueue++)
            this.push(hrefs[styleQueue]), this.push(spaceSeparator2);
          this.push(hrefs[styleQueue]);
        }
        this.push(styleTagResourceOpen32);
        for (styleQueue = 0;styleQueue < rules.length; styleQueue++)
          this.push(rules[styleQueue]);
        this.push(styleTagResourceClose2);
        rules.length = 0;
        hrefs.length = 0;
      }
    }
    function preloadLateStyle2(stylesheet) {
      if (stylesheet.state === PENDING$12) {
        stylesheet.state = PRELOADED2;
        var props = stylesheet.props;
        pushLinkImpl2(stylesheetFlushingQueue2, {
          rel: "preload",
          as: "style",
          href: stylesheet.props.href,
          crossOrigin: props.crossOrigin,
          fetchPriority: props.fetchPriority,
          integrity: props.integrity,
          media: props.media,
          hrefLang: props.hrefLang,
          referrerPolicy: props.referrerPolicy
        });
        for (stylesheet = 0;stylesheet < stylesheetFlushingQueue2.length; stylesheet++)
          this.push(stylesheetFlushingQueue2[stylesheet]);
        stylesheetFlushingQueue2.length = 0;
      }
    }
    function preloadLateStyles2(styleQueue) {
      styleQueue.sheets.forEach(preloadLateStyle2, this);
      styleQueue.sheets.clear();
    }
    function pushCompletedShellIdAttribute2(target, resumableState) {
      (resumableState.instructions & SentCompletedShellId2) === NothingSent2 && (resumableState.instructions |= SentCompletedShellId2, target.push(completedShellIdAttributeStart2, escapeTextForBrowser2("_" + resumableState.idPrefix + "R_"), attributeEnd2));
    }
    function writeStyleResourceDependenciesInJS2(destination, hoistableState) {
      destination.push(arrayFirstOpenBracket2);
      var nextArrayOpenBrackChunk = arrayFirstOpenBracket2;
      hoistableState.stylesheets.forEach(function(resource) {
        if (resource.state !== PREAMBLE2)
          if (resource.state === LATE2)
            destination.push(nextArrayOpenBrackChunk), resource = resource.props.href, checkAttributeStringCoercion2(resource, "href"), resource = escapeJSObjectForInstructionScripts2("" + resource), destination.push(resource), destination.push(arrayCloseBracket2), nextArrayOpenBrackChunk = arraySubsequentOpenBracket2;
          else {
            destination.push(nextArrayOpenBrackChunk);
            var precedence = resource.props["data-precedence"], props = resource.props, coercedHref = sanitizeURL2("" + resource.props.href);
            coercedHref = escapeJSObjectForInstructionScripts2(coercedHref);
            destination.push(coercedHref);
            checkAttributeStringCoercion2(precedence, "precedence");
            precedence = "" + precedence;
            destination.push(arrayInterstitial2);
            precedence = escapeJSObjectForInstructionScripts2(precedence);
            destination.push(precedence);
            for (var propKey in props)
              if (hasOwnProperty2.call(props, propKey) && (precedence = props[propKey], precedence != null))
                switch (propKey) {
                  case "href":
                  case "rel":
                  case "precedence":
                  case "data-precedence":
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error("link is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    writeStyleResourceAttributeInJS2(destination, propKey, precedence);
                }
            destination.push(arrayCloseBracket2);
            nextArrayOpenBrackChunk = arraySubsequentOpenBracket2;
            resource.state = LATE2;
          }
      });
      destination.push(arrayCloseBracket2);
    }
    function writeStyleResourceAttributeInJS2(destination, name, value) {
      var attributeName = name.toLowerCase();
      switch (typeof value) {
        case "function":
        case "symbol":
          return;
      }
      switch (name) {
        case "innerHTML":
        case "dangerouslySetInnerHTML":
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "style":
        case "ref":
          return;
        case "className":
          attributeName = "class";
          checkAttributeStringCoercion2(value, attributeName);
          name = "" + value;
          break;
        case "hidden":
          if (value === false)
            return;
          name = "";
          break;
        case "src":
        case "href":
          value = sanitizeURL2(value);
          checkAttributeStringCoercion2(value, attributeName);
          name = "" + value;
          break;
        default:
          if (2 < name.length && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N") || !isAttributeNameSafe2(name))
            return;
          checkAttributeStringCoercion2(value, attributeName);
          name = "" + value;
      }
      destination.push(arrayInterstitial2);
      attributeName = escapeJSObjectForInstructionScripts2(attributeName);
      destination.push(attributeName);
      destination.push(arrayInterstitial2);
      attributeName = escapeJSObjectForInstructionScripts2(name);
      destination.push(attributeName);
    }
    function createHoistableState2() {
      return { styles: new Set, stylesheets: new Set, suspenseyImages: false };
    }
    function preloadBootstrapScriptOrModule2(resumableState, renderState, href, props) {
      (resumableState.scriptResources.hasOwnProperty(href) || resumableState.moduleScriptResources.hasOwnProperty(href)) && console.error('Internal React Error: React expected bootstrap script or module with src "%s" to not have been preloaded already. please file an issue', href);
      resumableState.scriptResources[href] = EXISTS2;
      resumableState.moduleScriptResources[href] = EXISTS2;
      resumableState = [];
      pushLinkImpl2(resumableState, props);
      renderState.bootstrapScripts.add(resumableState);
    }
    function adoptPreloadCredentials2(target, preloadState) {
      target.crossOrigin == null && (target.crossOrigin = preloadState[0]);
      target.integrity == null && (target.integrity = preloadState[1]);
    }
    function getPreloadAsHeader2(href, as, params) {
      href = escapeHrefForLinkHeaderURLContext2(href);
      as = escapeStringForLinkHeaderQuotedParamValueContext2(as, "as");
      as = "<" + href + '>; rel=preload; as="' + as + '"';
      for (var paramName in params)
        hasOwnProperty2.call(params, paramName) && (href = params[paramName], typeof href === "string" && (as += "; " + paramName.toLowerCase() + '="' + escapeStringForLinkHeaderQuotedParamValueContext2(href, paramName) + '"'));
      return as;
    }
    function escapeHrefForLinkHeaderURLContext2(hrefInput) {
      checkAttributeStringCoercion2(hrefInput, "href");
      return ("" + hrefInput).replace(regexForHrefInLinkHeaderURLContext2, escapeHrefForLinkHeaderURLContextReplacer2);
    }
    function escapeHrefForLinkHeaderURLContextReplacer2(match) {
      switch (match) {
        case "<":
          return "%3C";
        case ">":
          return "%3E";
        case `
`:
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error("escapeLinkHrefForHeaderContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    }
    function escapeStringForLinkHeaderQuotedParamValueContext2(value, name) {
      willCoercionThrow2(value) && (console.error("The provided `%s` option is an unsupported type %s. This value must be coerced to a string before using it here.", name, typeName2(value)), testStringCoercion2(value));
      return ("" + value).replace(regexForLinkHeaderQuotedParamValueContext2, escapeStringForLinkHeaderQuotedParamValueContextReplacer2);
    }
    function escapeStringForLinkHeaderQuotedParamValueContextReplacer2(match) {
      switch (match) {
        case '"':
          return "%22";
        case "'":
          return "%27";
        case ";":
          return "%3B";
        case ",":
          return "%2C";
        case `
`:
          return "%0A";
        case "\r":
          return "%0D";
        default:
          throw Error("escapeStringForLinkHeaderQuotedParamValueContextReplacer encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    }
    function hoistStyleQueueDependency2(styleQueue) {
      this.styles.add(styleQueue);
    }
    function hoistStylesheetDependency2(stylesheet) {
      this.stylesheets.add(stylesheet);
    }
    function hoistHoistables2(parentState, childState) {
      childState.styles.forEach(hoistStyleQueueDependency2, parentState);
      childState.stylesheets.forEach(hoistStylesheetDependency2, parentState);
      childState.suspenseyImages && (parentState.suspenseyImages = true);
    }
    function createRenderState2(resumableState, generateStaticMarkup) {
      var idPrefix = resumableState.idPrefix, bootstrapChunks = [], bootstrapScriptContent = resumableState.bootstrapScriptContent, bootstrapScripts = resumableState.bootstrapScripts, bootstrapModules = resumableState.bootstrapModules;
      bootstrapScriptContent !== undefined && (bootstrapChunks.push("<script"), pushCompletedShellIdAttribute2(bootstrapChunks, resumableState), bootstrapChunks.push(endOfStartTag2, escapeEntireInlineScriptContent2(bootstrapScriptContent), endInlineScript2));
      idPrefix = {
        placeholderPrefix: idPrefix + "P:",
        segmentPrefix: idPrefix + "S:",
        boundaryPrefix: idPrefix + "B:",
        startInlineScript: "<script",
        startInlineStyle: "<style",
        preamble: { htmlChunks: null, headChunks: null, bodyChunks: null },
        externalRuntimeScript: null,
        bootstrapChunks,
        importMapChunks: [],
        onHeaders: undefined,
        headers: null,
        resets: {
          font: {},
          dns: {},
          connect: { default: {}, anonymous: {}, credentials: {} },
          image: {},
          style: {}
        },
        charsetChunks: [],
        viewportChunks: [],
        hoistableChunks: [],
        preconnects: new Set,
        fontPreloads: new Set,
        highImagePreloads: new Set,
        styles: new Map,
        bootstrapScripts: new Set,
        scripts: new Set,
        bulkPreloads: new Set,
        preloads: {
          images: new Map,
          stylesheets: new Map,
          scripts: new Map,
          moduleScripts: new Map
        },
        nonce: { script: undefined, style: undefined },
        hoistableState: null,
        stylesToHoist: false
      };
      if (bootstrapScripts !== undefined)
        for (bootstrapScriptContent = 0;bootstrapScriptContent < bootstrapScripts.length; bootstrapScriptContent++) {
          var scriptConfig = bootstrapScripts[bootstrapScriptContent], src, crossOrigin = undefined, integrity = undefined, props = {
            rel: "preload",
            as: "script",
            fetchPriority: "low",
            nonce: undefined
          };
          typeof scriptConfig === "string" ? props.href = src = scriptConfig : (props.href = src = scriptConfig.src, props.integrity = integrity = typeof scriptConfig.integrity === "string" ? scriptConfig.integrity : undefined, props.crossOrigin = crossOrigin = typeof scriptConfig === "string" || scriptConfig.crossOrigin == null ? undefined : scriptConfig.crossOrigin === "use-credentials" ? "use-credentials" : "");
          preloadBootstrapScriptOrModule2(resumableState, idPrefix, src, props);
          bootstrapChunks.push('<script src="', escapeTextForBrowser2(src), attributeEnd2);
          typeof integrity === "string" && bootstrapChunks.push(' integrity="', escapeTextForBrowser2(integrity), attributeEnd2);
          typeof crossOrigin === "string" && bootstrapChunks.push(' crossorigin="', escapeTextForBrowser2(crossOrigin), attributeEnd2);
          pushCompletedShellIdAttribute2(bootstrapChunks, resumableState);
          bootstrapChunks.push(' async=""></script>');
        }
      if (bootstrapModules !== undefined)
        for (bootstrapScripts = 0;bootstrapScripts < bootstrapModules.length; bootstrapScripts++)
          bootstrapScriptContent = bootstrapModules[bootstrapScripts], crossOrigin = src = undefined, integrity = {
            rel: "modulepreload",
            fetchPriority: "low",
            nonce: undefined
          }, typeof bootstrapScriptContent === "string" ? integrity.href = scriptConfig = bootstrapScriptContent : (integrity.href = scriptConfig = bootstrapScriptContent.src, integrity.integrity = crossOrigin = typeof bootstrapScriptContent.integrity === "string" ? bootstrapScriptContent.integrity : undefined, integrity.crossOrigin = src = typeof bootstrapScriptContent === "string" || bootstrapScriptContent.crossOrigin == null ? undefined : bootstrapScriptContent.crossOrigin === "use-credentials" ? "use-credentials" : ""), preloadBootstrapScriptOrModule2(resumableState, idPrefix, scriptConfig, integrity), bootstrapChunks.push('<script type="module" src="', escapeTextForBrowser2(scriptConfig), attributeEnd2), typeof crossOrigin === "string" && bootstrapChunks.push(' integrity="', escapeTextForBrowser2(crossOrigin), attributeEnd2), typeof src === "string" && bootstrapChunks.push(' crossorigin="', escapeTextForBrowser2(src), attributeEnd2), pushCompletedShellIdAttribute2(bootstrapChunks, resumableState), bootstrapChunks.push(' async=""></script>');
      return {
        placeholderPrefix: idPrefix.placeholderPrefix,
        segmentPrefix: idPrefix.segmentPrefix,
        boundaryPrefix: idPrefix.boundaryPrefix,
        startInlineScript: idPrefix.startInlineScript,
        startInlineStyle: idPrefix.startInlineStyle,
        preamble: idPrefix.preamble,
        externalRuntimeScript: idPrefix.externalRuntimeScript,
        bootstrapChunks: idPrefix.bootstrapChunks,
        importMapChunks: idPrefix.importMapChunks,
        onHeaders: idPrefix.onHeaders,
        headers: idPrefix.headers,
        resets: idPrefix.resets,
        charsetChunks: idPrefix.charsetChunks,
        viewportChunks: idPrefix.viewportChunks,
        hoistableChunks: idPrefix.hoistableChunks,
        preconnects: idPrefix.preconnects,
        fontPreloads: idPrefix.fontPreloads,
        highImagePreloads: idPrefix.highImagePreloads,
        styles: idPrefix.styles,
        bootstrapScripts: idPrefix.bootstrapScripts,
        scripts: idPrefix.scripts,
        bulkPreloads: idPrefix.bulkPreloads,
        preloads: idPrefix.preloads,
        nonce: idPrefix.nonce,
        stylesToHoist: idPrefix.stylesToHoist,
        generateStaticMarkup
      };
    }
    function pushTextInstance2(target, text2, renderState, textEmbedded) {
      if (renderState.generateStaticMarkup)
        return target.push(escapeTextForBrowser2(text2)), false;
      text2 === "" ? target = textEmbedded : (textEmbedded && target.push("<!-- -->"), target.push(escapeTextForBrowser2(text2)), target = true);
      return target;
    }
    function pushSegmentFinale2(target, renderState, lastPushedText, textEmbedded) {
      renderState.generateStaticMarkup || lastPushedText && textEmbedded && target.push("<!-- -->");
    }
    function getComponentNameFromType2(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE2 ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE2:
          return "Fragment";
        case REACT_PROFILER_TYPE2:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE2:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE2:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE2:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE2:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE2:
            return "Portal";
          case REACT_CONTEXT_TYPE2:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE2:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE2:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE2:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType2(type.type) || "Memo";
          case REACT_LAZY_TYPE2:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType2(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function popToNearestCommonAncestor2(prev, next) {
      if (prev !== next) {
        prev.context._currentValue2 = prev.parentValue;
        prev = prev.parent;
        var parentNext = next.parent;
        if (prev === null) {
          if (parentNext !== null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
        } else {
          if (parentNext === null)
            throw Error("The stacks must reach the root at the same time. This is a bug in React.");
          popToNearestCommonAncestor2(prev, parentNext);
        }
        next.context._currentValue2 = next.value;
      }
    }
    function popAllPrevious2(prev) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      prev !== null && popAllPrevious2(prev);
    }
    function pushAllNext2(next) {
      var parentNext = next.parent;
      parentNext !== null && pushAllNext2(parentNext);
      next.context._currentValue2 = next.value;
    }
    function popPreviousToCommonLevel2(prev, next) {
      prev.context._currentValue2 = prev.parentValue;
      prev = prev.parent;
      if (prev === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      prev.depth === next.depth ? popToNearestCommonAncestor2(prev, next) : popPreviousToCommonLevel2(prev, next);
    }
    function popNextToCommonLevel2(prev, next) {
      var parentNext = next.parent;
      if (parentNext === null)
        throw Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
      prev.depth === parentNext.depth ? popToNearestCommonAncestor2(prev, parentNext) : popNextToCommonLevel2(prev, parentNext);
      next.context._currentValue2 = next.value;
    }
    function switchContext2(newSnapshot) {
      var prev = currentActiveSnapshot2;
      prev !== newSnapshot && (prev === null ? pushAllNext2(newSnapshot) : newSnapshot === null ? popAllPrevious2(prev) : prev.depth === newSnapshot.depth ? popToNearestCommonAncestor2(prev, newSnapshot) : prev.depth > newSnapshot.depth ? popPreviousToCommonLevel2(prev, newSnapshot) : popNextToCommonLevel2(prev, newSnapshot), currentActiveSnapshot2 = newSnapshot);
    }
    function warnOnInvalidCallback2(callback) {
      if (callback !== null && typeof callback !== "function") {
        var key = String(callback);
        didWarnOnInvalidCallback2.has(key) || (didWarnOnInvalidCallback2.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
      }
    }
    function warnNoop2(publicInstance, callerName) {
      publicInstance = (publicInstance = publicInstance.constructor) && getComponentNameFromType2(publicInstance) || "ReactClass";
      var warningKey = publicInstance + "." + callerName;
      didWarnAboutNoopUpdateForComponent2[warningKey] || (console.error(`Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.

Please check the code for the %s component.`, callerName, publicInstance), didWarnAboutNoopUpdateForComponent2[warningKey] = true);
    }
    function pushTreeContext2(baseContext, totalChildren, index) {
      var baseIdWithLeadingBit = baseContext.id;
      baseContext = baseContext.overflow;
      var baseLength = 32 - clz322(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index += 1;
      var length = 32 - clz322(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        return {
          id: 1 << 32 - clz322(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit,
          overflow: length + baseContext
        };
      }
      return {
        id: 1 << length | index << baseLength | baseIdWithLeadingBit,
        overflow: baseContext
      };
    }
    function clz32Fallback2(x2) {
      x2 >>>= 0;
      return x2 === 0 ? 32 : 31 - (log2(x2) / LN22 | 0) | 0;
    }
    function noop4() {}
    function trackUsedThenable2(thenableState3, thenable, index) {
      index = thenableState3[index];
      index === undefined ? thenableState3.push(thenable) : index !== thenable && (thenable.then(noop4, noop4), thenable = index);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          typeof thenable.status === "string" ? thenable.then(noop4, noop4) : (thenableState3 = thenable, thenableState3.status = "pending", thenableState3.then(function(fulfilledValue) {
            if (thenable.status === "pending") {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          }, function(error40) {
            if (thenable.status === "pending") {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error40;
            }
          }));
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
          suspendedThenable2 = thenable;
          throw SuspenseException2;
      }
    }
    function getSuspendedThenable2() {
      if (suspendedThenable2 === null)
        throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
      var thenable = suspendedThenable2;
      suspendedThenable2 = null;
      return thenable;
    }
    function is3(x2, y) {
      return x2 === y && (x2 !== 0 || 1 / x2 === 1 / y) || x2 !== x2 && y !== y;
    }
    function resolveCurrentlyRenderingComponent2() {
      if (currentlyRenderingComponent2 === null)
        throw Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.`);
      isInHookUserCodeInDev2 && console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
      return currentlyRenderingComponent2;
    }
    function createHook2() {
      if (0 < numberOfReRenders2)
        throw Error("Rendered more hooks than during the previous render");
      return { memoizedState: null, queue: null, next: null };
    }
    function createWorkInProgressHook2() {
      workInProgressHook2 === null ? firstWorkInProgressHook2 === null ? (isReRender2 = false, firstWorkInProgressHook2 = workInProgressHook2 = createHook2()) : (isReRender2 = true, workInProgressHook2 = firstWorkInProgressHook2) : workInProgressHook2.next === null ? (isReRender2 = false, workInProgressHook2 = workInProgressHook2.next = createHook2()) : (isReRender2 = true, workInProgressHook2 = workInProgressHook2.next);
      return workInProgressHook2;
    }
    function getThenableStateAfterSuspending2() {
      var state = thenableState2;
      thenableState2 = null;
      return state;
    }
    function resetHooksState2() {
      isInHookUserCodeInDev2 = false;
      currentlyRenderingKeyPath2 = currentlyRenderingRequest2 = currentlyRenderingTask2 = currentlyRenderingComponent2 = null;
      didScheduleRenderPhaseUpdate2 = false;
      firstWorkInProgressHook2 = null;
      numberOfReRenders2 = 0;
      workInProgressHook2 = renderPhaseUpdates2 = null;
    }
    function readContext2(context) {
      isInHookUserCodeInDev2 && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      return context._currentValue2;
    }
    function basicStateReducer2(state, action) {
      return typeof action === "function" ? action(state) : action;
    }
    function useReducer2(reducer, initialArg, init) {
      reducer !== basicStateReducer2 && (currentHookNameInDev2 = "useReducer");
      currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
      workInProgressHook2 = createWorkInProgressHook2();
      if (isReRender2) {
        init = workInProgressHook2.queue;
        initialArg = init.dispatch;
        if (renderPhaseUpdates2 !== null) {
          var firstRenderPhaseUpdate = renderPhaseUpdates2.get(init);
          if (firstRenderPhaseUpdate !== undefined) {
            renderPhaseUpdates2.delete(init);
            init = workInProgressHook2.memoizedState;
            do {
              var action = firstRenderPhaseUpdate.action;
              isInHookUserCodeInDev2 = true;
              init = reducer(init, action);
              isInHookUserCodeInDev2 = false;
              firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
            } while (firstRenderPhaseUpdate !== null);
            workInProgressHook2.memoizedState = init;
            return [init, initialArg];
          }
        }
        return [workInProgressHook2.memoizedState, initialArg];
      }
      isInHookUserCodeInDev2 = true;
      reducer = reducer === basicStateReducer2 ? typeof initialArg === "function" ? initialArg() : initialArg : init !== undefined ? init(initialArg) : initialArg;
      isInHookUserCodeInDev2 = false;
      workInProgressHook2.memoizedState = reducer;
      reducer = workInProgressHook2.queue = { last: null, dispatch: null };
      reducer = reducer.dispatch = dispatchAction2.bind(null, currentlyRenderingComponent2, reducer);
      return [workInProgressHook2.memoizedState, reducer];
    }
    function useMemo2(nextCreate, deps) {
      currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
      workInProgressHook2 = createWorkInProgressHook2();
      deps = deps === undefined ? null : deps;
      if (workInProgressHook2 !== null) {
        var prevState = workInProgressHook2.memoizedState;
        if (prevState !== null && deps !== null) {
          a: {
            var JSCompiler_inline_result = prevState[1];
            if (JSCompiler_inline_result === null)
              console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev2), JSCompiler_inline_result = false;
            else {
              deps.length !== JSCompiler_inline_result.length && console.error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev2, "[" + deps.join(", ") + "]", "[" + JSCompiler_inline_result.join(", ") + "]");
              for (var i2 = 0;i2 < JSCompiler_inline_result.length && i2 < deps.length; i2++)
                if (!objectIs2(deps[i2], JSCompiler_inline_result[i2])) {
                  JSCompiler_inline_result = false;
                  break a;
                }
              JSCompiler_inline_result = true;
            }
          }
          if (JSCompiler_inline_result)
            return prevState[0];
        }
      }
      isInHookUserCodeInDev2 = true;
      nextCreate = nextCreate();
      isInHookUserCodeInDev2 = false;
      workInProgressHook2.memoizedState = [nextCreate, deps];
      return nextCreate;
    }
    function dispatchAction2(componentIdentity, queue, action) {
      if (25 <= numberOfReRenders2)
        throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      if (componentIdentity === currentlyRenderingComponent2)
        if (didScheduleRenderPhaseUpdate2 = true, componentIdentity = { action, next: null }, renderPhaseUpdates2 === null && (renderPhaseUpdates2 = new Map), action = renderPhaseUpdates2.get(queue), action === undefined)
          renderPhaseUpdates2.set(queue, componentIdentity);
        else {
          for (queue = action;queue.next !== null; )
            queue = queue.next;
          queue.next = componentIdentity;
        }
    }
    function throwOnUseEffectEventCall2() {
      throw Error("A function wrapped in useEffectEvent can't be called during rendering.");
    }
    function unsupportedStartTransition2() {
      throw Error("startTransition cannot be called during server rendering.");
    }
    function unsupportedSetOptimisticState2() {
      throw Error("Cannot update optimistic state while rendering.");
    }
    function useActionState2(action, initialState, permalink) {
      resolveCurrentlyRenderingComponent2();
      var actionStateHookIndex = actionStateCounter2++, request = currentlyRenderingRequest2;
      if (typeof action.$$FORM_ACTION === "function") {
        var nextPostbackStateKey = null, componentKeyPath = currentlyRenderingKeyPath2;
        request = request.formState;
        var isSignatureEqual = action.$$IS_SIGNATURE_EQUAL;
        if (request !== null && typeof isSignatureEqual === "function") {
          var postbackKey = request[1];
          isSignatureEqual.call(action, request[2], request[3]) && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]), 0), postbackKey === nextPostbackStateKey && (actionStateMatchingIndex2 = actionStateHookIndex, initialState = request[0]));
        }
        var boundAction = action.bind(null, initialState);
        action = function(payload) {
          boundAction(payload);
        };
        typeof boundAction.$$FORM_ACTION === "function" && (action.$$FORM_ACTION = function(prefix3) {
          prefix3 = boundAction.$$FORM_ACTION(prefix3);
          permalink !== undefined && (checkAttributeStringCoercion2(permalink, "target"), permalink += "", prefix3.action = permalink);
          var formData = prefix3.data;
          formData && (nextPostbackStateKey === null && (nextPostbackStateKey = permalink !== undefined ? "p" + permalink : "k" + murmurhash3_32_gc(JSON.stringify([
            componentKeyPath,
            null,
            actionStateHookIndex
          ]), 0)), formData.append("$ACTION_KEY", nextPostbackStateKey));
          return prefix3;
        });
        return [initialState, action, false];
      }
      var _boundAction = action.bind(null, initialState);
      return [
        initialState,
        function(payload) {
          _boundAction(payload);
        },
        false
      ];
    }
    function unwrapThenable2(thenable) {
      var index = thenableIndexCounter2;
      thenableIndexCounter2 += 1;
      thenableState2 === null && (thenableState2 = []);
      return trackUsedThenable2(thenableState2, thenable, index);
    }
    function unsupportedRefresh2() {
      throw Error("Cache cannot be refreshed during server rendering.");
    }
    function disabledLog2() {}
    function disableLogs2() {
      if (disabledDepth2 === 0) {
        prevLog2 = console.log;
        prevInfo2 = console.info;
        prevWarn2 = console.warn;
        prevError2 = console.error;
        prevGroup2 = console.group;
        prevGroupCollapsed2 = console.groupCollapsed;
        prevGroupEnd2 = console.groupEnd;
        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog2,
          writable: true
        };
        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
      }
      disabledDepth2++;
    }
    function reenableLogs2() {
      disabledDepth2--;
      if (disabledDepth2 === 0) {
        var props = { configurable: true, enumerable: true, writable: true };
        Object.defineProperties(console, {
          log: assign2({}, props, { value: prevLog2 }),
          info: assign2({}, props, { value: prevInfo2 }),
          warn: assign2({}, props, { value: prevWarn2 }),
          error: assign2({}, props, { value: prevError2 }),
          group: assign2({}, props, { value: prevGroup2 }),
          groupCollapsed: assign2({}, props, { value: prevGroupCollapsed2 }),
          groupEnd: assign2({}, props, { value: prevGroupEnd2 })
        });
      }
      0 > disabledDepth2 && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
    }
    function formatOwnerStack2(error40) {
      var prevPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      error40 = error40.stack;
      Error.prepareStackTrace = prevPrepareStackTrace;
      error40.startsWith(`Error: react-stack-top-frame
`) && (error40 = error40.slice(29));
      prevPrepareStackTrace = error40.indexOf(`
`);
      prevPrepareStackTrace !== -1 && (error40 = error40.slice(prevPrepareStackTrace + 1));
      prevPrepareStackTrace = error40.indexOf("react_stack_bottom_frame");
      prevPrepareStackTrace !== -1 && (prevPrepareStackTrace = error40.lastIndexOf(`
`, prevPrepareStackTrace));
      if (prevPrepareStackTrace !== -1)
        error40 = error40.slice(0, prevPrepareStackTrace);
      else
        return "";
      return error40;
    }
    function describeBuiltInComponentFrame2(name) {
      if (prefix2 === undefined)
        try {
          throw Error();
        } catch (x2) {
          var match = x2.stack.trim().match(/\n( *(at )?)/);
          prefix2 = match && match[1] || "";
          suffix2 = -1 < x2.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < x2.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + prefix2 + name + suffix2;
    }
    function describeNativeComponentFrame2(fn, construct2) {
      if (!fn || reentry2)
        return "";
      var frame = componentFrameCache2.get(fn);
      if (frame !== undefined)
        return frame;
      reentry2 = true;
      frame = Error.prepareStackTrace;
      Error.prepareStackTrace = undefined;
      var previousDispatcher3 = null;
      previousDispatcher3 = ReactSharedInternals2.H;
      ReactSharedInternals2.H = null;
      disableLogs2();
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct2) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    var control = x2;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$0) {
                    control = x$0;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$1) {
                  control = x$1;
                }
                (Fake = fn()) && typeof Fake.catch === "function" && Fake.catch(function() {});
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string")
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" });
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split(`
`), controlLines = controlStack.split(`
`);
          for (_RunInRootFrame$Deter = namePropDescriptor = 0;namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot"); )
            namePropDescriptor++;
          for (;_RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot"); )
            _RunInRootFrame$Deter++;
          if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
            for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
              _RunInRootFrame$Deter--;
          for (;1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
            if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              if (namePropDescriptor !== 1 || _RunInRootFrame$Deter !== 1) {
                do
                  if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                    var _frame = `
` + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                    fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                    typeof fn === "function" && componentFrameCache2.set(fn, _frame);
                    return _frame;
                  }
                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
              }
              break;
            }
        }
      } finally {
        reentry2 = false, ReactSharedInternals2.H = previousDispatcher3, reenableLogs2(), Error.prepareStackTrace = frame;
      }
      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame2(sampleLines) : "";
      typeof fn === "function" && componentFrameCache2.set(fn, sampleLines);
      return sampleLines;
    }
    function describeComponentStackByType2(type) {
      if (typeof type === "string")
        return describeBuiltInComponentFrame2(type);
      if (typeof type === "function")
        return type.prototype && type.prototype.isReactComponent ? describeNativeComponentFrame2(type, true) : describeNativeComponentFrame2(type, false);
      if (typeof type === "object" && type !== null) {
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE2:
            return describeNativeComponentFrame2(type.render, false);
          case REACT_MEMO_TYPE2:
            return describeNativeComponentFrame2(type.type, false);
          case REACT_LAZY_TYPE2:
            var lazyComponent = type, payload = lazyComponent._payload;
            lazyComponent = lazyComponent._init;
            try {
              type = lazyComponent(payload);
            } catch (x2) {
              return describeBuiltInComponentFrame2("Lazy");
            }
            return describeComponentStackByType2(type);
        }
        if (typeof type.name === "string") {
          a: {
            payload = type.name;
            lazyComponent = type.env;
            type = type.debugLocation;
            if (type != null) {
              type = formatOwnerStack2(type);
              var idx = type.lastIndexOf(`
`);
              type = idx === -1 ? type : type.slice(idx + 1);
              if (type.indexOf(payload) !== -1) {
                payload = `
` + type;
                break a;
              }
            }
            payload = describeBuiltInComponentFrame2(payload + (lazyComponent ? " [" + lazyComponent + "]" : ""));
          }
          return payload;
        }
      }
      switch (type) {
        case REACT_SUSPENSE_LIST_TYPE2:
          return describeBuiltInComponentFrame2("SuspenseList");
        case REACT_SUSPENSE_TYPE2:
          return describeBuiltInComponentFrame2("Suspense");
      }
      return "";
    }
    function isEligibleForOutlining2(request, boundary) {
      return (500 < boundary.byteSize || false) && boundary.contentPreamble === null;
    }
    function defaultErrorHandler2(error40) {
      if (typeof error40 === "object" && error40 !== null && typeof error40.environmentName === "string") {
        var JSCompiler_inline_result = error40.environmentName;
        error40 = [error40].slice(0);
        typeof error40[0] === "string" ? error40.splice(0, 1, "[%s] " + error40[0], " " + JSCompiler_inline_result + " ") : error40.splice(0, 0, "[%s]", " " + JSCompiler_inline_result + " ");
        error40.unshift(console);
        JSCompiler_inline_result = bind2.apply(console.error, error40);
        JSCompiler_inline_result();
      } else
        console.error(error40);
      return null;
    }
    function RequestInstance2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var abortSet = new Set;
      this.destination = null;
      this.flushScheduled = false;
      this.resumableState = resumableState;
      this.renderState = renderState;
      this.rootFormatContext = rootFormatContext;
      this.progressiveChunkSize = progressiveChunkSize === undefined ? 12800 : progressiveChunkSize;
      this.status = 10;
      this.fatalError = null;
      this.pendingRootTasks = this.allPendingTasks = this.nextSegmentId = 0;
      this.completedPreambleSegments = this.completedRootSegment = null;
      this.byteSize = 0;
      this.abortableTasks = abortSet;
      this.pingedTasks = [];
      this.clientRenderedBoundaries = [];
      this.completedBoundaries = [];
      this.partialBoundaries = [];
      this.trackedPostpones = null;
      this.onError = onError2 === undefined ? defaultErrorHandler2 : onError2;
      this.onPostpone = onPostpone === undefined ? noop4 : onPostpone;
      this.onAllReady = onAllReady === undefined ? noop4 : onAllReady;
      this.onShellReady = onShellReady === undefined ? noop4 : onShellReady;
      this.onShellError = onShellError === undefined ? noop4 : onShellError;
      this.onFatalError = onFatalError === undefined ? noop4 : onFatalError;
      this.formState = formState === undefined ? null : formState;
      this.didWarnForKey = null;
    }
    function createRequest2(children, resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState) {
      var now = getCurrentTime2();
      1000 < now - lastResetTime2 && (ReactSharedInternals2.recentlyCreatedOwnerStacks = 0, lastResetTime2 = now);
      resumableState = new RequestInstance2(resumableState, renderState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError, onPostpone, formState);
      renderState = createPendingSegment2(resumableState, 0, null, rootFormatContext, false, false);
      renderState.parentFlushed = true;
      children = createRenderTask2(resumableState, null, children, -1, null, renderState, null, null, resumableState.abortableTasks, null, rootFormatContext, null, emptyTreeContext2, null, null, emptyContextObject2, null);
      pushComponentStack2(children);
      resumableState.pingedTasks.push(children);
      return resumableState;
    }
    function pingTask2(request, task) {
      request.pingedTasks.push(task);
      request.pingedTasks.length === 1 && (request.flushScheduled = request.destination !== null, performWork2(request));
    }
    function createSuspenseBoundary2(request, row, fallbackAbortableTasks, contentPreamble, fallbackPreamble) {
      fallbackAbortableTasks = {
        status: PENDING2,
        rootSegmentID: -1,
        parentFlushed: false,
        pendingTasks: 0,
        row,
        completedSegments: [],
        byteSize: 0,
        fallbackAbortableTasks,
        errorDigest: null,
        contentState: createHoistableState2(),
        fallbackState: createHoistableState2(),
        contentPreamble,
        fallbackPreamble,
        trackedContentKeyPath: null,
        trackedFallbackNode: null,
        errorMessage: null,
        errorStack: null,
        errorComponentStack: null
      };
      row !== null && (row.pendingTasks++, contentPreamble = row.boundaries, contentPreamble !== null && (request.allPendingTasks++, fallbackAbortableTasks.pendingTasks++, contentPreamble.push(fallbackAbortableTasks)), request = row.inheritedHoistables, request !== null && hoistHoistables2(fallbackAbortableTasks.contentState, request));
      return fallbackAbortableTasks;
    }
    function createRenderTask2(request, thenableState3, node, childIndex, blockedBoundary, blockedSegment, blockedPreamble, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
      request.allPendingTasks++;
      blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      row !== null && row.pendingTasks++;
      var task = {
        replay: null,
        node,
        childIndex,
        ping: function() {
          return pingTask2(request, task);
        },
        blockedBoundary,
        blockedSegment,
        blockedPreamble,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        row,
        componentStack,
        thenableState: thenableState3
      };
      task.debugTask = debugTask;
      abortSet.add(task);
      return task;
    }
    function createReplayTask2(request, thenableState3, replay, node, childIndex, blockedBoundary, hoistableState, abortSet, keyPath, formatContext, context, treeContext, row, componentStack, legacyContext, debugTask) {
      request.allPendingTasks++;
      blockedBoundary === null ? request.pendingRootTasks++ : blockedBoundary.pendingTasks++;
      row !== null && row.pendingTasks++;
      replay.pendingTasks++;
      var task = {
        replay,
        node,
        childIndex,
        ping: function() {
          return pingTask2(request, task);
        },
        blockedBoundary,
        blockedSegment: null,
        blockedPreamble: null,
        hoistableState,
        abortSet,
        keyPath,
        formatContext,
        context,
        treeContext,
        row,
        componentStack,
        thenableState: thenableState3
      };
      task.debugTask = debugTask;
      abortSet.add(task);
      return task;
    }
    function createPendingSegment2(request, index, boundary, parentFormatContext, lastPushedText, textEmbedded) {
      return {
        status: PENDING2,
        parentFlushed: false,
        id: -1,
        index,
        chunks: [],
        children: [],
        preambleChildren: [],
        parentFormatContext,
        boundary,
        lastPushedText,
        textEmbedded
      };
    }
    function getCurrentStackInDEV2() {
      if (currentTaskInDEV2 === null || currentTaskInDEV2.componentStack === null)
        return "";
      var componentStack = currentTaskInDEV2.componentStack;
      try {
        var info = "";
        if (typeof componentStack.type === "string")
          info += describeBuiltInComponentFrame2(componentStack.type);
        else if (typeof componentStack.type === "function") {
          if (!componentStack.owner) {
            var JSCompiler_temp_const = info, fn = componentStack.type, name = fn ? fn.displayName || fn.name : "";
            var JSCompiler_inline_result = name ? describeBuiltInComponentFrame2(name) : "";
            info = JSCompiler_temp_const + JSCompiler_inline_result;
          }
        } else
          componentStack.owner || (info += describeComponentStackByType2(componentStack.type));
        for (;componentStack; )
          JSCompiler_temp_const = null, componentStack.debugStack != null ? JSCompiler_temp_const = formatOwnerStack2(componentStack.debugStack) : (JSCompiler_inline_result = componentStack, JSCompiler_inline_result.stack != null && (JSCompiler_temp_const = typeof JSCompiler_inline_result.stack !== "string" ? JSCompiler_inline_result.stack = formatOwnerStack2(JSCompiler_inline_result.stack) : JSCompiler_inline_result.stack)), (componentStack = componentStack.owner) && JSCompiler_temp_const && (info += `
` + JSCompiler_temp_const);
        var JSCompiler_inline_result$jscomp$0 = info;
      } catch (x2) {
        JSCompiler_inline_result$jscomp$0 = `
Error generating stack: ` + x2.message + `
` + x2.stack;
      }
      return JSCompiler_inline_result$jscomp$0;
    }
    function pushHaltedAwaitOnComponentStack2(task, debugInfo) {
      if (debugInfo != null)
        for (var i2 = debugInfo.length - 1;0 <= i2; i2--) {
          var info = debugInfo[i2];
          if (typeof info.name === "string")
            break;
          if (typeof info.time === "number")
            break;
          if (info.awaited != null) {
            var bestStack = info.debugStack == null ? info.awaited : info;
            if (bestStack.debugStack !== undefined) {
              task.componentStack = {
                parent: task.componentStack,
                type: info,
                owner: bestStack.owner,
                stack: bestStack.debugStack
              };
              task.debugTask = bestStack.debugTask;
              break;
            }
          }
        }
    }
    function pushServerComponentStack2(task, debugInfo) {
      if (debugInfo != null)
        for (var i2 = 0;i2 < debugInfo.length; i2++) {
          var componentInfo = debugInfo[i2];
          typeof componentInfo.name === "string" && componentInfo.debugStack !== undefined && (task.componentStack = {
            parent: task.componentStack,
            type: componentInfo,
            owner: componentInfo.owner,
            stack: componentInfo.debugStack
          }, task.debugTask = componentInfo.debugTask);
        }
    }
    function pushComponentStack2(task) {
      var node = task.node;
      if (typeof node === "object" && node !== null)
        switch (node.$$typeof) {
          case REACT_ELEMENT_TYPE2:
            var { type, _owner: owner, _debugStack: stack } = node;
            pushServerComponentStack2(task, node._debugInfo);
            task.debugTask = node._debugTask;
            task.componentStack = {
              parent: task.componentStack,
              type,
              owner,
              stack
            };
            break;
          case REACT_LAZY_TYPE2:
            pushServerComponentStack2(task, node._debugInfo);
            break;
          default:
            typeof node.then === "function" && pushServerComponentStack2(task, node._debugInfo);
        }
    }
    function replaceSuspenseComponentStackWithSuspenseFallbackStack2(componentStack) {
      return componentStack === null ? null : {
        parent: componentStack.parent,
        type: "Suspense Fallback",
        owner: componentStack.owner,
        stack: componentStack.stack
      };
    }
    function getThrownInfo2(node$jscomp$0) {
      var errorInfo = {};
      node$jscomp$0 && Object.defineProperty(errorInfo, "componentStack", {
        configurable: true,
        enumerable: true,
        get: function() {
          try {
            var info = "", node = node$jscomp$0;
            do
              info += describeComponentStackByType2(node.type), node = node.parent;
            while (node);
            var stack = info;
          } catch (x2) {
            stack = `
Error generating stack: ` + x2.message + `
` + x2.stack;
          }
          Object.defineProperty(errorInfo, "componentStack", {
            value: stack
          });
          return stack;
        }
      });
      return errorInfo;
    }
    function encodeErrorForBoundary2(boundary, digest, error40, thrownInfo, wasAborted) {
      boundary.errorDigest = digest;
      error40 instanceof Error ? (digest = String(error40.message), error40 = String(error40.stack)) : (digest = typeof error40 === "object" && error40 !== null ? describeObjectForErrorMessage2(error40) : String(error40), error40 = null);
      wasAborted = wasAborted ? `Switched to client rendering because the server rendering aborted due to:

` : `Switched to client rendering because the server rendering errored:

`;
      boundary.errorMessage = wasAborted + digest;
      boundary.errorStack = error40 !== null ? wasAborted + error40 : null;
      boundary.errorComponentStack = thrownInfo.componentStack;
    }
    function logRecoverableError2(request, error40, errorInfo, debugTask) {
      request = request.onError;
      error40 = debugTask ? debugTask.run(request.bind(null, error40, errorInfo)) : request(error40, errorInfo);
      if (error40 != null && typeof error40 !== "string")
        console.error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "%s" instead', typeof error40);
      else
        return error40;
    }
    function fatalError2(request, error40, errorInfo, debugTask) {
      errorInfo = request.onShellError;
      var onFatalError = request.onFatalError;
      debugTask ? (debugTask.run(errorInfo.bind(null, error40)), debugTask.run(onFatalError.bind(null, error40))) : (errorInfo(error40), onFatalError(error40));
      request.destination !== null ? (request.status = CLOSED2, request.destination.destroy(error40)) : (request.status = 13, request.fatalError = error40);
    }
    function finishSuspenseListRow2(request, row) {
      unblockSuspenseListRow2(request, row.next, row.hoistables);
    }
    function unblockSuspenseListRow2(request, unblockedRow, inheritedHoistables) {
      for (;unblockedRow !== null; ) {
        inheritedHoistables !== null && (hoistHoistables2(unblockedRow.hoistables, inheritedHoistables), unblockedRow.inheritedHoistables = inheritedHoistables);
        var unblockedBoundaries = unblockedRow.boundaries;
        if (unblockedBoundaries !== null) {
          unblockedRow.boundaries = null;
          for (var i2 = 0;i2 < unblockedBoundaries.length; i2++) {
            var unblockedBoundary = unblockedBoundaries[i2];
            inheritedHoistables !== null && hoistHoistables2(unblockedBoundary.contentState, inheritedHoistables);
            finishedTask2(request, unblockedBoundary, null, null);
          }
        }
        unblockedRow.pendingTasks--;
        if (0 < unblockedRow.pendingTasks)
          break;
        inheritedHoistables = unblockedRow.hoistables;
        unblockedRow = unblockedRow.next;
      }
    }
    function tryToResolveTogetherRow2(request, togetherRow) {
      var boundaries = togetherRow.boundaries;
      if (boundaries !== null && togetherRow.pendingTasks === boundaries.length) {
        for (var allCompleteAndInlinable = true, i2 = 0;i2 < boundaries.length; i2++) {
          var rowBoundary = boundaries[i2];
          if (rowBoundary.pendingTasks !== 1 || rowBoundary.parentFlushed || isEligibleForOutlining2(request, rowBoundary)) {
            allCompleteAndInlinable = false;
            break;
          }
        }
        allCompleteAndInlinable && unblockSuspenseListRow2(request, togetherRow, togetherRow.hoistables);
      }
    }
    function createSuspenseListRow2(previousRow) {
      var newRow = {
        pendingTasks: 1,
        boundaries: null,
        hoistables: createHoistableState2(),
        inheritedHoistables: null,
        together: false,
        next: null
      };
      previousRow !== null && 0 < previousRow.pendingTasks && (newRow.pendingTasks++, newRow.boundaries = [], previousRow.next = newRow);
      return newRow;
    }
    function renderSuspenseListRows2(request, task, keyPath, rows, revealOrder) {
      var { keyPath: prevKeyPath, treeContext: prevTreeContext, row: prevRow, componentStack: previousComponentStack } = task;
      var previousDebugTask = task.debugTask;
      pushServerComponentStack2(task, task.node.props.children._debugInfo);
      task.keyPath = keyPath;
      keyPath = rows.length;
      var previousSuspenseListRow = null;
      if (task.replay !== null) {
        var resumeSlots = task.replay.slots;
        if (resumeSlots !== null && typeof resumeSlots === "object")
          for (var n = 0;n < keyPath; n++) {
            var i2 = revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" ? n : keyPath - 1 - n, node = rows[i2];
            task.row = previousSuspenseListRow = createSuspenseListRow2(previousSuspenseListRow);
            task.treeContext = pushTreeContext2(prevTreeContext, keyPath, i2);
            var resumeSegmentID = resumeSlots[i2];
            typeof resumeSegmentID === "number" ? (resumeNode2(request, task, resumeSegmentID, node, i2), delete resumeSlots[i2]) : renderNode2(request, task, node, i2);
            --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow2(request, previousSuspenseListRow);
          }
        else
          for (resumeSlots = 0;resumeSlots < keyPath; resumeSlots++)
            n = revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards" ? resumeSlots : keyPath - 1 - resumeSlots, i2 = rows[n], warnForMissingKey2(request, task, i2), task.row = previousSuspenseListRow = createSuspenseListRow2(previousSuspenseListRow), task.treeContext = pushTreeContext2(prevTreeContext, keyPath, n), renderNode2(request, task, i2, n), --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow2(request, previousSuspenseListRow);
      } else if (revealOrder !== "backwards" && revealOrder !== "unstable_legacy-backwards")
        for (revealOrder = 0;revealOrder < keyPath; revealOrder++)
          resumeSlots = rows[revealOrder], warnForMissingKey2(request, task, resumeSlots), task.row = previousSuspenseListRow = createSuspenseListRow2(previousSuspenseListRow), task.treeContext = pushTreeContext2(prevTreeContext, keyPath, revealOrder), renderNode2(request, task, resumeSlots, revealOrder), --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow2(request, previousSuspenseListRow);
      else {
        revealOrder = task.blockedSegment;
        resumeSlots = revealOrder.children.length;
        n = revealOrder.chunks.length;
        for (i2 = keyPath - 1;0 <= i2; i2--) {
          node = rows[i2];
          task.row = previousSuspenseListRow = createSuspenseListRow2(previousSuspenseListRow);
          task.treeContext = pushTreeContext2(prevTreeContext, keyPath, i2);
          resumeSegmentID = createPendingSegment2(request, n, null, task.formatContext, i2 === 0 ? revealOrder.lastPushedText : true, true);
          revealOrder.children.splice(resumeSlots, 0, resumeSegmentID);
          task.blockedSegment = resumeSegmentID;
          warnForMissingKey2(request, task, node);
          try {
            renderNode2(request, task, node, i2), pushSegmentFinale2(resumeSegmentID.chunks, request.renderState, resumeSegmentID.lastPushedText, resumeSegmentID.textEmbedded), resumeSegmentID.status = COMPLETED2, --previousSuspenseListRow.pendingTasks === 0 && finishSuspenseListRow2(request, previousSuspenseListRow);
          } catch (thrownValue) {
            throw resumeSegmentID.status = request.status === 12 ? ABORTED2 : ERRORED2, thrownValue;
          }
        }
        task.blockedSegment = revealOrder;
        revealOrder.lastPushedText = false;
      }
      prevRow !== null && previousSuspenseListRow !== null && 0 < previousSuspenseListRow.pendingTasks && (prevRow.pendingTasks++, previousSuspenseListRow.next = prevRow);
      task.treeContext = prevTreeContext;
      task.row = prevRow;
      task.keyPath = prevKeyPath;
      task.componentStack = previousComponentStack;
      task.debugTask = previousDebugTask;
    }
    function renderWithHooks2(request, task, keyPath, Component, props, secondArg) {
      var prevThenableState = task.thenableState;
      task.thenableState = null;
      currentlyRenderingComponent2 = {};
      currentlyRenderingTask2 = task;
      currentlyRenderingRequest2 = request;
      currentlyRenderingKeyPath2 = keyPath;
      isInHookUserCodeInDev2 = false;
      actionStateCounter2 = localIdCounter2 = 0;
      actionStateMatchingIndex2 = -1;
      thenableIndexCounter2 = 0;
      thenableState2 = prevThenableState;
      for (request = callComponentInDEV2(Component, props, secondArg);didScheduleRenderPhaseUpdate2; )
        didScheduleRenderPhaseUpdate2 = false, actionStateCounter2 = localIdCounter2 = 0, actionStateMatchingIndex2 = -1, thenableIndexCounter2 = 0, numberOfReRenders2 += 1, workInProgressHook2 = null, request = Component(props, secondArg);
      resetHooksState2();
      return request;
    }
    function finishFunctionComponent2(request, task, keyPath, children, hasId, actionStateCount, actionStateMatchingIndex3) {
      var didEmitActionStateMarkers = false;
      if (actionStateCount !== 0 && request.formState !== null) {
        var segment = task.blockedSegment;
        if (segment !== null) {
          didEmitActionStateMarkers = true;
          segment = segment.chunks;
          for (var i2 = 0;i2 < actionStateCount; i2++)
            i2 === actionStateMatchingIndex3 ? segment.push("<!--F!-->") : segment.push("<!--F-->");
        }
      }
      actionStateCount = task.keyPath;
      task.keyPath = keyPath;
      hasId ? (keyPath = task.treeContext, task.treeContext = pushTreeContext2(keyPath, 1, 0), renderNode2(request, task, children, -1), task.treeContext = keyPath) : didEmitActionStateMarkers ? renderNode2(request, task, children, -1) : renderNodeDestructive2(request, task, children, -1);
      task.keyPath = actionStateCount;
    }
    function renderElement2(request, task, keyPath, type, props, ref) {
      if (typeof type === "function")
        if (type.prototype && type.prototype.isReactComponent) {
          var newProps = props;
          if ("ref" in props) {
            newProps = {};
            for (var propName in props)
              propName !== "ref" && (newProps[propName] = props[propName]);
          }
          var defaultProps = type.defaultProps;
          if (defaultProps) {
            newProps === props && (newProps = assign2({}, newProps, props));
            for (var _propName in defaultProps)
              newProps[_propName] === undefined && (newProps[_propName] = defaultProps[_propName]);
          }
          var resolvedProps = newProps;
          var context = emptyContextObject2, contextType = type.contextType;
          if ("contextType" in type && contextType !== null && (contextType === undefined || contextType.$$typeof !== REACT_CONTEXT_TYPE2) && !didWarnAboutInvalidateContextType2.has(type)) {
            didWarnAboutInvalidateContextType2.add(type);
            var addendum = contextType === undefined ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType !== "object" ? " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_CONSUMER_TYPE2 ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
            console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType2(type) || "Component", addendum);
          }
          typeof contextType === "object" && contextType !== null && (context = contextType._currentValue2);
          var instance = new type(resolvedProps, context);
          if (typeof type.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === undefined)) {
            var componentName = getComponentNameFromType2(type) || "Component";
            didWarnAboutUninitializedState2.has(componentName) || (didWarnAboutUninitializedState2.add(componentName), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
          }
          if (typeof type.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
            typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount === "function" && (foundWillMountName = "UNSAFE_componentWillMount");
            typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps === "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps");
            typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate === "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType2(type) || "Component", newApiName = typeof type.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              didWarnAboutLegacyLifecyclesAndDerivedState2.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState2.add(_componentName), console.error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://react.dev/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
            }
          }
          var name = getComponentNameFromType2(type) || "Component";
          instance.render || (type.prototype && typeof type.prototype.render === "function" ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", name) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", name));
          !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
          instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
          instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
          type.childContextTypes && !didWarnAboutChildContextTypes2.has(type) && (didWarnAboutChildContextTypes2.add(type), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", name));
          type.contextTypes && !didWarnAboutContextTypes$12.has(type) && (didWarnAboutContextTypes$12.add(type), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", name));
          typeof instance.componentShouldUpdate === "function" && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
          type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined" && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType2(type) || "A pure component");
          typeof instance.componentDidUnmount === "function" && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
          typeof instance.componentDidReceiveProps === "function" && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          typeof instance.componentWillRecieveProps === "function" && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          typeof instance.UNSAFE_componentWillRecieveProps === "function" && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          var hasMutatedProps = instance.props !== resolvedProps;
          instance.props !== undefined && hasMutatedProps && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name);
          instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
          typeof instance.getSnapshotBeforeUpdate !== "function" || typeof instance.componentDidUpdate === "function" || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2.has(type) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2.add(type), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType2(type)));
          typeof instance.getDerivedStateFromProps === "function" && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          typeof instance.getDerivedStateFromError === "function" && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
          typeof type.getSnapshotBeforeUpdate === "function" && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
          var state = instance.state;
          state && (typeof state !== "object" || isArrayImpl2(state)) && console.error("%s.state: must be set to an object or null", name);
          typeof instance.getChildContext === "function" && typeof type.childContextTypes !== "object" && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
          var initialState = instance.state !== undefined ? instance.state : null;
          instance.updater = classComponentUpdater2;
          instance.props = resolvedProps;
          instance.state = initialState;
          var internalInstance = { queue: [], replace: false };
          instance._reactInternals = internalInstance;
          var contextType$jscomp$0 = type.contextType;
          instance.context = typeof contextType$jscomp$0 === "object" && contextType$jscomp$0 !== null ? contextType$jscomp$0._currentValue2 : emptyContextObject2;
          if (instance.state === resolvedProps) {
            var componentName$jscomp$0 = getComponentNameFromType2(type) || "Component";
            didWarnAboutDirectlyAssigningPropsToState2.has(componentName$jscomp$0) || (didWarnAboutDirectlyAssigningPropsToState2.add(componentName$jscomp$0), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName$jscomp$0));
          }
          var getDerivedStateFromProps = type.getDerivedStateFromProps;
          if (typeof getDerivedStateFromProps === "function") {
            var partialState = getDerivedStateFromProps(resolvedProps, initialState);
            if (partialState === undefined) {
              var componentName$jscomp$1 = getComponentNameFromType2(type) || "Component";
              didWarnAboutUndefinedDerivedState2.has(componentName$jscomp$1) || (didWarnAboutUndefinedDerivedState2.add(componentName$jscomp$1), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName$jscomp$1));
            }
            var JSCompiler_inline_result = partialState === null || partialState === undefined ? initialState : assign2({}, initialState, partialState);
            instance.state = JSCompiler_inline_result;
          }
          if (typeof type.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                var componentName$jscomp$2 = getComponentNameFromType2(type) || "Unknown";
                didWarnAboutDeprecatedWillMount2[componentName$jscomp$2] || (console.warn(`componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.

* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.

Please update the following components: %s`, componentName$jscomp$2), didWarnAboutDeprecatedWillMount2[componentName$jscomp$2] = true);
              }
              instance.componentWillMount();
            }
            typeof instance.UNSAFE_componentWillMount === "function" && instance.UNSAFE_componentWillMount();
            oldState !== instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType2(type) || "Component"), classComponentUpdater2.enqueueReplaceState(instance, instance.state, null));
            if (internalInstance.queue !== null && 0 < internalInstance.queue.length) {
              var { queue: oldQueue, replace: oldReplace } = internalInstance;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1)
                instance.state = oldQueue[0];
              else {
                for (var nextState = oldReplace ? oldQueue[0] : instance.state, dontMutate = true, i2 = oldReplace ? 1 : 0;i2 < oldQueue.length; i2++) {
                  var partial2 = oldQueue[i2], partialState$jscomp$0 = typeof partial2 === "function" ? partial2.call(instance, nextState, resolvedProps, undefined) : partial2;
                  partialState$jscomp$0 != null && (dontMutate ? (dontMutate = false, nextState = assign2({}, nextState, partialState$jscomp$0)) : assign2(nextState, partialState$jscomp$0));
                }
                instance.state = nextState;
              }
            } else
              internalInstance.queue = null;
          }
          var nextChildren = callRenderInDEV2(instance);
          if (request.status === 12)
            throw null;
          instance.props !== resolvedProps && (didWarnAboutReassigningProps2 || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType2(type) || "a component"), didWarnAboutReassigningProps2 = true);
          var prevKeyPath = task.keyPath;
          task.keyPath = keyPath;
          renderNodeDestructive2(request, task, nextChildren, -1);
          task.keyPath = prevKeyPath;
        } else {
          if (type.prototype && typeof type.prototype.render === "function") {
            var componentName$jscomp$3 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutBadClass2[componentName$jscomp$3] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName$jscomp$3, componentName$jscomp$3), didWarnAboutBadClass2[componentName$jscomp$3] = true);
          }
          var value = renderWithHooks2(request, task, keyPath, type, props, undefined);
          if (request.status === 12)
            throw null;
          var hasId = localIdCounter2 !== 0, actionStateCount = actionStateCounter2, actionStateMatchingIndex$jscomp$0 = actionStateMatchingIndex2;
          if (type.contextTypes) {
            var _componentName$jscomp$0 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutContextTypes2[_componentName$jscomp$0] || (didWarnAboutContextTypes2[_componentName$jscomp$0] = true, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", _componentName$jscomp$0));
          }
          type && type.childContextTypes && console.error(`childContextTypes cannot be defined on a function component.
  %s.childContextTypes = ...`, type.displayName || type.name || "Component");
          if (typeof type.getDerivedStateFromProps === "function") {
            var componentName$jscomp$4 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutGetDerivedStateOnFunctionComponent2[componentName$jscomp$4] || (console.error("%s: Function components do not support getDerivedStateFromProps.", componentName$jscomp$4), didWarnAboutGetDerivedStateOnFunctionComponent2[componentName$jscomp$4] = true);
          }
          if (typeof type.contextType === "object" && type.contextType !== null) {
            var _componentName2 = getComponentNameFromType2(type) || "Unknown";
            didWarnAboutContextTypeOnFunctionComponent2[_componentName2] || (console.error("%s: Function components do not support contextType.", _componentName2), didWarnAboutContextTypeOnFunctionComponent2[_componentName2] = true);
          }
          finishFunctionComponent2(request, task, keyPath, value, hasId, actionStateCount, actionStateMatchingIndex$jscomp$0);
        }
      else if (typeof type === "string") {
        var segment = task.blockedSegment;
        if (segment === null) {
          var children = props.children, prevContext = task.formatContext, prevKeyPath$jscomp$0 = task.keyPath;
          task.formatContext = getChildFormatContext2(prevContext, type, props);
          task.keyPath = keyPath;
          renderNode2(request, task, children, -1);
          task.formatContext = prevContext;
          task.keyPath = prevKeyPath$jscomp$0;
        } else {
          var _children = pushStartInstance2(segment.chunks, type, props, request.resumableState, request.renderState, task.blockedPreamble, task.hoistableState, task.formatContext, segment.lastPushedText);
          segment.lastPushedText = false;
          var { formatContext: _prevContext2, keyPath: _prevKeyPath3 } = task;
          task.keyPath = keyPath;
          if ((task.formatContext = getChildFormatContext2(_prevContext2, type, props)).insertionMode === HTML_HEAD_MODE2) {
            var preambleSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
            segment.preambleChildren.push(preambleSegment);
            task.blockedSegment = preambleSegment;
            try {
              preambleSegment.status = 6, renderNode2(request, task, _children, -1), pushSegmentFinale2(preambleSegment.chunks, request.renderState, preambleSegment.lastPushedText, preambleSegment.textEmbedded), preambleSegment.status = COMPLETED2;
            } finally {
              task.blockedSegment = segment;
            }
          } else
            renderNode2(request, task, _children, -1);
          task.formatContext = _prevContext2;
          task.keyPath = _prevKeyPath3;
          a: {
            var target = segment.chunks, resumableState = request.resumableState;
            switch (type) {
              case "title":
              case "style":
              case "script":
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr":
                break a;
              case "body":
                if (_prevContext2.insertionMode <= HTML_HTML_MODE2) {
                  resumableState.hasBody = true;
                  break a;
                }
                break;
              case "html":
                if (_prevContext2.insertionMode === ROOT_HTML_MODE2) {
                  resumableState.hasHtml = true;
                  break a;
                }
                break;
              case "head":
                if (_prevContext2.insertionMode <= HTML_HTML_MODE2)
                  break a;
            }
            target.push(endChunkForTag2(type));
          }
          segment.lastPushedText = false;
        }
      } else {
        switch (type) {
          case REACT_LEGACY_HIDDEN_TYPE2:
          case REACT_STRICT_MODE_TYPE2:
          case REACT_PROFILER_TYPE2:
          case REACT_FRAGMENT_TYPE2:
            var prevKeyPath$jscomp$1 = task.keyPath;
            task.keyPath = keyPath;
            renderNodeDestructive2(request, task, props.children, -1);
            task.keyPath = prevKeyPath$jscomp$1;
            return;
          case REACT_ACTIVITY_TYPE2:
            var segment$jscomp$0 = task.blockedSegment;
            if (segment$jscomp$0 === null) {
              if (props.mode !== "hidden") {
                var prevKeyPath$jscomp$2 = task.keyPath;
                task.keyPath = keyPath;
                renderNode2(request, task, props.children, -1);
                task.keyPath = prevKeyPath$jscomp$2;
              }
            } else if (props.mode !== "hidden") {
              request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--&-->");
              segment$jscomp$0.lastPushedText = false;
              var _prevKeyPath4 = task.keyPath;
              task.keyPath = keyPath;
              renderNode2(request, task, props.children, -1);
              task.keyPath = _prevKeyPath4;
              request.renderState.generateStaticMarkup || segment$jscomp$0.chunks.push("<!--/&-->");
              segment$jscomp$0.lastPushedText = false;
            }
            return;
          case REACT_SUSPENSE_LIST_TYPE2:
            a: {
              var { children: children$jscomp$0, revealOrder } = props;
              if (revealOrder === "forwards" || revealOrder === "backwards" || revealOrder === "unstable_legacy-backwards") {
                if (isArrayImpl2(children$jscomp$0)) {
                  renderSuspenseListRows2(request, task, keyPath, children$jscomp$0, revealOrder);
                  break a;
                }
                var iteratorFn = getIteratorFn2(children$jscomp$0);
                if (iteratorFn) {
                  var iterator = iteratorFn.call(children$jscomp$0);
                  if (iterator) {
                    validateIterable2(task, children$jscomp$0, -1, iterator, iteratorFn);
                    var step = iterator.next();
                    if (!step.done) {
                      var rows = [];
                      do
                        rows.push(step.value), step = iterator.next();
                      while (!step.done);
                      renderSuspenseListRows2(request, task, keyPath, children$jscomp$0, revealOrder);
                    }
                    break a;
                  }
                }
              }
              if (revealOrder === "together") {
                var { keyPath: _prevKeyPath2, row: prevRow } = task, newRow = task.row = createSuspenseListRow2(null);
                newRow.boundaries = [];
                newRow.together = true;
                task.keyPath = keyPath;
                renderNodeDestructive2(request, task, children$jscomp$0, -1);
                --newRow.pendingTasks === 0 && finishSuspenseListRow2(request, newRow);
                task.keyPath = _prevKeyPath2;
                task.row = prevRow;
                prevRow !== null && 0 < newRow.pendingTasks && (prevRow.pendingTasks++, newRow.next = prevRow);
              } else {
                var prevKeyPath$jscomp$3 = task.keyPath;
                task.keyPath = keyPath;
                renderNodeDestructive2(request, task, children$jscomp$0, -1);
                task.keyPath = prevKeyPath$jscomp$3;
              }
            }
            return;
          case REACT_VIEW_TRANSITION_TYPE2:
          case REACT_SCOPE_TYPE2:
            throw Error("ReactDOMServer does not yet support scope components.");
          case REACT_SUSPENSE_TYPE2:
            a:
              if (task.replay !== null) {
                var { keyPath: _prevKeyPath, formatContext: _prevContext, row: _prevRow } = task;
                task.keyPath = keyPath;
                task.formatContext = getSuspenseContentFormatContext2(request.resumableState, _prevContext);
                task.row = null;
                var _content = props.children;
                try {
                  renderNode2(request, task, _content, -1);
                } finally {
                  task.keyPath = _prevKeyPath, task.formatContext = _prevContext, task.row = _prevRow;
                }
              } else {
                var { keyPath: prevKeyPath$jscomp$4, formatContext: prevContext$jscomp$0, row: prevRow$jscomp$0, blockedBoundary: parentBoundary, blockedPreamble: parentPreamble, hoistableState: parentHoistableState, blockedSegment: parentSegment } = task, fallback = props.fallback, content = props.children, fallbackAbortSet = new Set;
                var newBoundary = createSuspenseBoundary2(request, task.row, fallbackAbortSet, null, null);
                request.trackedPostpones !== null && (newBoundary.trackedContentKeyPath = keyPath);
                var boundarySegment = createPendingSegment2(request, parentSegment.chunks.length, newBoundary, task.formatContext, false, false);
                parentSegment.children.push(boundarySegment);
                parentSegment.lastPushedText = false;
                var contentRootSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
                contentRootSegment.parentFlushed = true;
                if (request.trackedPostpones !== null) {
                  var suspenseComponentStack = task.componentStack, fallbackKeyPath = [
                    keyPath[0],
                    "Suspense Fallback",
                    keyPath[2]
                  ], fallbackReplayNode = [
                    fallbackKeyPath[1],
                    fallbackKeyPath[2],
                    [],
                    null
                  ];
                  request.trackedPostpones.workingMap.set(fallbackKeyPath, fallbackReplayNode);
                  newBoundary.trackedFallbackNode = fallbackReplayNode;
                  task.blockedSegment = boundarySegment;
                  task.blockedPreamble = newBoundary.fallbackPreamble;
                  task.keyPath = fallbackKeyPath;
                  task.formatContext = getSuspenseFallbackFormatContext2(request.resumableState, prevContext$jscomp$0);
                  task.componentStack = replaceSuspenseComponentStackWithSuspenseFallbackStack2(suspenseComponentStack);
                  boundarySegment.status = 6;
                  try {
                    renderNode2(request, task, fallback, -1), pushSegmentFinale2(boundarySegment.chunks, request.renderState, boundarySegment.lastPushedText, boundarySegment.textEmbedded), boundarySegment.status = COMPLETED2;
                  } catch (thrownValue) {
                    throw boundarySegment.status = request.status === 12 ? ABORTED2 : ERRORED2, thrownValue;
                  } finally {
                    task.blockedSegment = parentSegment, task.blockedPreamble = parentPreamble, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0;
                  }
                  var suspendedPrimaryTask = createRenderTask2(request, null, content, -1, newBoundary, contentRootSegment, newBoundary.contentPreamble, newBoundary.contentState, task.abortSet, keyPath, getSuspenseContentFormatContext2(request.resumableState, task.formatContext), task.context, task.treeContext, null, suspenseComponentStack, emptyContextObject2, task.debugTask);
                  pushComponentStack2(suspendedPrimaryTask);
                  request.pingedTasks.push(suspendedPrimaryTask);
                } else {
                  task.blockedBoundary = newBoundary;
                  task.blockedPreamble = newBoundary.contentPreamble;
                  task.hoistableState = newBoundary.contentState;
                  task.blockedSegment = contentRootSegment;
                  task.keyPath = keyPath;
                  task.formatContext = getSuspenseContentFormatContext2(request.resumableState, prevContext$jscomp$0);
                  task.row = null;
                  contentRootSegment.status = 6;
                  try {
                    if (renderNode2(request, task, content, -1), pushSegmentFinale2(contentRootSegment.chunks, request.renderState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded), contentRootSegment.status = COMPLETED2, queueCompletedSegment2(newBoundary, contentRootSegment), newBoundary.pendingTasks === 0 && newBoundary.status === PENDING2) {
                      if (newBoundary.status = COMPLETED2, !isEligibleForOutlining2(request, newBoundary)) {
                        prevRow$jscomp$0 !== null && --prevRow$jscomp$0.pendingTasks === 0 && finishSuspenseListRow2(request, prevRow$jscomp$0);
                        request.pendingRootTasks === 0 && task.blockedPreamble && preparePreamble2(request);
                        break a;
                      }
                    } else
                      prevRow$jscomp$0 !== null && prevRow$jscomp$0.together && tryToResolveTogetherRow2(request, prevRow$jscomp$0);
                  } catch (thrownValue$2) {
                    newBoundary.status = CLIENT_RENDERED2;
                    if (request.status === 12) {
                      contentRootSegment.status = ABORTED2;
                      var error40 = request.fatalError;
                    } else
                      contentRootSegment.status = ERRORED2, error40 = thrownValue$2;
                    var thrownInfo = getThrownInfo2(task.componentStack);
                    var errorDigest = logRecoverableError2(request, error40, thrownInfo, task.debugTask);
                    encodeErrorForBoundary2(newBoundary, errorDigest, error40, thrownInfo, false);
                    untrackBoundary2(request, newBoundary);
                  } finally {
                    task.blockedBoundary = parentBoundary, task.blockedPreamble = parentPreamble, task.hoistableState = parentHoistableState, task.blockedSegment = parentSegment, task.keyPath = prevKeyPath$jscomp$4, task.formatContext = prevContext$jscomp$0, task.row = prevRow$jscomp$0;
                  }
                  var suspendedFallbackTask = createRenderTask2(request, null, fallback, -1, parentBoundary, boundarySegment, newBoundary.fallbackPreamble, newBoundary.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], getSuspenseFallbackFormatContext2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack2(task.componentStack), emptyContextObject2, task.debugTask);
                  pushComponentStack2(suspendedFallbackTask);
                  request.pingedTasks.push(suspendedFallbackTask);
                }
              }
            return;
        }
        if (typeof type === "object" && type !== null)
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE2:
              if ("ref" in props) {
                var propsWithoutRef = {};
                for (var key in props)
                  key !== "ref" && (propsWithoutRef[key] = props[key]);
              } else
                propsWithoutRef = props;
              var children$jscomp$1 = renderWithHooks2(request, task, keyPath, type.render, propsWithoutRef, ref);
              finishFunctionComponent2(request, task, keyPath, children$jscomp$1, localIdCounter2 !== 0, actionStateCounter2, actionStateMatchingIndex2);
              return;
            case REACT_MEMO_TYPE2:
              renderElement2(request, task, keyPath, type.type, props, ref);
              return;
            case REACT_CONTEXT_TYPE2:
              var { value: value$jscomp$0, children: children$jscomp$2 } = props;
              var prevSnapshot = task.context;
              var prevKeyPath$jscomp$5 = task.keyPath;
              var prevValue = type._currentValue2;
              type._currentValue2 = value$jscomp$0;
              type._currentRenderer2 !== undefined && type._currentRenderer2 !== null && type._currentRenderer2 !== rendererSigil2 && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              type._currentRenderer2 = rendererSigil2;
              var prevNode = currentActiveSnapshot2, newNode = {
                parent: prevNode,
                depth: prevNode === null ? 0 : prevNode.depth + 1,
                context: type,
                parentValue: prevValue,
                value: value$jscomp$0
              };
              currentActiveSnapshot2 = newNode;
              task.context = newNode;
              task.keyPath = keyPath;
              renderNodeDestructive2(request, task, children$jscomp$2, -1);
              var prevSnapshot$jscomp$0 = currentActiveSnapshot2;
              if (prevSnapshot$jscomp$0 === null)
                throw Error("Tried to pop a Context at the root of the app. This is a bug in React.");
              prevSnapshot$jscomp$0.context !== type && console.error("The parent context is not the expected context. This is probably a bug in React.");
              prevSnapshot$jscomp$0.context._currentValue2 = prevSnapshot$jscomp$0.parentValue;
              type._currentRenderer2 !== undefined && type._currentRenderer2 !== null && type._currentRenderer2 !== rendererSigil2 && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
              type._currentRenderer2 = rendererSigil2;
              var JSCompiler_inline_result$jscomp$0 = currentActiveSnapshot2 = prevSnapshot$jscomp$0.parent;
              task.context = JSCompiler_inline_result$jscomp$0;
              task.keyPath = prevKeyPath$jscomp$5;
              prevSnapshot !== task.context && console.error("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              return;
            case REACT_CONSUMER_TYPE2:
              var context$jscomp$0 = type._context, render = props.children;
              typeof render !== "function" && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              var newChildren = render(context$jscomp$0._currentValue2), prevKeyPath$jscomp$6 = task.keyPath;
              task.keyPath = keyPath;
              renderNodeDestructive2(request, task, newChildren, -1);
              task.keyPath = prevKeyPath$jscomp$6;
              return;
            case REACT_LAZY_TYPE2:
              var Component = callLazyInitInDEV2(type);
              if (request.status === 12)
                throw null;
              renderElement2(request, task, keyPath, Component, props, ref);
              return;
          }
        var info = "";
        if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0)
          info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + ((type == null ? type : typeof type) + "." + info));
      }
    }
    function resumeNode2(request, task, segmentId, node, childIndex) {
      var { replay: prevReplay, blockedBoundary } = task, resumedSegment = createPendingSegment2(request, 0, null, task.formatContext, false, false);
      resumedSegment.id = segmentId;
      resumedSegment.parentFlushed = true;
      try {
        task.replay = null, task.blockedSegment = resumedSegment, renderNode2(request, task, node, childIndex), resumedSegment.status = COMPLETED2, blockedBoundary === null ? request.completedRootSegment = resumedSegment : (queueCompletedSegment2(blockedBoundary, resumedSegment), blockedBoundary.parentFlushed && request.partialBoundaries.push(blockedBoundary));
      } finally {
        task.replay = prevReplay, task.blockedSegment = null;
      }
    }
    function replayElement2(request, task, keyPath, name, keyOrIndex, childIndex, type, props, ref, replay) {
      childIndex = replay.nodes;
      for (var i2 = 0;i2 < childIndex.length; i2++) {
        var node = childIndex[i2];
        if (keyOrIndex === node[1]) {
          if (node.length === 4) {
            if (name !== null && name !== node[0])
              throw Error("Expected the resume to render <" + node[0] + "> in this slot but instead it rendered <" + name + ">. The tree doesn't match so React will fallback to client rendering.");
            var childNodes = node[2];
            name = node[3];
            keyOrIndex = task.node;
            task.replay = { nodes: childNodes, slots: name, pendingTasks: 1 };
            try {
              renderElement2(request, task, keyPath, type, props, ref);
              if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              task.replay.pendingTasks--;
            } catch (x2) {
              if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException2 || typeof x2.then === "function"))
                throw task.node === keyOrIndex ? task.replay = replay : childIndex.splice(i2, 1), x2;
              task.replay.pendingTasks--;
              type = getThrownInfo2(task.componentStack);
              props = request;
              request = task.blockedBoundary;
              keyPath = x2;
              ref = name;
              name = logRecoverableError2(props, keyPath, type, task.debugTask);
              abortRemainingReplayNodes2(props, request, childNodes, ref, keyPath, name, type, false);
            }
            task.replay = replay;
          } else {
            if (type !== REACT_SUSPENSE_TYPE2)
              throw Error("Expected the resume to render <Suspense> in this slot but instead it rendered <" + (getComponentNameFromType2(type) || "Unknown") + ">. The tree doesn't match so React will fallback to client rendering.");
            a: {
              replay = undefined;
              name = node[5];
              type = node[2];
              ref = node[3];
              keyOrIndex = node[4] === null ? [] : node[4][2];
              node = node[4] === null ? null : node[4][3];
              var { keyPath: prevKeyPath, formatContext: prevContext, row: prevRow, replay: previousReplaySet, blockedBoundary: parentBoundary, hoistableState: parentHoistableState } = task, content = props.children, fallback = props.fallback, fallbackAbortSet = new Set;
              props = createSuspenseBoundary2(request, task.row, fallbackAbortSet, null, null);
              props.parentFlushed = true;
              props.rootSegmentID = name;
              task.blockedBoundary = props;
              task.hoistableState = props.contentState;
              task.keyPath = keyPath;
              task.formatContext = getSuspenseContentFormatContext2(request.resumableState, prevContext);
              task.row = null;
              task.replay = { nodes: type, slots: ref, pendingTasks: 1 };
              try {
                renderNode2(request, task, content, -1);
                if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                  throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
                task.replay.pendingTasks--;
                if (props.pendingTasks === 0 && props.status === PENDING2) {
                  props.status = COMPLETED2;
                  request.completedBoundaries.push(props);
                  break a;
                }
              } catch (error40) {
                props.status = CLIENT_RENDERED2, childNodes = getThrownInfo2(task.componentStack), replay = logRecoverableError2(request, error40, childNodes, task.debugTask), encodeErrorForBoundary2(props, replay, error40, childNodes, false), task.replay.pendingTasks--, request.clientRenderedBoundaries.push(props);
              } finally {
                task.blockedBoundary = parentBoundary, task.hoistableState = parentHoistableState, task.replay = previousReplaySet, task.keyPath = prevKeyPath, task.formatContext = prevContext, task.row = prevRow;
              }
              props = createReplayTask2(request, null, { nodes: keyOrIndex, slots: node, pendingTasks: 0 }, fallback, -1, parentBoundary, props.fallbackState, fallbackAbortSet, [keyPath[0], "Suspense Fallback", keyPath[2]], getSuspenseFallbackFormatContext2(request.resumableState, task.formatContext), task.context, task.treeContext, task.row, replaceSuspenseComponentStackWithSuspenseFallbackStack2(task.componentStack), emptyContextObject2, task.debugTask);
              pushComponentStack2(props);
              request.pingedTasks.push(props);
            }
          }
          childIndex.splice(i2, 1);
          break;
        }
      }
    }
    function validateIterable2(task, iterable, childIndex, iterator, iteratorFn) {
      if (iterator === iterable) {
        if (childIndex !== -1 || task.componentStack === null || typeof task.componentStack.type !== "function" || Object.prototype.toString.call(task.componentStack.type) !== "[object GeneratorFunction]" || Object.prototype.toString.call(iterator) !== "[object Generator]")
          didWarnAboutGenerators2 || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators2 = true;
      } else
        iterable.entries !== iteratorFn || didWarnAboutMaps2 || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps2 = true);
    }
    function renderNodeDestructive2(request, task, node, childIndex) {
      task.replay !== null && typeof task.replay.slots === "number" ? resumeNode2(request, task, task.replay.slots, node, childIndex) : (task.node = node, task.childIndex = childIndex, node = task.componentStack, childIndex = task.debugTask, pushComponentStack2(task), retryNode2(request, task), task.componentStack = node, task.debugTask = childIndex);
    }
    function retryNode2(request, task) {
      var { node, childIndex } = task;
      if (node !== null) {
        if (typeof node === "object") {
          switch (node.$$typeof) {
            case REACT_ELEMENT_TYPE2:
              var { type, key } = node;
              node = node.props;
              var refProp = node.ref;
              refProp = refProp !== undefined ? refProp : null;
              var debugTask = task.debugTask, name = getComponentNameFromType2(type);
              key = key == null ? childIndex === -1 ? 0 : childIndex : key;
              var keyPath = [task.keyPath, name, key];
              task.replay !== null ? debugTask ? debugTask.run(replayElement2.bind(null, request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay)) : replayElement2(request, task, keyPath, name, key, childIndex, type, node, refProp, task.replay) : debugTask ? debugTask.run(renderElement2.bind(null, request, task, keyPath, type, node, refProp)) : renderElement2(request, task, keyPath, type, node, refProp);
              return;
            case REACT_PORTAL_TYPE2:
              throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            case REACT_LAZY_TYPE2:
              type = callLazyInitInDEV2(node);
              if (request.status === 12)
                throw null;
              renderNodeDestructive2(request, task, type, childIndex);
              return;
          }
          if (isArrayImpl2(node)) {
            renderChildrenArray2(request, task, node, childIndex);
            return;
          }
          if (key = getIteratorFn2(node)) {
            if (type = key.call(node)) {
              validateIterable2(task, node, childIndex, type, key);
              node = type.next();
              if (!node.done) {
                key = [];
                do
                  key.push(node.value), node = type.next();
                while (!node.done);
                renderChildrenArray2(request, task, key, childIndex);
              }
              return;
            }
          }
          if (typeof node.then === "function")
            return task.thenableState = null, renderNodeDestructive2(request, task, unwrapThenable2(node), childIndex);
          if (node.$$typeof === REACT_CONTEXT_TYPE2)
            return renderNodeDestructive2(request, task, node._currentValue2, childIndex);
          request = Object.prototype.toString.call(node);
          throw Error("Objects are not valid as a React child (found: " + (request === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : request) + "). If you meant to render a collection of children, use an array instead.");
        }
        typeof node === "string" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance2(task.chunks, node, request.renderState, task.lastPushedText))) : typeof node === "number" || typeof node === "bigint" ? (task = task.blockedSegment, task !== null && (task.lastPushedText = pushTextInstance2(task.chunks, "" + node, request.renderState, task.lastPushedText))) : (typeof node === "function" && (request = node.displayName || node.name || "Component", console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.", request, request)), typeof node === "symbol" && console.error(`Symbols are not valid as a React child.
  %s`, String(node)));
      }
    }
    function warnForMissingKey2(request, task, child) {
      if (child !== null && typeof child === "object" && (child.$$typeof === REACT_ELEMENT_TYPE2 || child.$$typeof === REACT_PORTAL_TYPE2) && child._store && (!child._store.validated && child.key == null || child._store.validated === 2)) {
        if (typeof child._store !== "object")
          throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = 1;
        var didWarnForKey = request.didWarnForKey;
        didWarnForKey == null && (didWarnForKey = request.didWarnForKey = new WeakSet);
        request = task.componentStack;
        if (request !== null && !didWarnForKey.has(request)) {
          didWarnForKey.add(request);
          var componentName = getComponentNameFromType2(child.type);
          didWarnForKey = child._owner;
          var parentOwner = request.owner;
          request = "";
          if (parentOwner && typeof parentOwner.type !== "undefined") {
            var name = getComponentNameFromType2(parentOwner.type);
            name && (request = `

Check the render method of \`` + name + "`.");
          }
          request || componentName && (request = `

Check the top-level render call using <` + componentName + ">.");
          componentName = "";
          didWarnForKey != null && parentOwner !== didWarnForKey && (parentOwner = null, typeof didWarnForKey.type !== "undefined" ? parentOwner = getComponentNameFromType2(didWarnForKey.type) : typeof didWarnForKey.name === "string" && (parentOwner = didWarnForKey.name), parentOwner && (componentName = " It was passed a child from " + parentOwner + "."));
          didWarnForKey = task.componentStack;
          task.componentStack = {
            parent: task.componentStack,
            type: child.type,
            owner: child._owner,
            stack: child._debugStack
          };
          console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', request, componentName);
          task.componentStack = didWarnForKey;
        }
      }
    }
    function renderChildrenArray2(request, task, children, childIndex) {
      var { keyPath: prevKeyPath, componentStack: previousComponentStack } = task;
      var previousDebugTask = task.debugTask;
      pushServerComponentStack2(task, task.node._debugInfo);
      if (childIndex !== -1 && (task.keyPath = [task.keyPath, "Fragment", childIndex], task.replay !== null)) {
        for (var replay = task.replay, replayNodes = replay.nodes, j = 0;j < replayNodes.length; j++) {
          var node = replayNodes[j];
          if (node[1] === childIndex) {
            childIndex = node[2];
            node = node[3];
            task.replay = { nodes: childIndex, slots: node, pendingTasks: 1 };
            try {
              renderChildrenArray2(request, task, children, -1);
              if (task.replay.pendingTasks === 1 && 0 < task.replay.nodes.length)
                throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
              task.replay.pendingTasks--;
            } catch (x2) {
              if (typeof x2 === "object" && x2 !== null && (x2 === SuspenseException2 || typeof x2.then === "function"))
                throw x2;
              task.replay.pendingTasks--;
              var thrownInfo = getThrownInfo2(task.componentStack);
              children = task.blockedBoundary;
              var error40 = x2, resumeSlots = node;
              node = logRecoverableError2(request, error40, thrownInfo, task.debugTask);
              abortRemainingReplayNodes2(request, children, childIndex, resumeSlots, error40, node, thrownInfo, false);
            }
            task.replay = replay;
            replayNodes.splice(j, 1);
            break;
          }
        }
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
        return;
      }
      replay = task.treeContext;
      replayNodes = children.length;
      if (task.replay !== null && (j = task.replay.slots, j !== null && typeof j === "object")) {
        for (childIndex = 0;childIndex < replayNodes; childIndex++)
          node = children[childIndex], task.treeContext = pushTreeContext2(replay, replayNodes, childIndex), error40 = j[childIndex], typeof error40 === "number" ? (resumeNode2(request, task, error40, node, childIndex), delete j[childIndex]) : renderNode2(request, task, node, childIndex);
        task.treeContext = replay;
        task.keyPath = prevKeyPath;
        task.componentStack = previousComponentStack;
        task.debugTask = previousDebugTask;
        return;
      }
      for (j = 0;j < replayNodes; j++)
        childIndex = children[j], warnForMissingKey2(request, task, childIndex), task.treeContext = pushTreeContext2(replay, replayNodes, j), renderNode2(request, task, childIndex, j);
      task.treeContext = replay;
      task.keyPath = prevKeyPath;
      task.componentStack = previousComponentStack;
      task.debugTask = previousDebugTask;
    }
    function trackPostponedBoundary2(request, trackedPostpones, boundary) {
      boundary.status = POSTPONED2;
      boundary.rootSegmentID = request.nextSegmentId++;
      request = boundary.trackedContentKeyPath;
      if (request === null)
        throw Error("It should not be possible to postpone at the root. This is a bug in React.");
      var fallbackReplayNode = boundary.trackedFallbackNode, children = [], boundaryNode = trackedPostpones.workingMap.get(request);
      if (boundaryNode === undefined)
        return boundary = [
          request[1],
          request[2],
          children,
          null,
          fallbackReplayNode,
          boundary.rootSegmentID
        ], trackedPostpones.workingMap.set(request, boundary), addToReplayParent2(boundary, request[0], trackedPostpones), boundary;
      boundaryNode[4] = fallbackReplayNode;
      boundaryNode[5] = boundary.rootSegmentID;
      return boundaryNode;
    }
    function trackPostpone2(request, trackedPostpones, task, segment) {
      segment.status = POSTPONED2;
      var { keyPath, blockedBoundary: boundary } = task;
      if (boundary === null)
        segment.id = request.nextSegmentId++, trackedPostpones.rootSlots = segment.id, request.completedRootSegment !== null && (request.completedRootSegment.status = POSTPONED2);
      else {
        if (boundary !== null && boundary.status === PENDING2) {
          var boundaryNode = trackPostponedBoundary2(request, trackedPostpones, boundary);
          if (boundary.trackedContentKeyPath === keyPath && task.childIndex === -1) {
            segment.id === -1 && (segment.id = segment.parentFlushed ? boundary.rootSegmentID : request.nextSegmentId++);
            boundaryNode[3] = segment.id;
            return;
          }
        }
        segment.id === -1 && (segment.id = segment.parentFlushed && boundary !== null ? boundary.rootSegmentID : request.nextSegmentId++);
        if (task.childIndex === -1)
          keyPath === null ? trackedPostpones.rootSlots = segment.id : (task = trackedPostpones.workingMap.get(keyPath), task === undefined ? (task = [keyPath[1], keyPath[2], [], segment.id], addToReplayParent2(task, keyPath[0], trackedPostpones)) : task[3] = segment.id);
        else {
          if (keyPath === null)
            if (request = trackedPostpones.rootSlots, request === null)
              request = trackedPostpones.rootSlots = {};
            else {
              if (typeof request === "number")
                throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
            }
          else if (boundary = trackedPostpones.workingMap, boundaryNode = boundary.get(keyPath), boundaryNode === undefined)
            request = {}, boundaryNode = [keyPath[1], keyPath[2], [], request], boundary.set(keyPath, boundaryNode), addToReplayParent2(boundaryNode, keyPath[0], trackedPostpones);
          else if (request = boundaryNode[3], request === null)
            request = boundaryNode[3] = {};
          else if (typeof request === "number")
            throw Error("It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.");
          request[task.childIndex] = segment.id;
        }
      }
    }
    function untrackBoundary2(request, boundary) {
      request = request.trackedPostpones;
      request !== null && (boundary = boundary.trackedContentKeyPath, boundary !== null && (boundary = request.workingMap.get(boundary), boundary !== undefined && (boundary.length = 4, boundary[2] = [], boundary[3] = null)));
    }
    function spawnNewSuspendedReplayTask2(request, task, thenableState3) {
      return createReplayTask2(request, thenableState3, task.replay, task.node, task.childIndex, task.blockedBoundary, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject2, task.debugTask);
    }
    function spawnNewSuspendedRenderTask2(request, task, thenableState3) {
      var segment = task.blockedSegment, newSegment = createPendingSegment2(request, segment.chunks.length, null, task.formatContext, segment.lastPushedText, true);
      segment.children.push(newSegment);
      segment.lastPushedText = false;
      return createRenderTask2(request, thenableState3, task.node, task.childIndex, task.blockedBoundary, newSegment, task.blockedPreamble, task.hoistableState, task.abortSet, task.keyPath, task.formatContext, task.context, task.treeContext, task.row, task.componentStack, emptyContextObject2, task.debugTask);
    }
    function renderNode2(request, task, node, childIndex) {
      var { formatContext: previousFormatContext, context: previousContext, keyPath: previousKeyPath, treeContext: previousTreeContext, componentStack: previousComponentStack, debugTask: previousDebugTask, blockedSegment: segment } = task;
      if (segment === null) {
        segment = task.replay;
        try {
          return renderNodeDestructive2(request, task, node, childIndex);
        } catch (thrownValue) {
          if (resetHooksState2(), node = thrownValue === SuspenseException2 ? getSuspendedThenable2() : thrownValue, request.status !== 12 && typeof node === "object" && node !== null) {
            if (typeof node.then === "function") {
              childIndex = thrownValue === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
              request = spawnNewSuspendedReplayTask2(request, task, childIndex).ping;
              node.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.replay = segment;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
            if (node.message === "Maximum call stack size exceeded") {
              node = thrownValue === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
              node = spawnNewSuspendedReplayTask2(request, task, node);
              request.pingedTasks.push(node);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.replay = segment;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
          }
        }
      } else {
        var childrenLength = segment.children.length, chunkLength = segment.chunks.length;
        try {
          return renderNodeDestructive2(request, task, node, childIndex);
        } catch (thrownValue$3) {
          if (resetHooksState2(), segment.children.length = childrenLength, segment.chunks.length = chunkLength, node = thrownValue$3 === SuspenseException2 ? getSuspendedThenable2() : thrownValue$3, request.status !== 12 && typeof node === "object" && node !== null) {
            if (typeof node.then === "function") {
              segment = node;
              node = thrownValue$3 === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
              request = spawnNewSuspendedRenderTask2(request, task, node).ping;
              segment.then(request, request);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
            if (node.message === "Maximum call stack size exceeded") {
              segment = thrownValue$3 === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
              segment = spawnNewSuspendedRenderTask2(request, task, segment);
              request.pingedTasks.push(segment);
              task.formatContext = previousFormatContext;
              task.context = previousContext;
              task.keyPath = previousKeyPath;
              task.treeContext = previousTreeContext;
              task.componentStack = previousComponentStack;
              task.debugTask = previousDebugTask;
              switchContext2(previousContext);
              return;
            }
          }
        }
      }
      task.formatContext = previousFormatContext;
      task.context = previousContext;
      task.keyPath = previousKeyPath;
      task.treeContext = previousTreeContext;
      switchContext2(previousContext);
      throw node;
    }
    function abortTaskSoft2(task) {
      var { blockedBoundary: boundary, blockedSegment: segment } = task;
      segment !== null && (segment.status = ABORTED2, finishedTask2(this, boundary, task.row, segment));
    }
    function abortRemainingReplayNodes2(request$jscomp$0, boundary, nodes, slots, error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted2) {
      for (var i2 = 0;i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.length === 4)
          abortRemainingReplayNodes2(request$jscomp$0, boundary, node[2], node[3], error$jscomp$0, errorDigest$jscomp$0, errorInfo$jscomp$0, aborted2);
        else {
          var request = request$jscomp$0;
          node = node[5];
          var error40 = error$jscomp$0, errorDigest = errorDigest$jscomp$0, errorInfo = errorInfo$jscomp$0, wasAborted = aborted2, resumedBoundary = createSuspenseBoundary2(request, null, new Set, null, null);
          resumedBoundary.parentFlushed = true;
          resumedBoundary.rootSegmentID = node;
          resumedBoundary.status = CLIENT_RENDERED2;
          encodeErrorForBoundary2(resumedBoundary, errorDigest, error40, errorInfo, wasAborted);
          resumedBoundary.parentFlushed && request.clientRenderedBoundaries.push(resumedBoundary);
        }
      }
      nodes.length = 0;
      if (slots !== null) {
        if (boundary === null)
          throw Error("We should not have any resumable nodes in the shell. This is a bug in React.");
        boundary.status !== CLIENT_RENDERED2 && (boundary.status = CLIENT_RENDERED2, encodeErrorForBoundary2(boundary, errorDigest$jscomp$0, error$jscomp$0, errorInfo$jscomp$0, aborted2), boundary.parentFlushed && request$jscomp$0.clientRenderedBoundaries.push(boundary));
        if (typeof slots === "object")
          for (var index in slots)
            delete slots[index];
      }
    }
    function abortTask2(task, request, error40) {
      var { blockedBoundary: boundary, blockedSegment: segment } = task;
      if (segment !== null) {
        if (segment.status === 6)
          return;
        segment.status = ABORTED2;
      }
      var errorInfo = getThrownInfo2(task.componentStack), node = task.node;
      node !== null && typeof node === "object" && pushHaltedAwaitOnComponentStack2(task, node._debugInfo);
      if (boundary === null) {
        if (request.status !== 13 && request.status !== CLOSED2) {
          boundary = task.replay;
          if (boundary === null) {
            request.trackedPostpones !== null && segment !== null ? (boundary = request.trackedPostpones, logRecoverableError2(request, error40, errorInfo, task.debugTask), trackPostpone2(request, boundary, task, segment), finishedTask2(request, null, task.row, segment)) : (logRecoverableError2(request, error40, errorInfo, task.debugTask), fatalError2(request, error40, errorInfo, task.debugTask));
            return;
          }
          boundary.pendingTasks--;
          boundary.pendingTasks === 0 && 0 < boundary.nodes.length && (segment = logRecoverableError2(request, error40, errorInfo, null), abortRemainingReplayNodes2(request, null, boundary.nodes, boundary.slots, error40, segment, errorInfo, true));
          request.pendingRootTasks--;
          request.pendingRootTasks === 0 && completeShell2(request);
        }
      } else {
        node = request.trackedPostpones;
        if (boundary.status !== CLIENT_RENDERED2) {
          if (node !== null && segment !== null)
            return logRecoverableError2(request, error40, errorInfo, task.debugTask), trackPostpone2(request, node, task, segment), boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
              return abortTask2(fallbackTask, request, error40);
            }), boundary.fallbackAbortableTasks.clear(), finishedTask2(request, boundary, task.row, segment);
          boundary.status = CLIENT_RENDERED2;
          segment = logRecoverableError2(request, error40, errorInfo, task.debugTask);
          boundary.status = CLIENT_RENDERED2;
          encodeErrorForBoundary2(boundary, segment, error40, errorInfo, true);
          untrackBoundary2(request, boundary);
          boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);
        }
        boundary.pendingTasks--;
        errorInfo = boundary.row;
        errorInfo !== null && --errorInfo.pendingTasks === 0 && finishSuspenseListRow2(request, errorInfo);
        boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
          return abortTask2(fallbackTask, request, error40);
        });
        boundary.fallbackAbortableTasks.clear();
      }
      task = task.row;
      task !== null && --task.pendingTasks === 0 && finishSuspenseListRow2(request, task);
      request.allPendingTasks--;
      request.allPendingTasks === 0 && completeAll2(request);
    }
    function safelyEmitEarlyPreloads2(request, shellComplete) {
      try {
        var renderState = request.renderState, onHeaders = renderState.onHeaders;
        if (onHeaders) {
          var headers = renderState.headers;
          if (headers) {
            renderState.headers = null;
            var linkHeader = headers.preconnects;
            headers.fontPreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.fontPreloads);
            headers.highImagePreloads && (linkHeader && (linkHeader += ", "), linkHeader += headers.highImagePreloads);
            if (!shellComplete) {
              var queueIter = renderState.styles.values(), queueStep = queueIter.next();
              b:
                for (;0 < headers.remainingCapacity && !queueStep.done; queueStep = queueIter.next())
                  for (var sheetIter = queueStep.value.sheets.values(), sheetStep = sheetIter.next();0 < headers.remainingCapacity && !sheetStep.done; sheetStep = sheetIter.next()) {
                    var sheet = sheetStep.value, props = sheet.props, key = props.href, props$jscomp$0 = sheet.props;
                    var header = getPreloadAsHeader2(props$jscomp$0.href, "style", {
                      crossOrigin: props$jscomp$0.crossOrigin,
                      integrity: props$jscomp$0.integrity,
                      nonce: props$jscomp$0.nonce,
                      type: props$jscomp$0.type,
                      fetchPriority: props$jscomp$0.fetchPriority,
                      referrerPolicy: props$jscomp$0.referrerPolicy,
                      media: props$jscomp$0.media
                    });
                    if (0 <= (headers.remainingCapacity -= header.length + 2))
                      renderState.resets.style[key] = PRELOAD_NO_CREDS2, linkHeader && (linkHeader += ", "), linkHeader += header, renderState.resets.style[key] = typeof props.crossOrigin === "string" || typeof props.integrity === "string" ? [props.crossOrigin, props.integrity] : PRELOAD_NO_CREDS2;
                    else
                      break b;
                  }
            }
            linkHeader ? onHeaders({ Link: linkHeader }) : onHeaders({});
          }
        }
      } catch (error40) {
        logRecoverableError2(request, error40, {}, null);
      }
    }
    function completeShell2(request) {
      request.trackedPostpones === null && safelyEmitEarlyPreloads2(request, true);
      request.trackedPostpones === null && preparePreamble2(request);
      request.onShellError = noop4;
      request = request.onShellReady;
      request();
    }
    function completeAll2(request) {
      safelyEmitEarlyPreloads2(request, request.trackedPostpones === null ? true : request.completedRootSegment === null || request.completedRootSegment.status !== POSTPONED2);
      preparePreamble2(request);
      request = request.onAllReady;
      request();
    }
    function queueCompletedSegment2(boundary, segment) {
      if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null && segment.children[0].id === -1) {
        var childSegment = segment.children[0];
        childSegment.id = segment.id;
        childSegment.parentFlushed = true;
        childSegment.status !== COMPLETED2 && childSegment.status !== ABORTED2 && childSegment.status !== ERRORED2 || queueCompletedSegment2(boundary, childSegment);
      } else
        boundary.completedSegments.push(segment);
    }
    function finishedTask2(request, boundary, row, segment) {
      row !== null && (--row.pendingTasks === 0 ? finishSuspenseListRow2(request, row) : row.together && tryToResolveTogetherRow2(request, row));
      request.allPendingTasks--;
      if (boundary === null) {
        if (segment !== null && segment.parentFlushed) {
          if (request.completedRootSegment !== null)
            throw Error("There can only be one root segment. This is a bug in React.");
          request.completedRootSegment = segment;
        }
        request.pendingRootTasks--;
        request.pendingRootTasks === 0 && completeShell2(request);
      } else if (boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED2)
        if (boundary.pendingTasks === 0)
          if (boundary.status === PENDING2 && (boundary.status = COMPLETED2), segment !== null && segment.parentFlushed && (segment.status === COMPLETED2 || segment.status === ABORTED2) && queueCompletedSegment2(boundary, segment), boundary.parentFlushed && request.completedBoundaries.push(boundary), boundary.status === COMPLETED2)
            row = boundary.row, row !== null && hoistHoistables2(row.hoistables, boundary.contentState), isEligibleForOutlining2(request, boundary) || (boundary.fallbackAbortableTasks.forEach(abortTaskSoft2, request), boundary.fallbackAbortableTasks.clear(), row !== null && --row.pendingTasks === 0 && finishSuspenseListRow2(request, row)), request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary.contentPreamble !== null && preparePreamble2(request);
          else {
            if (boundary.status === POSTPONED2 && (boundary = boundary.row, boundary !== null)) {
              if (request.trackedPostpones !== null) {
                row = request.trackedPostpones;
                var postponedRow = boundary.next;
                if (postponedRow !== null && (segment = postponedRow.boundaries, segment !== null))
                  for (postponedRow.boundaries = null, postponedRow = 0;postponedRow < segment.length; postponedRow++) {
                    var postponedBoundary = segment[postponedRow];
                    trackPostponedBoundary2(request, row, postponedBoundary);
                    finishedTask2(request, postponedBoundary, null, null);
                  }
              }
              --boundary.pendingTasks === 0 && finishSuspenseListRow2(request, boundary);
            }
          }
        else
          segment === null || !segment.parentFlushed || segment.status !== COMPLETED2 && segment.status !== ABORTED2 || (queueCompletedSegment2(boundary, segment), boundary.completedSegments.length === 1 && boundary.parentFlushed && request.partialBoundaries.push(boundary)), boundary = boundary.row, boundary !== null && boundary.together && tryToResolveTogetherRow2(request, boundary);
      request.allPendingTasks === 0 && completeAll2(request);
    }
    function performWork2(request$jscomp$2) {
      if (request$jscomp$2.status !== CLOSED2 && request$jscomp$2.status !== 13) {
        var prevContext = currentActiveSnapshot2, prevDispatcher = ReactSharedInternals2.H;
        ReactSharedInternals2.H = HooksDispatcher2;
        var prevAsyncDispatcher = ReactSharedInternals2.A;
        ReactSharedInternals2.A = DefaultAsyncDispatcher2;
        var prevRequest = currentRequest2;
        currentRequest2 = request$jscomp$2;
        var prevGetCurrentStackImpl = ReactSharedInternals2.getCurrentStack;
        ReactSharedInternals2.getCurrentStack = getCurrentStackInDEV2;
        var prevResumableState = currentResumableState2;
        currentResumableState2 = request$jscomp$2.resumableState;
        try {
          var pingedTasks = request$jscomp$2.pingedTasks, i2;
          for (i2 = 0;i2 < pingedTasks.length; i2++) {
            var request = request$jscomp$2, task = pingedTasks[i2], segment = task.blockedSegment;
            if (segment === null) {
              var prevTaskInDEV = undefined, request$jscomp$0 = request;
              request = task;
              if (request.replay.pendingTasks !== 0) {
                switchContext2(request.context);
                prevTaskInDEV = currentTaskInDEV2;
                currentTaskInDEV2 = request;
                try {
                  typeof request.replay.slots === "number" ? resumeNode2(request$jscomp$0, request, request.replay.slots, request.node, request.childIndex) : retryNode2(request$jscomp$0, request);
                  if (request.replay.pendingTasks === 1 && 0 < request.replay.nodes.length)
                    throw Error("Couldn't find all resumable slots by key/index during replaying. The tree doesn't match so React will fallback to client rendering.");
                  request.replay.pendingTasks--;
                  request.abortSet.delete(request);
                  finishedTask2(request$jscomp$0, request.blockedBoundary, request.row, null);
                } catch (thrownValue) {
                  resetHooksState2();
                  var x2 = thrownValue === SuspenseException2 ? getSuspendedThenable2() : thrownValue;
                  if (typeof x2 === "object" && x2 !== null && typeof x2.then === "function") {
                    var ping = request.ping;
                    x2.then(ping, ping);
                    request.thenableState = thrownValue === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
                  } else {
                    request.replay.pendingTasks--;
                    request.abortSet.delete(request);
                    var errorInfo = getThrownInfo2(request.componentStack), errorDigest = undefined, request$jscomp$1 = request$jscomp$0, boundary = request.blockedBoundary, error$jscomp$0 = request$jscomp$0.status === 12 ? request$jscomp$0.fatalError : x2, errorInfo$jscomp$0 = errorInfo, replayNodes = request.replay.nodes, resumeSlots = request.replay.slots;
                    errorDigest = logRecoverableError2(request$jscomp$1, error$jscomp$0, errorInfo$jscomp$0, request.debugTask);
                    abortRemainingReplayNodes2(request$jscomp$1, boundary, replayNodes, resumeSlots, error$jscomp$0, errorDigest, errorInfo$jscomp$0, false);
                    request$jscomp$0.pendingRootTasks--;
                    request$jscomp$0.pendingRootTasks === 0 && completeShell2(request$jscomp$0);
                    request$jscomp$0.allPendingTasks--;
                    request$jscomp$0.allPendingTasks === 0 && completeAll2(request$jscomp$0);
                  }
                } finally {
                  currentTaskInDEV2 = prevTaskInDEV;
                }
              }
            } else if (request$jscomp$0 = prevTaskInDEV = undefined, errorDigest = task, request$jscomp$1 = segment, request$jscomp$1.status === PENDING2) {
              request$jscomp$1.status = 6;
              switchContext2(errorDigest.context);
              request$jscomp$0 = currentTaskInDEV2;
              currentTaskInDEV2 = errorDigest;
              var childrenLength = request$jscomp$1.children.length, chunkLength = request$jscomp$1.chunks.length;
              try {
                retryNode2(request, errorDigest), pushSegmentFinale2(request$jscomp$1.chunks, request.renderState, request$jscomp$1.lastPushedText, request$jscomp$1.textEmbedded), errorDigest.abortSet.delete(errorDigest), request$jscomp$1.status = COMPLETED2, finishedTask2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
              } catch (thrownValue) {
                resetHooksState2();
                request$jscomp$1.children.length = childrenLength;
                request$jscomp$1.chunks.length = chunkLength;
                var x$jscomp$0 = thrownValue === SuspenseException2 ? getSuspendedThenable2() : request.status === 12 ? request.fatalError : thrownValue;
                if (request.status === 12 && request.trackedPostpones !== null) {
                  var trackedPostpones = request.trackedPostpones, thrownInfo = getThrownInfo2(errorDigest.componentStack);
                  errorDigest.abortSet.delete(errorDigest);
                  logRecoverableError2(request, x$jscomp$0, thrownInfo, errorDigest.debugTask);
                  trackPostpone2(request, trackedPostpones, errorDigest, request$jscomp$1);
                  finishedTask2(request, errorDigest.blockedBoundary, errorDigest.row, request$jscomp$1);
                } else if (typeof x$jscomp$0 === "object" && x$jscomp$0 !== null && typeof x$jscomp$0.then === "function") {
                  request$jscomp$1.status = PENDING2;
                  errorDigest.thenableState = thrownValue === SuspenseException2 ? getThenableStateAfterSuspending2() : null;
                  var ping$jscomp$0 = errorDigest.ping;
                  x$jscomp$0.then(ping$jscomp$0, ping$jscomp$0);
                } else {
                  var errorInfo$jscomp$1 = getThrownInfo2(errorDigest.componentStack);
                  errorDigest.abortSet.delete(errorDigest);
                  request$jscomp$1.status = ERRORED2;
                  var { blockedBoundary: boundary$jscomp$0, row, debugTask } = errorDigest;
                  row !== null && --row.pendingTasks === 0 && finishSuspenseListRow2(request, row);
                  request.allPendingTasks--;
                  prevTaskInDEV = logRecoverableError2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
                  if (boundary$jscomp$0 === null)
                    fatalError2(request, x$jscomp$0, errorInfo$jscomp$1, debugTask);
                  else if (boundary$jscomp$0.pendingTasks--, boundary$jscomp$0.status !== CLIENT_RENDERED2) {
                    boundary$jscomp$0.status = CLIENT_RENDERED2;
                    encodeErrorForBoundary2(boundary$jscomp$0, prevTaskInDEV, x$jscomp$0, errorInfo$jscomp$1, false);
                    untrackBoundary2(request, boundary$jscomp$0);
                    var boundaryRow = boundary$jscomp$0.row;
                    boundaryRow !== null && --boundaryRow.pendingTasks === 0 && finishSuspenseListRow2(request, boundaryRow);
                    boundary$jscomp$0.parentFlushed && request.clientRenderedBoundaries.push(boundary$jscomp$0);
                    request.pendingRootTasks === 0 && request.trackedPostpones === null && boundary$jscomp$0.contentPreamble !== null && preparePreamble2(request);
                  }
                  request.allPendingTasks === 0 && completeAll2(request);
                }
              } finally {
                currentTaskInDEV2 = request$jscomp$0;
              }
            }
          }
          pingedTasks.splice(0, i2);
          request$jscomp$2.destination !== null && flushCompletedQueues2(request$jscomp$2, request$jscomp$2.destination);
        } catch (error40) {
          pingedTasks = {}, logRecoverableError2(request$jscomp$2, error40, pingedTasks, null), fatalError2(request$jscomp$2, error40, pingedTasks, null);
        } finally {
          currentResumableState2 = prevResumableState, ReactSharedInternals2.H = prevDispatcher, ReactSharedInternals2.A = prevAsyncDispatcher, ReactSharedInternals2.getCurrentStack = prevGetCurrentStackImpl, prevDispatcher === HooksDispatcher2 && switchContext2(prevContext), currentRequest2 = prevRequest;
        }
      }
    }
    function preparePreambleFromSubtree2(request, segment, collectedPreambleSegments) {
      segment.preambleChildren.length && collectedPreambleSegments.push(segment.preambleChildren);
      for (var pendingPreambles = false, i2 = 0;i2 < segment.children.length; i2++)
        pendingPreambles = preparePreambleFromSegment2(request, segment.children[i2], collectedPreambleSegments) || pendingPreambles;
      return pendingPreambles;
    }
    function preparePreambleFromSegment2(request, segment, collectedPreambleSegments) {
      var boundary = segment.boundary;
      if (boundary === null)
        return preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
      var { contentPreamble: preamble, fallbackPreamble } = boundary;
      if (preamble === null || fallbackPreamble === null)
        return false;
      switch (boundary.status) {
        case COMPLETED2:
          hoistPreambleState2(request.renderState, preamble);
          request.byteSize += boundary.byteSize;
          segment = boundary.completedSegments[0];
          if (!segment)
            throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
          return preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
        case POSTPONED2:
          if (request.trackedPostpones !== null)
            return true;
        case CLIENT_RENDERED2:
          if (segment.status === COMPLETED2)
            return hoistPreambleState2(request.renderState, fallbackPreamble), preparePreambleFromSubtree2(request, segment, collectedPreambleSegments);
        default:
          return true;
      }
    }
    function preparePreamble2(request) {
      if (request.completedRootSegment && request.completedPreambleSegments === null) {
        var collectedPreambleSegments = [], originalRequestByteSize = request.byteSize, hasPendingPreambles = preparePreambleFromSegment2(request, request.completedRootSegment, collectedPreambleSegments), preamble = request.renderState.preamble;
        hasPendingPreambles === false || preamble.headChunks && preamble.bodyChunks ? request.completedPreambleSegments = collectedPreambleSegments : request.byteSize = originalRequestByteSize;
      }
    }
    function flushSubtree2(request, destination, segment, hoistableState) {
      segment.parentFlushed = true;
      switch (segment.status) {
        case PENDING2:
          segment.id = request.nextSegmentId++;
        case POSTPONED2:
          return hoistableState = segment.id, segment.lastPushedText = false, segment.textEmbedded = false, request = request.renderState, destination.push(placeholder12), destination.push(request.placeholderPrefix), request = hoistableState.toString(16), destination.push(request), destination.push(placeholder22);
        case COMPLETED2:
          segment.status = FLUSHED2;
          var r = true, chunks = segment.chunks, chunkIdx = 0;
          segment = segment.children;
          for (var childIdx = 0;childIdx < segment.length; childIdx++) {
            for (r = segment[childIdx];chunkIdx < r.index; chunkIdx++)
              destination.push(chunks[chunkIdx]);
            r = flushSegment2(request, destination, r, hoistableState);
          }
          for (;chunkIdx < chunks.length - 1; chunkIdx++)
            destination.push(chunks[chunkIdx]);
          chunkIdx < chunks.length && (r = destination.push(chunks[chunkIdx]));
          return r;
        case ABORTED2:
          return true;
        default:
          throw Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
      }
    }
    function flushSegment2(request, destination, segment, hoistableState) {
      var boundary = segment.boundary;
      if (boundary === null)
        return flushSubtree2(request, destination, segment, hoistableState);
      boundary.parentFlushed = true;
      if (boundary.status === CLIENT_RENDERED2) {
        var row = boundary.row;
        row !== null && --row.pendingTasks === 0 && finishSuspenseListRow2(request, row);
        if (!request.renderState.generateStaticMarkup) {
          var { errorDigest, errorMessage } = boundary;
          row = boundary.errorStack;
          boundary = boundary.errorComponentStack;
          destination.push(startClientRenderedSuspenseBoundary2);
          destination.push(clientRenderedSuspenseBoundaryError12);
          errorDigest && (destination.push(clientRenderedSuspenseBoundaryError1A2), errorDigest = escapeTextForBrowser2(errorDigest), destination.push(errorDigest), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          errorMessage && (destination.push(clientRenderedSuspenseBoundaryError1B2), errorMessage = escapeTextForBrowser2(errorMessage), destination.push(errorMessage), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          row && (destination.push(clientRenderedSuspenseBoundaryError1C2), row = escapeTextForBrowser2(row), destination.push(row), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          boundary && (destination.push(clientRenderedSuspenseBoundaryError1D2), row = escapeTextForBrowser2(boundary), destination.push(row), destination.push(clientRenderedSuspenseBoundaryErrorAttrInterstitial2));
          destination.push(clientRenderedSuspenseBoundaryError22);
        }
        flushSubtree2(request, destination, segment, hoistableState);
        request = request.renderState.generateStaticMarkup ? true : destination.push(endSuspenseBoundary2);
        return request;
      }
      if (boundary.status !== COMPLETED2)
        return boundary.status === PENDING2 && (boundary.rootSegmentID = request.nextSegmentId++), 0 < boundary.completedSegments.length && request.partialBoundaries.push(boundary), writeStartPendingSuspenseBoundary2(destination, request.renderState, boundary.rootSegmentID), hoistableState && hoistHoistables2(hoistableState, boundary.fallbackState), flushSubtree2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary2);
      if (!flushingPartialBoundaries2 && isEligibleForOutlining2(request, boundary) && flushedByteSize2 + boundary.byteSize > request.progressiveChunkSize)
        return boundary.rootSegmentID = request.nextSegmentId++, request.completedBoundaries.push(boundary), writeStartPendingSuspenseBoundary2(destination, request.renderState, boundary.rootSegmentID), flushSubtree2(request, destination, segment, hoistableState), destination.push(endSuspenseBoundary2);
      flushedByteSize2 += boundary.byteSize;
      hoistableState && hoistHoistables2(hoistableState, boundary.contentState);
      segment = boundary.row;
      segment !== null && isEligibleForOutlining2(request, boundary) && --segment.pendingTasks === 0 && finishSuspenseListRow2(request, segment);
      request.renderState.generateStaticMarkup || destination.push(startCompletedSuspenseBoundary2);
      segment = boundary.completedSegments;
      if (segment.length !== 1)
        throw Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
      flushSegment2(request, destination, segment[0], hoistableState);
      request = request.renderState.generateStaticMarkup ? true : destination.push(endSuspenseBoundary2);
      return request;
    }
    function flushSegmentContainer2(request, destination, segment, hoistableState) {
      writeStartSegment2(destination, request.renderState, segment.parentFormatContext, segment.id);
      flushSegment2(request, destination, segment, hoistableState);
      return writeEndSegment2(destination, segment.parentFormatContext);
    }
    function flushCompletedBoundary2(request, destination, boundary) {
      flushedByteSize2 = boundary.byteSize;
      for (var completedSegments = boundary.completedSegments, i2 = 0;i2 < completedSegments.length; i2++)
        flushPartiallyCompletedSegment2(request, destination, boundary, completedSegments[i2]);
      completedSegments.length = 0;
      completedSegments = boundary.row;
      completedSegments !== null && isEligibleForOutlining2(request, boundary) && --completedSegments.pendingTasks === 0 && finishSuspenseListRow2(request, completedSegments);
      writeHoistablesForBoundary2(destination, boundary.contentState, request.renderState);
      completedSegments = request.resumableState;
      request = request.renderState;
      i2 = boundary.rootSegmentID;
      boundary = boundary.contentState;
      var requiresStyleInsertion = request.stylesToHoist;
      request.stylesToHoist = false;
      destination.push(request.startInlineScript);
      destination.push(endOfStartTag2);
      requiresStyleInsertion ? ((completedSegments.instructions & SentClientRenderFunction2) === NothingSent2 && (completedSegments.instructions |= SentClientRenderFunction2, destination.push(clientRenderScriptFunctionOnly2)), (completedSegments.instructions & SentCompleteBoundaryFunction2) === NothingSent2 && (completedSegments.instructions |= SentCompleteBoundaryFunction2, destination.push(completeBoundaryScriptFunctionOnly2)), (completedSegments.instructions & SentStyleInsertionFunction2) === NothingSent2 ? (completedSegments.instructions |= SentStyleInsertionFunction2, destination.push(completeBoundaryWithStylesScript1FullPartial2)) : destination.push(completeBoundaryWithStylesScript1Partial2)) : ((completedSegments.instructions & SentCompleteBoundaryFunction2) === NothingSent2 && (completedSegments.instructions |= SentCompleteBoundaryFunction2, destination.push(completeBoundaryScriptFunctionOnly2)), destination.push(completeBoundaryScript1Partial2));
      completedSegments = i2.toString(16);
      destination.push(request.boundaryPrefix);
      destination.push(completedSegments);
      destination.push(completeBoundaryScript22);
      destination.push(request.segmentPrefix);
      destination.push(completedSegments);
      requiresStyleInsertion ? (destination.push(completeBoundaryScript3a2), writeStyleResourceDependenciesInJS2(destination, boundary)) : destination.push(completeBoundaryScript3b2);
      boundary = destination.push(completeBoundaryScriptEnd2);
      return writeBootstrap2(destination, request) && boundary;
    }
    function flushPartiallyCompletedSegment2(request, destination, boundary, segment) {
      if (segment.status === FLUSHED2)
        return true;
      var hoistableState = boundary.contentState, segmentID = segment.id;
      if (segmentID === -1) {
        if ((segment.id = boundary.rootSegmentID) === -1)
          throw Error("A root segment ID must have been assigned by now. This is a bug in React.");
        return flushSegmentContainer2(request, destination, segment, hoistableState);
      }
      if (segmentID === boundary.rootSegmentID)
        return flushSegmentContainer2(request, destination, segment, hoistableState);
      flushSegmentContainer2(request, destination, segment, hoistableState);
      boundary = request.resumableState;
      request = request.renderState;
      destination.push(request.startInlineScript);
      destination.push(endOfStartTag2);
      (boundary.instructions & SentCompleteSegmentFunction2) === NothingSent2 ? (boundary.instructions |= SentCompleteSegmentFunction2, destination.push(completeSegmentScript1Full2)) : destination.push(completeSegmentScript1Partial2);
      destination.push(request.segmentPrefix);
      segmentID = segmentID.toString(16);
      destination.push(segmentID);
      destination.push(completeSegmentScript22);
      destination.push(request.placeholderPrefix);
      destination.push(segmentID);
      destination = destination.push(completeSegmentScriptEnd2);
      return destination;
    }
    function flushCompletedQueues2(request, destination) {
      try {
        if (!(0 < request.pendingRootTasks)) {
          var i2, completedRootSegment = request.completedRootSegment;
          if (completedRootSegment !== null) {
            if (completedRootSegment.status === POSTPONED2)
              return;
            var completedPreambleSegments = request.completedPreambleSegments;
            if (completedPreambleSegments === null)
              return;
            flushedByteSize2 = request.byteSize;
            var { resumableState, renderState } = request, preamble = renderState.preamble, htmlChunks = preamble.htmlChunks, headChunks = preamble.headChunks, i$jscomp$0;
            if (htmlChunks) {
              for (i$jscomp$0 = 0;i$jscomp$0 < htmlChunks.length; i$jscomp$0++)
                destination.push(htmlChunks[i$jscomp$0]);
              if (headChunks)
                for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
                  destination.push(headChunks[i$jscomp$0]);
              else {
                var chunk = startChunkForTag2("head");
                destination.push(chunk);
                destination.push(endOfStartTag2);
              }
            } else if (headChunks)
              for (i$jscomp$0 = 0;i$jscomp$0 < headChunks.length; i$jscomp$0++)
                destination.push(headChunks[i$jscomp$0]);
            var charsetChunks = renderState.charsetChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < charsetChunks.length; i$jscomp$0++)
              destination.push(charsetChunks[i$jscomp$0]);
            charsetChunks.length = 0;
            renderState.preconnects.forEach(flushResource2, destination);
            renderState.preconnects.clear();
            var viewportChunks = renderState.viewportChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < viewportChunks.length; i$jscomp$0++)
              destination.push(viewportChunks[i$jscomp$0]);
            viewportChunks.length = 0;
            renderState.fontPreloads.forEach(flushResource2, destination);
            renderState.fontPreloads.clear();
            renderState.highImagePreloads.forEach(flushResource2, destination);
            renderState.highImagePreloads.clear();
            currentlyFlushingRenderState2 = renderState;
            renderState.styles.forEach(flushStylesInPreamble2, destination);
            currentlyFlushingRenderState2 = null;
            var importMapChunks = renderState.importMapChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < importMapChunks.length; i$jscomp$0++)
              destination.push(importMapChunks[i$jscomp$0]);
            importMapChunks.length = 0;
            renderState.bootstrapScripts.forEach(flushResource2, destination);
            renderState.scripts.forEach(flushResource2, destination);
            renderState.scripts.clear();
            renderState.bulkPreloads.forEach(flushResource2, destination);
            renderState.bulkPreloads.clear();
            resumableState.instructions |= SentCompletedShellId2;
            var hoistableChunks = renderState.hoistableChunks;
            for (i$jscomp$0 = 0;i$jscomp$0 < hoistableChunks.length; i$jscomp$0++)
              destination.push(hoistableChunks[i$jscomp$0]);
            for (resumableState = hoistableChunks.length = 0;resumableState < completedPreambleSegments.length; resumableState++) {
              var segments = completedPreambleSegments[resumableState];
              for (renderState = 0;renderState < segments.length; renderState++)
                flushSegment2(request, destination, segments[renderState], null);
            }
            var preamble$jscomp$0 = request.renderState.preamble, headChunks$jscomp$0 = preamble$jscomp$0.headChunks;
            if (preamble$jscomp$0.htmlChunks || headChunks$jscomp$0) {
              var chunk$jscomp$0 = endChunkForTag2("head");
              destination.push(chunk$jscomp$0);
            }
            var bodyChunks = preamble$jscomp$0.bodyChunks;
            if (bodyChunks)
              for (completedPreambleSegments = 0;completedPreambleSegments < bodyChunks.length; completedPreambleSegments++)
                destination.push(bodyChunks[completedPreambleSegments]);
            flushSegment2(request, destination, completedRootSegment, null);
            request.completedRootSegment = null;
            var renderState$jscomp$0 = request.renderState;
            if (request.allPendingTasks !== 0 || request.clientRenderedBoundaries.length !== 0 || request.completedBoundaries.length !== 0 || request.trackedPostpones !== null && (request.trackedPostpones.rootNodes.length !== 0 || request.trackedPostpones.rootSlots !== null)) {
              var resumableState$jscomp$0 = request.resumableState;
              if ((resumableState$jscomp$0.instructions & SentMarkShellTime2) === NothingSent2) {
                resumableState$jscomp$0.instructions |= SentMarkShellTime2;
                destination.push(renderState$jscomp$0.startInlineScript);
                if ((resumableState$jscomp$0.instructions & SentCompletedShellId2) === NothingSent2) {
                  resumableState$jscomp$0.instructions |= SentCompletedShellId2;
                  var shellId = "_" + resumableState$jscomp$0.idPrefix + "R_";
                  destination.push(completedShellIdAttributeStart2);
                  var chunk$jscomp$1 = escapeTextForBrowser2(shellId);
                  destination.push(chunk$jscomp$1);
                  destination.push(attributeEnd2);
                }
                destination.push(endOfStartTag2);
                destination.push(shellTimeRuntimeScript2);
                destination.push(endInlineScript2);
              }
            }
            writeBootstrap2(destination, renderState$jscomp$0);
          }
          var renderState$jscomp$1 = request.renderState;
          completedRootSegment = 0;
          var viewportChunks$jscomp$0 = renderState$jscomp$1.viewportChunks;
          for (completedRootSegment = 0;completedRootSegment < viewportChunks$jscomp$0.length; completedRootSegment++)
            destination.push(viewportChunks$jscomp$0[completedRootSegment]);
          viewportChunks$jscomp$0.length = 0;
          renderState$jscomp$1.preconnects.forEach(flushResource2, destination);
          renderState$jscomp$1.preconnects.clear();
          renderState$jscomp$1.fontPreloads.forEach(flushResource2, destination);
          renderState$jscomp$1.fontPreloads.clear();
          renderState$jscomp$1.highImagePreloads.forEach(flushResource2, destination);
          renderState$jscomp$1.highImagePreloads.clear();
          renderState$jscomp$1.styles.forEach(preloadLateStyles2, destination);
          renderState$jscomp$1.scripts.forEach(flushResource2, destination);
          renderState$jscomp$1.scripts.clear();
          renderState$jscomp$1.bulkPreloads.forEach(flushResource2, destination);
          renderState$jscomp$1.bulkPreloads.clear();
          var hoistableChunks$jscomp$0 = renderState$jscomp$1.hoistableChunks;
          for (completedRootSegment = 0;completedRootSegment < hoistableChunks$jscomp$0.length; completedRootSegment++)
            destination.push(hoistableChunks$jscomp$0[completedRootSegment]);
          hoistableChunks$jscomp$0.length = 0;
          var clientRenderedBoundaries = request.clientRenderedBoundaries;
          for (i2 = 0;i2 < clientRenderedBoundaries.length; i2++) {
            var boundary = clientRenderedBoundaries[i2];
            renderState$jscomp$1 = destination;
            var { resumableState: resumableState$jscomp$1, renderState: renderState$jscomp$2 } = request, id = boundary.rootSegmentID, errorDigest = boundary.errorDigest, errorMessage = boundary.errorMessage, errorStack = boundary.errorStack, errorComponentStack = boundary.errorComponentStack;
            renderState$jscomp$1.push(renderState$jscomp$2.startInlineScript);
            renderState$jscomp$1.push(endOfStartTag2);
            (resumableState$jscomp$1.instructions & SentClientRenderFunction2) === NothingSent2 ? (resumableState$jscomp$1.instructions |= SentClientRenderFunction2, renderState$jscomp$1.push(clientRenderScript1Full2)) : renderState$jscomp$1.push(clientRenderScript1Partial2);
            renderState$jscomp$1.push(renderState$jscomp$2.boundaryPrefix);
            var chunk$jscomp$2 = id.toString(16);
            renderState$jscomp$1.push(chunk$jscomp$2);
            renderState$jscomp$1.push(clientRenderScript1A2);
            if (errorDigest || errorMessage || errorStack || errorComponentStack) {
              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$3 = escapeJSStringsForInstructionScripts2(errorDigest || "");
              renderState$jscomp$1.push(chunk$jscomp$3);
            }
            if (errorMessage || errorStack || errorComponentStack) {
              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$4 = escapeJSStringsForInstructionScripts2(errorMessage || "");
              renderState$jscomp$1.push(chunk$jscomp$4);
            }
            if (errorStack || errorComponentStack) {
              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$5 = escapeJSStringsForInstructionScripts2(errorStack || "");
              renderState$jscomp$1.push(chunk$jscomp$5);
            }
            if (errorComponentStack) {
              renderState$jscomp$1.push(clientRenderErrorScriptArgInterstitial2);
              var chunk$jscomp$6 = escapeJSStringsForInstructionScripts2(errorComponentStack);
              renderState$jscomp$1.push(chunk$jscomp$6);
            }
            var JSCompiler_inline_result = renderState$jscomp$1.push(clientRenderScriptEnd2);
            if (!JSCompiler_inline_result) {
              request.destination = null;
              i2++;
              clientRenderedBoundaries.splice(0, i2);
              return;
            }
          }
          clientRenderedBoundaries.splice(0, i2);
          var completedBoundaries = request.completedBoundaries;
          for (i2 = 0;i2 < completedBoundaries.length; i2++)
            if (!flushCompletedBoundary2(request, destination, completedBoundaries[i2])) {
              request.destination = null;
              i2++;
              completedBoundaries.splice(0, i2);
              return;
            }
          completedBoundaries.splice(0, i2);
          flushingPartialBoundaries2 = true;
          var partialBoundaries = request.partialBoundaries;
          for (i2 = 0;i2 < partialBoundaries.length; i2++) {
            a: {
              clientRenderedBoundaries = request;
              boundary = destination;
              var boundary$jscomp$0 = partialBoundaries[i2];
              flushedByteSize2 = boundary$jscomp$0.byteSize;
              var completedSegments = boundary$jscomp$0.completedSegments;
              for (JSCompiler_inline_result = 0;JSCompiler_inline_result < completedSegments.length; JSCompiler_inline_result++)
                if (!flushPartiallyCompletedSegment2(clientRenderedBoundaries, boundary, boundary$jscomp$0, completedSegments[JSCompiler_inline_result])) {
                  JSCompiler_inline_result++;
                  completedSegments.splice(0, JSCompiler_inline_result);
                  var JSCompiler_inline_result$jscomp$0 = false;
                  break a;
                }
              completedSegments.splice(0, JSCompiler_inline_result);
              var row = boundary$jscomp$0.row;
              row !== null && row.together && boundary$jscomp$0.pendingTasks === 1 && (row.pendingTasks === 1 ? unblockSuspenseListRow2(clientRenderedBoundaries, row, row.hoistables) : row.pendingTasks--);
              JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary2(boundary, boundary$jscomp$0.contentState, clientRenderedBoundaries.renderState);
            }
            if (!JSCompiler_inline_result$jscomp$0) {
              request.destination = null;
              i2++;
              partialBoundaries.splice(0, i2);
              return;
            }
          }
          partialBoundaries.splice(0, i2);
          flushingPartialBoundaries2 = false;
          var largeBoundaries = request.completedBoundaries;
          for (i2 = 0;i2 < largeBoundaries.length; i2++)
            if (!flushCompletedBoundary2(request, destination, largeBoundaries[i2])) {
              request.destination = null;
              i2++;
              largeBoundaries.splice(0, i2);
              return;
            }
          largeBoundaries.splice(0, i2);
        }
      } finally {
        flushingPartialBoundaries2 = false, request.allPendingTasks === 0 && request.clientRenderedBoundaries.length === 0 && request.completedBoundaries.length === 0 && (request.flushScheduled = false, i2 = request.resumableState, i2.hasBody && (partialBoundaries = endChunkForTag2("body"), destination.push(partialBoundaries)), i2.hasHtml && (i2 = endChunkForTag2("html"), destination.push(i2)), request.abortableTasks.size !== 0 && console.error("There was still abortable task at the root when we closed. This is a bug in React."), request.status = CLOSED2, destination.push(null), request.destination = null);
      }
    }
    function startWork2(request) {
      request.flushScheduled = request.destination !== null;
      performWork2(request);
      request.status === 10 && (request.status = 11);
      request.trackedPostpones === null && safelyEmitEarlyPreloads2(request, request.pendingRootTasks === 0);
    }
    function enqueueFlush2(request) {
      if (request.flushScheduled === false && request.pingedTasks.length === 0 && request.destination !== null) {
        request.flushScheduled = true;
        var destination = request.destination;
        destination ? flushCompletedQueues2(request, destination) : request.flushScheduled = false;
      }
    }
    function startFlowing(request, destination) {
      if (request.status === 13)
        request.status = CLOSED2, destination.destroy(request.fatalError);
      else if (request.status !== CLOSED2 && request.destination === null) {
        request.destination = destination;
        try {
          flushCompletedQueues2(request, destination);
        } catch (error40) {
          destination = {}, logRecoverableError2(request, error40, destination, null), fatalError2(request, error40, destination, null);
        }
      }
    }
    function abort2(request, reason) {
      if (request.status === 11 || request.status === 10)
        request.status = 12;
      try {
        var abortableTasks = request.abortableTasks;
        if (0 < abortableTasks.size) {
          var error40 = reason === undefined ? Error("The render was aborted by the server without a reason.") : typeof reason === "object" && reason !== null && typeof reason.then === "function" ? Error("The render was aborted by the server with a promise.") : reason;
          request.fatalError = error40;
          abortableTasks.forEach(function(task) {
            var prevTaskInDEV = currentTaskInDEV2, prevGetCurrentStackImpl = ReactSharedInternals2.getCurrentStack;
            currentTaskInDEV2 = task;
            ReactSharedInternals2.getCurrentStack = getCurrentStackInDEV2;
            try {
              abortTask2(task, request, error40);
            } finally {
              currentTaskInDEV2 = prevTaskInDEV, ReactSharedInternals2.getCurrentStack = prevGetCurrentStackImpl;
            }
          });
          abortableTasks.clear();
        }
        request.destination !== null && flushCompletedQueues2(request, request.destination);
      } catch (error$4) {
        reason = {}, logRecoverableError2(request, error$4, reason, null), fatalError2(request, error$4, reason, null);
      }
    }
    function addToReplayParent2(node, parentKeyPath, trackedPostpones) {
      if (parentKeyPath === null)
        trackedPostpones.rootNodes.push(node);
      else {
        var workingMap = trackedPostpones.workingMap, parentNode = workingMap.get(parentKeyPath);
        parentNode === undefined && (parentNode = [parentKeyPath[1], parentKeyPath[2], [], null], workingMap.set(parentKeyPath, parentNode), addToReplayParent2(parentNode, parentKeyPath[0], trackedPostpones));
        parentNode[2].push(node);
      }
    }
    function onError() {}
    function renderToStringImpl(children, options, generateStaticMarkup, abortReason) {
      var didFatal = false, fatalError3 = null, result = "", readyToStream = false;
      options = createResumableState2(options ? options.identifierPrefix : undefined);
      children = createRequest2(children, options, createRenderState2(options, generateStaticMarkup), createFormatContext2(ROOT_HTML_MODE2, null, 0, null), Infinity, onError, undefined, function() {
        readyToStream = true;
      }, undefined, undefined, undefined);
      startWork2(children);
      abort2(children, abortReason);
      startFlowing(children, {
        push: function(chunk) {
          chunk !== null && (result += chunk);
          return true;
        },
        destroy: function(error40) {
          didFatal = true;
          fatalError3 = error40;
        }
      });
      if (didFatal && fatalError3 !== abortReason)
        throw fatalError3;
      if (!readyToStream)
        throw Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
      return result;
    }
    var REACT_ELEMENT_TYPE2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE2 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE2 = Symbol.for("react.lazy"), REACT_SCOPE_TYPE2 = Symbol.for("react.scope"), REACT_ACTIVITY_TYPE2 = Symbol.for("react.activity"), REACT_LEGACY_HIDDEN_TYPE2 = Symbol.for("react.legacy_hidden"), REACT_MEMO_CACHE_SENTINEL2 = Symbol.for("react.memo_cache_sentinel"), REACT_VIEW_TRANSITION_TYPE2 = Symbol.for("react.view_transition"), MAYBE_ITERATOR_SYMBOL2 = Symbol.iterator, isArrayImpl2 = Array.isArray, jsxPropsParents2 = new WeakMap, jsxChildrenParents2 = new WeakMap, CLIENT_REFERENCE_TAG2 = Symbol.for("react.client.reference"), assign2 = Object.assign, hasOwnProperty2 = Object.prototype.hasOwnProperty, VALID_ATTRIBUTE_NAME_REGEX2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), illegalAttributeNameCache2 = {}, validatedAttributeNameCache2 = {}, unitlessNumbers2 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")), aliases2 = new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), hasReadOnlyValue2 = {
      button: true,
      checkbox: true,
      image: true,
      hidden: true,
      radio: true,
      reset: true,
      submit: true
    }, ariaProperties2 = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0,
      "aria-braillelabel": 0,
      "aria-brailleroledescription": 0,
      "aria-colindextext": 0,
      "aria-rowindextext": 0
    }, warnedProperties$12 = {}, rARIA$12 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel$12 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), didWarnValueNull2 = false, possibleStandardNames2 = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, warnedProperties2 = {}, EVENT_NAME_REGEX2 = /^on./, INVALID_EVENT_NAME_REGEX2 = /^on[^A-Z]/, rARIA2 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), rARIACamel2 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), badVendoredStyleNamePattern2 = /^(?:webkit|moz|o)[A-Z]/, msPattern$12 = /^-ms-/, hyphenPattern2 = /-(.)/g, badStyleValueWithSemicolonPattern2 = /;\s*$/, warnedStyleNames2 = {}, warnedStyleValues2 = {}, warnedForNaNValue2 = false, warnedForInfinityValue2 = false, matchHtmlRegExp2 = /["'&<>]/, uppercasePattern2 = /([A-Z])/g, msPattern2 = /^ms-/, isJavaScriptProtocol2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, ReactSharedInternals2 = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals2 = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending2 = Object.freeze({
      pending: false,
      data: null,
      method: null,
      action: null
    }), previousDispatcher2 = ReactDOMSharedInternals2.d;
    ReactDOMSharedInternals2.d = {
      f: previousDispatcher2.f,
      r: previousDispatcher2.r,
      D: function(href) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (typeof href === "string" && href) {
            if (!resumableState.dnsResources.hasOwnProperty(href)) {
              resumableState.dnsResources[href] = EXISTS2;
              resumableState = renderState.headers;
              var header, JSCompiler_temp;
              if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity)
                JSCompiler_temp = (header = "<" + escapeHrefForLinkHeaderURLContext2(href) + ">; rel=dns-prefetch", 0 <= (resumableState.remainingCapacity -= header.length + 2));
              JSCompiler_temp ? (renderState.resets.dns[href] = EXISTS2, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (header = [], pushLinkImpl2(header, { href, rel: "dns-prefetch" }), renderState.preconnects.add(header));
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.D(href);
      },
      C: function(href, crossOrigin) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (typeof href === "string" && href) {
            var bucket = crossOrigin === "use-credentials" ? "credentials" : typeof crossOrigin === "string" ? "anonymous" : "default";
            if (!resumableState.connectResources[bucket].hasOwnProperty(href)) {
              resumableState.connectResources[bucket][href] = EXISTS2;
              resumableState = renderState.headers;
              var header, JSCompiler_temp;
              if (JSCompiler_temp = resumableState && 0 < resumableState.remainingCapacity) {
                JSCompiler_temp = "<" + escapeHrefForLinkHeaderURLContext2(href) + ">; rel=preconnect";
                if (typeof crossOrigin === "string") {
                  var escapedCrossOrigin = escapeStringForLinkHeaderQuotedParamValueContext2(crossOrigin, "crossOrigin");
                  JSCompiler_temp += '; crossorigin="' + escapedCrossOrigin + '"';
                }
                JSCompiler_temp = (header = JSCompiler_temp, 0 <= (resumableState.remainingCapacity -= header.length + 2));
              }
              JSCompiler_temp ? (renderState.resets.connect[bucket][href] = EXISTS2, resumableState.preconnects && (resumableState.preconnects += ", "), resumableState.preconnects += header) : (bucket = [], pushLinkImpl2(bucket, {
                rel: "preconnect",
                href,
                crossOrigin
              }), renderState.preconnects.add(bucket));
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.C(href, crossOrigin);
      },
      L: function(href, as, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (as && href) {
            switch (as) {
              case "image":
                if (options) {
                  var imageSrcSet = options.imageSrcSet;
                  var imageSizes = options.imageSizes;
                  var fetchPriority = options.fetchPriority;
                }
                var key = imageSrcSet ? imageSrcSet + `
` + (imageSizes || "") : href;
                if (resumableState.imageResources.hasOwnProperty(key))
                  return;
                resumableState.imageResources[key] = PRELOAD_NO_CREDS2;
                resumableState = renderState.headers;
                var header;
                resumableState && 0 < resumableState.remainingCapacity && typeof imageSrcSet !== "string" && fetchPriority === "high" && (header = getPreloadAsHeader2(href, as, options), 0 <= (resumableState.remainingCapacity -= header.length + 2)) ? (renderState.resets.image[key] = PRELOAD_NO_CREDS2, resumableState.highImagePreloads && (resumableState.highImagePreloads += ", "), resumableState.highImagePreloads += header) : (resumableState = [], pushLinkImpl2(resumableState, assign2({
                  rel: "preload",
                  href: imageSrcSet ? undefined : href,
                  as
                }, options)), fetchPriority === "high" ? renderState.highImagePreloads.add(resumableState) : (renderState.bulkPreloads.add(resumableState), renderState.preloads.images.set(key, resumableState)));
                break;
              case "style":
                if (resumableState.styleResources.hasOwnProperty(href))
                  return;
                imageSrcSet = [];
                pushLinkImpl2(imageSrcSet, assign2({ rel: "preload", href, as }, options));
                resumableState.styleResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                renderState.preloads.stylesheets.set(href, imageSrcSet);
                renderState.bulkPreloads.add(imageSrcSet);
                break;
              case "script":
                if (resumableState.scriptResources.hasOwnProperty(href))
                  return;
                imageSrcSet = [];
                renderState.preloads.scripts.set(href, imageSrcSet);
                renderState.bulkPreloads.add(imageSrcSet);
                pushLinkImpl2(imageSrcSet, assign2({ rel: "preload", href, as }, options));
                resumableState.scriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                break;
              default:
                if (resumableState.unknownResources.hasOwnProperty(as)) {
                  if (imageSrcSet = resumableState.unknownResources[as], imageSrcSet.hasOwnProperty(href))
                    return;
                } else
                  imageSrcSet = {}, resumableState.unknownResources[as] = imageSrcSet;
                imageSrcSet[href] = PRELOAD_NO_CREDS2;
                if ((resumableState = renderState.headers) && 0 < resumableState.remainingCapacity && as === "font" && (key = getPreloadAsHeader2(href, as, options), 0 <= (resumableState.remainingCapacity -= key.length + 2)))
                  renderState.resets.font[href] = PRELOAD_NO_CREDS2, resumableState.fontPreloads && (resumableState.fontPreloads += ", "), resumableState.fontPreloads += key;
                else
                  switch (resumableState = [], href = assign2({ rel: "preload", href, as }, options), pushLinkImpl2(resumableState, href), as) {
                    case "font":
                      renderState.fontPreloads.add(resumableState);
                      break;
                    default:
                      renderState.bulkPreloads.add(resumableState);
                  }
            }
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.L(href, as, options);
      },
      m: function(href, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (href) {
            var as = options && typeof options.as === "string" ? options.as : "script";
            switch (as) {
              case "script":
                if (resumableState.moduleScriptResources.hasOwnProperty(href))
                  return;
                as = [];
                resumableState.moduleScriptResources[href] = !options || typeof options.crossOrigin !== "string" && typeof options.integrity !== "string" ? PRELOAD_NO_CREDS2 : [options.crossOrigin, options.integrity];
                renderState.preloads.moduleScripts.set(href, as);
                break;
              default:
                if (resumableState.moduleUnknownResources.hasOwnProperty(as)) {
                  var resources = resumableState.unknownResources[as];
                  if (resources.hasOwnProperty(href))
                    return;
                } else
                  resources = {}, resumableState.moduleUnknownResources[as] = resources;
                as = [];
                resources[href] = PRELOAD_NO_CREDS2;
            }
            pushLinkImpl2(as, assign2({ rel: "modulepreload", href }, options));
            renderState.bulkPreloads.add(as);
            enqueueFlush2(request);
          }
        } else
          previousDispatcher2.m(href, options);
      },
      X: function(src, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (src) {
            var resourceState = resumableState.scriptResources.hasOwnProperty(src) ? resumableState.scriptResources[src] : undefined;
            resourceState !== EXISTS2 && (resumableState.scriptResources[src] = EXISTS2, options = assign2({ src, async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(options, resourceState), src = renderState.preloads.scripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl2(src, options), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.X(src, options);
      },
      S: function(href, precedence, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (href) {
            precedence = precedence || "default";
            var styleQueue = renderState.styles.get(precedence), resourceState = resumableState.styleResources.hasOwnProperty(href) ? resumableState.styleResources[href] : undefined;
            resourceState !== EXISTS2 && (resumableState.styleResources[href] = EXISTS2, styleQueue || (styleQueue = {
              precedence: escapeTextForBrowser2(precedence),
              rules: [],
              hrefs: [],
              sheets: new Map
            }, renderState.styles.set(precedence, styleQueue)), precedence = {
              state: PENDING$12,
              props: assign2({
                rel: "stylesheet",
                href,
                "data-precedence": precedence
              }, options)
            }, resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(precedence.props, resourceState), (renderState = renderState.preloads.stylesheets.get(href)) && 0 < renderState.length ? renderState.length = 0 : precedence.state = PRELOADED2), styleQueue.sheets.set(href, precedence), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.S(href, precedence, options);
      },
      M: function(src, options) {
        var request = currentRequest2 ? currentRequest2 : null;
        if (request) {
          var { resumableState, renderState } = request;
          if (src) {
            var resourceState = resumableState.moduleScriptResources.hasOwnProperty(src) ? resumableState.moduleScriptResources[src] : undefined;
            resourceState !== EXISTS2 && (resumableState.moduleScriptResources[src] = EXISTS2, options = assign2({ src, type: "module", async: true }, options), resourceState && (resourceState.length === 2 && adoptPreloadCredentials2(options, resourceState), src = renderState.preloads.moduleScripts.get(src)) && (src.length = 0), src = [], renderState.scripts.add(src), pushScriptImpl2(src, options), enqueueFlush2(request));
          }
        } else
          previousDispatcher2.M(src, options);
      }
    };
    var NothingSent2 = 0, SentCompleteSegmentFunction2 = 1, SentCompleteBoundaryFunction2 = 2, SentClientRenderFunction2 = 4, SentStyleInsertionFunction2 = 8, SentCompletedShellId2 = 32, SentMarkShellTime2 = 64, EXISTS2 = null, PRELOAD_NO_CREDS2 = [];
    Object.freeze(PRELOAD_NO_CREDS2);
    var currentlyFlushingRenderState2 = null, endInlineScript2 = "</script>", scriptRegex2 = /(<\/|<)(s)(cript)/gi;
    var didWarnForNewBooleanPropsWithEmptyValue2 = {};
    var ROOT_HTML_MODE2 = 0, HTML_HTML_MODE2 = 1, HTML_MODE2 = 2, HTML_HEAD_MODE2 = 3, SVG_MODE2 = 4, MATHML_MODE2 = 5, HTML_TABLE_MODE2 = 6, HTML_TABLE_BODY_MODE2 = 7, HTML_TABLE_ROW_MODE2 = 8, HTML_COLGROUP_MODE2 = 9, styleNameCache2 = new Map, styleAttributeStart2 = ' style="', styleAssign2 = ":", styleSeparator2 = ";", attributeSeparator2 = " ", attributeAssign2 = '="', attributeEnd2 = '"', attributeEmptyString2 = '=""', actionJavaScriptURL2 = escapeTextForBrowser2("javascript:throw new Error('React form unexpectedly submitted.')"), endOfStartTag2 = ">", endOfStartTagSelfClosing2 = "/>", didWarnDefaultInputValue2 = false, didWarnDefaultChecked2 = false, didWarnDefaultSelectValue2 = false, didWarnDefaultTextareaValue2 = false, didWarnInvalidOptionChildren2 = false, didWarnInvalidOptionInnerHTML2 = false, didWarnSelectedSetOnOption2 = false, didWarnFormActionType2 = false, didWarnFormActionName2 = false, didWarnFormActionTarget2 = false, didWarnFormActionMethod2 = false, formReplayingRuntimeScript2 = `addEventListener("submit",function(a){if(!a.defaultPrevented){var c=a.target,d=a.submitter,e=c.action,b=d;if(d){var f=d.getAttribute("formAction");null!=f&&(e=f,b=null)}"javascript:throw new Error('React form unexpectedly submitted.')"===e&&(a.preventDefault(),b?(a=document.createElement("input"),a.name=b.name,a.value=b.value,b.parentNode.insertBefore(a,b),b=new FormData(c),a.parentNode.removeChild(a)):b=new FormData(c),a=c.ownerDocument||c,(a.$$reactFormReplay=a.$$reactFormReplay||[]).push(c,d,b))}});`, styleRegex2 = /(<\/|<)(s)(tyle)/gi, leadingNewline = `
`, VALID_TAG_REGEX2 = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, validatedTagCache2 = new Map, endTagCache2 = new Map, shellTimeRuntimeScript2 = "requestAnimationFrame(function(){$RT=performance.now()});", placeholder12 = '<template id="', placeholder22 = '"></template>', startCompletedSuspenseBoundary2 = "<!--$-->", startPendingSuspenseBoundary12 = '<!--$?--><template id="', startPendingSuspenseBoundary22 = '"></template>', startClientRenderedSuspenseBoundary2 = "<!--$!-->", endSuspenseBoundary2 = "<!--/$-->", clientRenderedSuspenseBoundaryError12 = "<template", clientRenderedSuspenseBoundaryErrorAttrInterstitial2 = '"', clientRenderedSuspenseBoundaryError1A2 = ' data-dgst="', clientRenderedSuspenseBoundaryError1B2 = ' data-msg="', clientRenderedSuspenseBoundaryError1C2 = ' data-stck="', clientRenderedSuspenseBoundaryError1D2 = ' data-cstck="', clientRenderedSuspenseBoundaryError22 = "></template>", startSegmentHTML3 = '<div hidden id="', startSegmentHTML22 = '">', endSegmentHTML2 = "</div>", startSegmentSVG3 = '<svg aria-hidden="true" style="display:none" id="', startSegmentSVG22 = '">', endSegmentSVG2 = "</svg>", startSegmentMathML3 = '<math aria-hidden="true" style="display:none" id="', startSegmentMathML22 = '">', endSegmentMathML2 = "</math>", startSegmentTable3 = '<table hidden id="', startSegmentTable22 = '">', endSegmentTable2 = "</table>", startSegmentTableBody3 = '<table hidden><tbody id="', startSegmentTableBody22 = '">', endSegmentTableBody2 = "</tbody></table>", startSegmentTableRow3 = '<table hidden><tr id="', startSegmentTableRow22 = '">', endSegmentTableRow2 = "</tr></table>", startSegmentColGroup3 = '<table hidden><colgroup id="', startSegmentColGroup22 = '">', endSegmentColGroup2 = "</colgroup></table>", completeSegmentScript1Full2 = '$RS=function(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("', completeSegmentScript1Partial2 = '$RS("', completeSegmentScript22 = '","', completeSegmentScriptEnd2 = '")</script>', completeBoundaryScriptFunctionOnly2 = `$RB=[];$RV=function(a){$RT=performance.now();for(var b=0;b<a.length;b+=2){var c=a[b],e=a[b+1];null!==e.parentNode&&e.parentNode.removeChild(e);var f=c.parentNode;if(f){var g=c.previousSibling,h=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d||"/&"===d)if(0===h)break;else h--;else"$"!==d&&"$?"!==d&&"$~"!==d&&"$!"!==d&&"&"!==d||h++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;e.firstChild;)f.insertBefore(e.firstChild,c);g.data="$";g._reactRetry&&requestAnimationFrame(g._reactRetry)}}a.length=0};
$RC=function(a,b){if(b=document.getElementById(b))(a=document.getElementById(a))?(a.previousSibling.data="$~",$RB.push(a,b),2===$RB.length&&("number"!==typeof $RT?requestAnimationFrame($RV.bind(null,$RB)):(a=performance.now(),setTimeout($RV.bind(null,$RB),2300>a&&2E3<a?2300-a:$RT+300-a)))):b.parentNode.removeChild(b)};`, completeBoundaryScript1Partial2 = '$RC("', completeBoundaryWithStylesScript1FullPartial2 = `$RM=new Map;$RR=function(n,w,p){function u(q){this._p=null;q()}for(var r=new Map,t=document,h,b,e=t.querySelectorAll("link[data-precedence],style[data-precedence]"),v=[],k=0;b=e[k++];)"not all"===b.getAttribute("media")?v.push(b):("LINK"===b.tagName&&$RM.set(b.getAttribute("href"),b),r.set(b.dataset.precedence,h=b));e=0;b=[];var l,a;for(k=!0;;){if(k){var f=p[e++];if(!f){k=!1;e=0;continue}var c=!1,m=0;var d=f[m++];if(a=$RM.get(d)){var g=a._p;c=!0}else{a=t.createElement("link");a.href=d;a.rel=
"stylesheet";for(a.dataset.precedence=l=f[m++];g=f[m++];)a.setAttribute(g,f[m++]);g=a._p=new Promise(function(q,x){a.onload=u.bind(a,q);a.onerror=u.bind(a,x)});$RM.set(d,a)}d=a.getAttribute("media");!g||d&&!matchMedia(d).matches||b.push(g);if(c)continue}else{a=v[e++];if(!a)break;l=a.getAttribute("data-precedence");a.removeAttribute("media")}c=r.get(l)||h;c===h&&(h=a);r.set(l,a);c?c.parentNode.insertBefore(a,c.nextSibling):(c=t.head,c.insertBefore(a,c.firstChild))}if(p=document.getElementById(n))p.previousSibling.data=
"$~";Promise.all(b).then($RC.bind(null,n,w),$RX.bind(null,n,"CSS failed to load"))};$RR("`, completeBoundaryWithStylesScript1Partial2 = '$RR("', completeBoundaryScript22 = '","', completeBoundaryScript3a2 = '",', completeBoundaryScript3b2 = '"', completeBoundaryScriptEnd2 = ")</script>", clientRenderScriptFunctionOnly2 = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};', clientRenderScript1Full2 = '$RX=function(b,c,d,e,f){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),f&&(a.cstck=f),b._reactRetry&&b._reactRetry())};;$RX("', clientRenderScript1Partial2 = '$RX("', clientRenderScript1A2 = '"', clientRenderErrorScriptArgInterstitial2 = ",", clientRenderScriptEnd2 = ")</script>", regexForJSStringsInInstructionScripts2 = /[<\u2028\u2029]/g, regexForJSStringsInScripts2 = /[&><\u2028\u2029]/g, lateStyleTagResourceOpen12 = ' media="not all" data-precedence="', lateStyleTagResourceOpen22 = '" data-href="', lateStyleTagResourceOpen32 = '">', lateStyleTagTemplateClose2 = "</style>", currentlyRenderingBoundaryHasStylesToHoist2 = false, destinationHasCapacity2 = true, stylesheetFlushingQueue2 = [], styleTagResourceOpen12 = ' data-precedence="', styleTagResourceOpen22 = '" data-href="', spaceSeparator2 = " ", styleTagResourceOpen32 = '">', styleTagResourceClose2 = "</style>", completedShellIdAttributeStart2 = ' id="', arrayFirstOpenBracket2 = "[", arraySubsequentOpenBracket2 = ",[", arrayInterstitial2 = ",", arrayCloseBracket2 = "]", PENDING$12 = 0, PRELOADED2 = 1, PREAMBLE2 = 2, LATE2 = 3, regexForHrefInLinkHeaderURLContext2 = /[<>\r\n]/g, regexForLinkHeaderQuotedParamValueContext2 = /["';,\r\n]/g, doctypeChunk = "", bind2 = Function.prototype.bind, REACT_CLIENT_REFERENCE2 = Symbol.for("react.client.reference"), emptyContextObject2 = {};
    Object.freeze(emptyContextObject2);
    var rendererSigil2 = {};
    var currentActiveSnapshot2 = null, didWarnAboutNoopUpdateForComponent2 = {}, didWarnAboutDeprecatedWillMount2 = {};
    var didWarnAboutUninitializedState2 = new Set;
    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate2 = new Set;
    var didWarnAboutLegacyLifecyclesAndDerivedState2 = new Set;
    var didWarnAboutDirectlyAssigningPropsToState2 = new Set;
    var didWarnAboutUndefinedDerivedState2 = new Set;
    var didWarnAboutContextTypes$12 = new Set;
    var didWarnAboutChildContextTypes2 = new Set;
    var didWarnAboutInvalidateContextType2 = new Set;
    var didWarnOnInvalidCallback2 = new Set;
    var classComponentUpdater2 = {
      enqueueSetState: function(inst, payload, callback) {
        var internals = inst._reactInternals;
        internals.queue === null ? warnNoop2(inst, "setState") : (internals.queue.push(payload), callback !== undefined && callback !== null && warnOnInvalidCallback2(callback));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        inst.replace = true;
        inst.queue = [payload];
        callback !== undefined && callback !== null && warnOnInvalidCallback2(callback);
      },
      enqueueForceUpdate: function(inst, callback) {
        inst._reactInternals.queue === null ? warnNoop2(inst, "forceUpdate") : callback !== undefined && callback !== null && warnOnInvalidCallback2(callback);
      }
    }, emptyTreeContext2 = { id: 1, overflow: "" }, clz322 = Math.clz32 ? Math.clz32 : clz32Fallback2, log2 = Math.log, LN22 = Math.LN2, SuspenseException2 = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."), suspendedThenable2 = null, objectIs2 = typeof Object.is === "function" ? Object.is : is3, currentlyRenderingComponent2 = null, currentlyRenderingTask2 = null, currentlyRenderingRequest2 = null, currentlyRenderingKeyPath2 = null, firstWorkInProgressHook2 = null, workInProgressHook2 = null, isReRender2 = false, didScheduleRenderPhaseUpdate2 = false, localIdCounter2 = 0, actionStateCounter2 = 0, actionStateMatchingIndex2 = -1, thenableIndexCounter2 = 0, thenableState2 = null, renderPhaseUpdates2 = null, numberOfReRenders2 = 0, isInHookUserCodeInDev2 = false, currentHookNameInDev2, HooksDispatcher2 = {
      readContext: readContext2,
      use: function(usable) {
        if (usable !== null && typeof usable === "object") {
          if (typeof usable.then === "function")
            return unwrapThenable2(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE2)
            return readContext2(usable);
        }
        throw Error("An unsupported type was passed to use(): " + String(usable));
      },
      useContext: function(context) {
        currentHookNameInDev2 = "useContext";
        resolveCurrentlyRenderingComponent2();
        return context._currentValue2;
      },
      useMemo: useMemo2,
      useReducer: useReducer2,
      useRef: function(initialValue) {
        currentlyRenderingComponent2 = resolveCurrentlyRenderingComponent2();
        workInProgressHook2 = createWorkInProgressHook2();
        var previousRef = workInProgressHook2.memoizedState;
        return previousRef === null ? (initialValue = { current: initialValue }, Object.seal(initialValue), workInProgressHook2.memoizedState = initialValue) : previousRef;
      },
      useState: function(initialState) {
        currentHookNameInDev2 = "useState";
        return useReducer2(basicStateReducer2, initialState);
      },
      useInsertionEffect: noop4,
      useLayoutEffect: noop4,
      useCallback: function(callback, deps) {
        return useMemo2(function() {
          return callback;
        }, deps);
      },
      useImperativeHandle: noop4,
      useEffect: noop4,
      useDebugValue: noop4,
      useDeferredValue: function(value, initialValue) {
        resolveCurrentlyRenderingComponent2();
        return initialValue !== undefined ? initialValue : value;
      },
      useTransition: function() {
        resolveCurrentlyRenderingComponent2();
        return [false, unsupportedStartTransition2];
      },
      useId: function() {
        var treeId = currentlyRenderingTask2.treeContext;
        var overflow = treeId.overflow;
        treeId = treeId.id;
        treeId = (treeId & ~(1 << 32 - clz322(treeId) - 1)).toString(32) + overflow;
        var resumableState = currentResumableState2;
        if (resumableState === null)
          throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
        overflow = localIdCounter2++;
        treeId = "_" + resumableState.idPrefix + "R_" + treeId;
        0 < overflow && (treeId += "H" + overflow.toString(32));
        return treeId + "_";
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        if (getServerSnapshot === undefined)
          throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        return getServerSnapshot();
      },
      useOptimistic: function(passthrough) {
        resolveCurrentlyRenderingComponent2();
        return [passthrough, unsupportedSetOptimisticState2];
      },
      useActionState: useActionState2,
      useFormState: useActionState2,
      useHostTransitionStatus: function() {
        resolveCurrentlyRenderingComponent2();
        return NotPending2;
      },
      useMemoCache: function(size2) {
        for (var data = Array(size2), i2 = 0;i2 < size2; i2++)
          data[i2] = REACT_MEMO_CACHE_SENTINEL2;
        return data;
      },
      useCacheRefresh: function() {
        return unsupportedRefresh2;
      },
      useEffectEvent: function() {
        return throwOnUseEffectEventCall2;
      }
    }, currentResumableState2 = null, currentTaskInDEV2 = null, DefaultAsyncDispatcher2 = {
      getCacheForType: function() {
        throw Error("Not implemented.");
      },
      cacheSignal: function() {
        throw Error("Not implemented.");
      },
      getOwner: function() {
        return currentTaskInDEV2 === null ? null : currentTaskInDEV2.componentStack;
      }
    }, disabledDepth2 = 0, prevLog2, prevInfo2, prevWarn2, prevError2, prevGroup2, prevGroupCollapsed2, prevGroupEnd2;
    disabledLog2.__reactDisabledLog = true;
    var prefix2, suffix2, reentry2 = false;
    var componentFrameCache2 = new (typeof WeakMap === "function" ? WeakMap : Map);
    var callComponent2 = {
      react_stack_bottom_frame: function(Component, props, secondArg) {
        return Component(props, secondArg);
      }
    }, callComponentInDEV2 = callComponent2.react_stack_bottom_frame.bind(callComponent2), callRender2 = {
      react_stack_bottom_frame: function(instance) {
        return instance.render();
      }
    }, callRenderInDEV2 = callRender2.react_stack_bottom_frame.bind(callRender2), callLazyInit2 = {
      react_stack_bottom_frame: function(lazy2) {
        var init = lazy2._init;
        return init(lazy2._payload);
      }
    }, callLazyInitInDEV2 = callLazyInit2.react_stack_bottom_frame.bind(callLazyInit2), lastResetTime2 = 0;
    if (typeof performance === "object" && typeof performance.now === "function") {
      var localPerformance2 = performance;
      var getCurrentTime2 = function() {
        return localPerformance2.now();
      };
    } else {
      var localDate2 = Date;
      getCurrentTime2 = function() {
        return localDate2.now();
      };
    }
    var CLIENT_RENDERED2 = 4, PENDING2 = 0, COMPLETED2 = 1, FLUSHED2 = 2, ABORTED2 = 3, ERRORED2 = 4, POSTPONED2 = 5, CLOSED2 = 14, currentRequest2 = null, didWarnAboutBadClass2 = {}, didWarnAboutContextTypes2 = {}, didWarnAboutContextTypeOnFunctionComponent2 = {}, didWarnAboutGetDerivedStateOnFunctionComponent2 = {}, didWarnAboutReassigningProps2 = false, didWarnAboutGenerators2 = false, didWarnAboutMaps2 = false, flushedByteSize2 = 0, flushingPartialBoundaries2 = false;
    exports.renderToStaticMarkup = function(children, options) {
      return renderToStringImpl(children, options, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    exports.renderToString = function(children, options) {
      return renderToStringImpl(children, options, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    };
    exports.version = "19.2.0";
  })();
});

// node_modules/react-dom/server.bun.js
var exports_server_bun = {};
__export(exports_server_bun, {
  version: () => $version2,
  resume: () => $resume,
  renderToString: () => $renderToString,
  renderToStaticMarkup: () => $renderToStaticMarkup,
  renderToReadableStream: () => $renderToReadableStream2
});
var react_dom_server_legacy_browser_development, b2, l, $version2, $renderToReadableStream2, $resume, $renderToString, $renderToStaticMarkup;
var init_server_bun = __esm(() => {
  init_react_dom_server_bun_development();
  react_dom_server_legacy_browser_development = __toESM(require_react_dom_server_legacy_browser_development(), 1);
  if (false) {} else {
    b2 = exports_react_dom_server_bun_development;
    l = react_dom_server_legacy_browser_development;
  }
  $version2 = b2.version;
  $renderToReadableStream2 = b2.renderToReadableStream;
  $resume = b2.resume;
  $renderToString = l.renderToString;
  $renderToStaticMarkup = l.renderToStaticMarkup;
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS((exports) => {
  var React2 = __toESM(require_react(), 1);
  (function() {
    function getComponentNameFromType2(type) {
      if (type == null)
        return null;
      if (typeof type === "function")
        return type.$$typeof === REACT_CLIENT_REFERENCE2 ? null : type.displayName || type.name || null;
      if (typeof type === "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE2:
          return "Fragment";
        case REACT_PROFILER_TYPE2:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE2:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE2:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE2:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE2:
          return "Activity";
      }
      if (typeof type === "object")
        switch (typeof type.tag === "number" && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
          case REACT_PORTAL_TYPE2:
            return "Portal";
          case REACT_CONTEXT_TYPE2:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE2:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE2:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = type !== "" ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE2:
            return innerType = type.displayName || null, innerType !== null ? innerType : getComponentNameFromType2(type.type) || "Memo";
          case REACT_LAZY_TYPE2:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType2(type(innerType));
            } catch (x2) {}
        }
      return null;
    }
    function testStringCoercion2(value) {
      return "" + value;
    }
    function checkKeyStringCoercion(value) {
      try {
        testStringCoercion2(value);
        var JSCompiler_inline_result = false;
      } catch (e) {
        JSCompiler_inline_result = true;
      }
      if (JSCompiler_inline_result) {
        JSCompiler_inline_result = console;
        var JSCompiler_temp_const = JSCompiler_inline_result.error;
        var JSCompiler_inline_result$jscomp$0 = typeof Symbol === "function" && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
        return testStringCoercion2(value);
      }
    }
    function getTaskName(type) {
      if (type === REACT_FRAGMENT_TYPE2)
        return "<>";
      if (typeof type === "object" && type !== null && type.$$typeof === REACT_LAZY_TYPE2)
        return "<...>";
      try {
        var name = getComponentNameFromType2(type);
        return name ? "<" + name + ">" : "<...>";
      } catch (x2) {
        return "<...>";
      }
    }
    function getOwner() {
      var dispatcher = ReactSharedInternals2.A;
      return dispatcher === null ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
      return Error("react-stack-top-frame");
    }
    function hasValidKey(config2) {
      if (hasOwnProperty2.call(config2, "key")) {
        var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
        if (getter && getter.isReactWarning)
          return false;
      }
      return config2.key !== undefined;
    }
    function defineKeyPropWarningGetter(props, displayName) {
      function warnAboutAccessingKey() {
        specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
      }
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, "key", {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }
    function elementRefGetterWithDeprecationWarning() {
      var componentName = getComponentNameFromType2(this.type);
      didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
      componentName = this.props.ref;
      return componentName !== undefined ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
      var refProp = props.ref;
      type = {
        $$typeof: REACT_ELEMENT_TYPE2,
        type,
        key,
        props,
        _owner: owner
      };
      (refProp !== undefined ? refProp : null) !== null ? Object.defineProperty(type, "ref", {
        enumerable: false,
        get: elementRefGetterWithDeprecationWarning
      }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
      type._store = {};
      Object.defineProperty(type._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: 0
      });
      Object.defineProperty(type, "_debugInfo", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: null
      });
      Object.defineProperty(type, "_debugStack", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugStack
      });
      Object.defineProperty(type, "_debugTask", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: debugTask
      });
      Object.freeze && (Object.freeze(type.props), Object.freeze(type));
      return type;
    }
    function jsxDEVImpl(type, config2, maybeKey, isStaticChildren, debugStack, debugTask) {
      var children = config2.children;
      if (children !== undefined)
        if (isStaticChildren)
          if (isArrayImpl2(children)) {
            for (isStaticChildren = 0;isStaticChildren < children.length; isStaticChildren++)
              validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
          } else
            console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else
          validateChildKeys(children);
      if (hasOwnProperty2.call(config2, "key")) {
        children = getComponentNameFromType2(type);
        var keys = Object.keys(config2).filter(function(k2) {
          return k2 !== "key";
        });
        isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
        didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
      }
      children = null;
      maybeKey !== undefined && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
      hasValidKey(config2) && (checkKeyStringCoercion(config2.key), children = "" + config2.key);
      if ("key" in config2) {
        maybeKey = {};
        for (var propName in config2)
          propName !== "key" && (maybeKey[propName] = config2[propName]);
      } else
        maybeKey = config2;
      children && defineKeyPropWarningGetter(maybeKey, typeof type === "function" ? type.displayName || type.name || "Unknown" : type);
      return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
      isValidElement(node) ? node._store && (node._store.validated = 1) : typeof node === "object" && node !== null && node.$$typeof === REACT_LAZY_TYPE2 && (node._payload.status === "fulfilled" ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object2) {
      return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE2;
    }
    var REACT_ELEMENT_TYPE2 = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE2 = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE2 = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE2 = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE2 = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE2 = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE2 = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE2 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE2 = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE2 = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE2 = Symbol.for("react.memo"), REACT_LAZY_TYPE2 = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE2 = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE2 = Symbol.for("react.client.reference"), ReactSharedInternals2 = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty2 = Object.prototype.hasOwnProperty, isArrayImpl2 = Array.isArray, createTask = console.createTask ? console.createTask : function() {
      return null;
    };
    React2 = {
      react_stack_bottom_frame: function(callStackForError) {
        return callStackForError();
      }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React2.react_stack_bottom_frame.bind(React2, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE2;
    exports.jsx = function(type, config2, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals2.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config2, maybeKey, false, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
    exports.jsxs = function(type, config2, maybeKey) {
      var trackActualOwner = 1e4 > ReactSharedInternals2.recentlyCreatedOwnerStacks++;
      return jsxDEVImpl(type, config2, maybeKey, true, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
  })();
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS((exports, module) => {
  var react_jsx_runtime_development = __toESM(require_react_jsx_runtime_development(), 1);
  if (false) {} else {
    module.exports = react_jsx_runtime_development;
  }
});

// node_modules/prettier/plugins/html.mjs
var exports_html = {};
__export(exports_html, {
  printers: () => uu,
  parsers: () => tn,
  options: () => Us,
  languages: () => Hs,
  default: () => ym
});
function yi(t3) {
  if (typeof t3 == "string")
    return we;
  if (Array.isArray(t3))
    return ze;
  if (!t3)
    return;
  let { type: e } = t3;
  if (Dt.has(e))
    return e;
}
function bi(t3) {
  let e = t3 === null ? "null" : typeof t3;
  if (e !== "string" && e !== "object")
    return `Unexpected doc '${e}', 
Expected it to be 'string' or 'object'.`;
  if (Fe(t3))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(t3);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = wi([...Dt].map((s) => `'${s}'`));
  return `Unexpected doc.type '${t3.type}'.
Expected it to be ${n}.`;
}
function hr(t3, e) {
  if (typeof t3 == "string")
    return e(t3);
  let r = new Map;
  return n(t3);
  function n(i2) {
    if (r.has(i2))
      return r.get(i2);
    let a = s(i2);
    return r.set(i2, a), a;
  }
  function s(i2) {
    switch (Fe(i2)) {
      case ze:
        return e(i2.map(n));
      case ke:
        return e({ ...i2, parts: i2.parts.map(n) });
      case ce:
        return e({ ...i2, breakContents: n(i2.breakContents), flatContents: n(i2.flatContents) });
      case xe: {
        let { expandedStates: a, contents: o } = i2;
        return a ? (a = a.map(n), o = a[0]) : o = n(o), e({ ...i2, contents: o, expandedStates: a });
      }
      case Te:
      case be:
      case Be:
      case Qe:
      case Ke:
        return e({ ...i2, contents: n(i2.contents) });
      case we:
      case Ye:
      case je:
      case Xe:
      case j:
      case Le:
        return e(i2);
      default:
        throw new pr(i2);
    }
  }
}
function B(t3, e = hn) {
  return hr(t3, (r) => typeof r == "string" ? H(e, r.split(`
`)) : r);
}
function k2(t3) {
  return re(t3), { type: be, contents: t3 };
}
function fn(t3, e) {
  return re(e), { type: Te, contents: e, n: t3 };
}
function E(t3, e = {}) {
  return re(t3), fr(e.expandedStates, true), { type: xe, id: e.id, contents: t3, break: !!e.shouldBreak, expandedStates: e.expandedStates };
}
function dn(t3) {
  return fn(Number.NEGATIVE_INFINITY, t3);
}
function gn(t3) {
  return fn({ type: "root" }, t3);
}
function vt(t3) {
  return mn(t3), { type: ke, parts: t3 };
}
function pe(t3, e = "", r = {}) {
  return re(t3), e !== "" && re(e), { type: ce, breakContents: t3, flatContents: e, groupId: r.groupId };
}
function Cn(t3, e) {
  return re(t3), { type: Be, contents: t3, groupId: e.groupId, negate: e.negate };
}
function H(t3, e) {
  re(t3), fr(e);
  let r = [];
  for (let n = 0;n < e.length; n++)
    n !== 0 && r.push(t3), r.push(e[n]);
  return r;
}
function Bi(t3, e) {
  let r = e === true || e === yt ? yt : Sn, n = r === yt ? Sn : yt, s = 0, i2 = 0;
  for (let a of t3)
    a === r ? s++ : a === n && i2++;
  return s > i2 ? n : r;
}
function dr(t3) {
  if (typeof t3 != "string")
    throw new TypeError("Expected a string");
  return t3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Pi(t3) {
  return (t3 == null ? undefined : t3.type) === "front-matter";
}
function Dn(t3, e) {
  var r;
  if (t3.type === "text" || t3.type === "comment" || Pe(t3) || t3.type === "yaml" || t3.type === "toml")
    return null;
  if (t3.type === "attribute" && delete e.value, t3.type === "docType" && delete e.value, t3.type === "angularControlFlowBlock" && ((r = t3.parameters) != null && r.children))
    for (let n of e.parameters.children)
      Ii.has(t3.name) ? delete n.expression : n.expression = n.expression.trim();
  t3.type === "angularIcuExpression" && (e.switchValue = t3.switchValue.trim()), t3.type === "angularLetDeclarationInitializer" && delete e.value;
}
async function Ri(t3, e) {
  if (t3.language === "yaml") {
    let r = t3.value.trim(), n = r ? await e(r, { parser: "yaml" }) : "";
    return gn([t3.startDelimiter, t3.explicitLanguage, S, n, n ? S : "", t3.endDelimiter]);
  }
}
function he(t3, e = true) {
  return [k2([v, t3]), e ? v : ""];
}
function X(t3, e) {
  let r = t3.type === "NGRoot" ? t3.node.type === "NGMicrosyntax" && t3.node.body.length === 1 && t3.node.body[0].type === "NGMicrosyntaxExpression" ? t3.node.body[0].expression : t3.node : t3.type === "JsExpressionRoot" ? t3.node : t3;
  return r && (r.type === "ObjectExpression" || r.type === "ArrayExpression" || (e.parser === "__vue_expression" || e.parser === "__vue_ts_expression") && (r.type === "TemplateLiteral" || r.type === "StringLiteral"));
}
async function T2(t3, e, r, n) {
  r = { __isInHtmlAttribute: true, __embeddedInHtml: true, ...r };
  let s = true;
  n && (r.__onHtmlBindingRoot = (a, o) => {
    s = n(a, o);
  });
  let i2 = await e(t3, r, e);
  return s ? E(i2) : he(i2);
}
function $i(t3, e, r, n) {
  let { node: s } = r, i2 = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
  return /^\s*$/u.test(i2) ? "" : T2(i2, t3, { parser: "__ng_directive", __isInHtmlAttribute: false }, X);
}
function Mi(t3) {
  return Array.isArray(t3) && t3.length > 0;
}
function Fn(t3) {
  if (t3 = t3 instanceof URL ? t3 : new URL(t3), t3.protocol !== "file:")
    throw new TypeError(`URL must be a file URL: received "${t3.protocol}"`);
  return t3;
}
function Hi(t3) {
  return t3 = Fn(t3), decodeURIComponent(t3.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function Vi(t3) {
  t3 = Fn(t3);
  let e = decodeURIComponent(t3.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return t3.hostname !== "" && (e = `\\\\${t3.hostname}${e}`), e;
}
function Pn(t3) {
  return qi ? Vi(t3) : Hi(t3);
}
function In(t3, e) {
  if (!e)
    return;
  let r = Ui(e).toLowerCase();
  return t3.find(({ filenames: n }) => n == null ? undefined : n.some((s) => s.toLowerCase() === r)) ?? t3.find(({ extensions: n }) => n == null ? undefined : n.some((s) => r.endsWith(s)));
}
function Wi(t3, e) {
  if (e)
    return t3.find(({ name: r }) => r.toLowerCase() === e) ?? t3.find(({ aliases: r }) => r == null ? undefined : r.includes(e)) ?? t3.find(({ extensions: r }) => r == null ? undefined : r.includes(`.${e}`));
}
function Rn(t3, e) {
  if (e) {
    if (String(e).startsWith("file:"))
      try {
        e = Nn(e);
      } catch {
        return;
      }
    if (typeof e == "string")
      return t3.find(({ isSupported: r }) => r == null ? undefined : r({ filepath: e }));
  }
}
function Gi(t3, e) {
  let r = bn(false, t3.plugins).flatMap((s) => s.languages ?? []), n = Wi(r, e.language) ?? In(r, e.physicalFile) ?? In(r, e.file) ?? Rn(r, e.physicalFile) ?? Rn(r, e.file) ?? (e.physicalFile, undefined);
  return n == null ? undefined : n.parsers[0];
}
function zi(t3) {
  return t3.type === "element" && !t3.hasExplicitNamespace && !["html", "svg"].includes(t3.namespace);
}
function wt(t3, e) {
  return !!(t3.type === "ieConditionalComment" && t3.lastChild && !t3.lastChild.isSelfClosing && !t3.lastChild.endSourceSpan || t3.type === "ieConditionalComment" && !t3.complete || de(t3) && t3.children.some((r) => r.type !== "text" && r.type !== "interpolation") || xt(t3, e) && !W(t3, e) && t3.type !== "interpolation");
}
function ge(t3) {
  return t3.type === "attribute" || !t3.parent || !t3.prev ? false : ji(t3.prev);
}
function ji(t3) {
  return t3.type === "comment" && t3.value.trim() === "prettier-ignore";
}
function $2(t3) {
  return t3.type === "text" || t3.type === "comment";
}
function W(t3, e) {
  return t3.type === "element" && (t3.fullName === "script" || t3.fullName === "style" || t3.fullName === "svg:style" || t3.fullName === "svg:script" || t3.fullName === "mj-style" && e.parser === "mjml" || fe(t3) && (t3.name === "script" || t3.name === "style"));
}
function qn(t3, e) {
  return t3.children && !W(t3, e);
}
function Hn(t3, e) {
  return W(t3, e) || t3.type === "interpolation" || Ar(t3);
}
function Ar(t3) {
  return Jn(t3).startsWith("pre");
}
function Vn(t3, e) {
  var s, i2;
  let r = n();
  if (r && !t3.prev && ((i2 = (s = t3.parent) == null ? undefined : s.tagDefinition) != null && i2.ignoreFirstLf))
    return t3.type === "interpolation";
  return r;
  function n() {
    return Pe(t3) || t3.type === "angularControlFlowBlock" ? false : (t3.type === "text" || t3.type === "interpolation") && t3.prev && (t3.prev.type === "text" || t3.prev.type === "interpolation") ? true : !t3.parent || t3.parent.cssDisplay === "none" ? false : de(t3.parent) ? true : !(!t3.prev && (t3.parent.type === "root" || de(t3) && t3.parent || W(t3.parent, e) || et2(t3.parent, e) || !ea(t3.parent.cssDisplay)) || t3.prev && !na(t3.prev.cssDisplay));
  }
}
function Un(t3, e) {
  return Pe(t3) || t3.type === "angularControlFlowBlock" ? false : (t3.type === "text" || t3.type === "interpolation") && t3.next && (t3.next.type === "text" || t3.next.type === "interpolation") ? true : !t3.parent || t3.parent.cssDisplay === "none" ? false : de(t3.parent) ? true : !(!t3.next && (t3.parent.type === "root" || de(t3) && t3.parent || W(t3.parent, e) || et2(t3.parent, e) || !ta(t3.parent.cssDisplay)) || t3.next && !ra(t3.next.cssDisplay));
}
function Wn(t3, e) {
  return sa(t3.cssDisplay) && !W(t3, e);
}
function Je(t3) {
  return Pe(t3) || t3.next && t3.sourceSpan.end && t3.sourceSpan.end.line + 1 < t3.next.sourceSpan.start.line;
}
function Gn(t3) {
  return Dr(t3) || t3.type === "element" && t3.children.length > 0 && (["body", "script", "style"].includes(t3.name) || t3.children.some((e) => Xi(e))) || t3.firstChild && t3.firstChild === t3.lastChild && t3.firstChild.type !== "text" && Yn(t3.firstChild) && (!t3.lastChild.isTrailingSpaceSensitive || jn(t3.lastChild));
}
function Dr(t3) {
  return t3.type === "element" && t3.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(t3.name) || t3.cssDisplay.startsWith("table") && t3.cssDisplay !== "table-cell");
}
function bt(t3) {
  return Kn(t3) || t3.prev && Ki(t3.prev) || zn(t3);
}
function Ki(t3) {
  return Kn(t3) || t3.type === "element" && t3.fullName === "br" || zn(t3);
}
function zn(t3) {
  return Yn(t3) && jn(t3);
}
function Yn(t3) {
  return t3.hasLeadingSpaces && (t3.prev ? t3.prev.sourceSpan.end.line < t3.sourceSpan.start.line : t3.parent.type === "root" || t3.parent.startSourceSpan.end.line < t3.sourceSpan.start.line);
}
function jn(t3) {
  return t3.hasTrailingSpaces && (t3.next ? t3.next.sourceSpan.start.line > t3.sourceSpan.end.line : t3.parent.type === "root" || t3.parent.endSourceSpan && t3.parent.endSourceSpan.start.line > t3.sourceSpan.end.line);
}
function Kn(t3) {
  switch (t3.type) {
    case "ieConditionalComment":
    case "comment":
    case "directive":
      return true;
    case "element":
      return ["script", "select"].includes(t3.name);
  }
  return false;
}
function Tt(t3) {
  return t3.lastChild ? Tt(t3.lastChild) : t3;
}
function Xi(t3) {
  var e;
  return (e = t3.children) == null ? undefined : e.some((r) => r.type !== "text");
}
function Xn(t3) {
  if (t3)
    switch (t3) {
      case "module":
      case "text/javascript":
      case "text/babel":
      case "text/jsx":
      case "application/javascript":
        return "babel";
      case "application/x-typescript":
        return "typescript";
      case "text/markdown":
        return "markdown";
      case "text/html":
        return "html";
      case "text/x-handlebars-template":
        return "glimmer";
      default:
        if (t3.endsWith("json") || t3.endsWith("importmap") || t3 === "speculationrules")
          return "json";
    }
}
function Qi(t3, e) {
  let { name: r, attrMap: n } = t3;
  if (r !== "script" || Object.prototype.hasOwnProperty.call(n, "src"))
    return;
  let { type: s, lang: i2 } = t3.attrMap;
  return !i2 && !s ? "babel" : Ne(e, { language: i2 }) ?? Xn(s);
}
function Ji(t3, e) {
  if (!xt(t3, e))
    return;
  let { attrMap: r } = t3;
  if (Object.prototype.hasOwnProperty.call(r, "src"))
    return;
  let { type: n, lang: s } = r;
  return Ne(e, { language: s }) ?? Xn(n);
}
function Zi(t3, e) {
  if (t3.name === "style") {
    let { lang: r } = t3.attrMap;
    return r ? Ne(e, { language: r }) : "css";
  }
  if (t3.name === "mj-style" && e.parser === "mjml")
    return "css";
}
function vr(t3, e) {
  return Qi(t3, e) ?? Zi(t3, e) ?? Ji(t3, e);
}
function Ze(t3) {
  return t3 === "block" || t3 === "list-item" || t3.startsWith("table");
}
function ea(t3) {
  return !Ze(t3) && t3 !== "inline-block";
}
function ta(t3) {
  return !Ze(t3) && t3 !== "inline-block";
}
function ra(t3) {
  return !Ze(t3);
}
function na(t3) {
  return !Ze(t3);
}
function sa(t3) {
  return !Ze(t3) && t3 !== "inline-block";
}
function de(t3) {
  return Jn(t3).startsWith("pre");
}
function ia(t3, e) {
  let r = t3;
  for (;r; ) {
    if (e(r))
      return true;
    r = r.parent;
  }
  return false;
}
function Qn(t3, e) {
  var n;
  if (Ce(t3, e))
    return "block";
  if (((n = t3.prev) == null ? undefined : n.type) === "comment") {
    let s = t3.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
    if (s)
      return s[1];
  }
  let r = false;
  if (t3.type === "element" && t3.namespace === "svg")
    if (ia(t3, (s) => s.fullName === "svg:foreignObject"))
      r = true;
    else
      return t3.name === "svg" ? "inline-block" : "block";
  switch (e.htmlWhitespaceSensitivity) {
    case "strict":
      return "inline";
    case "ignore":
      return "block";
    default:
      if (t3.type === "element" && (!t3.namespace || r || fe(t3)) && Object.prototype.hasOwnProperty.call(Sr, t3.name))
        return Sr[t3.name];
  }
  return $n;
}
function Jn(t3) {
  return t3.type === "element" && (!t3.namespace || fe(t3)) && Object.prototype.hasOwnProperty.call(_r, t3.name) ? _r[t3.name] : On;
}
function aa(t3) {
  let e = Number.POSITIVE_INFINITY;
  for (let r of t3.split(`
`)) {
    if (r.length === 0)
      continue;
    let n = O.getLeadingWhitespaceCount(r);
    if (n === 0)
      return 0;
    r.length !== n && n < e && (e = n);
  }
  return e === Number.POSITIVE_INFINITY ? 0 : e;
}
function yr(t3, e = aa(t3)) {
  return e === 0 ? t3 : t3.split(`
`).map((r) => r.slice(e)).join(`
`);
}
function wr(t3) {
  return w(false, w(false, t3, "&apos;", "'"), "&quot;", '"');
}
function P(t3) {
  return wr(t3.value);
}
function et2(t3, e) {
  return Ce(t3, e) && !oa.has(t3.fullName);
}
function Ce(t3, e) {
  return e.parser === "vue" && t3.type === "element" && t3.parent.type === "root" && t3.fullName.toLowerCase() !== "html";
}
function xt(t3, e) {
  return Ce(t3, e) && (et2(t3, e) || t3.attrMap.lang && t3.attrMap.lang !== "html");
}
function Zn(t3) {
  let e = t3.fullName;
  return e.charAt(0) === "#" || e === "slot-scope" || e === "v-slot" || e.startsWith("v-slot:");
}
function es(t3, e) {
  let r = t3.parent;
  if (!Ce(r, e))
    return false;
  let n = r.fullName, s = t3.fullName;
  return n === "script" && s === "setup" || n === "style" && s === "vars";
}
function kt(t3, e = t3.value) {
  return t3.parent.isWhitespaceSensitive ? t3.parent.isIndentationSensitive ? B(e) : B(yr(Er(e)), S) : H(_2, O.split(e));
}
function Bt(t3, e) {
  return Ce(t3, e) && t3.name === "script";
}
async function ts(t3, e) {
  let r = [];
  for (let [n, s] of t3.split(br).entries())
    if (n % 2 === 0)
      r.push(B(s));
    else
      try {
        r.push(E(["{{", k2([_2, await T2(s, e, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), _2, "}}"]));
      } catch {
        r.push("{{", B(s), "}}");
      }
  return r;
}
function Tr({ parser: t3 }) {
  return (e, r, n) => T2(P(n.node), e, { parser: t3 }, X);
}
function pa(t3, e) {
  if (e.parser !== "angular")
    return;
  let { node: r } = t3, n = r.fullName;
  if (n.startsWith("(") && n.endsWith(")") || n.startsWith("on-"))
    return ua;
  if (n.startsWith("[") && n.endsWith("]") || /^bind(?:on)?-/u.test(n) || /^ng-(?:if|show|hide|class|style)$/u.test(n))
    return la;
  if (n.startsWith("*"))
    return ca;
  let s = P(r);
  if (/^i18n(?:-.+)?$/u.test(n))
    return () => he(vt(kt(r, s.trim())), !s.includes("@@"));
  if (br.test(s))
    return (i2) => ts(s, i2);
}
function ha(t3, e) {
  let { node: r } = t3, n = P(r);
  if (r.fullName === "class" && !e.parentParser && !n.includes("{{"))
    return () => n.trim().split(/\s+/u).join(" ");
}
function ss(t3) {
  return t3 === "\t" || t3 === `
` || t3 === "\f" || t3 === "\r" || t3 === " ";
}
function Sa(t3) {
  let e = t3.length, r, n, s, i2, a, o = 0, u;
  function p(C) {
    let A, D = C.exec(t3.substring(o));
    if (D)
      return [A] = D, o += A.length, A;
  }
  let l2 = [];
  for (;; ) {
    if (p(fa), o >= e) {
      if (l2.length === 0)
        throw new Error("Must contain one or more image candidate strings.");
      return l2;
    }
    u = o, r = p(da), n = [], r.slice(-1) === "," ? (r = r.replace(ga, ""), f()) : m();
  }
  function m() {
    for (p(ma), s = "", i2 = "in descriptor";; ) {
      if (a = t3.charAt(o), i2 === "in descriptor")
        if (ss(a))
          s && (n.push(s), s = "", i2 = "after descriptor");
        else if (a === ",") {
          o += 1, s && n.push(s), f();
          return;
        } else if (a === "(")
          s += a, i2 = "in parens";
        else if (a === "") {
          s && n.push(s), f();
          return;
        } else
          s += a;
      else if (i2 === "in parens")
        if (a === ")")
          s += a, i2 = "in descriptor";
        else if (a === "") {
          n.push(s), f();
          return;
        } else
          s += a;
      else if (i2 === "after descriptor" && !ss(a))
        if (a === "") {
          f();
          return;
        } else
          i2 = "in descriptor", o -= 1;
      o += 1;
    }
  }
  function f() {
    let C = false, A, D, I, F, c = {}, g, y, q, x2, U;
    for (F = 0;F < n.length; F++)
      g = n[F], y = g[g.length - 1], q = g.substring(0, g.length - 1), x2 = parseInt(q, 10), U = parseFloat(q), is3.test(q) && y === "w" ? ((A || D) && (C = true), x2 === 0 ? C = true : A = x2) : Ca.test(q) && y === "x" ? ((A || D || I) && (C = true), U < 0 ? C = true : D = U) : is3.test(q) && y === "h" ? ((I || D) && (C = true), x2 === 0 ? C = true : I = x2) : C = true;
    if (!C)
      c.source = { value: r, startOffset: u }, A && (c.width = { value: A }), D && (c.density = { value: D }), I && (c.height = { value: I }), l2.push(c);
    else
      throw new Error(`Invalid srcset descriptor found in "${t3}" at "${g}".`);
  }
}
function _a2(t3) {
  if (t3.node.fullName === "srcset" && (t3.parent.fullName === "img" || t3.parent.fullName === "source"))
    return () => Aa(P(t3.node));
}
function Aa(t3) {
  let e = as(t3), r = Ea.filter((l2) => e.some((m) => Object.prototype.hasOwnProperty.call(m, l2)));
  if (r.length > 1)
    throw new Error("Mixed descriptor in srcset is not supported");
  let [n] = r, s = os2[n], i2 = e.map((l2) => l2.source.value), a = Math.max(...i2.map((l2) => l2.length)), o = e.map((l2) => l2[n] ? String(l2[n].value) : ""), u = o.map((l2) => {
    let m = l2.indexOf(".");
    return m === -1 ? l2.length : m;
  }), p = Math.max(...u);
  return he(H([",", _2], i2.map((l2, m) => {
    let f = [l2], C = o[m];
    if (C) {
      let A = a - l2.length + 1, D = p - u[m], I = " ".repeat(A + D);
      f.push(pe(I, " "), C + s);
    }
    return f;
  })));
}
function ls(t3, e) {
  let { node: r } = t3, n = P(t3.node).trim();
  if (r.fullName === "style" && !e.parentParser && !n.includes("{{"))
    return async (s) => he(await s(n, { parser: "css", __isHTMLStyleAttribute: true }));
}
function Da(t3, e) {
  let { root: r } = t3;
  return xr.has(r) || xr.set(r, r.children.some((n) => Bt(n, e) && ["ts", "typescript"].includes(n.attrMap.lang))), xr.get(r);
}
function cs(t3, e, r) {
  let { node: n } = r, s = P(n);
  return T2(`type T<${s}> = any`, t3, { parser: "babel-ts", __isEmbeddedTypescriptGenericParameters: true }, X);
}
function ps(t3, e, { parseWithTs: r }) {
  return T2(`function _(${t3}) {}`, e, { parser: r ? "babel-ts" : "babel", __isVueBindings: true });
}
async function hs(t3, e, r, n) {
  let s = P(r.node), { left: i2, operator: a, right: o } = va(s), u = Ie(r, n);
  return [E(await T2(`function _(${i2}) {}`, t3, { parser: u ? "babel-ts" : "babel", __isVueForBindingLeft: true })), " ", a, " ", await T2(o, t3, { parser: u ? "__ts_expression" : "__js_expression" })];
}
function va(t3) {
  let e = /(.*?)\s+(in|of)\s+(.*)/su, r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u, n = /^\(|\)$/gu, s = t3.match(e);
  if (!s)
    return;
  let i2 = {};
  if (i2.for = s[3].trim(), !i2.for)
    return;
  let a = w(false, s[1].trim(), n, ""), o = a.match(r);
  o ? (i2.alias = a.replace(r, ""), i2.iterator1 = o[1].trim(), o[2] && (i2.iterator2 = o[2].trim())) : i2.alias = a;
  let u = [i2.alias, i2.iterator1, i2.iterator2];
  if (!u.some((p, l2) => !p && (l2 === 0 || u.slice(l2 + 1).some(Boolean))))
    return { left: u.filter(Boolean).join(","), operator: s[2], right: i2.for };
}
function ya(t3, e) {
  if (e.parser !== "vue")
    return;
  let { node: r } = t3, n = r.fullName;
  if (n === "v-for")
    return hs;
  if (n === "generic" && Bt(r.parent, e))
    return cs;
  let s = P(r), i2 = Ie(t3, e);
  if (Zn(r) || es(r, e))
    return (a) => ps(s, a, { parseWithTs: i2 });
  if (n.startsWith("@") || n.startsWith("v-on:"))
    return (a) => wa(s, a, { parseWithTs: i2 });
  if (n.startsWith(":") || n.startsWith(".") || n.startsWith("v-bind:"))
    return (a) => ba(s, a, { parseWithTs: i2 });
  if (n.startsWith("v-"))
    return (a) => ms(s, a, { parseWithTs: i2 });
}
async function wa(t3, e, { parseWithTs: r }) {
  var n;
  try {
    return await ms(t3, e, { parseWithTs: r });
  } catch (s) {
    if (((n = s.cause) == null ? undefined : n.code) !== "BABEL_PARSER_SYNTAX_ERROR")
      throw s;
  }
  return T2(t3, e, { parser: r ? "__vue_ts_event_binding" : "__vue_event_binding" }, X);
}
function ba(t3, e, { parseWithTs: r }) {
  return T2(t3, e, { parser: r ? "__vue_ts_expression" : "__vue_expression" }, X);
}
function ms(t3, e, { parseWithTs: r }) {
  return T2(t3, e, { parser: r ? "__ts_expression" : "__js_expression" }, X);
}
function Ta(t3, e) {
  let { node: r } = t3;
  if (r.value) {
    if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(e.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || e.parser === "lwc" && r.value.startsWith("{") && r.value.endsWith("}"))
      return [r.rawName, "=", r.value];
    for (let n of [us, ls, ns, fs2, rs]) {
      let s = n(t3, e);
      if (s)
        return xa(s);
    }
  }
}
function xa(t3) {
  return async (e, r, n, s) => {
    let i2 = await t3(e, r, n, s);
    if (i2)
      return i2 = hr(i2, (a) => typeof a == "string" ? w(false, a, '"', "&quot;") : a), [n.node.rawName, '="', E(i2), '"'];
  };
}
function J(t3) {
  return t3.sourceSpan.start.offset;
}
function se(t3) {
  return t3.sourceSpan.end.offset;
}
function tt(t3, e) {
  return [t3.isSelfClosing ? "" : Ba(t3, e), Se(t3, e)];
}
function Ba(t3, e) {
  return t3.lastChild && Ae(t3.lastChild) ? "" : [La(t3, e), Lt(t3, e)];
}
function Se(t3, e) {
  return (t3.next ? Q(t3.next) : Ee(t3.parent)) ? "" : [_e(t3, e), G(t3, e)];
}
function La(t3, e) {
  return Ee(t3) ? _e(t3.lastChild, e) : "";
}
function G(t3, e) {
  return Ae(t3) ? Lt(t3.parent, e) : rt(t3) ? Ft(t3.next, e) : "";
}
function Lt(t3, e) {
  if (Cs(t3, e))
    return "";
  switch (t3.type) {
    case "ieConditionalComment":
      return "<!";
    case "element":
      if (t3.hasHtmComponentClosingTag)
        return "<//";
    default:
      return `</${t3.rawName}`;
  }
}
function _e(t3, e) {
  if (Cs(t3, e))
    return "";
  switch (t3.type) {
    case "ieConditionalComment":
    case "ieConditionalEndComment":
      return "[endif]-->";
    case "ieConditionalStartComment":
      return "]><!-->";
    case "interpolation":
      return "}}";
    case "angularIcuExpression":
      return "}";
    case "element":
      if (t3.isSelfClosing)
        return "/>";
    default:
      return ">";
  }
}
function Cs(t3, e) {
  return !t3.isSelfClosing && !t3.endSourceSpan && (ge(t3) || wt(t3.parent, e));
}
function Q(t3) {
  return t3.prev && t3.prev.type !== "docType" && t3.type !== "angularControlFlowBlock" && !$2(t3.prev) && t3.isLeadingSpaceSensitive && !t3.hasLeadingSpaces;
}
function Ee(t3) {
  var e;
  return ((e = t3.lastChild) == null ? undefined : e.isTrailingSpaceSensitive) && !t3.lastChild.hasTrailingSpaces && !$2(Tt(t3.lastChild)) && !de(t3);
}
function Ae(t3) {
  return !t3.next && !t3.hasTrailingSpaces && t3.isTrailingSpaceSensitive && $2(Tt(t3));
}
function rt(t3) {
  return t3.next && !$2(t3.next) && $2(t3) && t3.isTrailingSpaceSensitive && !t3.hasTrailingSpaces;
}
function Fa(t3) {
  let e = t3.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
  return e ? e[1] ? e[1].split(/\s+/u) : true : false;
}
function nt(t3) {
  return !t3.prev && t3.isLeadingSpaceSensitive && !t3.hasLeadingSpaces;
}
function Pa(t3, e, r) {
  var m;
  let { node: n } = t3;
  if (!me(n.attrs))
    return n.isSelfClosing ? " " : "";
  let s = ((m = n.prev) == null ? undefined : m.type) === "comment" && Fa(n.prev.value), i2 = typeof s == "boolean" ? () => s : Array.isArray(s) ? (f) => s.includes(f.rawName) : () => false, a = t3.map(({ node: f }) => i2(f) ? B(e.originalText.slice(J(f), se(f))) : r(), "attrs"), o = n.type === "element" && n.fullName === "script" && n.attrs.length === 1 && n.attrs[0].fullName === "src" && n.children.length === 0, p = e.singleAttributePerLine && n.attrs.length > 1 && !Ce(n, e) ? S : _2, l2 = [k2([o ? " " : _2, H(p, a)])];
  return n.firstChild && nt(n.firstChild) || n.isSelfClosing && Ee(n.parent) || o ? l2.push(n.isSelfClosing ? " " : "") : l2.push(e.bracketSameLine ? n.isSelfClosing ? " " : "" : n.isSelfClosing ? _2 : v), l2;
}
function Na(t3) {
  return t3.firstChild && nt(t3.firstChild) ? "" : Pt(t3);
}
function st(t3, e, r) {
  let { node: n } = t3;
  return [De(n, e), Pa(t3, e, r), n.isSelfClosing ? "" : Na(n)];
}
function De(t3, e) {
  return t3.prev && rt(t3.prev) ? "" : [z(t3, e), Ft(t3, e)];
}
function z(t3, e) {
  return nt(t3) ? Pt(t3.parent) : Q(t3) ? _e(t3.prev, e) : "";
}
function Ft(t3, e) {
  switch (t3.type) {
    case "ieConditionalComment":
    case "ieConditionalStartComment":
      return `<!--[if ${t3.condition}`;
    case "ieConditionalEndComment":
      return "<!--<!";
    case "interpolation":
      return "{{";
    case "docType": {
      if (t3.value === "html") {
        let { filepath: n } = e;
        if (n && /\.html?$/u.test(n))
          return gs;
      }
      let r = J(t3);
      return e.originalText.slice(r, r + gs.length);
    }
    case "angularIcuExpression":
      return "{";
    case "element":
      if (t3.condition)
        return `<!--[if ${t3.condition}]><!--><${t3.rawName}`;
    default:
      return `<${t3.rawName}`;
  }
}
function Pt(t3) {
  switch (t3.type) {
    case "ieConditionalComment":
      return "]>";
    case "element":
      if (t3.condition)
        return "><!--<![endif]-->";
    default:
      return ">";
  }
}
function Ia(t3, e) {
  if (!t3.endSourceSpan)
    return "";
  let r = t3.startSourceSpan.end.offset;
  t3.firstChild && nt(t3.firstChild) && (r -= Pt(t3).length);
  let n = t3.endSourceSpan.start.offset;
  return t3.lastChild && Ae(t3.lastChild) ? n += Lt(t3, e).length : Ee(t3) && (n -= _e(t3.lastChild, e).length), e.originalText.slice(r, n);
}
function $a(t3, e) {
  let { node: r } = t3;
  switch (r.type) {
    case "element":
      if (W(r, e) || r.type === "interpolation")
        return;
      if (!r.isSelfClosing && xt(r, e)) {
        let n = vr(r, e);
        return n ? async (s, i2) => {
          let a = Nt(r, e), o = /^\s*$/u.test(a), u = "";
          return o || (u = await s(Er(a), { parser: n, __embeddedInHtml: true }), o = u === ""), [z(r, e), E(st(t3, e, i2)), o ? "" : S, u, o ? "" : S, tt(r, e), G(r, e)];
        } : undefined;
      }
      break;
    case "text":
      if (W(r.parent, e)) {
        let n = vr(r.parent, e);
        if (n)
          return async (s) => {
            let i2 = n === "markdown" ? yr(r.value.replace(/^[^\S\n]*\n/u, "")) : r.value, a = { parser: n, __embeddedInHtml: true };
            if (e.parser === "html" && n === "babel") {
              let o = "script", { attrMap: u } = r.parent;
              u && (u.type === "module" || (u.type === "text/babel" || u.type === "text/jsx") && u["data-type"] === "module") && (o = "module"), a.__babelSourceType = o;
            }
            return [ne2, z(r, e), await s(i2, a), G(r, e)];
          };
      } else if (r.parent.type === "interpolation")
        return async (n) => {
          let s = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return e.parser === "angular" ? s.parser = "__ng_interpolation" : e.parser === "vue" ? s.parser = Ie(t3, e) ? "__vue_ts_expression" : "__vue_expression" : s.parser = "__js_expression", [k2([_2, await n(r.value, s)]), r.parent.next && Q(r.parent.next) ? " " : _2];
        };
      break;
    case "attribute":
      return ds(t3, e);
    case "front-matter":
      return (n) => yn(r, n);
    case "angularControlFlowBlockParameters":
      return Ra.has(t3.parent.name) ? wn : undefined;
    case "angularLetDeclarationInitializer":
      return (n) => T2(r.value, n, { parser: "__ng_binding", __isInHtmlAttribute: false });
  }
}
function at(t3) {
  if (it !== null && typeof it.property) {
    let e = it;
    return it = at.prototype = null, e;
  }
  return it = at.prototype = t3 ?? Object.create(null), new at;
}
function kr(t3) {
  return at(t3);
}
function Ma(t3, e = "type") {
  kr(t3);
  function r(n) {
    let s = n[e], i2 = t3[s];
    if (!Array.isArray(i2))
      throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: n });
    return i2;
  }
  return r;
}
function ws(t3) {
  return ys.test(t3);
}
function bs(t3) {
  return vs.test(t3);
}
function Ts(t3) {
  return `<!-- @${Ds} -->

${t3}`;
}
function ks(t3) {
  let e = se(t3);
  return t3.type === "element" && !t3.endSourceSpan && me(t3.children) ? Math.max(e, ks(K(false, t3.children, -1))) : e;
}
function ot(t3, e, r) {
  let n = t3.node;
  if (ge(n)) {
    let s = ks(n);
    return [z(n, e), B(O.trimEnd(e.originalText.slice(J(n) + (n.prev && rt(n.prev) ? Ft(n).length : 0), s - (n.next && Q(n.next) ? _e(n, e).length : 0)))), G(n, e)];
  }
  return r();
}
function It(t3, e) {
  return $2(t3) && $2(e) ? t3.isTrailingSpaceSensitive ? t3.hasTrailingSpaces ? bt(e) ? S : _2 : "" : bt(e) ? S : v : rt(t3) && (ge(e) || e.firstChild || e.isSelfClosing || e.type === "element" && e.attrs.length > 0) || t3.type === "element" && t3.isSelfClosing && Q(e) ? "" : !e.isLeadingSpaceSensitive || bt(e) || Q(e) && t3.lastChild && Ae(t3.lastChild) && t3.lastChild.lastChild && Ae(t3.lastChild.lastChild) ? S : e.hasLeadingSpaces ? _2 : v;
}
function Re(t3, e, r) {
  let { node: n } = t3;
  if (Dr(n))
    return [ne2, ...t3.map((i2) => {
      let a = i2.node, o = a.prev ? It(a.prev, a) : "";
      return [o ? [o, Je(a.prev) ? S : ""] : "", ot(i2, e, r)];
    }, "children")];
  let s = n.children.map(() => Symbol(""));
  return t3.map((i2, a) => {
    let o = i2.node;
    if ($2(o)) {
      if (o.prev && $2(o.prev)) {
        let A = It(o.prev, o);
        if (A)
          return Je(o.prev) ? [S, S, ot(i2, e, r)] : [A, ot(i2, e, r)];
      }
      return ot(i2, e, r);
    }
    let u = [], p = [], l2 = [], m = [], f = o.prev ? It(o.prev, o) : "", C = o.next ? It(o, o.next) : "";
    return f && (Je(o.prev) ? u.push(S, S) : f === S ? u.push(S) : $2(o.prev) ? p.push(f) : p.push(pe("", v, { groupId: s[a - 1] }))), C && (Je(o) ? $2(o.next) && m.push(S, S) : C === S ? $2(o.next) && m.push(S) : l2.push(C)), [...u, E([...p, E([ot(i2, e, r), ...l2], { id: s[a] })]), ...m];
  }, "children");
}
function Bs(t3, e, r) {
  let { node: n } = t3, s = [];
  Va(t3) && s.push("} "), s.push("@", n.name), n.parameters && s.push(" (", E(r("parameters")), ")"), s.push(" {");
  let i2 = Ls(n);
  return n.children.length > 0 ? (n.firstChild.hasLeadingSpaces = true, n.lastChild.hasTrailingSpaces = true, s.push(k2([S, Re(t3, e, r)])), i2 && s.push(S, "}")) : i2 && s.push("}"), E(s, { shouldBreak: true });
}
function Ls(t3) {
  var e, r;
  return !(((e = t3.next) == null ? undefined : e.type) === "angularControlFlowBlock" && ((r = xs.get(t3.name)) != null && r.has(t3.next.name)));
}
function Va(t3) {
  let { previous: e } = t3;
  return (e == null ? undefined : e.type) === "angularControlFlowBlock" && !ge(e) && !Ls(e);
}
function Fs(t3, e, r) {
  return [k2([v, H([";", _2], t3.map(r, "children"))]), v];
}
function Ps(t3, e, r) {
  let { node: n } = t3;
  return [De(n, e), E([n.switchValue.trim(), ", ", n.clause, n.cases.length > 0 ? [",", k2([_2, H(_2, t3.map(r, "cases"))])] : "", v]), Se(n, e)];
}
function Ns(t3, e, r) {
  let { node: n } = t3;
  return [n.value, " {", E([k2([v, t3.map(({ node: s, isLast: i2 }) => {
    let a = [r()];
    return s.type === "text" && (s.hasLeadingSpaces && a.unshift(_2), s.hasTrailingSpaces && !i2 && a.push(_2)), a;
  }, "expression")]), v]), "}"];
}
function Is(t3, e, r) {
  let { node: n } = t3;
  if (wt(n, e))
    return [z(n, e), E(st(t3, e, r)), B(Nt(n, e)), ...tt(n, e), G(n, e)];
  let s = n.children.length === 1 && (n.firstChild.type === "interpolation" || n.firstChild.type === "angularIcuExpression") && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces, i2 = Symbol("element-attr-group-id"), a = (l2) => E([E(st(t3, e, r), { id: i2 }), l2, tt(n, e)]), o = (l2) => s ? Cn(l2, { groupId: i2 }) : (W(n, e) || et2(n, e)) && n.parent.type === "root" && e.parser === "vue" && !e.vueIndentScriptAndStyle ? l2 : k2(l2), u = () => s ? pe(v, "", { groupId: i2 }) : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive ? _2 : n.firstChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive ? dn(v) : v, p = () => (n.next ? Q(n.next) : Ee(n.parent)) ? n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? " " : "" : s ? pe(v, "", { groupId: i2 }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? _2 : (n.lastChild.type === "comment" || n.lastChild.type === "text" && n.isWhitespaceSensitive && n.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${e.tabWidth * (t3.ancestors.length - 1)}}$`, "u").test(n.lastChild.value) ? "" : v;
  return n.children.length === 0 ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? _2 : "") : a([Gn(n) ? ne2 : "", o([u(), Re(t3, e, r)]), p()]);
}
function ut(t3) {
  return t3 >= 9 && t3 <= 32 || t3 == 160;
}
function Rt(t3) {
  return 48 <= t3 && t3 <= 57;
}
function lt2(t3) {
  return t3 >= 97 && t3 <= 122 || t3 >= 65 && t3 <= 90;
}
function Rs(t3) {
  return t3 >= 97 && t3 <= 102 || t3 >= 65 && t3 <= 70 || Rt(t3);
}
function $t(t3) {
  return t3 === 10 || t3 === 13;
}
function Br(t3) {
  return 48 <= t3 && t3 <= 55;
}
function Ot(t3) {
  return t3 === 39 || t3 === 34 || t3 === 96;
}
function Os(t3) {
  return t3.replace(Ua, (...e) => e[1].toUpperCase());
}
function Ga(t4, e) {
  for (let r of Wa)
    r(t4, e);
  return t4;
}
function za(t4) {
  t4.walk((e) => {
    if (e.type === "element" && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && e.children[0].type === "text" && e.children[0].value[0] === `
`) {
      let r = e.children[0];
      r.value.length === 1 ? e.removeChild(r) : r.value = r.value.slice(1);
    }
  });
}
function Ya(t4) {
  let e = (r) => {
    var n, s;
    return r.type === "element" && ((n = r.prev) == null ? undefined : n.type) === "ieConditionalStartComment" && r.prev.sourceSpan.end.offset === r.startSourceSpan.start.offset && ((s = r.firstChild) == null ? undefined : s.type) === "ieConditionalEndComment" && r.firstChild.sourceSpan.start.offset === r.startSourceSpan.end.offset;
  };
  t4.walk((r) => {
    if (r.children)
      for (let n = 0;n < r.children.length; n++) {
        let s = r.children[n];
        if (!e(s))
          continue;
        let { prev: i2, firstChild: a } = s;
        r.removeChild(i2), n--;
        let o = new h(i2.sourceSpan.start, a.sourceSpan.end), u = new h(o.start, s.sourceSpan.end);
        s.condition = i2.condition, s.sourceSpan = u, s.startSourceSpan = o, s.removeChild(a);
      }
  });
}
function ja(t4, e, r) {
  t4.walk((n) => {
    if (n.children)
      for (let s = 0;s < n.children.length; s++) {
        let i2 = n.children[s];
        if (i2.type !== "text" && !e(i2))
          continue;
        i2.type !== "text" && (i2.type = "text", i2.value = r(i2));
        let a = i2.prev;
        !a || a.type !== "text" || (a.value += i2.value, a.sourceSpan = new h(a.sourceSpan.start, i2.sourceSpan.end), n.removeChild(i2), s--);
      }
  });
}
function Ka(t4) {
  return ja(t4, (e) => e.type === "cdata", (e) => `<![CDATA[${e.value}]]>`);
}
function Xa(t4) {
  let e = (r) => {
    var n, s;
    return r.type === "element" && r.attrs.length === 0 && r.children.length === 1 && r.firstChild.type === "text" && !O.hasWhitespaceCharacter(r.children[0].value) && !r.firstChild.hasLeadingSpaces && !r.firstChild.hasTrailingSpaces && r.isLeadingSpaceSensitive && !r.hasLeadingSpaces && r.isTrailingSpaceSensitive && !r.hasTrailingSpaces && ((n = r.prev) == null ? undefined : n.type) === "text" && ((s = r.next) == null ? undefined : s.type) === "text";
  };
  t4.walk((r) => {
    if (r.children)
      for (let n = 0;n < r.children.length; n++) {
        let s = r.children[n];
        if (!e(s))
          continue;
        let { prev: i2, next: a } = s;
        i2.value += `<${s.rawName}>` + s.firstChild.value + `</${s.rawName}>` + a.value, i2.sourceSpan = new h(i2.sourceSpan.start, a.sourceSpan.end), i2.isTrailingSpaceSensitive = a.isTrailingSpaceSensitive, i2.hasTrailingSpaces = a.hasTrailingSpaces, r.removeChild(s), n--, r.removeChild(a);
      }
  });
}
function Qa(t4, e) {
  if (e.parser === "html")
    return;
  let r = /\{\{(.+?)\}\}/su;
  t4.walk((n) => {
    if (qn(n, e))
      for (let s of n.children) {
        if (s.type !== "text")
          continue;
        let i2 = s.sourceSpan.start, a = null, o = s.value.split(r);
        for (let u = 0;u < o.length; u++, i2 = a) {
          let p = o[u];
          if (u % 2 === 0) {
            a = i2.moveBy(p.length), p.length > 0 && n.insertChildBefore(s, { type: "text", value: p, sourceSpan: new h(i2, a) });
            continue;
          }
          a = i2.moveBy(p.length + 4), n.insertChildBefore(s, { type: "interpolation", sourceSpan: new h(i2, a), children: p.length === 0 ? [] : [{ type: "text", value: p, sourceSpan: new h(i2.moveBy(2), a.moveBy(-2)) }] });
        }
        n.removeChild(s);
      }
  });
}
function Ja(t4, e) {
  t4.walk((r) => {
    let n = r.$children;
    if (!n)
      return;
    if (n.length === 0 || n.length === 1 && n[0].type === "text" && O.trim(n[0].value).length === 0) {
      r.hasDanglingSpaces = n.length > 0, r.$children = [];
      return;
    }
    let s = Hn(r, e), i2 = Ar(r);
    if (!s)
      for (let a = 0;a < n.length; a++) {
        let o = n[a];
        if (o.type !== "text")
          continue;
        let { leadingWhitespace: u, text: p, trailingWhitespace: l2 } = Mn(o.value), m = o.prev, f = o.next;
        p ? (o.value = p, o.sourceSpan = new h(o.sourceSpan.start.moveBy(u.length), o.sourceSpan.end.moveBy(-l2.length)), u && (m && (m.hasTrailingSpaces = true), o.hasLeadingSpaces = true), l2 && (o.hasTrailingSpaces = true, f && (f.hasLeadingSpaces = true))) : (r.removeChild(o), a--, (u || l2) && (m && (m.hasTrailingSpaces = true), f && (f.hasLeadingSpaces = true)));
      }
    r.isWhitespaceSensitive = s, r.isIndentationSensitive = i2;
  });
}
function Za(t4) {
  t4.walk((e) => {
    e.isSelfClosing = !e.children || e.type === "element" && (e.tagDefinition.isVoid || e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end);
  });
}
function eo(t4, e) {
  t4.walk((r) => {
    r.type === "element" && (r.hasHtmComponentClosingTag = r.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(e.originalText.slice(r.endSourceSpan.start.offset, r.endSourceSpan.end.offset)));
  });
}
function to(t4, e) {
  t4.walk((r) => {
    r.cssDisplay = Qn(r, e);
  });
}
function ro(t4, e) {
  t4.walk((r) => {
    let { children: n } = r;
    if (n) {
      if (n.length === 0) {
        r.isDanglingSpaceSensitive = Wn(r, e);
        return;
      }
      for (let s of n)
        s.isLeadingSpaceSensitive = Vn(s, e), s.isTrailingSpaceSensitive = Un(s, e);
      for (let s = 0;s < n.length; s++) {
        let i2 = n[s];
        i2.isLeadingSpaceSensitive = (s === 0 || i2.prev.isTrailingSpaceSensitive) && i2.isLeadingSpaceSensitive, i2.isTrailingSpaceSensitive = (s === n.length - 1 || i2.next.isLeadingSpaceSensitive) && i2.isTrailingSpaceSensitive;
      }
    }
  });
}
function no(t4, e, r) {
  let { node: n } = t4;
  switch (n.type) {
    case "front-matter":
      return B(n.raw);
    case "root":
      return e.__onHtmlRoot && e.__onHtmlRoot(n), [E(Re(t4, e, r)), S];
    case "element":
    case "ieConditionalComment":
      return Is(t4, e, r);
    case "angularControlFlowBlock":
      return Bs(t4, e, r);
    case "angularControlFlowBlockParameters":
      return Fs(t4, e, r);
    case "angularControlFlowBlockParameter":
      return O.trim(n.expression);
    case "angularLetDeclaration":
      return E(["@let ", E([n.id, " =", E(k2([_2, r("init")]))]), ";"]);
    case "angularLetDeclarationInitializer":
      return n.value;
    case "angularIcuExpression":
      return Ps(t4, e, r);
    case "angularIcuCase":
      return Ns(t4, e, r);
    case "ieConditionalStartComment":
    case "ieConditionalEndComment":
      return [De(n), Se(n)];
    case "interpolation":
      return [De(n, e), ...t4.map(r, "children"), Se(n, e)];
    case "text": {
      if (n.parent.type === "interpolation") {
        let o = /\n[^\S\n]*$/u, u = o.test(n.value), p = u ? n.value.replace(o, "") : n.value;
        return [B(p), u ? S : ""];
      }
      let s = z(n, e), i2 = kt(n), a = G(n, e);
      return i2[0] = [s, i2[0]], i2.push([i2.pop(), a]), vt(i2);
    }
    case "docType":
      return [E([De(n, e), " ", w(false, n.value.replace(/^html\b/iu, "html"), /\s+/gu, " ")]), Se(n, e)];
    case "comment":
      return [z(n, e), B(e.originalText.slice(J(n), se(n))), G(n, e)];
    case "attribute": {
      if (n.value === null)
        return n.rawName;
      let s = wr(n.value), i2 = _n(s, '"');
      return [n.rawName, "=", i2, B(i2 === '"' ? w(false, s, '"', "&quot;") : w(false, s, "'", "&apos;")), i2];
    }
    case "cdata":
    default:
      throw new An(n, "HTML");
  }
}
function ct(t4, e = true) {
  if (t4[0] != ":")
    return [null, t4];
  let r = t4.indexOf(":", 1);
  if (r === -1) {
    if (e)
      throw new Error(`Unsupported format "${t4}" expecting ":namespace:name"`);
    return [null, t4];
  }
  return [t4.slice(1, r), t4.slice(r + 1)];
}
function Nr(t4) {
  return ct(t4)[1] === "ng-container";
}
function Ir(t4) {
  return ct(t4)[1] === "ng-content";
}
function Me(t4) {
  return t4 === null ? null : ct(t4)[0];
}
function qe(t4, e) {
  return t4 ? `:${t4}:${e}` : e;
}
function Rr() {
  return Ht || (Ht = {}, qt(Z.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), qt(Z.STYLE, ["*|style"]), qt(Z.URL, ["*|formAction", "area|href", "area|ping", "audio|src", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "form|action", "img|src", "input|src", "ins|cite", "q|cite", "source|src", "track|src", "video|poster", "video|src"]), qt(Z.RESOURCE_URL, ["applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])), Ht;
}
function qt(t4, e) {
  for (let r of e)
    Ht[r.toLowerCase()] = t4;
}
function ho(t4) {
  switch (t4) {
    case "width":
    case "height":
    case "minWidth":
    case "minHeight":
    case "maxWidth":
    case "maxHeight":
    case "left":
    case "top":
    case "bottom":
    case "right":
    case "fontSize":
    case "outlineWidth":
    case "outlineOffset":
    case "paddingTop":
    case "paddingLeft":
    case "paddingBottom":
    case "paddingRight":
    case "marginTop":
    case "marginLeft":
    case "marginBottom":
    case "marginRight":
    case "borderRadius":
    case "borderWidth":
    case "borderTopWidth":
    case "borderLeftWidth":
    case "borderRightWidth":
    case "borderBottomWidth":
    case "textIndent":
      return true;
    default:
      return false;
  }
}
function He(t4) {
  return pt || (Ks = new d({ canSelfClose: true }), pt = Object.assign(Object.create(null), { base: new d({ isVoid: true }), meta: new d({ isVoid: true }), area: new d({ isVoid: true }), embed: new d({ isVoid: true }), link: new d({ isVoid: true }), img: new d({ isVoid: true }), input: new d({ isVoid: true }), param: new d({ isVoid: true }), hr: new d({ isVoid: true }), br: new d({ isVoid: true }), source: new d({ isVoid: true }), track: new d({ isVoid: true }), wbr: new d({ isVoid: true }), p: new d({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new d({ closedByChildren: ["tbody", "tfoot"] }), tbody: new d({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new d({ closedByChildren: ["tbody"], closedByParent: true }), tr: new d({ closedByChildren: ["tr"], closedByParent: true }), td: new d({ closedByChildren: ["td", "th"], closedByParent: true }), th: new d({ closedByChildren: ["td", "th"], closedByParent: true }), col: new d({ isVoid: true }), svg: new d({ implicitNamespacePrefix: "svg" }), foreignObject: new d({ implicitNamespacePrefix: "svg", preventNamespaceInheritance: true }), math: new d({ implicitNamespacePrefix: "math" }), li: new d({ closedByChildren: ["li"], closedByParent: true }), dt: new d({ closedByChildren: ["dt", "dd"] }), dd: new d({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new d({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new d({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new d({ closedByChildren: ["optgroup"], closedByParent: true }), option: new d({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new d({ ignoreFirstLf: true }), listing: new d({ ignoreFirstLf: true }), style: new d({ contentType: N.RAW_TEXT }), script: new d({ contentType: N.RAW_TEXT }), title: new d({ contentType: { default: N.ESCAPABLE_RAW_TEXT, svg: N.PARSABLE_DATA } }), textarea: new d({ contentType: N.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), new Ut().allKnownElementNames().forEach((e) => {
    !pt[e] && Me(e) === null && (pt[e] = new d({ canSelfClose: false }));
  })), pt[t4] ?? Ks;
}
function Qt(t4, e, r = null) {
  let n = [], s = t4.visit ? (i2) => t4.visit(i2, r) || i2.visit(t4, r) : (i2) => i2.visit(t4, r);
  return e.forEach((i2) => {
    let a = s(i2);
    a && n.push(a);
  }), n;
}
function Xs(t4, e) {
  if (e != null && !(Array.isArray(e) && e.length == 2))
    throw new Error(`Expected '${t4}' to be an array, [start, end].`);
  if (e != null) {
    let r = e[0], n = e[1];
    go.forEach((s) => {
      if (s.test(r) || s.test(n))
        throw new Error(`['${r}', '${n}'] contains unusable interpolation symbol.`);
    });
  }
}
function li(t5, e, r, n = {}) {
  let s = new Wr(new ve(t5, e), r, n);
  return s.tokenize(), new Ur(Vo(s.tokens), s.errors, s.nonNormalizedIcuExpressions);
}
function Ue(t5) {
  return `Unexpected character "${t5 === 0 ? "EOF" : String.fromCharCode(t5)}"`;
}
function ti(t5) {
  return `Unknown entity "${t5}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
}
function Ro(t5, e) {
  return `Unable to parse entity "${e}" - ${t5} character reference entities must end with ";"`;
}
function b3(t5) {
  return !ut(t5) || t5 === 0;
}
function ri(t5) {
  return ut(t5) || t5 === 62 || t5 === 60 || t5 === 47 || t5 === 39 || t5 === 34 || t5 === 61 || t5 === 0;
}
function $o(t5) {
  return (t5 < 97 || 122 < t5) && (t5 < 65 || 90 < t5) && (t5 < 48 || t5 > 57);
}
function Oo(t5) {
  return t5 === 59 || t5 === 0 || !Rs(t5);
}
function Mo(t5) {
  return t5 === 59 || t5 === 0 || !lt2(t5);
}
function qo(t5) {
  return t5 !== 125;
}
function Ho(t5, e) {
  return ni(t5) === ni(e);
}
function ni(t5) {
  return t5 >= 97 && t5 <= 122 ? t5 - 97 + 65 : t5;
}
function si(t5) {
  return lt2(t5) || Rt(t5) || t5 === 95;
}
function ii(t5) {
  return t5 !== 59 && b3(t5);
}
function Vo(t5) {
  let e = [], r;
  for (let n = 0;n < t5.length; n++) {
    let s = t5[n];
    r && r.type === 5 && s.type === 5 || r && r.type === 16 && s.type === 16 ? (r.parts[0] += s.parts[0], r.sourceSpan.end = s.sourceSpan.end) : (r = s, e.push(r));
  }
  return e;
}
function ci(t9, e) {
  return t9.length > 0 && t9[t9.length - 1] === e;
}
function pi(t9, e) {
  return Ve[e] !== undefined ? Ve[e] || t9 : /^#x[a-f0-9]+$/i.test(e) ? String.fromCodePoint(parseInt(e.slice(2), 16)) : /^#\d+$/.test(e) ? String.fromCodePoint(parseInt(e.slice(1), 10)) : t9;
}
function Qr(t9, e = {}) {
  let { canSelfClose: r = false, allowHtmComponentClosingTags: n = false, isTagNameCaseSensitive: s = false, getTagContentType: i2, tokenizeAngularBlocks: a = false, tokenizeAngularLetDeclaration: o = false } = e;
  return Uo().parse(t9, "angular-html-parser", { tokenizeExpansionForms: a, interpolationConfig: undefined, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a, tokenizeLet: o }, s, i2);
}
function Wo(t9, e) {
  let r = new SyntaxError(t9 + " (" + e.loc.start.line + ":" + e.loc.start.column + ")");
  return Object.assign(r, e);
}
function Go(t9) {
  let e = t9.slice(0, _t);
  if (e !== "---" && e !== "+++")
    return;
  let r = t9.indexOf(`
`, _t);
  if (r === -1)
    return;
  let n = t9.slice(_t, r).trim(), s = t9.indexOf(`
${e}`, r), i2 = n;
  if (i2 || (i2 = e === "+++" ? "toml" : "yaml"), s === -1 && e === "---" && i2 === "yaml" && (s = t9.indexOf(`
...`, r)), s === -1)
    return;
  let a = s + 1 + _t, o = t9.charAt(a + 1);
  if (!/\s?/u.test(o))
    return;
  let u = t9.slice(0, a);
  return { type: "front-matter", language: i2, explicitLanguage: n, value: t9.slice(r + 1, s), startDelimiter: e, endDelimiter: u.slice(-_t), raw: u };
}
function zo(t9) {
  let e = Go(t9);
  if (!e)
    return { content: t9 };
  let { raw: r } = e;
  return { frontMatter: e, content: w(false, r, /[^\n]/gu, " ") + t9.slice(r.length) };
}
function Yo(t9, e) {
  let r = t9.map(e);
  return r.some((n, s) => n !== t9[s]) ? r : t9;
}
function di(t9, e) {
  if (t9.value)
    for (let { regex: r, parse: n } of jo) {
      let s = t9.value.match(r);
      if (s)
        return n(t9, e, s);
    }
  return null;
}
function Ko(t9, e, r) {
  let [, n, s, i2] = r, a = 4 + n.length, o = t9.sourceSpan.start.moveBy(a), u = o.moveBy(i2.length), [p, l2] = (() => {
    try {
      return [true, e(i2, o).children];
    } catch {
      return [false, [{ type: "text", value: i2, sourceSpan: new h(o, u) }]];
    }
  })();
  return { type: "ieConditionalComment", complete: p, children: l2, condition: w(false, s.trim(), /\s+/gu, " "), sourceSpan: t9.sourceSpan, startSourceSpan: new h(t9.sourceSpan.start, o), endSourceSpan: new h(u, t9.sourceSpan.end) };
}
function Xo(t9, e, r) {
  let [, n] = r;
  return { type: "ieConditionalStartComment", condition: w(false, n.trim(), /\s+/gu, " "), sourceSpan: t9.sourceSpan };
}
function Qo(t9) {
  return { type: "ieConditionalEndComment", sourceSpan: t9.sourceSpan };
}
function Jo(t9) {
  if (t9.type === "block") {
    if (t9.name = w(false, t9.name.toLowerCase(), /\s+/gu, " ").trim(), t9.type = "angularControlFlowBlock", !me(t9.parameters)) {
      delete t9.parameters;
      return;
    }
    for (let e of t9.parameters)
      e.type = "angularControlFlowBlockParameter";
    t9.parameters = { type: "angularControlFlowBlockParameters", children: t9.parameters, sourceSpan: new h(t9.parameters[0].sourceSpan.start, K(false, t9.parameters, -1).sourceSpan.end) };
  }
}
function Zo(t9) {
  t9.type === "letDeclaration" && (t9.type = "angularLetDeclaration", t9.id = t9.name, t9.init = { type: "angularLetDeclarationInitializer", sourceSpan: new h(t9.valueSpan.start, t9.valueSpan.end), value: t9.value }, delete t9.name, delete t9.value);
}
function eu(t9) {
  (t9.type === "plural" || t9.type === "select") && (t9.clause = t9.type, t9.type = "angularIcuExpression"), t9.type === "expansionCase" && (t9.type = "angularIcuCase");
}
function Si(t9, e, r) {
  let { name: n, canSelfClose: s = true, normalizeTagName: i2 = false, normalizeAttributeName: a = false, allowHtmComponentClosingTags: o = false, isTagNameCaseSensitive: u = false, shouldParseAsRawText: p } = e, { rootNodes: l2, errors: m } = Qr(t9, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: p ? (...c) => p(...c) ? N.RAW_TEXT : undefined : undefined, tokenizeAngularBlocks: n === "angular" ? true : undefined, tokenizeAngularLetDeclaration: n === "angular" ? true : undefined });
  if (n === "vue") {
    if (l2.some((x2) => x2.type === "docType" && x2.value === "html" || x2.type === "element" && x2.name.toLowerCase() === "html"))
      return Si(t9, en, r);
    let g, y = () => g ?? (g = Qr(t9, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })), q = (x2) => y().rootNodes.find(({ startSourceSpan: U }) => U && U.start.offset === x2.startSourceSpan.start.offset) ?? x2;
    for (let [x2, U] of l2.entries()) {
      let { endSourceSpan: nn, startSourceSpan: Ei } = U;
      if (nn === null)
        m = y().errors, l2[x2] = q(U);
      else if (tu(U, r)) {
        let sn = y().errors.find((an) => an.span.start.offset > Ei.start.offset && an.span.start.offset < nn.end.offset);
        sn && Ci(sn), l2[x2] = q(U);
      }
    }
  }
  m.length > 0 && Ci(m[0]);
  let f = (c) => {
    let g = c.name.startsWith(":") ? c.name.slice(1).split(":")[0] : null, y = c.nameSpan.toString(), q = g !== null && y.startsWith(`${g}:`), x2 = q ? y.slice(g.length + 1) : y;
    c.name = x2, c.namespace = g, c.hasExplicitNamespace = q;
  }, C = (c) => {
    switch (c.type) {
      case "element":
        f(c);
        for (let g of c.attrs)
          f(g), g.valueSpan ? (g.value = g.valueSpan.toString(), /["']/u.test(g.value[0]) && (g.value = g.value.slice(1, -1))) : g.value = null;
        break;
      case "comment":
        c.value = c.sourceSpan.toString().slice(4, -3);
        break;
      case "text":
        c.value = c.sourceSpan.toString();
        break;
    }
  }, A = (c, g) => {
    let y = c.toLowerCase();
    return g(y) ? y : c;
  }, D = (c) => {
    if (c.type === "element" && (i2 && (!c.namespace || c.namespace === c.tagDefinition.implicitNamespacePrefix || fe(c)) && (c.name = A(c.name, (g) => gi.has(g))), a))
      for (let g of c.attrs)
        g.namespace || (g.name = A(g.name, (y) => ur.has(c.name) && (ur.get("*").has(y) || ur.get(c.name).has(y))));
  }, I = (c) => {
    c.sourceSpan && c.endSourceSpan && (c.sourceSpan = new h(c.sourceSpan.start, c.endSourceSpan.end));
  }, F = (c) => {
    if (c.type === "element") {
      let g = He(u ? c.name : c.name.toLowerCase());
      !c.namespace || c.namespace === g.implicitNamespacePrefix || fe(c) ? c.tagDefinition = g : c.tagDefinition = He("");
    }
  };
  return Qt(new class extends ft {
    visitExpansionCase(c, g) {
      n === "angular" && this.visitChildren(g, (y) => {
        y(c.expression);
      });
    }
    visit(c) {
      C(c), F(c), D(c), I(c);
    }
  }, l2), l2;
}
function tu(t9, e) {
  var n;
  if (t9.type !== "element" || t9.name !== "template")
    return false;
  let r = (n = t9.attrs.find((s) => s.name === "lang")) == null ? undefined : n.value;
  return !r || Ne(e, { language: r }) === "html";
}
function Ci(t9) {
  let { msg: e, span: { start: r, end: n } } = t9;
  throw hi(e, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: t9 });
}
function _i(t9, e, r = {}, n = true) {
  let { frontMatter: s, content: i2 } = n ? mi(t9) : { frontMatter: null, content: t9 }, a = new ve(t9, r.filepath), o = new ie(a, 0, 0, 0), u = o.moveBy(t9.length), p = { type: "root", sourceSpan: new h(o, u), children: Si(i2, e, r) };
  if (s) {
    let f = new ie(a, 0, 0, 0), C = f.moveBy(s.raw.length);
    s.sourceSpan = new h(f, C), p.children.unshift(s);
  }
  let l2 = new or2(p), m = (f, C) => {
    let { offset: A } = C, D = w(false, t9.slice(0, A), /[^\n\r]/gu, " "), F = _i(D + f, e, r, false);
    F.sourceSpan = new h(C, K(false, F.children, -1).sourceSpan.end);
    let c = F.children[0];
    return c.length === A ? F.children.shift() : (c.sourceSpan = new h(c.sourceSpan.start.moveBy(A), c.sourceSpan.end), c.value = c.value.slice(A)), F;
  };
  return l2.walk((f) => {
    if (f.type === "comment") {
      let C = di(f, m);
      C && f.parent.replaceChild(f, C);
    }
    Jo(f), Zo(f), eu(f);
  }), l2;
}
function Et(t9) {
  return { parse: (e, r) => _i(e, t9, r), hasPragma: ws, hasIgnorePragma: bs, astFormat: "html", locStart: J, locEnd: se };
}
var on, un = (t3) => {
  throw TypeError(t3);
}, Ai = (t3, e, r) => (e in t3) ? on(t3, e, { enumerable: true, configurable: true, writable: true, value: r }) : t3[e] = r, ln = (t3, e) => {
  for (var r in e)
    on(t3, r, { get: e[r], enumerable: true });
}, lr = (t3, e, r) => Ai(t3, typeof e != "symbol" ? e + "" : e, r), cn = (t3, e, r) => e.has(t3) || un("Cannot " + r), R = (t3, e, r) => (cn(t3, e, "read from private field"), r ? r.call(t3) : e.get(t3)), At = (t3, e, r) => e.has(t3) ? un("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t3) : e.set(t3, r), pn = (t3, e, r, n) => (cn(t3, e, "write to private field"), n ? n.call(t3, r) : e.set(t3, r), r), rn, Di = (t3, e, r, n) => {
  if (!(t3 && e == null))
    return e.replaceAll ? e.replaceAll(r, n) : r.global ? e.replace(r, n) : e.split(r).join(n);
}, w, we = "string", ze = "array", Ye = "cursor", be = "indent", Te = "align", je = "trim", xe = "group", ke = "fill", ce = "if-break", Be = "indent-if-break", Ke = "line-suffix", Xe = "line-suffix-boundary", j = "line", Qe = "label", Le = "break-parent", Dt, vi = (t3, e, r) => {
  if (!(t3 && e == null))
    return Array.isArray(e) || typeof e == "string" ? e[r < 0 ? e.length + r : r] : e.at(r);
}, K, Fe, wi = (t3) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(t3), cr, pr, mr = () => {}, re, fr, mn, ne2, xi, ki, _2, v, S, hn, yt = "'", Sn = '"', _n, V, gr = class {
  constructor(e) {
    At(this, V);
    pn(this, V, new Set(e));
  }
  getLeadingWhitespaceCount(e) {
    let r = R(this, V), n = 0;
    for (let s = 0;s < e.length && r.has(e.charAt(s)); s++)
      n++;
    return n;
  }
  getTrailingWhitespaceCount(e) {
    let r = R(this, V), n = 0;
    for (let s = e.length - 1;s >= 0 && r.has(e.charAt(s)); s--)
      n++;
    return n;
  }
  getLeadingWhitespace(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(0, r);
  }
  getTrailingWhitespace(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(e.length - r);
  }
  hasLeadingWhitespace(e) {
    return R(this, V).has(e.charAt(0));
  }
  hasTrailingWhitespace(e) {
    return R(this, V).has(K(false, e, -1));
  }
  trimStart(e) {
    let r = this.getLeadingWhitespaceCount(e);
    return e.slice(r);
  }
  trimEnd(e) {
    let r = this.getTrailingWhitespaceCount(e);
    return e.slice(0, e.length - r);
  }
  trim(e) {
    return this.trimEnd(this.trimStart(e));
  }
  split(e, r = false) {
    let n = `[${dr([...R(this, V)].join(""))}]+`, s = new RegExp(r ? `(${n})` : n, "u");
    return e.split(s);
  }
  hasWhitespaceCharacter(e) {
    let r = R(this, V);
    return Array.prototype.some.call(e, (n) => r.has(n));
  }
  hasNonWhitespaceCharacter(e) {
    let r = R(this, V);
    return Array.prototype.some.call(e, (n) => !r.has(n));
  }
  isWhitespaceOnly(e) {
    let r = R(this, V);
    return Array.prototype.every.call(e, (n) => r.has(n));
  }
}, En, Li, Fi, O, Cr, An, Pe, Ni, Ii, vn, yn, wn, Oi = (t3, e) => {
  if (!(t3 && e == null))
    return e.toReversed || !Array.isArray(e) ? e.toReversed() : [...e].reverse();
}, bn, me, Tn, xn, kn, Bn, Ln, qi, Nn, Ui = (t3) => String(t3).split(/[/\\]/u).pop(), Ne, $n = "inline", Sr, On = "normal", _r, fe, Yi = (t3) => w(false, t3, /^[\t\f\r ]*\n/gu, ""), Er = (t3) => Yi(O.trimEnd(t3)), Mn = (t3) => {
  let e = t3, r = O.getLeadingWhitespace(e);
  r && (e = e.slice(r.length));
  let n = O.getTrailingWhitespace(e);
  return n && (e = e.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: e };
}, oa, br, ua, la, ca, rs, ns, ma, fa, da, ga, is3, Ca, as, os2, Ea, us, xr, Ie, fs2, ds, ka, gs = "<!doctype", Nt, Ra, Ss, it = null, Oa = 10, _s, qa, Es, Ha, As, Ds = "format", vs, ys, xs, Ua, ie = class t3 {
  constructor(e, r, n, s) {
    this.file = e, this.offset = r, this.line = n, this.col = s;
  }
  toString() {
    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
  }
  moveBy(e) {
    let r = this.file.content, n = r.length, s = this.offset, i2 = this.line, a = this.col;
    for (;s > 0 && e < 0; )
      if (s--, e++, r.charCodeAt(s) == 10) {
        i2--;
        let u = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
        a = u > 0 ? s - u : s;
      } else
        a--;
    for (;s < n && e > 0; ) {
      let o = r.charCodeAt(s);
      s++, e--, o == 10 ? (i2++, a = 0) : a++;
    }
    return new t3(this.file, s, i2, a);
  }
  getContext(e, r) {
    let n = this.file.content, s = this.offset;
    if (s != null) {
      s > n.length - 1 && (s = n.length - 1);
      let i2 = s, a = 0, o = 0;
      for (;a < e && s > 0 && (s--, a++, !(n[s] == `
` && ++o == r)); )
        ;
      for (a = 0, o = 0;a < e && i2 < n.length - 1 && (i2++, a++, !(n[i2] == `
` && ++o == r)); )
        ;
      return { before: n.substring(s, this.offset), after: n.substring(this.offset, i2 + 1) };
    }
    return null;
  }
}, ve = class {
  constructor(e, r) {
    this.content = e, this.url = r;
  }
}, h = class {
  constructor(e, r, n = e, s = null) {
    this.start = e, this.end = r, this.fullStart = n, this.details = s;
  }
  toString() {
    return this.start.file.content.substring(this.start.offset, this.end.offset);
  }
}, Mt, Oe = class {
  constructor(e, r, n = Mt.ERROR, s) {
    this.span = e, this.msg = r, this.level = n, this.relatedError = s;
  }
  contextualMessage() {
    let e = this.span.start.getContext(100, 3);
    return e ? `${this.msg} ("${e.before}[${Mt[this.level]} ->]${e.after}")` : this.msg;
  }
  toString() {
    let e = this.span.details ? `, ${this.span.details}` : "";
    return `${this.contextualMessage()}: ${this.span.start}${e}`;
  }
}, Wa, Ms, so, qs, Hs, Lr, Vs = "HTML", io, Us, tn, ah, Ws, Gs, zs, Fr, Pr, Z, Ys, N, Ht, Vt = class {
}, ao = "boolean", oo = "number", uo = "string", lo = "object", co, js, po, Ut, d = class {
  constructor({ closedByChildren: e, implicitNamespacePrefix: r, contentType: n = N.PARSABLE_DATA, closedByParent: s = false, isVoid: i2 = false, ignoreFirstLf: a = false, preventNamespaceInheritance: o = false, canSelfClose: u = false } = {}) {
    this.closedByChildren = {}, this.closedByParent = false, e && e.length > 0 && e.forEach((p) => this.closedByChildren[p] = true), this.isVoid = i2, this.closedByParent = s || i2, this.implicitNamespacePrefix = r || null, this.contentType = n, this.ignoreFirstLf = a, this.preventNamespaceInheritance = o, this.canSelfClose = u ?? i2;
  }
  isClosedByChild(e) {
    return this.isVoid || e.toLowerCase() in this.closedByChildren;
  }
  getContentType(e) {
    return typeof this.contentType == "object" ? (e === undefined ? undefined : this.contentType[e]) ?? this.contentType.default : this.contentType;
  }
}, Ks, pt, ae = class {
  constructor(e, r) {
    this.sourceSpan = e, this.i18n = r;
  }
}, Wt, Gt, zt, Yt = class {
  constructor(e, r, n, s, i2) {
    this.value = e, this.expression = r, this.sourceSpan = n, this.valueSourceSpan = s, this.expSourceSpan = i2, this.type = "expansionCase";
  }
  visit(e, r) {
    return e.visitExpansionCase(this, r);
  }
}, jt, Y2, Kt = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "comment";
  }
  visit(e, r) {
    return e.visitComment(this, r);
  }
}, Xt = class {
  constructor(e, r) {
    this.value = e, this.sourceSpan = r, this.type = "docType";
  }
  visit(e, r) {
    return e.visitDocType(this, r);
  }
}, ee, ht = class {
  constructor(e, r) {
    this.expression = e, this.sourceSpan = r, this.type = "blockParameter", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitBlockParameter(this, r);
  }
}, mt = class {
  constructor(e, r, n, s, i2) {
    this.name = e, this.value = r, this.sourceSpan = n, this.nameSpan = s, this.valueSpan = i2, this.type = "letDeclaration", this.startSourceSpan = null, this.endSourceSpan = null;
  }
  visit(e, r) {
    return e.visitLetDeclaration(this, r);
  }
}, ft = class {
  constructor() {}
  visitElement(e, r) {
    this.visitChildren(r, (n) => {
      n(e.attrs), n(e.children);
    });
  }
  visitAttribute(e, r) {}
  visitText(e, r) {}
  visitCdata(e, r) {}
  visitComment(e, r) {}
  visitDocType(e, r) {}
  visitExpansion(e, r) {
    return this.visitChildren(r, (n) => {
      n(e.cases);
    });
  }
  visitExpansionCase(e, r) {}
  visitBlock(e, r) {
    this.visitChildren(r, (n) => {
      n(e.parameters), n(e.children);
    });
  }
  visitBlockParameter(e, r) {}
  visitLetDeclaration(e, r) {}
  visitChildren(e, r) {
    let n = [], s = this;
    function i2(a) {
      a && n.push(Qt(s, a, e));
    }
    return r(i2), Array.prototype.concat.apply([], n);
  }
}, Ve, fo = "\uE500", go, $r = class t4 {
  static fromArray(e) {
    return e ? (Xs("interpolation", e), new t4(e[0], e[1])) : Or3;
  }
  constructor(e, r) {
    this.start = e, this.end = r;
  }
}, Or3, gt2, Ur = class {
  constructor(e, r, n) {
    this.tokens = e, this.errors = r, this.nonNormalizedIcuExpressions = n;
  }
}, Io, rr, Ct = class {
  constructor(e) {
    this.error = e;
  }
}, Wr = class {
  constructor(e, r, n) {
    this._getTagContentType = r, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this.nonNormalizedIcuExpressions = [], this._tokenizeIcu = n.tokenizeExpansionForms || false, this._interpolationConfig = n.interpolationConfig || Or3, this._leadingTriviaCodePoints = n.leadingTriviaChars && n.leadingTriviaChars.map((i2) => i2.codePointAt(0) || 0), this._canSelfClose = n.canSelfClose || false, this._allowHtmComponentClosingTags = n.allowHtmComponentClosingTags || false;
    let s = n.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
    this._cursor = n.escapedString ? new Gr(e, s) : new nr(e, s), this._preserveLineEndings = n.preserveLineEndings || false, this._i18nNormalizeLineEndingsInICUs = n.i18nNormalizeLineEndingsInICUs || false, this._tokenizeBlocks = n.tokenizeBlocks ?? true, this._tokenizeLet = n.tokenizeLet ?? true;
    try {
      this._cursor.init();
    } catch (i2) {
      this.handleError(i2);
    }
  }
  _processCarriageReturns(e) {
    return this._preserveLineEndings ? e : e.replace(Io, `
`);
  }
  tokenize() {
    for (;this._cursor.peek() !== 0; ) {
      let e = this._cursor.clone();
      try {
        if (this._attemptCharCode(60))
          if (this._attemptCharCode(33))
            this._attemptStr("[CDATA[") ? this._consumeCdata(e) : this._attemptStr("--") ? this._consumeComment(e) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(e) : this._consumeBogusComment(e);
          else if (this._attemptCharCode(47))
            this._consumeTagClose(e);
          else {
            let r = this._cursor.clone();
            this._attemptCharCode(63) ? (this._cursor = r, this._consumeBogusComment(e)) : this._consumeTagOpen(e);
          }
        else
          this._tokenizeLet && this._cursor.peek() === 64 && !this._inInterpolation && this._attemptStr("@let") ? this._consumeLetDeclaration(e) : this._tokenizeBlocks && this._attemptCharCode(64) ? this._consumeBlockStart(e) : this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansionCase() && !this._isInExpansionForm() && this._attemptCharCode(125) ? this._consumeBlockEnd(e) : this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeWithInterpolation(5, 8, () => this._isTextEnd(), () => this._isTagStart());
      } catch (r) {
        this.handleError(r);
      }
    }
    this._beginToken(34), this._endToken([]);
  }
  _getBlockName() {
    let e = false, r = this._cursor.clone();
    return this._attemptCharCodeUntilFn((n) => ut(n) ? !e : si(n) ? (e = true, false) : true), this._cursor.getChars(r).trim();
  }
  _consumeBlockStart(e) {
    this._beginToken(25, e);
    let r = this._endToken([this._getBlockName()]);
    if (this._cursor.peek() === 40)
      if (this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(b3), this._attemptCharCode(41))
        this._attemptCharCodeUntilFn(b3);
      else {
        r.type = 29;
        return;
      }
    this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : r.type = 29;
  }
  _consumeBlockEnd(e) {
    this._beginToken(27, e), this._endToken([]);
  }
  _consumeBlockParameters() {
    for (this._attemptCharCodeUntilFn(ii);this._cursor.peek() !== 41 && this._cursor.peek() !== 0; ) {
      this._beginToken(28);
      let e = this._cursor.clone(), r = null, n = 0;
      for (;this._cursor.peek() !== 59 && this._cursor.peek() !== 0 || r !== null; ) {
        let s = this._cursor.peek();
        if (s === 92)
          this._cursor.advance();
        else if (s === r)
          r = null;
        else if (r === null && Ot(s))
          r = s;
        else if (s === 40 && r === null)
          n++;
        else if (s === 41 && r === null) {
          if (n === 0)
            break;
          n > 0 && n--;
        }
        this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(ii);
    }
  }
  _consumeLetDeclaration(e) {
    if (this._beginToken(30, e), ut(this._cursor.peek()))
      this._attemptCharCodeUntilFn(b3);
    else {
      let s = this._endToken([this._cursor.getChars(e)]);
      s.type = 33;
      return;
    }
    let r = this._endToken([this._getLetDeclarationName()]);
    if (this._attemptCharCodeUntilFn(b3), !this._attemptCharCode(61)) {
      r.type = 33;
      return;
    }
    this._attemptCharCodeUntilFn((s) => b3(s) && !$t(s)), this._consumeLetDeclarationValue(), this._cursor.peek() === 59 ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : (r.type = 33, r.sourceSpan = this._cursor.getSpan(e));
  }
  _getLetDeclarationName() {
    let e = this._cursor.clone(), r = false;
    return this._attemptCharCodeUntilFn((n) => lt2(n) || n === 36 || n === 95 || r && Rt(n) ? (r = true, false) : true), this._cursor.getChars(e).trim();
  }
  _consumeLetDeclarationValue() {
    let e = this._cursor.clone();
    for (this._beginToken(31, e);this._cursor.peek() !== 0; ) {
      let r = this._cursor.peek();
      if (r === 59)
        break;
      Ot(r) && (this._cursor.advance(), this._attemptCharCodeUntilFn((n) => n === 92 ? (this._cursor.advance(), false) : n === r)), this._cursor.advance();
    }
    this._endToken([this._cursor.getChars(e)]);
  }
  _tokenizeExpansionForm() {
    if (this.isExpansionFormStart())
      return this._consumeExpansionFormStart(), true;
    if (qo(this._cursor.peek()) && this._isInExpansionForm())
      return this._consumeExpansionCaseStart(), true;
    if (this._cursor.peek() === 125) {
      if (this._isInExpansionCase())
        return this._consumeExpansionCaseEnd(), true;
      if (this._isInExpansionForm())
        return this._consumeExpansionFormEnd(), true;
    }
    return false;
  }
  _beginToken(e, r = this._cursor.clone()) {
    this._currentTokenStart = r, this._currentTokenType = e;
  }
  _endToken(e, r) {
    if (this._currentTokenStart === null)
      throw new gt2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(r));
    if (this._currentTokenType === null)
      throw new gt2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
    let n = { type: this._currentTokenType, parts: e, sourceSpan: (r ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
    return this.tokens.push(n), this._currentTokenStart = null, this._currentTokenType = null, n;
  }
  _createError(e, r) {
    this._isInExpansionForm() && (e += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
    let n = new gt2(e, this._currentTokenType, r);
    return this._currentTokenStart = null, this._currentTokenType = null, new Ct(n);
  }
  handleError(e) {
    if (e instanceof St && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), e instanceof Ct)
      this.errors.push(e.error);
    else
      throw e;
  }
  _attemptCharCode(e) {
    return this._cursor.peek() === e ? (this._cursor.advance(), true) : false;
  }
  _attemptCharCodeCaseInsensitive(e) {
    return Ho(this._cursor.peek(), e) ? (this._cursor.advance(), true) : false;
  }
  _requireCharCode(e) {
    let r = this._cursor.clone();
    if (!this._attemptCharCode(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptStr(e) {
    let r = e.length;
    if (this._cursor.charsLeft() < r)
      return false;
    let n = this._cursor.clone();
    for (let s = 0;s < r; s++)
      if (!this._attemptCharCode(e.charCodeAt(s)))
        return this._cursor = n, false;
    return true;
  }
  _attemptStrCaseInsensitive(e) {
    for (let r = 0;r < e.length; r++)
      if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(r)))
        return false;
    return true;
  }
  _requireStr(e) {
    let r = this._cursor.clone();
    if (!this._attemptStr(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _requireStrCaseInsensitive(e) {
    let r = this._cursor.clone();
    if (!this._attemptStrCaseInsensitive(e))
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(r));
  }
  _attemptCharCodeUntilFn(e) {
    for (;!e(this._cursor.peek()); )
      this._cursor.advance();
  }
  _requireCharCodeUntilFn(e, r) {
    let n = this._cursor.clone();
    if (this._attemptCharCodeUntilFn(e), this._cursor.diff(n) < r)
      throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(n));
  }
  _attemptUntilChar(e) {
    for (;this._cursor.peek() !== e; )
      this._cursor.advance();
  }
  _readChar() {
    let e = String.fromCodePoint(this._cursor.peek());
    return this._cursor.advance(), e;
  }
  _consumeEntity(e) {
    this._beginToken(9);
    let r = this._cursor.clone();
    if (this._cursor.advance(), this._attemptCharCode(35)) {
      let n = this._attemptCharCode(120) || this._attemptCharCode(88), s = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Oo), this._cursor.peek() != 59) {
        this._cursor.advance();
        let a = n ? rr.HEX : rr.DEC;
        throw this._createError(Ro(a, this._cursor.getChars(r)), this._cursor.getSpan());
      }
      let i2 = this._cursor.getChars(s);
      this._cursor.advance();
      try {
        let a = parseInt(i2, n ? 16 : 10);
        this._endToken([String.fromCharCode(a), this._cursor.getChars(r)]);
      } catch {
        throw this._createError(ti(this._cursor.getChars(r)), this._cursor.getSpan());
      }
    } else {
      let n = this._cursor.clone();
      if (this._attemptCharCodeUntilFn(Mo), this._cursor.peek() != 59)
        this._beginToken(e, r), this._cursor = n, this._endToken(["&"]);
      else {
        let s = this._cursor.getChars(n);
        this._cursor.advance();
        let i2 = Ve[s];
        if (!i2)
          throw this._createError(ti(s), this._cursor.getSpan(r));
        this._endToken([i2, `&${s};`]);
      }
    }
  }
  _consumeRawText(e, r) {
    this._beginToken(e ? 6 : 7);
    let n = [];
    for (;; ) {
      let s = this._cursor.clone(), i2 = r();
      if (this._cursor = s, i2)
        break;
      e && this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(n.join(""))]), n.length = 0, this._consumeEntity(6), this._beginToken(6)) : n.push(this._readChar());
    }
    this._endToken([this._processCarriageReturns(n.join(""))]);
  }
  _consumeComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(11), this._requireStr("-->"), this._endToken([]);
  }
  _consumeBogusComment(e) {
    this._beginToken(10, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(11), this._cursor.advance(), this._endToken([]);
  }
  _consumeCdata(e) {
    this._beginToken(12, e), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(13), this._requireStr("]]>"), this._endToken([]);
  }
  _consumeDocType(e) {
    this._beginToken(18, e), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === 62), this._beginToken(19), this._cursor.advance(), this._endToken([]);
  }
  _consumePrefixAndName() {
    let e = this._cursor.clone(), r = "";
    for (;this._cursor.peek() !== 58 && !$o(this._cursor.peek()); )
      this._cursor.advance();
    let n;
    this._cursor.peek() === 58 ? (r = this._cursor.getChars(e), this._cursor.advance(), n = this._cursor.clone()) : n = e, this._requireCharCodeUntilFn(ri, r === "" ? 0 : 1);
    let s = this._cursor.getChars(n);
    return [r, s];
  }
  _consumeTagOpen(e) {
    let r, n, s, i2 = [];
    try {
      if (!lt2(this._cursor.peek()))
        throw this._createError(Ue(this._cursor.peek()), this._cursor.getSpan(e));
      for (s = this._consumeTagOpenStart(e), n = s.parts[0], r = s.parts[1], this._attemptCharCodeUntilFn(b3);this._cursor.peek() !== 47 && this._cursor.peek() !== 62 && this._cursor.peek() !== 60 && this._cursor.peek() !== 0; ) {
        let [o, u] = this._consumeAttributeName();
        if (this._attemptCharCodeUntilFn(b3), this._attemptCharCode(61)) {
          this._attemptCharCodeUntilFn(b3);
          let p = this._consumeAttributeValue();
          i2.push({ prefix: o, name: u, value: p });
        } else
          i2.push({ prefix: o, name: u });
        this._attemptCharCodeUntilFn(b3);
      }
      this._consumeTagOpenEnd();
    } catch (o) {
      if (o instanceof Ct) {
        s ? s.type = 4 : (this._beginToken(5, e), this._endToken(["<"]));
        return;
      }
      throw o;
    }
    if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === 2)
      return;
    let a = this._getTagContentType(r, n, this._fullNameStack.length > 0, i2);
    this._handleFullNameStackForTagOpen(n, r), a === N.RAW_TEXT ? this._consumeRawTextWithTagClose(n, r, false) : a === N.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(n, r, true);
  }
  _consumeRawTextWithTagClose(e, r, n) {
    this._consumeRawText(n, () => !this._attemptCharCode(60) || !this._attemptCharCode(47) || (this._attemptCharCodeUntilFn(b3), !this._attemptStrCaseInsensitive(e ? `${e}:${r}` : r)) ? false : (this._attemptCharCodeUntilFn(b3), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((s) => s === 62, 3), this._cursor.advance(), this._endToken([e, r]), this._handleFullNameStackForTagClose(e, r);
  }
  _consumeTagOpenStart(e) {
    this._beginToken(0, e);
    let r = this._consumePrefixAndName();
    return this._endToken(r);
  }
  _consumeAttributeName() {
    let e = this._cursor.peek();
    if (e === 39 || e === 34)
      throw this._createError(Ue(e), this._cursor.getSpan());
    this._beginToken(14);
    let r = this._consumePrefixAndName();
    return this._endToken(r), r;
  }
  _consumeAttributeValue() {
    let e;
    if (this._cursor.peek() === 39 || this._cursor.peek() === 34) {
      let r = this._cursor.peek();
      this._consumeQuote(r);
      let n = () => this._cursor.peek() === r;
      e = this._consumeWithInterpolation(16, 17, n, n), this._consumeQuote(r);
    } else {
      let r = () => ri(this._cursor.peek());
      e = this._consumeWithInterpolation(16, 17, r, r);
    }
    return e;
  }
  _consumeQuote(e) {
    this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
  }
  _consumeTagOpenEnd() {
    let e = this._attemptCharCode(47) ? 2 : 1;
    this._beginToken(e), this._requireCharCode(62), this._endToken([]);
  }
  _consumeTagClose(e) {
    if (this._beginToken(3, e), this._attemptCharCodeUntilFn(b3), this._allowHtmComponentClosingTags && this._attemptCharCode(47))
      this._attemptCharCodeUntilFn(b3), this._requireCharCode(62), this._endToken([]);
    else {
      let [r, n] = this._consumePrefixAndName();
      this._attemptCharCodeUntilFn(b3), this._requireCharCode(62), this._endToken([r, n]), this._handleFullNameStackForTagClose(r, n);
    }
  }
  _consumeExpansionFormStart() {
    this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
    let e = this._readUntil(44), r = this._processCarriageReturns(e);
    if (this._i18nNormalizeLineEndingsInICUs)
      this._endToken([r]);
    else {
      let s = this._endToken([e]);
      r !== e && this.nonNormalizedIcuExpressions.push(s);
    }
    this._requireCharCode(44), this._attemptCharCodeUntilFn(b3), this._beginToken(7);
    let n = this._readUntil(44);
    this._endToken([n]), this._requireCharCode(44), this._attemptCharCodeUntilFn(b3);
  }
  _consumeExpansionCaseStart() {
    this._beginToken(21);
    let e = this._readUntil(123).trim();
    this._endToken([e]), this._attemptCharCodeUntilFn(b3), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(b3), this._expansionCaseStack.push(22);
  }
  _consumeExpansionCaseEnd() {
    this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(b3), this._expansionCaseStack.pop();
  }
  _consumeExpansionFormEnd() {
    this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
  }
  _consumeWithInterpolation(e, r, n, s) {
    this._beginToken(e);
    let i2 = [];
    for (;!n(); ) {
      let o = this._cursor.clone();
      this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(i2.join(""))], o), i2.length = 0, this._consumeInterpolation(r, o, s), this._beginToken(e)) : this._cursor.peek() === 38 ? (this._endToken([this._processCarriageReturns(i2.join(""))]), i2.length = 0, this._consumeEntity(e), this._beginToken(e)) : i2.push(this._readChar());
    }
    this._inInterpolation = false;
    let a = this._processCarriageReturns(i2.join(""));
    return this._endToken([a]), a;
  }
  _consumeInterpolation(e, r, n) {
    let s = [];
    this._beginToken(e, r), s.push(this._interpolationConfig.start);
    let i2 = this._cursor.clone(), a = null, o = false;
    for (;this._cursor.peek() !== 0 && (n === null || !n()); ) {
      let u = this._cursor.clone();
      if (this._isTagStart()) {
        this._cursor = u, s.push(this._getProcessedChars(i2, u)), this._endToken(s);
        return;
      }
      if (a === null)
        if (this._attemptStr(this._interpolationConfig.end)) {
          s.push(this._getProcessedChars(i2, u)), s.push(this._interpolationConfig.end), this._endToken(s);
          return;
        } else
          this._attemptStr("//") && (o = true);
      let p = this._cursor.peek();
      this._cursor.advance(), p === 92 ? this._cursor.advance() : p === a ? a = null : !o && a === null && Ot(p) && (a = p);
    }
    s.push(this._getProcessedChars(i2, this._cursor)), this._endToken(s);
  }
  _getProcessedChars(e, r) {
    return this._processCarriageReturns(r.getChars(e));
  }
  _isTextEnd() {
    return !!(this._isTagStart() || this._cursor.peek() === 0 || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === 125 && this._isInExpansionCase()) || this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || this._cursor.peek() === 64 || this._cursor.peek() === 125));
  }
  _isTagStart() {
    if (this._cursor.peek() === 60) {
      let e = this._cursor.clone();
      e.advance();
      let r = e.peek();
      if (97 <= r && r <= 122 || 65 <= r && r <= 90 || r === 47 || r === 33)
        return true;
    }
    return false;
  }
  _isBlockStart() {
    if (this._tokenizeBlocks && this._cursor.peek() === 64) {
      let e = this._cursor.clone();
      if (e.advance(), si(e.peek()))
        return true;
    }
    return false;
  }
  _readUntil(e) {
    let r = this._cursor.clone();
    return this._attemptUntilChar(e), this._cursor.getChars(r);
  }
  _isInExpansion() {
    return this._isInExpansionCase() || this._isInExpansionForm();
  }
  _isInExpansionCase() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 22;
  }
  _isInExpansionForm() {
    return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === 20;
  }
  isExpansionFormStart() {
    if (this._cursor.peek() !== 123)
      return false;
    if (this._interpolationConfig) {
      let e = this._cursor.clone(), r = this._attemptStr(this._interpolationConfig.start);
      return this._cursor = e, !r;
    }
    return true;
  }
  _handleFullNameStackForTagOpen(e, r) {
    let n = qe(e, r);
    (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === n) && this._fullNameStack.push(n);
  }
  _handleFullNameStackForTagClose(e, r) {
    let n = qe(e, r);
    this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === n && this._fullNameStack.pop();
  }
}, nr = class t5 {
  constructor(e, r) {
    if (e instanceof t5) {
      this.file = e.file, this.input = e.input, this.end = e.end;
      let n = e.state;
      this.state = { peek: n.peek, offset: n.offset, line: n.line, column: n.column };
    } else {
      if (!r)
        throw new Error("Programming error: the range argument must be provided with a file argument.");
      this.file = e, this.input = e.content, this.end = r.endPos, this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol };
    }
  }
  clone() {
    return new t5(this);
  }
  peek() {
    return this.state.peek;
  }
  charsLeft() {
    return this.end - this.state.offset;
  }
  diff(e) {
    return this.state.offset - e.state.offset;
  }
  advance() {
    this.advanceState(this.state);
  }
  init() {
    this.updatePeek(this.state);
  }
  getSpan(e, r) {
    e = e || this;
    let n = e;
    if (r)
      for (;this.diff(e) > 0 && r.indexOf(e.peek()) !== -1; )
        n === e && (e = e.clone()), e.advance();
    let s = this.locationFromCursor(e), i2 = this.locationFromCursor(this), a = n !== e ? this.locationFromCursor(n) : s;
    return new h(s, i2, a);
  }
  getChars(e) {
    return this.input.substring(e.state.offset, this.state.offset);
  }
  charAt(e) {
    return this.input.charCodeAt(e);
  }
  advanceState(e) {
    if (e.offset >= this.end)
      throw this.state = e, new St('Unexpected character "EOF"', this);
    let r = this.charAt(e.offset);
    r === 10 ? (e.line++, e.column = 0) : $t(r) || e.column++, e.offset++, this.updatePeek(e);
  }
  updatePeek(e) {
    e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
  }
  locationFromCursor(e) {
    return new ie(e.file, e.state.offset, e.state.line, e.state.column);
  }
}, Gr, St = class {
  constructor(e, r) {
    this.msg = e, this.cursor = r;
  }
}, L, jr = class {
  constructor(e, r) {
    this.rootNodes = e, this.errors = r;
  }
}, sr = class {
  constructor(e) {
    this.getTagDefinition = e;
  }
  parse(e, r, n, s = false, i2) {
    let a = (D) => (I, ...F) => D(I.toLowerCase(), ...F), o = s ? this.getTagDefinition : a(this.getTagDefinition), u = (D) => o(D).getContentType(), p = s ? i2 : a(i2), m = li(e, r, i2 ? (D, I, F, c) => {
      let g = p(D, I, F, c);
      return g !== undefined ? g : u(D);
    } : u, n), f = n && n.canSelfClose || false, C = n && n.allowHtmComponentClosingTags || false, A = new Kr(m.tokens, o, f, C, s);
    return A.build(), new jr(A.rootNodes, m.errors.concat(A.errors));
  }
}, Kr = class t8 {
  constructor(e, r, n, s, i2) {
    this.tokens = e, this.getTagDefinition = r, this.canSelfClose = n, this.allowHtmComponentClosingTags = s, this.isTagNameCaseSensitive = i2, this._index = -1, this._containerStack = [], this.rootNodes = [], this.errors = [], this._advance();
  }
  build() {
    for (;this._peek.type !== 34; )
      this._peek.type === 0 || this._peek.type === 4 ? this._consumeStartTag(this._advance()) : this._peek.type === 3 ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === 12 ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === 10 ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === 5 || this._peek.type === 7 || this._peek.type === 6 ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === 20 ? this._consumeExpansion(this._advance()) : this._peek.type === 25 ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : this._peek.type === 27 ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : this._peek.type === 29 ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : this._peek.type === 30 ? (this._closeVoidElement(), this._consumeLet(this._advance())) : this._peek.type === 18 ? this._consumeDocType(this._advance()) : this._peek.type === 33 ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
    for (let e of this._containerStack)
      e instanceof ee && this.errors.push(L.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
  }
  _advance() {
    let e = this._peek;
    return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], e;
  }
  _advanceIf(e) {
    return this._peek.type === e ? this._advance() : null;
  }
  _consumeCdata(e) {
    let r = this._advance(), n = this._getText(r), s = this._advanceIf(13);
    this._addToParent(new Gt(n, new h(e.sourceSpan.start, (s || r).sourceSpan.end), [r]));
  }
  _consumeComment(e) {
    let r = this._advanceIf(7), n = this._advanceIf(11), s = r != null ? r.parts[0].trim() : null, i2 = n == null ? e.sourceSpan : new h(e.sourceSpan.start, n.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new Kt(s, i2));
  }
  _consumeDocType(e) {
    let r = this._advanceIf(7), n = this._advanceIf(19), s = r != null ? r.parts[0].trim() : null, i2 = new h(e.sourceSpan.start, (n || r || e).sourceSpan.end);
    this._addToParent(new Xt(s, i2));
  }
  _consumeExpansion(e) {
    let r = this._advance(), n = this._advance(), s = [];
    for (;this._peek.type === 21; ) {
      let a = this._parseExpansionCase();
      if (!a)
        return;
      s.push(a);
    }
    if (this._peek.type !== 24) {
      this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      return;
    }
    let i2 = new h(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
    this._addToParent(new zt(r.parts[0], n.parts[0], s, i2, r.sourceSpan)), this._advance();
  }
  _parseExpansionCase() {
    let e = this._advance();
    if (this._peek.type !== 22)
      return this.errors.push(L.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
    let r = this._advance(), n = this._collectExpansionExpTokens(r);
    if (!n)
      return null;
    let s = this._advance();
    n.push({ type: 34, parts: [], sourceSpan: s.sourceSpan });
    let i2 = new t8(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
    if (i2.build(), i2.errors.length > 0)
      return this.errors = this.errors.concat(i2.errors), null;
    let a = new h(e.sourceSpan.start, s.sourceSpan.end, e.sourceSpan.fullStart), o = new h(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
    return new Yt(e.parts[0], i2.rootNodes, a, e.sourceSpan, o);
  }
  _collectExpansionExpTokens(e) {
    let r = [], n = [22];
    for (;; ) {
      if ((this._peek.type === 20 || this._peek.type === 22) && n.push(this._peek.type), this._peek.type === 23)
        if (ci(n, 22)) {
          if (n.pop(), n.length === 0)
            return r;
        } else
          return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 24)
        if (ci(n, 20))
          n.pop();
        else
          return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      if (this._peek.type === 34)
        return this.errors.push(L.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
      r.push(this._advance());
    }
  }
  _getText(e) {
    let r = e.parts[0];
    if (r.length > 0 && r[0] == `
`) {
      let n = this._getClosestParentElement();
      n != null && n.children.length == 0 && this.getTagDefinition(n.name).ignoreFirstLf && (r = r.substring(1));
    }
    return r;
  }
  _consumeText(e) {
    let r = [e], n = e.sourceSpan, s = e.parts[0];
    if (s.length > 0 && s[0] === `
`) {
      let i2 = this._getContainer();
      i2 != null && i2.children.length === 0 && this.getTagDefinition(i2.name).ignoreFirstLf && (s = s.substring(1), r[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [s] });
    }
    for (;this._peek.type === 8 || this._peek.type === 5 || this._peek.type === 9; )
      e = this._advance(), r.push(e), e.type === 8 ? s += e.parts.join("").replace(/&([^;]+);/g, pi) : e.type === 9 ? s += e.parts[0] : s += e.parts.join("");
    if (s.length > 0) {
      let i2 = e.sourceSpan;
      this._addToParent(new Wt(s, new h(n.start, i2.end, n.fullStart, n.details), r));
    }
  }
  _closeVoidElement() {
    let e = this._getContainer();
    e instanceof Y2 && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
  }
  _consumeStartTag(e) {
    let [r, n] = e.parts, s = [];
    for (;this._peek.type === 14; )
      s.push(this._consumeAttr(this._advance()));
    let i2 = this._getElementFullName(r, n, this._getClosestParentElement()), a = false;
    if (this._peek.type === 2) {
      this._advance(), a = true;
      let C = this.getTagDefinition(i2);
      this.canSelfClose || C.canSelfClose || Me(i2) !== null || C.isVoid || this.errors.push(L.create(i2, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
    } else
      this._peek.type === 1 && (this._advance(), a = false);
    let o = this._peek.sourceSpan.fullStart, u = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), p = new h(e.sourceSpan.start, o, e.sourceSpan.fullStart), l2 = new h(e.sourceSpan.start.moveBy(1), e.sourceSpan.end), m = new Y2(i2, s, [], u, p, undefined, l2), f = this._getContainer();
    this._pushContainer(m, f instanceof Y2 && this.getTagDefinition(f.name).isClosedByChild(m.name)), a ? this._popContainer(i2, Y2, u) : e.type === 4 && (this._popContainer(i2, Y2, null), this.errors.push(L.create(i2, u, `Opening tag "${i2}" not terminated.`)));
  }
  _pushContainer(e, r) {
    r && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
  }
  _consumeEndTag(e) {
    let r = this.allowHtmComponentClosingTags && e.parts.length === 0 ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
    if (r && this.getTagDefinition(r).isVoid)
      this.errors.push(L.create(r, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
    else if (!this._popContainer(r, Y2, e.sourceSpan)) {
      let n = `Unexpected closing tag "${r}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
      this.errors.push(L.create(r, e.sourceSpan, n));
    }
  }
  _popContainer(e, r, n) {
    let s = false;
    for (let i2 = this._containerStack.length - 1;i2 >= 0; i2--) {
      let a = this._containerStack[i2];
      if (Me(a.name) ? a.name === e : (e == null || a.name.toLowerCase() === e.toLowerCase()) && a instanceof r)
        return a.endSourceSpan = n, a.sourceSpan.end = n !== null ? n.end : a.sourceSpan.end, this._containerStack.splice(i2, this._containerStack.length - i2), !s;
      (a instanceof ee || a instanceof Y2 && !this.getTagDefinition(a.name).closedByParent) && (s = true);
    }
    return false;
  }
  _consumeAttr(e) {
    let r = qe(e.parts[0], e.parts[1]), n = e.sourceSpan.end, s;
    this._peek.type === 15 && (s = this._advance());
    let i2 = "", a = [], o, u;
    if (this._peek.type === 16)
      for (o = this._peek.sourceSpan, u = this._peek.sourceSpan.end;this._peek.type === 16 || this._peek.type === 17 || this._peek.type === 9; ) {
        let m = this._advance();
        a.push(m), m.type === 17 ? i2 += m.parts.join("").replace(/&([^;]+);/g, pi) : m.type === 9 ? i2 += m.parts[0] : i2 += m.parts.join(""), u = n = m.sourceSpan.end;
      }
    this._peek.type === 15 && (u = n = this._advance().sourceSpan.end);
    let l2 = o && u && new h((s == null ? undefined : s.sourceSpan.start) ?? o.start, u, (s == null ? undefined : s.sourceSpan.fullStart) ?? o.fullStart);
    return new jt(r, i2, new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, l2, a.length > 0 ? a : undefined, undefined);
  }
  _consumeBlockOpen(e) {
    let r = [];
    for (;this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new ht(o.parts[0], o.sourceSpan));
    }
    this._peek.type === 26 && this._advance();
    let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i2 = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new ee(e.parts[0], r, [], s, e.sourceSpan, i2);
    this._pushContainer(a, false);
  }
  _consumeBlockClose(e) {
    this._popContainer(null, ee, e.sourceSpan) || this.errors.push(L.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
  }
  _consumeIncompleteBlock(e) {
    let r = [];
    for (;this._peek.type === 28; ) {
      let o = this._advance();
      r.push(new ht(o.parts[0], o.sourceSpan));
    }
    let n = this._peek.sourceSpan.fullStart, s = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), i2 = new h(e.sourceSpan.start, n, e.sourceSpan.fullStart), a = new ee(e.parts[0], r, [], s, e.sourceSpan, i2);
    this._pushContainer(a, false), this._popContainer(null, ee, null), this.errors.push(L.create(e.parts[0], s, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
  }
  _consumeLet(e) {
    let r = e.parts[0], n, s;
    if (this._peek.type !== 31) {
      this.errors.push(L.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${r}". Declaration must have a value.`));
      return;
    } else
      n = this._advance();
    if (this._peek.type !== 32) {
      this.errors.push(L.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${r}". Declaration must be terminated with a semicolon.`));
      return;
    } else
      s = this._advance();
    let i2 = s.sourceSpan.fullStart, a = new h(e.sourceSpan.start, i2, e.sourceSpan.fullStart), o = e.sourceSpan.toString().lastIndexOf(r), u = e.sourceSpan.start.moveBy(o), p = new h(u, e.sourceSpan.end), l2 = new mt(r, n.parts[0], a, p, n.sourceSpan);
    this._addToParent(l2);
  }
  _consumeIncompleteLet(e) {
    let r = e.parts[0] ?? "", n = r ? ` "${r}"` : "";
    if (r.length > 0) {
      let s = e.sourceSpan.toString().lastIndexOf(r), i2 = e.sourceSpan.start.moveBy(s), a = new h(i2, e.sourceSpan.end), o = new h(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)), u = new mt(r, "", e.sourceSpan, a, o);
      this._addToParent(u);
    }
    this.errors.push(L.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${n}. @let declarations must be written as \`@let <name> = <value>;\``));
  }
  _getContainer() {
    return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
  }
  _getClosestParentElement() {
    for (let e = this._containerStack.length - 1;e > -1; e--)
      if (this._containerStack[e] instanceof Y2)
        return this._containerStack[e];
    return null;
  }
  _addToParent(e) {
    let r = this._getContainer();
    r === null ? this.rootNodes.push(e) : r.children.push(e);
  }
  _getElementFullName(e, r, n) {
    if (e === "" && (e = this.getTagDefinition(r).implicitNamespacePrefix || "", e === "" && n != null)) {
      let s = ct(n.name)[1];
      this.getTagDefinition(s).preventNamespaceInheritance || (e = Me(n.name));
    }
    return qe(e, r);
  }
}, ir, Xr = null, Uo = () => (Xr || (Xr = new ir), Xr), hi, _t = 3, mi, ar, fi, le, Jr, Zr, Ge = class Ge2 {
  constructor(e = {}) {
    At(this, le);
    lr(this, "type");
    lr(this, "parent");
    for (let r of new Set([...fi, ...Object.keys(e)]))
      this.setProperty(r, e[r]);
  }
  setProperty(e, r) {
    if (this[e] !== r) {
      if (e in ar && (r = r.map((n) => this.createChild(n))), !fi.has(e)) {
        this[e] = r;
        return;
      }
      Object.defineProperty(this, e, { value: r, enumerable: false, configurable: true });
    }
  }
  map(e) {
    let r;
    for (let n in ar) {
      let s = this[n];
      if (s) {
        let i2 = Yo(s, (a) => a.map(e));
        r !== s && (r || (r = new Ge2({ parent: this.parent })), r.setProperty(n, i2));
      }
    }
    if (r)
      for (let n in this)
        n in ar || (r[n] = this[n]);
    return e(r || this);
  }
  walk(e) {
    for (let r in ar) {
      let n = this[r];
      if (n)
        for (let s = 0;s < n.length; s++)
          n[s].walk(e);
    }
    e(this);
  }
  createChild(e) {
    let r = e instanceof Ge2 ? e.clone() : new Ge2(e);
    return r.setProperty("parent", this), r;
  }
  insertChildBefore(e, r) {
    let n = this.$children;
    n.splice(n.indexOf(e), 0, this.createChild(r));
  }
  removeChild(e) {
    let r = this.$children;
    r.splice(r.indexOf(e), 1);
  }
  replaceChild(e, r) {
    let n = this.$children;
    n[n.indexOf(e)] = this.createChild(r);
  }
  clone() {
    return new Ge2(this);
  }
  get $children() {
    return this[R(this, le, Jr)];
  }
  set $children(e) {
    this[R(this, le, Jr)] = e;
  }
  get firstChild() {
    var e;
    return (e = this.$children) == null ? undefined : e[0];
  }
  get lastChild() {
    return K(true, this.$children, -1);
  }
  get prev() {
    let e = R(this, le, Zr);
    return e[e.indexOf(this) - 1];
  }
  get next() {
    let e = R(this, le, Zr);
    return e[e.indexOf(this) + 1];
  }
  get rawName() {
    return this.hasExplicitNamespace ? this.fullName : this.name;
  }
  get fullName() {
    return this.namespace ? this.namespace + ":" + this.name : this.name;
  }
  get attrMap() {
    return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
  }
}, or2, jo, ur, gi, en, ru, nu, su, iu, au, ou, uu, ym;
var init_html = __esm(() => {
  on = Object.defineProperty;
  rn = {};
  ln(rn, { languages: () => Hs, options: () => Us, parsers: () => tn, printers: () => uu });
  w = Di;
  Dt = new Set([Ye, be, Te, je, xe, ke, ce, Be, Ke, Xe, j, Qe, Le]);
  K = vi;
  Fe = yi;
  cr = class extends Error {
    name = "InvalidDocError";
    constructor(e) {
      super(bi(e)), this.doc = e;
    }
  };
  pr = cr;
  re = mr;
  fr = mr;
  mn = mr;
  ne2 = { type: Le };
  xi = { type: j, hard: true };
  ki = { type: j, hard: true, literal: true };
  _2 = { type: j };
  v = { type: j, soft: true };
  S = [xi, ne2];
  hn = [ki, ne2];
  _n = Bi;
  V = new WeakMap;
  En = gr;
  Li = ["\t", `
`, "\f", "\r", " "];
  Fi = new En(Li);
  O = Fi;
  Cr = class extends Error {
    name = "UnexpectedNodeError";
    constructor(e, r, n = "type") {
      super(`Unexpected ${r} node ${n}: ${JSON.stringify(e[n])}.`), this.node = e;
    }
  };
  An = Cr;
  Pe = Pi;
  Ni = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan", "keySpan", "tagDefinition", "tokens", "valueTokens", "switchValueSourceSpan", "expSourceSpan", "valueSourceSpan"]);
  Ii = new Set(["if", "else if", "for", "switch", "case"]);
  Dn.ignoredProperties = Ni;
  vn = Dn;
  yn = Ri;
  wn = $i;
  bn = Oi;
  me = Mi;
  qi = ((Tn = globalThis.Deno) == null ? undefined : Tn.build.os) === "windows" || ((kn = (xn = globalThis.navigator) == null ? undefined : xn.platform) == null ? undefined : kn.startsWith("Win")) || ((Ln = (Bn = globalThis.process) == null ? undefined : Bn.platform) == null ? undefined : Ln.startsWith("win")) || false;
  Nn = Pn;
  Ne = Gi;
  Sr = { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", style: "none", template: "inline", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", dialog: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", search: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", menu: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", input: "inline-block", button: "inline-block", fieldset: "block", details: "block", summary: "block", marquee: "inline-block", source: "block", track: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" };
  _r = { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" };
  fe = zi;
  oa = new Set(["template", "style", "script"]);
  br = /\{\{(.+?)\}\}/su;
  ua = Tr({ parser: "__ng_action" });
  la = Tr({ parser: "__ng_binding" });
  ca = Tr({ parser: "__ng_directive" });
  rs = pa;
  ns = ha;
  ma = /^[ \t\n\r\u000c]+/;
  fa = /^[, \t\n\r\u000c]+/;
  da = /^[^ \t\n\r\u000c]+/;
  ga = /[,]+$/;
  is3 = /^\d+$/;
  Ca = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
  as = Sa;
  os2 = { width: "w", height: "h", density: "x" };
  Ea = Object.keys(os2);
  us = _a2;
  xr = new WeakMap;
  Ie = Da;
  fs2 = ya;
  ds = Ta;
  ka = new Proxy(() => {}, { get: () => ka });
  Nt = Ia;
  Ra = new Set(["if", "else if", "for", "switch", "case"]);
  Ss = $a;
  for (let t3 = 0;t3 <= Oa; t3++)
    at();
  _s = Ma;
  qa = { "front-matter": [], root: ["children"], element: ["attrs", "children"], ieConditionalComment: ["children"], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ["children"], text: ["children"], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ["children", "parameters"], angularControlFlowBlockParameters: ["children"], angularControlFlowBlockParameter: [], angularLetDeclaration: ["init"], angularLetDeclarationInitializer: [], angularIcuExpression: ["cases"], angularIcuCase: ["expression"] };
  Es = qa;
  Ha = _s(Es);
  As = Ha;
  vs = /^\s*<!--\s*@(?:noformat|noprettier)\s*-->/u;
  ys = /^\s*<!--\s*@(?:format|prettier)\s*-->/u;
  xs = new Map([["if", new Set(["else if", "else"])], ["else if", new Set(["else if", "else"])], ["for", new Set(["empty"])], ["defer", new Set(["placeholder", "error", "loading"])], ["placeholder", new Set(["placeholder", "error", "loading"])], ["error", new Set(["placeholder", "error", "loading"])], ["loading", new Set(["placeholder", "error", "loading"])]]);
  Ua = /-+([a-z0-9])/g;
  (function(t4) {
    t4[t4.WARNING = 0] = "WARNING", t4[t4.ERROR = 1] = "ERROR";
  })(Mt || (Mt = {}));
  Wa = [za, Ya, Ka, Qa, Ja, to, Za, eo, ro, Xa];
  Ms = Ga;
  so = { preprocess: Ms, print: no, insertPragma: Ts, massageAstNode: vn, embed: Ss, getVisitorKeys: As };
  qs = so;
  Hs = [{ name: "Angular", type: "markup", extensions: [".component.html"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["angular"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "HTML", type: "markup", extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["html"], vscodeLanguageIds: ["html"], linguistLanguageId: 146 }, { name: "Lightning Web Components", type: "markup", extensions: [], tmScope: "text.html.basic", aceMode: "html", aliases: ["xhtml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["lwc"], vscodeLanguageIds: ["html"], filenames: [], linguistLanguageId: 146 }, { name: "MJML", type: "markup", extensions: [".mjml"], tmScope: "text.mjml.basic", aceMode: "html", aliases: ["MJML", "mjml"], codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", parsers: ["mjml"], filenames: [], vscodeLanguageIds: ["mjml"], linguistLanguageId: 146 }, { name: "Vue", type: "markup", extensions: [".vue"], tmScope: "source.vue", aceMode: "html", parsers: ["vue"], vscodeLanguageIds: ["vue"], linguistLanguageId: 391 }];
  Lr = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, objectWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap object literals.", choices: [{ value: "preserve", description: "Keep as multi-line, if there is a newline between the opening brace and first property." }, { value: "collapse", description: "Fit to a single line when possible." }] }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
  io = { bracketSameLine: Lr.bracketSameLine, htmlWhitespaceSensitivity: { category: Vs, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: Lr.singleAttributePerLine, vueIndentScriptAndStyle: { category: Vs, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
  Us = io;
  tn = {};
  ln(tn, { angular: () => iu, html: () => ru, lwc: () => ou, mjml: () => su, vue: () => au });
  ah = new RegExp(`(\\:not\\()|(([\\.\\#]?)[-\\w]+)|(?:\\[([-.\\w*\\\\$]+)(?:=(["']?)([^\\]"']*)\\5)?\\])|(\\))|(\\s*,\\s*)`, "g");
  (function(t4) {
    t4[t4.Emulated = 0] = "Emulated", t4[t4.None = 2] = "None", t4[t4.ShadowDom = 3] = "ShadowDom";
  })(Ws || (Ws = {}));
  (function(t4) {
    t4[t4.OnPush = 0] = "OnPush", t4[t4.Default = 1] = "Default";
  })(Gs || (Gs = {}));
  (function(t4) {
    t4[t4.None = 0] = "None", t4[t4.SignalBased = 1] = "SignalBased", t4[t4.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform";
  })(zs || (zs = {}));
  Fr = { name: "custom-elements" };
  Pr = { name: "no-errors-schema" };
  (function(t4) {
    t4[t4.NONE = 0] = "NONE", t4[t4.HTML = 1] = "HTML", t4[t4.STYLE = 2] = "STYLE", t4[t4.SCRIPT = 3] = "SCRIPT", t4[t4.URL = 4] = "URL", t4[t4.RESOURCE_URL = 5] = "RESOURCE_URL";
  })(Z || (Z = {}));
  (function(t4) {
    t4[t4.Error = 0] = "Error", t4[t4.Warning = 1] = "Warning", t4[t4.Ignore = 2] = "Ignore";
  })(Ys || (Ys = {}));
  (function(t4) {
    t4[t4.RAW_TEXT = 0] = "RAW_TEXT", t4[t4.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", t4[t4.PARSABLE_DATA = 2] = "PARSABLE_DATA";
  })(N || (N = {}));
  co = ["[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored", "[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy", "media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume", ":svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":svg:graphics^:svg:|", ":svg:animation^:svg:|*begin,*end,*repeat", ":svg:geometry^:svg:|", ":svg:componentTransferFunction^:svg:|", ":svg:gradient^:svg:|", ":svg:textContent^:svg:graphics|", ":svg:textPositioning^:svg:textContent|", "a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username", "area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username", "audio^media|", "br^[HTMLElement]|clear", "base^[HTMLElement]|href,target", "body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink", "button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value", "canvas^[HTMLElement]|#height,#width", "content^[HTMLElement]|select", "dl^[HTMLElement]|!compact", "data^[HTMLElement]|value", "datalist^[HTMLElement]|", "details^[HTMLElement]|!open", "dialog^[HTMLElement]|!open,returnValue", "dir^[HTMLElement]|!compact", "div^[HTMLElement]|align", "embed^[HTMLElement]|align,height,name,src,type,width", "fieldset^[HTMLElement]|!disabled,name", "font^[HTMLElement]|color,face,size", "form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target", "frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src", "frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows", "hr^[HTMLElement]|align,color,!noShade,size,width", "head^[HTMLElement]|", "h1,h2,h3,h4,h5,h6^[HTMLElement]|align", "html^[HTMLElement]|version", "iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width", "img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width", "input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width", "li^[HTMLElement]|type,#value", "label^[HTMLElement]|htmlFor", "legend^[HTMLElement]|align", "link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type", "map^[HTMLElement]|name", "marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width", "menu^[HTMLElement]|!compact", "meta^[HTMLElement]|content,httpEquiv,media,name,scheme", "meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value", "ins,del^[HTMLElement]|cite,dateTime", "ol^[HTMLElement]|!compact,!reversed,#start,type", "object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width", "optgroup^[HTMLElement]|!disabled,label", "option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value", "output^[HTMLElement]|defaultValue,%htmlFor,name,value", "p^[HTMLElement]|align", "param^[HTMLElement]|name,type,value,valueType", "picture^[HTMLElement]|", "pre^[HTMLElement]|#width", "progress^[HTMLElement]|#max,#value", "q,blockquote,cite^[HTMLElement]|", "script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type", "select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value", "slot^[HTMLElement]|name", "source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width", "span^[HTMLElement]|", "style^[HTMLElement]|!disabled,media,type", "caption^[HTMLElement]|align", "th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width", "col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width", "table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width", "tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign", "tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign", "template^[HTMLElement]|", "textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap", "time^[HTMLElement]|dateTime", "title^[HTMLElement]|text", "track^[HTMLElement]|!default,kind,label,src,srclang", "ul^[HTMLElement]|!compact,type", "unknown^[HTMLElement]|", "video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width", ":svg:a^:svg:graphics|", ":svg:animate^:svg:animation|", ":svg:animateMotion^:svg:animation|", ":svg:animateTransform^:svg:animation|", ":svg:circle^:svg:geometry|", ":svg:clipPath^:svg:graphics|", ":svg:defs^:svg:graphics|", ":svg:desc^:svg:|", ":svg:discard^:svg:|", ":svg:ellipse^:svg:geometry|", ":svg:feBlend^:svg:|", ":svg:feColorMatrix^:svg:|", ":svg:feComponentTransfer^:svg:|", ":svg:feComposite^:svg:|", ":svg:feConvolveMatrix^:svg:|", ":svg:feDiffuseLighting^:svg:|", ":svg:feDisplacementMap^:svg:|", ":svg:feDistantLight^:svg:|", ":svg:feDropShadow^:svg:|", ":svg:feFlood^:svg:|", ":svg:feFuncA^:svg:componentTransferFunction|", ":svg:feFuncB^:svg:componentTransferFunction|", ":svg:feFuncG^:svg:componentTransferFunction|", ":svg:feFuncR^:svg:componentTransferFunction|", ":svg:feGaussianBlur^:svg:|", ":svg:feImage^:svg:|", ":svg:feMerge^:svg:|", ":svg:feMergeNode^:svg:|", ":svg:feMorphology^:svg:|", ":svg:feOffset^:svg:|", ":svg:fePointLight^:svg:|", ":svg:feSpecularLighting^:svg:|", ":svg:feSpotLight^:svg:|", ":svg:feTile^:svg:|", ":svg:feTurbulence^:svg:|", ":svg:filter^:svg:|", ":svg:foreignObject^:svg:graphics|", ":svg:g^:svg:graphics|", ":svg:image^:svg:graphics|decoding", ":svg:line^:svg:geometry|", ":svg:linearGradient^:svg:gradient|", ":svg:mpath^:svg:|", ":svg:marker^:svg:|", ":svg:mask^:svg:|", ":svg:metadata^:svg:|", ":svg:path^:svg:geometry|", ":svg:pattern^:svg:|", ":svg:polygon^:svg:geometry|", ":svg:polyline^:svg:geometry|", ":svg:radialGradient^:svg:gradient|", ":svg:rect^:svg:geometry|", ":svg:svg^:svg:graphics|#currentScale,#zoomAndPan", ":svg:script^:svg:|type", ":svg:set^:svg:animation|", ":svg:stop^:svg:|", ":svg:style^:svg:|!disabled,media,title,type", ":svg:switch^:svg:graphics|", ":svg:symbol^:svg:|", ":svg:tspan^:svg:textPositioning|", ":svg:text^:svg:textPositioning|", ":svg:textPath^:svg:textContent|", ":svg:title^:svg:|", ":svg:use^:svg:graphics|", ":svg:view^:svg:|#zoomAndPan", "data^[HTMLElement]|value", "keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name", "menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default", "summary^[HTMLElement]|", "time^[HTMLElement]|dateTime", ":svg:cursor^:svg:|", ":math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex", ":math:math^:math:|", ":math:maction^:math:|", ":math:menclose^:math:|", ":math:merror^:math:|", ":math:mfenced^:math:|", ":math:mfrac^:math:|", ":math:mi^:math:|", ":math:mmultiscripts^:math:|", ":math:mn^:math:|", ":math:mo^:math:|", ":math:mover^:math:|", ":math:mpadded^:math:|", ":math:mphantom^:math:|", ":math:mroot^:math:|", ":math:mrow^:math:|", ":math:ms^:math:|", ":math:mspace^:math:|", ":math:msqrt^:math:|", ":math:mstyle^:math:|", ":math:msub^:math:|", ":math:msubsup^:math:|", ":math:msup^:math:|", ":math:mtable^:math:|", ":math:mtd^:math:|", ":math:mtext^:math:|", ":math:mtr^:math:|", ":math:munder^:math:|", ":math:munderover^:math:|", ":math:semantics^:math:|"];
  js = new Map(Object.entries({ class: "className", for: "htmlFor", formaction: "formAction", innerHtml: "innerHTML", readonly: "readOnly", tabindex: "tabIndex" }));
  po = Array.from(js).reduce((t4, [e, r]) => (t4.set(e, r), t4), new Map);
  Ut = class extends Vt {
    constructor() {
      super(), this._schema = new Map, this._eventSchema = new Map, co.forEach((e) => {
        let r = new Map, n = new Set, [s, i2] = e.split("|"), a = i2.split(","), [o, u] = s.split("^");
        o.split(",").forEach((l2) => {
          this._schema.set(l2.toLowerCase(), r), this._eventSchema.set(l2.toLowerCase(), n);
        });
        let p = u && this._schema.get(u.toLowerCase());
        if (p) {
          for (let [l2, m] of p)
            r.set(l2, m);
          for (let l2 of this._eventSchema.get(u.toLowerCase()))
            n.add(l2);
        }
        a.forEach((l2) => {
          if (l2.length > 0)
            switch (l2[0]) {
              case "*":
                n.add(l2.substring(1));
                break;
              case "!":
                r.set(l2.substring(1), ao);
                break;
              case "#":
                r.set(l2.substring(1), oo);
                break;
              case "%":
                r.set(l2.substring(1), lo);
                break;
              default:
                r.set(l2, uo);
            }
        });
      });
    }
    hasProperty(e, r, n) {
      if (n.some((i2) => i2.name === Pr.name))
        return true;
      if (e.indexOf("-") > -1) {
        if (Nr(e) || Ir(e))
          return false;
        if (n.some((i2) => i2.name === Fr.name))
          return true;
      }
      return (this._schema.get(e.toLowerCase()) || this._schema.get("unknown")).has(r);
    }
    hasElement(e, r) {
      return r.some((n) => n.name === Pr.name) || e.indexOf("-") > -1 && (Nr(e) || Ir(e) || r.some((n) => n.name === Fr.name)) ? true : this._schema.has(e.toLowerCase());
    }
    securityContext(e, r, n) {
      n && (r = this.getMappedPropName(r)), e = e.toLowerCase(), r = r.toLowerCase();
      let s = Rr()[e + "|" + r];
      return s || (s = Rr()["*|" + r], s || Z.NONE);
    }
    getMappedPropName(e) {
      return js.get(e) ?? e;
    }
    getDefaultComponentElementName() {
      return "ng-component";
    }
    validateProperty(e) {
      return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...
If '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: false };
    }
    validateAttribute(e) {
      return e.toLowerCase().startsWith("on") ? { error: true, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: false };
    }
    allKnownElementNames() {
      return Array.from(this._schema.keys());
    }
    allKnownAttributesOfElement(e) {
      let r = this._schema.get(e.toLowerCase()) || this._schema.get("unknown");
      return Array.from(r.keys()).map((n) => po.get(n) ?? n);
    }
    allKnownEventsOfElement(e) {
      return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
    }
    normalizeAnimationStyleProperty(e) {
      return Os(e);
    }
    normalizeAnimationStyleValue(e, r, n) {
      let s = "", i2 = n.toString().trim(), a = null;
      if (ho(e) && n !== 0 && n !== "0")
        if (typeof n == "number")
          s = "px";
        else {
          let o = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
          o && o[1].length == 0 && (a = `Please provide a CSS unit value for ${r}:${n}`);
        }
      return { error: a, value: i2 + s };
    }
  };
  Wt = class extends ae {
    constructor(e, r, n, s) {
      super(r, s), this.value = e, this.tokens = n, this.type = "text";
    }
    visit(e, r) {
      return e.visitText(this, r);
    }
  };
  Gt = class extends ae {
    constructor(e, r, n, s) {
      super(r, s), this.value = e, this.tokens = n, this.type = "cdata";
    }
    visit(e, r) {
      return e.visitCdata(this, r);
    }
  };
  zt = class extends ae {
    constructor(e, r, n, s, i2, a) {
      super(s, a), this.switchValue = e, this.type = r, this.cases = n, this.switchValueSourceSpan = i2;
    }
    visit(e, r) {
      return e.visitExpansion(this, r);
    }
  };
  jt = class extends ae {
    constructor(e, r, n, s, i2, a, o) {
      super(n, o), this.name = e, this.value = r, this.keySpan = s, this.valueSpan = i2, this.valueTokens = a, this.type = "attribute";
    }
    visit(e, r) {
      return e.visitAttribute(this, r);
    }
    get nameSpan() {
      return this.keySpan;
    }
  };
  Y2 = class extends ae {
    constructor(e, r, n, s, i2, a = null, o = null, u) {
      super(s, u), this.name = e, this.attrs = r, this.children = n, this.startSourceSpan = i2, this.endSourceSpan = a, this.nameSpan = o, this.type = "element";
    }
    visit(e, r) {
      return e.visitElement(this, r);
    }
  };
  ee = class extends ae {
    constructor(e, r, n, s, i2, a, o = null, u) {
      super(s, u), this.name = e, this.parameters = r, this.children = n, this.nameSpan = i2, this.startSourceSpan = a, this.endSourceSpan = o, this.type = "block";
    }
    visit(e, r) {
      return e.visitBlock(this, r);
    }
  };
  Ve = { AElig: "\xC6", AMP: "&", amp: "&", Aacute: "\xC1", Abreve: "\u0102", Acirc: "\xC2", Acy: "\u0410", Afr: "\uD835\uDD04", Agrave: "\xC0", Alpha: "\u0391", Amacr: "\u0100", And: "\u2A53", Aogon: "\u0104", Aopf: "\uD835\uDD38", ApplyFunction: "\u2061", af: "\u2061", Aring: "\xC5", angst: "\xC5", Ascr: "\uD835\uDC9C", Assign: "\u2254", colone: "\u2254", coloneq: "\u2254", Atilde: "\xC3", Auml: "\xC4", Backslash: "\u2216", setminus: "\u2216", setmn: "\u2216", smallsetminus: "\u2216", ssetmn: "\u2216", Barv: "\u2AE7", Barwed: "\u2306", doublebarwedge: "\u2306", Bcy: "\u0411", Because: "\u2235", becaus: "\u2235", because: "\u2235", Bernoullis: "\u212C", Bscr: "\u212C", bernou: "\u212C", Beta: "\u0392", Bfr: "\uD835\uDD05", Bopf: "\uD835\uDD39", Breve: "\u02D8", breve: "\u02D8", Bumpeq: "\u224E", HumpDownHump: "\u224E", bump: "\u224E", CHcy: "\u0427", COPY: "\xA9", copy: "\xA9", Cacute: "\u0106", Cap: "\u22D2", CapitalDifferentialD: "\u2145", DD: "\u2145", Cayleys: "\u212D", Cfr: "\u212D", Ccaron: "\u010C", Ccedil: "\xC7", Ccirc: "\u0108", Cconint: "\u2230", Cdot: "\u010A", Cedilla: "\xB8", cedil: "\xB8", CenterDot: "\xB7", centerdot: "\xB7", middot: "\xB7", Chi: "\u03A7", CircleDot: "\u2299", odot: "\u2299", CircleMinus: "\u2296", ominus: "\u2296", CirclePlus: "\u2295", oplus: "\u2295", CircleTimes: "\u2297", otimes: "\u2297", ClockwiseContourIntegral: "\u2232", cwconint: "\u2232", CloseCurlyDoubleQuote: "\u201D", rdquo: "\u201D", rdquor: "\u201D", CloseCurlyQuote: "\u2019", rsquo: "\u2019", rsquor: "\u2019", Colon: "\u2237", Proportion: "\u2237", Colone: "\u2A74", Congruent: "\u2261", equiv: "\u2261", Conint: "\u222F", DoubleContourIntegral: "\u222F", ContourIntegral: "\u222E", conint: "\u222E", oint: "\u222E", Copf: "\u2102", complexes: "\u2102", Coproduct: "\u2210", coprod: "\u2210", CounterClockwiseContourIntegral: "\u2233", awconint: "\u2233", Cross: "\u2A2F", Cscr: "\uD835\uDC9E", Cup: "\u22D3", CupCap: "\u224D", asympeq: "\u224D", DDotrahd: "\u2911", DJcy: "\u0402", DScy: "\u0405", DZcy: "\u040F", Dagger: "\u2021", ddagger: "\u2021", Darr: "\u21A1", Dashv: "\u2AE4", DoubleLeftTee: "\u2AE4", Dcaron: "\u010E", Dcy: "\u0414", Del: "\u2207", nabla: "\u2207", Delta: "\u0394", Dfr: "\uD835\uDD07", DiacriticalAcute: "\xB4", acute: "\xB4", DiacriticalDot: "\u02D9", dot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", dblac: "\u02DD", DiacriticalGrave: "`", grave: "`", DiacriticalTilde: "\u02DC", tilde: "\u02DC", Diamond: "\u22C4", diam: "\u22C4", diamond: "\u22C4", DifferentialD: "\u2146", dd: "\u2146", Dopf: "\uD835\uDD3B", Dot: "\xA8", DoubleDot: "\xA8", die: "\xA8", uml: "\xA8", DotDot: "\u20DC", DotEqual: "\u2250", doteq: "\u2250", esdot: "\u2250", DoubleDownArrow: "\u21D3", Downarrow: "\u21D3", dArr: "\u21D3", DoubleLeftArrow: "\u21D0", Leftarrow: "\u21D0", lArr: "\u21D0", DoubleLeftRightArrow: "\u21D4", Leftrightarrow: "\u21D4", hArr: "\u21D4", iff: "\u21D4", DoubleLongLeftArrow: "\u27F8", Longleftarrow: "\u27F8", xlArr: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", Longleftrightarrow: "\u27FA", xhArr: "\u27FA", DoubleLongRightArrow: "\u27F9", Longrightarrow: "\u27F9", xrArr: "\u27F9", DoubleRightArrow: "\u21D2", Implies: "\u21D2", Rightarrow: "\u21D2", rArr: "\u21D2", DoubleRightTee: "\u22A8", vDash: "\u22A8", DoubleUpArrow: "\u21D1", Uparrow: "\u21D1", uArr: "\u21D1", DoubleUpDownArrow: "\u21D5", Updownarrow: "\u21D5", vArr: "\u21D5", DoubleVerticalBar: "\u2225", par: "\u2225", parallel: "\u2225", shortparallel: "\u2225", spar: "\u2225", DownArrow: "\u2193", ShortDownArrow: "\u2193", darr: "\u2193", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", duarr: "\u21F5", DownBreve: "\u0311", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", leftharpoondown: "\u21BD", lhard: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", rhard: "\u21C1", rightharpoondown: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", top: "\u22A4", DownTeeArrow: "\u21A7", mapstodown: "\u21A7", Dscr: "\uD835\uDC9F", Dstrok: "\u0110", ENG: "\u014A", ETH: "\xD0", Eacute: "\xC9", Ecaron: "\u011A", Ecirc: "\xCA", Ecy: "\u042D", Edot: "\u0116", Efr: "\uD835\uDD08", Egrave: "\xC8", Element: "\u2208", in: "\u2208", isin: "\u2208", isinv: "\u2208", Emacr: "\u0112", EmptySmallSquare: "\u25FB", EmptyVerySmallSquare: "\u25AB", Eogon: "\u0118", Eopf: "\uD835\uDD3C", Epsilon: "\u0395", Equal: "\u2A75", EqualTilde: "\u2242", eqsim: "\u2242", esim: "\u2242", Equilibrium: "\u21CC", rightleftharpoons: "\u21CC", rlhar: "\u21CC", Escr: "\u2130", expectation: "\u2130", Esim: "\u2A73", Eta: "\u0397", Euml: "\xCB", Exists: "\u2203", exist: "\u2203", ExponentialE: "\u2147", ee: "\u2147", exponentiale: "\u2147", Fcy: "\u0424", Ffr: "\uD835\uDD09", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", blacksquare: "\u25AA", squarf: "\u25AA", squf: "\u25AA", Fopf: "\uD835\uDD3D", ForAll: "\u2200", forall: "\u2200", Fouriertrf: "\u2131", Fscr: "\u2131", GJcy: "\u0403", GT: ">", gt: ">", Gamma: "\u0393", Gammad: "\u03DC", Gbreve: "\u011E", Gcedil: "\u0122", Gcirc: "\u011C", Gcy: "\u0413", Gdot: "\u0120", Gfr: "\uD835\uDD0A", Gg: "\u22D9", ggg: "\u22D9", Gopf: "\uD835\uDD3E", GreaterEqual: "\u2265", ge: "\u2265", geq: "\u2265", GreaterEqualLess: "\u22DB", gel: "\u22DB", gtreqless: "\u22DB", GreaterFullEqual: "\u2267", gE: "\u2267", geqq: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", gl: "\u2277", gtrless: "\u2277", GreaterSlantEqual: "\u2A7E", geqslant: "\u2A7E", ges: "\u2A7E", GreaterTilde: "\u2273", gsim: "\u2273", gtrsim: "\u2273", Gscr: "\uD835\uDCA2", Gt: "\u226B", NestedGreaterGreater: "\u226B", gg: "\u226B", HARDcy: "\u042A", Hacek: "\u02C7", caron: "\u02C7", Hat: "^", Hcirc: "\u0124", Hfr: "\u210C", Poincareplane: "\u210C", HilbertSpace: "\u210B", Hscr: "\u210B", hamilt: "\u210B", Hopf: "\u210D", quaternions: "\u210D", HorizontalLine: "\u2500", boxh: "\u2500", Hstrok: "\u0126", HumpEqual: "\u224F", bumpe: "\u224F", bumpeq: "\u224F", IEcy: "\u0415", IJlig: "\u0132", IOcy: "\u0401", Iacute: "\xCD", Icirc: "\xCE", Icy: "\u0418", Idot: "\u0130", Ifr: "\u2111", Im: "\u2111", image: "\u2111", imagpart: "\u2111", Igrave: "\xCC", Imacr: "\u012A", ImaginaryI: "\u2148", ii: "\u2148", Int: "\u222C", Integral: "\u222B", int: "\u222B", Intersection: "\u22C2", bigcap: "\u22C2", xcap: "\u22C2", InvisibleComma: "\u2063", ic: "\u2063", InvisibleTimes: "\u2062", it: "\u2062", Iogon: "\u012E", Iopf: "\uD835\uDD40", Iota: "\u0399", Iscr: "\u2110", imagline: "\u2110", Itilde: "\u0128", Iukcy: "\u0406", Iuml: "\xCF", Jcirc: "\u0134", Jcy: "\u0419", Jfr: "\uD835\uDD0D", Jopf: "\uD835\uDD41", Jscr: "\uD835\uDCA5", Jsercy: "\u0408", Jukcy: "\u0404", KHcy: "\u0425", KJcy: "\u040C", Kappa: "\u039A", Kcedil: "\u0136", Kcy: "\u041A", Kfr: "\uD835\uDD0E", Kopf: "\uD835\uDD42", Kscr: "\uD835\uDCA6", LJcy: "\u0409", LT: "<", lt: "<", Lacute: "\u0139", Lambda: "\u039B", Lang: "\u27EA", Laplacetrf: "\u2112", Lscr: "\u2112", lagran: "\u2112", Larr: "\u219E", twoheadleftarrow: "\u219E", Lcaron: "\u013D", Lcedil: "\u013B", Lcy: "\u041B", LeftAngleBracket: "\u27E8", lang: "\u27E8", langle: "\u27E8", LeftArrow: "\u2190", ShortLeftArrow: "\u2190", larr: "\u2190", leftarrow: "\u2190", slarr: "\u2190", LeftArrowBar: "\u21E4", larrb: "\u21E4", LeftArrowRightArrow: "\u21C6", leftrightarrows: "\u21C6", lrarr: "\u21C6", LeftCeiling: "\u2308", lceil: "\u2308", LeftDoubleBracket: "\u27E6", lobrk: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", dharl: "\u21C3", downharpoonleft: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", lfloor: "\u230A", LeftRightArrow: "\u2194", harr: "\u2194", leftrightarrow: "\u2194", LeftRightVector: "\u294E", LeftTee: "\u22A3", dashv: "\u22A3", LeftTeeArrow: "\u21A4", mapstoleft: "\u21A4", LeftTeeVector: "\u295A", LeftTriangle: "\u22B2", vartriangleleft: "\u22B2", vltri: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", ltrie: "\u22B4", trianglelefteq: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", uharl: "\u21BF", upharpoonleft: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", leftharpoonup: "\u21BC", lharu: "\u21BC", LeftVectorBar: "\u2952", LessEqualGreater: "\u22DA", leg: "\u22DA", lesseqgtr: "\u22DA", LessFullEqual: "\u2266", lE: "\u2266", leqq: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", lg: "\u2276", LessLess: "\u2AA1", LessSlantEqual: "\u2A7D", leqslant: "\u2A7D", les: "\u2A7D", LessTilde: "\u2272", lesssim: "\u2272", lsim: "\u2272", Lfr: "\uD835\uDD0F", Ll: "\u22D8", Lleftarrow: "\u21DA", lAarr: "\u21DA", Lmidot: "\u013F", LongLeftArrow: "\u27F5", longleftarrow: "\u27F5", xlarr: "\u27F5", LongLeftRightArrow: "\u27F7", longleftrightarrow: "\u27F7", xharr: "\u27F7", LongRightArrow: "\u27F6", longrightarrow: "\u27F6", xrarr: "\u27F6", Lopf: "\uD835\uDD43", LowerLeftArrow: "\u2199", swarr: "\u2199", swarrow: "\u2199", LowerRightArrow: "\u2198", searr: "\u2198", searrow: "\u2198", Lsh: "\u21B0", lsh: "\u21B0", Lstrok: "\u0141", Lt: "\u226A", NestedLessLess: "\u226A", ll: "\u226A", Map: "\u2905", Mcy: "\u041C", MediumSpace: "\u205F", Mellintrf: "\u2133", Mscr: "\u2133", phmmat: "\u2133", Mfr: "\uD835\uDD10", MinusPlus: "\u2213", mnplus: "\u2213", mp: "\u2213", Mopf: "\uD835\uDD44", Mu: "\u039C", NJcy: "\u040A", Nacute: "\u0143", Ncaron: "\u0147", Ncedil: "\u0145", Ncy: "\u041D", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", ZeroWidthSpace: "\u200B", NewLine: `
`, Nfr: "\uD835\uDD11", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nbsp: "\xA0", Nopf: "\u2115", naturals: "\u2115", Not: "\u2AEC", NotCongruent: "\u2262", nequiv: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", npar: "\u2226", nparallel: "\u2226", nshortparallel: "\u2226", nspar: "\u2226", NotElement: "\u2209", notin: "\u2209", notinva: "\u2209", NotEqual: "\u2260", ne: "\u2260", NotEqualTilde: "\u2242\u0338", nesim: "\u2242\u0338", NotExists: "\u2204", nexist: "\u2204", nexists: "\u2204", NotGreater: "\u226F", ngt: "\u226F", ngtr: "\u226F", NotGreaterEqual: "\u2271", nge: "\u2271", ngeq: "\u2271", NotGreaterFullEqual: "\u2267\u0338", ngE: "\u2267\u0338", ngeqq: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", nGtv: "\u226B\u0338", NotGreaterLess: "\u2279", ntgl: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", NotGreaterTilde: "\u2275", ngsim: "\u2275", NotHumpDownHump: "\u224E\u0338", nbump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", nbumpe: "\u224F\u0338", NotLeftTriangle: "\u22EA", nltri: "\u22EA", ntriangleleft: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", nltrie: "\u22EC", ntrianglelefteq: "\u22EC", NotLess: "\u226E", nless: "\u226E", nlt: "\u226E", NotLessEqual: "\u2270", nle: "\u2270", nleq: "\u2270", NotLessGreater: "\u2278", ntlg: "\u2278", NotLessLess: "\u226A\u0338", nLtv: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", NotLessTilde: "\u2274", nlsim: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", NotPrecedes: "\u2280", npr: "\u2280", nprec: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", npre: "\u2AAF\u0338", npreceq: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", nprcue: "\u22E0", NotReverseElement: "\u220C", notni: "\u220C", notniva: "\u220C", NotRightTriangle: "\u22EB", nrtri: "\u22EB", ntriangleright: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", nrtrie: "\u22ED", ntrianglerighteq: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", nsqsube: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", nsqsupe: "\u22E3", NotSubset: "\u2282\u20D2", nsubset: "\u2282\u20D2", vnsub: "\u2282\u20D2", NotSubsetEqual: "\u2288", nsube: "\u2288", nsubseteq: "\u2288", NotSucceeds: "\u2281", nsc: "\u2281", nsucc: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", nsce: "\u2AB0\u0338", nsucceq: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", nsccue: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", nsupset: "\u2283\u20D2", vnsup: "\u2283\u20D2", NotSupersetEqual: "\u2289", nsupe: "\u2289", nsupseteq: "\u2289", NotTilde: "\u2241", nsim: "\u2241", NotTildeEqual: "\u2244", nsime: "\u2244", nsimeq: "\u2244", NotTildeFullEqual: "\u2247", ncong: "\u2247", NotTildeTilde: "\u2249", nap: "\u2249", napprox: "\u2249", NotVerticalBar: "\u2224", nmid: "\u2224", nshortmid: "\u2224", nsmid: "\u2224", Nscr: "\uD835\uDCA9", Ntilde: "\xD1", Nu: "\u039D", OElig: "\u0152", Oacute: "\xD3", Ocirc: "\xD4", Ocy: "\u041E", Odblac: "\u0150", Ofr: "\uD835\uDD12", Ograve: "\xD2", Omacr: "\u014C", Omega: "\u03A9", ohm: "\u03A9", Omicron: "\u039F", Oopf: "\uD835\uDD46", OpenCurlyDoubleQuote: "\u201C", ldquo: "\u201C", OpenCurlyQuote: "\u2018", lsquo: "\u2018", Or: "\u2A54", Oscr: "\uD835\uDCAA", Oslash: "\xD8", Otilde: "\xD5", Otimes: "\u2A37", Ouml: "\xD6", OverBar: "\u203E", oline: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", tbrk: "\u23B4", OverParenthesis: "\u23DC", PartialD: "\u2202", part: "\u2202", Pcy: "\u041F", Pfr: "\uD835\uDD13", Phi: "\u03A6", Pi: "\u03A0", PlusMinus: "\xB1", plusmn: "\xB1", pm: "\xB1", Popf: "\u2119", primes: "\u2119", Pr: "\u2ABB", Precedes: "\u227A", pr: "\u227A", prec: "\u227A", PrecedesEqual: "\u2AAF", pre: "\u2AAF", preceq: "\u2AAF", PrecedesSlantEqual: "\u227C", prcue: "\u227C", preccurlyeq: "\u227C", PrecedesTilde: "\u227E", precsim: "\u227E", prsim: "\u227E", Prime: "\u2033", Product: "\u220F", prod: "\u220F", Proportional: "\u221D", prop: "\u221D", propto: "\u221D", varpropto: "\u221D", vprop: "\u221D", Pscr: "\uD835\uDCAB", Psi: "\u03A8", QUOT: '"', quot: '"', Qfr: "\uD835\uDD14", Qopf: "\u211A", rationals: "\u211A", Qscr: "\uD835\uDCAC", RBarr: "\u2910", drbkarow: "\u2910", REG: "\xAE", circledR: "\xAE", reg: "\xAE", Racute: "\u0154", Rang: "\u27EB", Rarr: "\u21A0", twoheadrightarrow: "\u21A0", Rarrtl: "\u2916", Rcaron: "\u0158", Rcedil: "\u0156", Rcy: "\u0420", Re: "\u211C", Rfr: "\u211C", real: "\u211C", realpart: "\u211C", ReverseElement: "\u220B", SuchThat: "\u220B", ni: "\u220B", niv: "\u220B", ReverseEquilibrium: "\u21CB", leftrightharpoons: "\u21CB", lrhar: "\u21CB", ReverseUpEquilibrium: "\u296F", duhar: "\u296F", Rho: "\u03A1", RightAngleBracket: "\u27E9", rang: "\u27E9", rangle: "\u27E9", RightArrow: "\u2192", ShortRightArrow: "\u2192", rarr: "\u2192", rightarrow: "\u2192", srarr: "\u2192", RightArrowBar: "\u21E5", rarrb: "\u21E5", RightArrowLeftArrow: "\u21C4", rightleftarrows: "\u21C4", rlarr: "\u21C4", RightCeiling: "\u2309", rceil: "\u2309", RightDoubleBracket: "\u27E7", robrk: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", dharr: "\u21C2", downharpoonright: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rfloor: "\u230B", RightTee: "\u22A2", vdash: "\u22A2", RightTeeArrow: "\u21A6", map: "\u21A6", mapsto: "\u21A6", RightTeeVector: "\u295B", RightTriangle: "\u22B3", vartriangleright: "\u22B3", vrtri: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", rtrie: "\u22B5", trianglerighteq: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", uharr: "\u21BE", upharpoonright: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", rharu: "\u21C0", rightharpoonup: "\u21C0", RightVectorBar: "\u2953", Ropf: "\u211D", reals: "\u211D", RoundImplies: "\u2970", Rrightarrow: "\u21DB", rAarr: "\u21DB", Rscr: "\u211B", realine: "\u211B", Rsh: "\u21B1", rsh: "\u21B1", RuleDelayed: "\u29F4", SHCHcy: "\u0429", SHcy: "\u0428", SOFTcy: "\u042C", Sacute: "\u015A", Sc: "\u2ABC", Scaron: "\u0160", Scedil: "\u015E", Scirc: "\u015C", Scy: "\u0421", Sfr: "\uD835\uDD16", ShortUpArrow: "\u2191", UpArrow: "\u2191", uarr: "\u2191", uparrow: "\u2191", Sigma: "\u03A3", SmallCircle: "\u2218", compfn: "\u2218", Sopf: "\uD835\uDD4A", Sqrt: "\u221A", radic: "\u221A", Square: "\u25A1", squ: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", sqcap: "\u2293", SquareSubset: "\u228F", sqsub: "\u228F", sqsubset: "\u228F", SquareSubsetEqual: "\u2291", sqsube: "\u2291", sqsubseteq: "\u2291", SquareSuperset: "\u2290", sqsup: "\u2290", sqsupset: "\u2290", SquareSupersetEqual: "\u2292", sqsupe: "\u2292", sqsupseteq: "\u2292", SquareUnion: "\u2294", sqcup: "\u2294", Sscr: "\uD835\uDCAE", Star: "\u22C6", sstarf: "\u22C6", Sub: "\u22D0", Subset: "\u22D0", SubsetEqual: "\u2286", sube: "\u2286", subseteq: "\u2286", Succeeds: "\u227B", sc: "\u227B", succ: "\u227B", SucceedsEqual: "\u2AB0", sce: "\u2AB0", succeq: "\u2AB0", SucceedsSlantEqual: "\u227D", sccue: "\u227D", succcurlyeq: "\u227D", SucceedsTilde: "\u227F", scsim: "\u227F", succsim: "\u227F", Sum: "\u2211", sum: "\u2211", Sup: "\u22D1", Supset: "\u22D1", Superset: "\u2283", sup: "\u2283", supset: "\u2283", SupersetEqual: "\u2287", supe: "\u2287", supseteq: "\u2287", THORN: "\xDE", TRADE: "\u2122", trade: "\u2122", TSHcy: "\u040B", TScy: "\u0426", Tab: "\t", Tau: "\u03A4", Tcaron: "\u0164", Tcedil: "\u0162", Tcy: "\u0422", Tfr: "\uD835\uDD17", Therefore: "\u2234", there4: "\u2234", therefore: "\u2234", Theta: "\u0398", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", Tilde: "\u223C", sim: "\u223C", thicksim: "\u223C", thksim: "\u223C", TildeEqual: "\u2243", sime: "\u2243", simeq: "\u2243", TildeFullEqual: "\u2245", cong: "\u2245", TildeTilde: "\u2248", ap: "\u2248", approx: "\u2248", asymp: "\u2248", thickapprox: "\u2248", thkap: "\u2248", Topf: "\uD835\uDD4B", TripleDot: "\u20DB", tdot: "\u20DB", Tscr: "\uD835\uDCAF", Tstrok: "\u0166", Uacute: "\xDA", Uarr: "\u219F", Uarrocir: "\u2949", Ubrcy: "\u040E", Ubreve: "\u016C", Ucirc: "\xDB", Ucy: "\u0423", Udblac: "\u0170", Ufr: "\uD835\uDD18", Ugrave: "\xD9", Umacr: "\u016A", UnderBar: "_", lowbar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", bbrk: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", bigcup: "\u22C3", xcup: "\u22C3", UnionPlus: "\u228E", uplus: "\u228E", Uogon: "\u0172", Uopf: "\uD835\uDD4C", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", udarr: "\u21C5", UpDownArrow: "\u2195", updownarrow: "\u2195", varr: "\u2195", UpEquilibrium: "\u296E", udhar: "\u296E", UpTee: "\u22A5", bot: "\u22A5", bottom: "\u22A5", perp: "\u22A5", UpTeeArrow: "\u21A5", mapstoup: "\u21A5", UpperLeftArrow: "\u2196", nwarr: "\u2196", nwarrow: "\u2196", UpperRightArrow: "\u2197", nearr: "\u2197", nearrow: "\u2197", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", Uring: "\u016E", Uscr: "\uD835\uDCB0", Utilde: "\u0168", Uuml: "\xDC", VDash: "\u22AB", Vbar: "\u2AEB", Vcy: "\u0412", Vdash: "\u22A9", Vdashl: "\u2AE6", Vee: "\u22C1", bigvee: "\u22C1", xvee: "\u22C1", Verbar: "\u2016", Vert: "\u2016", VerticalBar: "\u2223", mid: "\u2223", shortmid: "\u2223", smid: "\u2223", VerticalLine: "|", verbar: "|", vert: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", wr: "\u2240", wreath: "\u2240", VeryThinSpace: "\u200A", hairsp: "\u200A", Vfr: "\uD835\uDD19", Vopf: "\uD835\uDD4D", Vscr: "\uD835\uDCB1", Vvdash: "\u22AA", Wcirc: "\u0174", Wedge: "\u22C0", bigwedge: "\u22C0", xwedge: "\u22C0", Wfr: "\uD835\uDD1A", Wopf: "\uD835\uDD4E", Wscr: "\uD835\uDCB2", Xfr: "\uD835\uDD1B", Xi: "\u039E", Xopf: "\uD835\uDD4F", Xscr: "\uD835\uDCB3", YAcy: "\u042F", YIcy: "\u0407", YUcy: "\u042E", Yacute: "\xDD", Ycirc: "\u0176", Ycy: "\u042B", Yfr: "\uD835\uDD1C", Yopf: "\uD835\uDD50", Yscr: "\uD835\uDCB4", Yuml: "\u0178", ZHcy: "\u0416", Zacute: "\u0179", Zcaron: "\u017D", Zcy: "\u0417", Zdot: "\u017B", Zeta: "\u0396", Zfr: "\u2128", zeetrf: "\u2128", Zopf: "\u2124", integers: "\u2124", Zscr: "\uD835\uDCB5", aacute: "\xE1", abreve: "\u0103", ac: "\u223E", mstpos: "\u223E", acE: "\u223E\u0333", acd: "\u223F", acirc: "\xE2", acy: "\u0430", aelig: "\xE6", afr: "\uD835\uDD1E", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", alpha: "\u03B1", amacr: "\u0101", amalg: "\u2A3F", and: "\u2227", wedge: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", angle: "\u2220", ange: "\u29A4", angmsd: "\u2221", measuredangle: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angzarr: "\u237C", aogon: "\u0105", aopf: "\uD835\uDD52", apE: "\u2A70", apacir: "\u2A6F", ape: "\u224A", approxeq: "\u224A", apid: "\u224B", apos: "'", aring: "\xE5", ascr: "\uD835\uDCB6", ast: "*", midast: "*", atilde: "\xE3", auml: "\xE4", awint: "\u2A11", bNot: "\u2AED", backcong: "\u224C", bcong: "\u224C", backepsilon: "\u03F6", bepsi: "\u03F6", backprime: "\u2035", bprime: "\u2035", backsim: "\u223D", bsim: "\u223D", backsimeq: "\u22CD", bsime: "\u22CD", barvee: "\u22BD", barwed: "\u2305", barwedge: "\u2305", bbrktbrk: "\u23B6", bcy: "\u0431", bdquo: "\u201E", ldquor: "\u201E", bemptyv: "\u29B0", beta: "\u03B2", beth: "\u2136", between: "\u226C", twixt: "\u226C", bfr: "\uD835\uDD1F", bigcirc: "\u25EF", xcirc: "\u25EF", bigodot: "\u2A00", xodot: "\u2A00", bigoplus: "\u2A01", xoplus: "\u2A01", bigotimes: "\u2A02", xotime: "\u2A02", bigsqcup: "\u2A06", xsqcup: "\u2A06", bigstar: "\u2605", starf: "\u2605", bigtriangledown: "\u25BD", xdtri: "\u25BD", bigtriangleup: "\u25B3", xutri: "\u25B3", biguplus: "\u2A04", xuplus: "\u2A04", bkarow: "\u290D", rbarr: "\u290D", blacklozenge: "\u29EB", lozf: "\u29EB", blacktriangle: "\u25B4", utrif: "\u25B4", blacktriangledown: "\u25BE", dtrif: "\u25BE", blacktriangleleft: "\u25C2", ltrif: "\u25C2", blacktriangleright: "\u25B8", rtrif: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bnot: "\u2310", bopf: "\uD835\uDD53", bowtie: "\u22C8", boxDL: "\u2557", boxDR: "\u2554", boxDl: "\u2556", boxDr: "\u2553", boxH: "\u2550", boxHD: "\u2566", boxHU: "\u2569", boxHd: "\u2564", boxHu: "\u2567", boxUL: "\u255D", boxUR: "\u255A", boxUl: "\u255C", boxUr: "\u2559", boxV: "\u2551", boxVH: "\u256C", boxVL: "\u2563", boxVR: "\u2560", boxVh: "\u256B", boxVl: "\u2562", boxVr: "\u255F", boxbox: "\u29C9", boxdL: "\u2555", boxdR: "\u2552", boxdl: "\u2510", boxdr: "\u250C", boxhD: "\u2565", boxhU: "\u2568", boxhd: "\u252C", boxhu: "\u2534", boxminus: "\u229F", minusb: "\u229F", boxplus: "\u229E", plusb: "\u229E", boxtimes: "\u22A0", timesb: "\u22A0", boxuL: "\u255B", boxuR: "\u2558", boxul: "\u2518", boxur: "\u2514", boxv: "\u2502", boxvH: "\u256A", boxvL: "\u2561", boxvR: "\u255E", boxvh: "\u253C", boxvl: "\u2524", boxvr: "\u251C", brvbar: "\xA6", bscr: "\uD835\uDCB7", bsemi: "\u204F", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bumpE: "\u2AAE", cacute: "\u0107", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", caps: "\u2229\uFE00", caret: "\u2041", ccaps: "\u2A4D", ccaron: "\u010D", ccedil: "\xE7", ccirc: "\u0109", ccups: "\u2A4C", ccupssm: "\u2A50", cdot: "\u010B", cemptyv: "\u29B2", cent: "\xA2", cfr: "\uD835\uDD20", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", chi: "\u03C7", cir: "\u25CB", cirE: "\u29C3", circ: "\u02C6", circeq: "\u2257", cire: "\u2257", circlearrowleft: "\u21BA", olarr: "\u21BA", circlearrowright: "\u21BB", orarr: "\u21BB", circledS: "\u24C8", oS: "\u24C8", circledast: "\u229B", oast: "\u229B", circledcirc: "\u229A", ocir: "\u229A", circleddash: "\u229D", odash: "\u229D", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", clubs: "\u2663", clubsuit: "\u2663", colon: ":", comma: ",", commat: "@", comp: "\u2201", complement: "\u2201", congdot: "\u2A6D", copf: "\uD835\uDD54", copysr: "\u2117", crarr: "\u21B5", cross: "\u2717", cscr: "\uD835\uDCB8", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", curlyeqprec: "\u22DE", cuesc: "\u22DF", curlyeqsucc: "\u22DF", cularr: "\u21B6", curvearrowleft: "\u21B6", cularrp: "\u293D", cup: "\u222A", cupbrcap: "\u2A48", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curvearrowright: "\u21B7", curarrm: "\u293C", curlyvee: "\u22CE", cuvee: "\u22CE", curlywedge: "\u22CF", cuwed: "\u22CF", curren: "\xA4", cwint: "\u2231", cylcty: "\u232D", dHar: "\u2965", dagger: "\u2020", daleth: "\u2138", dash: "\u2010", hyphen: "\u2010", dbkarow: "\u290F", rBarr: "\u290F", dcaron: "\u010F", dcy: "\u0434", ddarr: "\u21CA", downdownarrows: "\u21CA", ddotseq: "\u2A77", eDDot: "\u2A77", deg: "\xB0", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", dfr: "\uD835\uDD21", diamondsuit: "\u2666", diams: "\u2666", digamma: "\u03DD", gammad: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", djcy: "\u0452", dlcorn: "\u231E", llcorner: "\u231E", dlcrop: "\u230D", dollar: "$", dopf: "\uD835\uDD55", doteqdot: "\u2251", eDot: "\u2251", dotminus: "\u2238", minusd: "\u2238", dotplus: "\u2214", plusdo: "\u2214", dotsquare: "\u22A1", sdotb: "\u22A1", drcorn: "\u231F", lrcorner: "\u231F", drcrop: "\u230C", dscr: "\uD835\uDCB9", dscy: "\u0455", dsol: "\u29F6", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", triangledown: "\u25BF", dwangle: "\u29A6", dzcy: "\u045F", dzigrarr: "\u27FF", eacute: "\xE9", easter: "\u2A6E", ecaron: "\u011B", ecir: "\u2256", eqcirc: "\u2256", ecirc: "\xEA", ecolon: "\u2255", eqcolon: "\u2255", ecy: "\u044D", edot: "\u0117", efDot: "\u2252", fallingdotseq: "\u2252", efr: "\uD835\uDD22", eg: "\u2A9A", egrave: "\xE8", egs: "\u2A96", eqslantgtr: "\u2A96", egsdot: "\u2A98", el: "\u2A99", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", eqslantless: "\u2A95", elsdot: "\u2A97", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", emptyv: "\u2205", varnothing: "\u2205", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", eng: "\u014B", ensp: "\u2002", eogon: "\u0119", eopf: "\uD835\uDD56", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", epsilon: "\u03B5", epsiv: "\u03F5", straightepsilon: "\u03F5", varepsilon: "\u03F5", equals: "=", equest: "\u225F", questeq: "\u225F", equivDD: "\u2A78", eqvparsl: "\u29E5", erDot: "\u2253", risingdotseq: "\u2253", erarr: "\u2971", escr: "\u212F", eta: "\u03B7", eth: "\xF0", euml: "\xEB", euro: "\u20AC", excl: "!", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", ffr: "\uD835\uDD23", filig: "\uFB01", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", fopf: "\uD835\uDD57", fork: "\u22D4", pitchfork: "\u22D4", forkv: "\u2AD9", fpartint: "\u2A0D", frac12: "\xBD", half: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", sfrown: "\u2322", fscr: "\uD835\uDCBB", gEl: "\u2A8C", gtreqqless: "\u2A8C", gacute: "\u01F5", gamma: "\u03B3", gap: "\u2A86", gtrapprox: "\u2A86", gbreve: "\u011F", gcirc: "\u011D", gcy: "\u0433", gdot: "\u0121", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", gfr: "\uD835\uDD24", gimel: "\u2137", gjcy: "\u0453", glE: "\u2A92", gla: "\u2AA5", glj: "\u2AA4", gnE: "\u2269", gneqq: "\u2269", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gneq: "\u2A88", gnsim: "\u22E7", gopf: "\uD835\uDD58", gscr: "\u210A", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtrdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrarr: "\u2978", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", hardcy: "\u044A", harrcir: "\u2948", harrw: "\u21AD", leftrightsquigarrow: "\u21AD", hbar: "\u210F", hslash: "\u210F", planck: "\u210F", plankv: "\u210F", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", mldr: "\u2026", hercon: "\u22B9", hfr: "\uD835\uDD25", hksearow: "\u2925", searhk: "\u2925", hkswarow: "\u2926", swarhk: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", larrhk: "\u21A9", hookrightarrow: "\u21AA", rarrhk: "\u21AA", hopf: "\uD835\uDD59", horbar: "\u2015", hscr: "\uD835\uDCBD", hstrok: "\u0127", hybull: "\u2043", iacute: "\xED", icirc: "\xEE", icy: "\u0438", iecy: "\u0435", iexcl: "\xA1", ifr: "\uD835\uDD26", igrave: "\xEC", iiiint: "\u2A0C", qint: "\u2A0C", iiint: "\u222D", tint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", ijlig: "\u0133", imacr: "\u012B", imath: "\u0131", inodot: "\u0131", imof: "\u22B7", imped: "\u01B5", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", intcal: "\u22BA", intercal: "\u22BA", intlarhk: "\u2A17", intprod: "\u2A3C", iprod: "\u2A3C", iocy: "\u0451", iogon: "\u012F", iopf: "\uD835\uDD5A", iota: "\u03B9", iquest: "\xBF", iscr: "\uD835\uDCBE", isinE: "\u22F9", isindot: "\u22F5", isins: "\u22F4", isinsv: "\u22F3", itilde: "\u0129", iukcy: "\u0456", iuml: "\xEF", jcirc: "\u0135", jcy: "\u0439", jfr: "\uD835\uDD27", jmath: "\u0237", jopf: "\uD835\uDD5B", jscr: "\uD835\uDCBF", jsercy: "\u0458", jukcy: "\u0454", kappa: "\u03BA", kappav: "\u03F0", varkappa: "\u03F0", kcedil: "\u0137", kcy: "\u043A", kfr: "\uD835\uDD28", kgreen: "\u0138", khcy: "\u0445", kjcy: "\u045C", kopf: "\uD835\uDD5C", kscr: "\uD835\uDCC0", lAtail: "\u291B", lBarr: "\u290E", lEg: "\u2A8B", lesseqqgtr: "\u2A8B", lHar: "\u2962", lacute: "\u013A", laemptyv: "\u29B4", lambda: "\u03BB", langd: "\u2991", lap: "\u2A85", lessapprox: "\u2A85", laquo: "\xAB", larrbfs: "\u291F", larrfs: "\u291D", larrlp: "\u21AB", looparrowleft: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", leftarrowtail: "\u21A2", lat: "\u2AAB", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lcub: "{", lbrack: "[", lsqb: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", lcaron: "\u013E", lcedil: "\u013C", lcy: "\u043B", ldca: "\u2936", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", leq: "\u2264", leftleftarrows: "\u21C7", llarr: "\u21C7", leftthreetimes: "\u22CB", lthree: "\u22CB", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessdot: "\u22D6", ltdot: "\u22D6", lfisht: "\u297C", lfr: "\uD835\uDD29", lgE: "\u2A91", lharul: "\u296A", lhblk: "\u2584", ljcy: "\u0459", llhard: "\u296B", lltri: "\u25FA", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnE: "\u2268", lneqq: "\u2268", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lneq: "\u2A87", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", longmapsto: "\u27FC", xmap: "\u27FC", looparrowright: "\u21AC", rarrlp: "\u21AC", lopar: "\u2985", lopf: "\uD835\uDD5D", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", loz: "\u25CA", lozenge: "\u25CA", lpar: "(", lparlt: "\u2993", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\uD835\uDCC1", lsime: "\u2A8D", lsimg: "\u2A8F", lsquor: "\u201A", sbquo: "\u201A", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltrPar: "\u2996", ltri: "\u25C3", triangleleft: "\u25C3", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", mDDot: "\u223A", macr: "\xAF", strns: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", marker: "\u25AE", mcomma: "\u2A29", mcy: "\u043C", mdash: "\u2014", mfr: "\uD835\uDD2A", mho: "\u2127", micro: "\xB5", midcir: "\u2AF0", minus: "\u2212", minusdu: "\u2A2A", mlcp: "\u2ADB", models: "\u22A7", mopf: "\uD835\uDD5E", mscr: "\uD835\uDCC2", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nGg: "\u22D9\u0338", nGt: "\u226B\u20D2", nLeftarrow: "\u21CD", nlArr: "\u21CD", nLeftrightarrow: "\u21CE", nhArr: "\u21CE", nLl: "\u22D8\u0338", nLt: "\u226A\u20D2", nRightarrow: "\u21CF", nrArr: "\u21CF", nVDash: "\u22AF", nVdash: "\u22AE", nacute: "\u0144", nang: "\u2220\u20D2", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", natur: "\u266E", natural: "\u266E", ncap: "\u2A43", ncaron: "\u0148", ncedil: "\u0146", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", ncy: "\u043D", ndash: "\u2013", neArr: "\u21D7", nearhk: "\u2924", nedot: "\u2250\u0338", nesear: "\u2928", toea: "\u2928", nfr: "\uD835\uDD2B", nharr: "\u21AE", nleftrightarrow: "\u21AE", nhpar: "\u2AF2", nis: "\u22FC", nisd: "\u22FA", njcy: "\u045A", nlE: "\u2266\u0338", nleqq: "\u2266\u0338", nlarr: "\u219A", nleftarrow: "\u219A", nldr: "\u2025", nopf: "\uD835\uDD5F", not: "\xAC", notinE: "\u22F9\u0338", notindot: "\u22F5\u0338", notinvb: "\u22F7", notinvc: "\u22F6", notnivb: "\u22FE", notnivc: "\u22FD", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", nrarr: "\u219B", nrightarrow: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nscr: "\uD835\uDCC3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsubseteqq: "\u2AC5\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupseteqq: "\u2AC6\u0338", ntilde: "\xF1", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvDash: "\u22AD", nvHarr: "\u2904", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwArr: "\u21D6", nwarhk: "\u2923", nwnear: "\u2927", oacute: "\xF3", ocirc: "\xF4", ocy: "\u043E", odblac: "\u0151", odiv: "\u2A38", odsold: "\u29BC", oelig: "\u0153", ofcir: "\u29BF", ofr: "\uD835\uDD2C", ogon: "\u02DB", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", olcir: "\u29BE", olcross: "\u29BB", olt: "\u29C0", omacr: "\u014D", omega: "\u03C9", omicron: "\u03BF", omid: "\u29B6", oopf: "\uD835\uDD60", opar: "\u29B7", operp: "\u29B9", or: "\u2228", vee: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", oscr: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oslash: "\xF8", osol: "\u2298", otilde: "\xF5", otimesas: "\u2A36", ouml: "\xF6", ovbar: "\u233D", para: "\xB6", parsim: "\u2AF3", parsl: "\u2AFD", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", pertenk: "\u2031", pfr: "\uD835\uDD2D", phi: "\u03C6", phiv: "\u03D5", straightphi: "\u03D5", varphi: "\u03D5", phone: "\u260E", pi: "\u03C0", piv: "\u03D6", varpi: "\u03D6", planckh: "\u210E", plus: "+", plusacir: "\u2A23", pluscir: "\u2A22", plusdu: "\u2A25", pluse: "\u2A72", plussim: "\u2A26", plustwo: "\u2A27", pointint: "\u2A15", popf: "\uD835\uDD61", pound: "\xA3", prE: "\u2AB3", prap: "\u2AB7", precapprox: "\u2AB7", precnapprox: "\u2AB9", prnap: "\u2AB9", precneqq: "\u2AB5", prnE: "\u2AB5", precnsim: "\u22E8", prnsim: "\u22E8", prime: "\u2032", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prurel: "\u22B0", pscr: "\uD835\uDCC5", psi: "\u03C8", puncsp: "\u2008", qfr: "\uD835\uDD2E", qopf: "\uD835\uDD62", qprime: "\u2057", qscr: "\uD835\uDCC6", quatint: "\u2A16", quest: "?", rAtail: "\u291C", rHar: "\u2964", race: "\u223D\u0331", racute: "\u0155", raemptyv: "\u29B3", rangd: "\u2992", range: "\u29A5", raquo: "\xBB", rarrap: "\u2975", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrpl: "\u2945", rarrsim: "\u2974", rarrtl: "\u21A3", rightarrowtail: "\u21A3", rarrw: "\u219D", rightsquigarrow: "\u219D", ratail: "\u291A", ratio: "\u2236", rbbrk: "\u2773", rbrace: "}", rcub: "}", rbrack: "]", rsqb: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", rcaron: "\u0159", rcedil: "\u0157", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdsh: "\u21B3", rect: "\u25AD", rfisht: "\u297D", rfr: "\uD835\uDD2F", rharul: "\u296C", rho: "\u03C1", rhov: "\u03F1", varrho: "\u03F1", rightrightarrows: "\u21C9", rrarr: "\u21C9", rightthreetimes: "\u22CC", rthree: "\u22CC", ring: "\u02DA", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", ropar: "\u2986", ropf: "\uD835\uDD63", roplus: "\u2A2E", rotimes: "\u2A35", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rsaquo: "\u203A", rscr: "\uD835\uDCC7", rtimes: "\u22CA", rtri: "\u25B9", triangleright: "\u25B9", rtriltri: "\u29CE", ruluhar: "\u2968", rx: "\u211E", sacute: "\u015B", scE: "\u2AB4", scap: "\u2AB8", succapprox: "\u2AB8", scaron: "\u0161", scedil: "\u015F", scirc: "\u015D", scnE: "\u2AB6", succneqq: "\u2AB6", scnap: "\u2ABA", succnapprox: "\u2ABA", scnsim: "\u22E9", succnsim: "\u22E9", scpolint: "\u2A13", scy: "\u0441", sdot: "\u22C5", sdote: "\u2A66", seArr: "\u21D8", sect: "\xA7", semi: ";", seswar: "\u2929", tosa: "\u2929", sext: "\u2736", sfr: "\uD835\uDD30", sharp: "\u266F", shchcy: "\u0449", shcy: "\u0448", shy: "\xAD", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", varsigma: "\u03C2", simdot: "\u2A6A", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", smashp: "\u2A33", smeparsl: "\u29E4", smile: "\u2323", ssmile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", sopf: "\uD835\uDD64", spades: "\u2660", spadesuit: "\u2660", sqcaps: "\u2293\uFE00", sqcups: "\u2294\uFE00", sscr: "\uD835\uDCC8", star: "\u2606", sub: "\u2282", subset: "\u2282", subE: "\u2AC5", subseteqq: "\u2AC5", subdot: "\u2ABD", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subsetneqq: "\u2ACB", subne: "\u228A", subsetneq: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supE: "\u2AC6", supseteqq: "\u2AC6", supdot: "\u2ABE", supdsub: "\u2AD8", supedot: "\u2AC4", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supsetneqq: "\u2ACC", supne: "\u228B", supsetneq: "\u228B", supplus: "\u2AC0", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swArr: "\u21D9", swnwar: "\u292A", szlig: "\xDF", target: "\u2316", tau: "\u03C4", tcaron: "\u0165", tcedil: "\u0163", tcy: "\u0442", telrec: "\u2315", tfr: "\uD835\uDD31", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", vartheta: "\u03D1", thorn: "\xFE", times: "\xD7", timesbar: "\u2A31", timesd: "\u2A30", topbot: "\u2336", topcir: "\u2AF1", topf: "\uD835\uDD65", topfork: "\u2ADA", tprime: "\u2034", triangle: "\u25B5", utri: "\u25B5", triangleq: "\u225C", trie: "\u225C", tridot: "\u25EC", triminus: "\u2A3A", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", tscr: "\uD835\uDCC9", tscy: "\u0446", tshcy: "\u045B", tstrok: "\u0167", uHar: "\u2963", uacute: "\xFA", ubrcy: "\u045E", ubreve: "\u016D", ucirc: "\xFB", ucy: "\u0443", udblac: "\u0171", ufisht: "\u297E", ufr: "\uD835\uDD32", ugrave: "\xF9", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", umacr: "\u016B", uogon: "\u0173", uopf: "\uD835\uDD66", upsi: "\u03C5", upsilon: "\u03C5", upuparrows: "\u21C8", uuarr: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", uring: "\u016F", urtri: "\u25F9", uscr: "\uD835\uDCCA", utdot: "\u22F0", utilde: "\u0169", uuml: "\xFC", uwangle: "\u29A7", vBar: "\u2AE8", vBarv: "\u2AE9", vangrt: "\u299C", varsubsetneq: "\u228A\uFE00", vsubne: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", vsubnE: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", vsupne: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vsupnE: "\u2ACC\uFE00", vcy: "\u0432", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", vfr: "\uD835\uDD33", vopf: "\uD835\uDD67", vscr: "\uD835\uDCCB", vzigzag: "\u299A", wcirc: "\u0175", wedbar: "\u2A5F", wedgeq: "\u2259", weierp: "\u2118", wp: "\u2118", wfr: "\uD835\uDD34", wopf: "\uD835\uDD68", wscr: "\uD835\uDCCC", xfr: "\uD835\uDD35", xi: "\u03BE", xnis: "\u22FB", xopf: "\uD835\uDD69", xscr: "\uD835\uDCCD", yacute: "\xFD", yacy: "\u044F", ycirc: "\u0177", ycy: "\u044B", yen: "\xA5", yfr: "\uD835\uDD36", yicy: "\u0457", yopf: "\uD835\uDD6A", yscr: "\uD835\uDCCE", yucy: "\u044E", yuml: "\xFF", zacute: "\u017A", zcaron: "\u017E", zcy: "\u0437", zdot: "\u017C", zeta: "\u03B6", zfr: "\uD835\uDD37", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\uD835\uDD6B", zscr: "\uD835\uDCCF", zwj: "\u200D", zwnj: "\u200C" };
  Ve.ngsp = fo;
  go = [/@/, /^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
  Or3 = new $r("{{", "}}");
  gt2 = class extends Oe {
    constructor(e, r, n) {
      super(n, e), this.tokenType = r;
    }
  };
  Io = /\r\n?/g;
  (function(t5) {
    t5.HEX = "hexadecimal", t5.DEC = "decimal";
  })(rr || (rr = {}));
  Gr = class t6 extends nr {
    constructor(e, r) {
      e instanceof t6 ? (super(e), this.internalState = { ...e.internalState }) : (super(e, r), this.internalState = this.state);
    }
    advance() {
      this.state = this.internalState, super.advance(), this.processEscapeSequence();
    }
    init() {
      super.init(), this.processEscapeSequence();
    }
    clone() {
      return new t6(this);
    }
    getChars(e) {
      let r = e.clone(), n = "";
      for (;r.internalState.offset < this.internalState.offset; )
        n += String.fromCodePoint(r.peek()), r.advance();
      return n;
    }
    processEscapeSequence() {
      let e = () => this.internalState.peek;
      if (e() === 92)
        if (this.internalState = { ...this.state }, this.advanceState(this.internalState), e() === 110)
          this.state.peek = 10;
        else if (e() === 114)
          this.state.peek = 13;
        else if (e() === 118)
          this.state.peek = 11;
        else if (e() === 116)
          this.state.peek = 9;
        else if (e() === 98)
          this.state.peek = 8;
        else if (e() === 102)
          this.state.peek = 12;
        else if (e() === 117)
          if (this.advanceState(this.internalState), e() === 123) {
            this.advanceState(this.internalState);
            let r = this.clone(), n = 0;
            for (;e() !== 125; )
              this.advanceState(this.internalState), n++;
            this.state.peek = this.decodeHexDigits(r, n);
          } else {
            let r = this.clone();
            this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 4);
          }
        else if (e() === 120) {
          this.advanceState(this.internalState);
          let r = this.clone();
          this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(r, 2);
        } else if (Br(e())) {
          let r = "", n = 0, s = this.clone();
          for (;Br(e()) && n < 3; )
            s = this.clone(), r += String.fromCodePoint(e()), this.advanceState(this.internalState), n++;
          this.state.peek = parseInt(r, 8), this.internalState = s.internalState;
        } else
          $t(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
    }
    decodeHexDigits(e, r) {
      let n = this.input.slice(e.internalState.offset, e.internalState.offset + r), s = parseInt(n, 16);
      if (isNaN(s))
        throw e.state = e.internalState, new St("Invalid hexadecimal escape sequence", e);
      return s;
    }
  };
  L = class t7 extends Oe {
    static create(e, r, n) {
      return new t7(e, r, n);
    }
    constructor(e, r, n) {
      super(r, n), this.elementName = e;
    }
  };
  ir = class extends sr {
    constructor() {
      super(He);
    }
    parse(e, r, n, s = false, i2) {
      return super.parse(e, r, n, s, i2);
    }
  };
  hi = Wo;
  mi = zo;
  ar = { attrs: true, children: true, cases: true, expression: true };
  fi = new Set(["parent"]);
  le = new WeakSet, Jr = function() {
    return this.type === "angularIcuCase" ? "expression" : this.type === "angularIcuExpression" ? "cases" : "children";
  }, Zr = function() {
    var e;
    return ((e = this.parent) == null ? undefined : e.$children) ?? [];
  };
  or2 = Ge;
  jo = [{ regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su, parse: Ko }, { regex: /^\[if([^\]]*)\]><!$/u, parse: Xo }, { regex: /^<!\s*\[endif\]$/u, parse: Qo }];
  ur = new Map([["*", new Set(["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inert", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "popover", "slot", "spellcheck", "style", "tabindex", "title", "translate", "writingsuggestions"])], ["a", new Set(["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"])], ["applet", new Set(["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"])], ["area", new Set(["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"])], ["audio", new Set(["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"])], ["base", new Set(["href", "target"])], ["basefont", new Set(["color", "face", "size"])], ["blockquote", new Set(["cite"])], ["body", new Set(["alink", "background", "bgcolor", "link", "text", "vlink"])], ["br", new Set(["clear"])], ["button", new Set(["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "popovertarget", "popovertargetaction", "type", "value"])], ["canvas", new Set(["height", "width"])], ["caption", new Set(["align"])], ["col", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["colgroup", new Set(["align", "char", "charoff", "span", "valign", "width"])], ["data", new Set(["value"])], ["del", new Set(["cite", "datetime"])], ["details", new Set(["name", "open"])], ["dialog", new Set(["open"])], ["dir", new Set(["compact"])], ["div", new Set(["align"])], ["dl", new Set(["compact"])], ["embed", new Set(["height", "src", "type", "width"])], ["fieldset", new Set(["disabled", "form", "name"])], ["font", new Set(["color", "face", "size"])], ["form", new Set(["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"])], ["frame", new Set(["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"])], ["frameset", new Set(["cols", "rows"])], ["h1", new Set(["align"])], ["h2", new Set(["align"])], ["h3", new Set(["align"])], ["h4", new Set(["align"])], ["h5", new Set(["align"])], ["h6", new Set(["align"])], ["head", new Set(["profile"])], ["hr", new Set(["align", "noshade", "size", "width"])], ["html", new Set(["manifest", "version"])], ["iframe", new Set(["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"])], ["img", new Set(["align", "alt", "border", "crossorigin", "decoding", "fetchpriority", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"])], ["input", new Set(["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "popovertarget", "popovertargetaction", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"])], ["ins", new Set(["cite", "datetime"])], ["isindex", new Set(["prompt"])], ["label", new Set(["for", "form"])], ["legend", new Set(["align"])], ["li", new Set(["type", "value"])], ["link", new Set(["as", "blocking", "charset", "color", "crossorigin", "disabled", "fetchpriority", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"])], ["map", new Set(["name"])], ["menu", new Set(["compact"])], ["meta", new Set(["charset", "content", "http-equiv", "media", "name", "scheme"])], ["meter", new Set(["high", "low", "max", "min", "optimum", "value"])], ["object", new Set(["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"])], ["ol", new Set(["compact", "reversed", "start", "type"])], ["optgroup", new Set(["disabled", "label"])], ["option", new Set(["disabled", "label", "selected", "value"])], ["output", new Set(["for", "form", "name"])], ["p", new Set(["align"])], ["param", new Set(["name", "type", "value", "valuetype"])], ["pre", new Set(["width"])], ["progress", new Set(["max", "value"])], ["q", new Set(["cite"])], ["script", new Set(["async", "blocking", "charset", "crossorigin", "defer", "fetchpriority", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"])], ["select", new Set(["autocomplete", "disabled", "form", "multiple", "name", "required", "size"])], ["slot", new Set(["name"])], ["source", new Set(["height", "media", "sizes", "src", "srcset", "type", "width"])], ["style", new Set(["blocking", "media", "type"])], ["table", new Set(["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"])], ["tbody", new Set(["align", "char", "charoff", "valign"])], ["td", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["template", new Set(["shadowrootclonable", "shadowrootdelegatesfocus", "shadowrootmode"])], ["textarea", new Set(["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"])], ["tfoot", new Set(["align", "char", "charoff", "valign"])], ["th", new Set(["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"])], ["thead", new Set(["align", "char", "charoff", "valign"])], ["time", new Set(["datetime"])], ["tr", new Set(["align", "bgcolor", "char", "charoff", "valign"])], ["track", new Set(["default", "kind", "label", "src", "srclang"])], ["ul", new Set(["compact", "type"])], ["video", new Set(["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"])]]);
  gi = new Set(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]);
  en = { name: "html", normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true };
  ru = Et(en);
  nu = new Set(["mj-style", "mj-raw"]);
  su = Et({ ...en, name: "mjml", shouldParseAsRawText: (t9) => nu.has(t9) });
  iu = Et({ name: "angular" });
  au = Et({ name: "vue", isTagNameCaseSensitive: true, shouldParseAsRawText(t9, e, r, n) {
    return t9.toLowerCase() !== "html" && !r && (t9 !== "template" || n.some(({ name: s, value: i2 }) => s === "lang" && i2 !== "html" && i2 !== "" && i2 !== undefined));
  } });
  ou = Et({ name: "lwc", canSelfClose: false });
  uu = { html: qs };
  ym = rn;
});

// node_modules/prettier/standalone.mjs
function Et2(e, t9, r) {
  return rr2.diff(e, t9, r);
}
function nr2(e) {
  let t9 = e.indexOf("\r");
  return t9 !== -1 ? e.charAt(t9 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function xe2(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Ct2(e, t9) {
  let r;
  switch (t9) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t9)}.`);
  }
  let n = e.match(r);
  return n ? n.length : 0;
}
function ur2(e) {
  return te(false, e, /\r\n?/gu, `
`);
}
function or3(e) {
  let t9 = e.length;
  for (;t9 > 0 && (e[t9 - 1] === "\r" || e[t9 - 1] === `
`); )
    t9--;
  return t9 < e.length ? e.slice(0, t9) : e;
}
function _u(e) {
  if (typeof e == "string")
    return W2;
  if (Array.isArray(e))
    return Y3;
  if (!e)
    return;
  let { type: t9 } = e;
  if (Ue2.has(t9))
    return t9;
}
function wu(e) {
  let t9 = e === null ? "null" : typeof e;
  if (t9 !== "string" && t9 !== "object")
    return `Unexpected doc '${t9}', 
Expected it to be 'string' or 'object'.`;
  if (M(e))
    throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]")
    return `Unexpected doc '${r}'.`;
  let n = xu([...Ue2].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
function bu(e, t9, r, n) {
  let u = [e];
  for (;u.length > 0; ) {
    let o = u.pop();
    if (o === ir2) {
      r(u.pop());
      continue;
    }
    r && u.push(o, ir2);
    let i2 = M(o);
    if (!i2)
      throw new q(o);
    if ((t9 == null ? undefined : t9(o)) !== false)
      switch (i2) {
        case Y3:
        case k3: {
          let s = i2 === Y3 ? o : o.parts;
          for (let a = s.length, c = a - 1;c >= 0; --c)
            u.push(s[c]);
          break;
        }
        case _3:
          u.push(o.flatContents, o.breakContents);
          break;
        case B2:
          if (n && o.expandedStates)
            for (let s = o.expandedStates.length, a = s - 1;a >= 0; --a)
              u.push(o.expandedStates[a]);
          else
            u.push(o.contents);
          break;
        case O2:
        case N2:
        case v2:
        case S2:
        case L2:
          u.push(o.contents);
          break;
        case W2:
        case j2:
        case P2:
        case I:
        case g:
        case w2:
          break;
        default:
          throw new q(o);
      }
  }
}
function be2(e, t9) {
  if (typeof e == "string")
    return t9(e);
  let r = new Map;
  return n(e);
  function n(o) {
    if (r.has(o))
      return r.get(o);
    let i2 = u(o);
    return r.set(o, i2), i2;
  }
  function u(o) {
    switch (M(o)) {
      case Y3:
        return t9(o.map(n));
      case k3:
        return t9({ ...o, parts: o.parts.map(n) });
      case _3:
        return t9({ ...o, breakContents: n(o.breakContents), flatContents: n(o.flatContents) });
      case B2: {
        let { expandedStates: i2, contents: s } = o;
        return i2 ? (i2 = i2.map(n), s = i2[0]) : s = n(s), t9({ ...o, contents: s, expandedStates: i2 });
      }
      case O2:
      case N2:
      case v2:
      case S2:
      case L2:
        return t9({ ...o, contents: n(o.contents) });
      case W2:
      case j2:
      case P2:
      case I:
      case g:
      case w2:
        return t9(o);
      default:
        throw new q(o);
    }
  }
}
function Ve2(e, t9, r) {
  let n = r, u = false;
  function o(i2) {
    if (u)
      return false;
    let s = t9(i2);
    s !== undefined && (u = true, n = s);
  }
  return le2(e, o), n;
}
function ku(e) {
  if (e.type === B2 && e.break || e.type === g && e.hard || e.type === w2)
    return true;
}
function Dr2(e) {
  return Ve2(e, ku, false);
}
function sr2(e) {
  if (e.length > 0) {
    let t9 = y(false, e, -1);
    !t9.expandedStates && !t9.break && (t9.break = "propagated");
  }
  return null;
}
function cr2(e) {
  let t9 = new Set, r = [];
  function n(o) {
    if (o.type === w2 && sr2(r), o.type === B2) {
      if (r.push(o), t9.has(o))
        return false;
      t9.add(o);
    }
  }
  function u(o) {
    o.type === B2 && r.pop().break && sr2(r);
  }
  le2(e, n, u, true);
}
function Su(e) {
  return e.type === g && !e.hard ? e.soft ? "" : " " : e.type === _3 ? e.flatContents : e;
}
function fr2(e) {
  return be2(e, Su);
}
function ar2(e) {
  for (e = [...e];e.length >= 2 && y(false, e, -2).type === g && y(false, e, -1).type === w2; )
    e.length -= 2;
  if (e.length > 0) {
    let t9 = we2(y(false, e, -1));
    e[e.length - 1] = t9;
  }
  return e;
}
function we2(e) {
  switch (M(e)) {
    case N2:
    case v2:
    case B2:
    case L2:
    case S2: {
      let t9 = we2(e.contents);
      return { ...e, contents: t9 };
    }
    case _3:
      return { ...e, breakContents: we2(e.breakContents), flatContents: we2(e.flatContents) };
    case k3:
      return { ...e, parts: ar2(e.parts) };
    case Y3:
      return ar2(e);
    case W2:
      return or3(e);
    case O2:
    case j2:
    case P2:
    case I:
    case g:
    case w2:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function $e(e) {
  return we2(Nu(e));
}
function Tu(e) {
  switch (M(e)) {
    case k3:
      if (e.parts.every((t9) => t9 === ""))
        return "";
      break;
    case B2:
      if (!e.contents && !e.id && !e.break && !e.expandedStates)
        return "";
      if (e.contents.type === B2 && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates)
        return e.contents;
      break;
    case O2:
    case N2:
    case v2:
    case L2:
      if (!e.contents)
        return "";
      break;
    case _3:
      if (!e.flatContents && !e.breakContents)
        return "";
      break;
    case Y3: {
      let t9 = [];
      for (let r of e) {
        if (!r)
          continue;
        let [n, ...u] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof y(false, t9, -1) == "string" ? t9[t9.length - 1] += n : t9.push(n), t9.push(...u);
      }
      return t9.length === 0 ? "" : t9.length === 1 ? t9[0] : t9;
    }
    case W2:
    case j2:
    case P2:
    case I:
    case g:
    case S2:
    case w2:
      break;
    default:
      throw new q(e);
  }
  return e;
}
function Nu(e) {
  return be2(e, (t9) => Tu(t9));
}
function lr2(e, t9 = We) {
  return be2(e, (r) => typeof r == "string" ? ke2(t9, r.split(`
`)) : r);
}
function Ou(e) {
  if (e.type === g)
    return true;
}
function Fr2(e) {
  return Ve2(e, Ou, false);
}
function Fe2(e, t9) {
  return e.type === S2 ? { ...e, contents: t9(e.contents) } : t9(e);
}
function ie2(e) {
  return K2(e), { type: N2, contents: e };
}
function oe(e, t9) {
  return K2(t9), { type: O2, contents: t9, n: e };
}
function At2(e, t9 = {}) {
  return K2(e), yt2(t9.expandedStates, true), { type: B2, id: t9.id, contents: e, break: !!t9.shouldBreak, expandedStates: t9.expandedStates };
}
function dr2(e) {
  return oe(Number.NEGATIVE_INFINITY, e);
}
function mr2(e) {
  return oe({ type: "root" }, e);
}
function Er2(e) {
  return oe(-1, e);
}
function Cr2(e, t9) {
  return At2(e[0], { ...t9, expandedStates: e });
}
function hr2(e) {
  return pr2(e), { type: k3, parts: e };
}
function gr2(e, t9 = "", r = {}) {
  return K2(e), t9 !== "" && K2(t9), { type: _3, breakContents: e, flatContents: t9, groupId: r.groupId };
}
function yr2(e, t9) {
  return K2(e), { type: v2, contents: e, groupId: t9.groupId, negate: t9.negate };
}
function Se2(e) {
  return K2(e), { type: L2, contents: e };
}
function ke2(e, t9) {
  K2(e), yt2(t9);
  let r = [];
  for (let n = 0;n < t9.length; n++)
    n !== 0 && r.push(e), r.push(t9[n]);
  return r;
}
function Ge3(e, t9, r) {
  K2(e);
  let n = e;
  if (t9 > 0) {
    for (let u = 0;u < Math.floor(t9 / r); ++u)
      n = ie2(n);
    n = oe(t9 % r, n), n = oe(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function xr2(e, t9) {
  return K2(t9), e ? { type: S2, label: e, contents: t9 } : t9;
}
function Q2(e) {
  var t9;
  if (!e)
    return "";
  if (Array.isArray(e)) {
    let r = [];
    for (let n of e)
      if (Array.isArray(n))
        r.push(...Q2(n));
      else {
        let u = Q2(n);
        u !== "" && r.push(u);
      }
    return r;
  }
  return e.type === _3 ? { ...e, breakContents: Q2(e.breakContents), flatContents: Q2(e.flatContents) } : e.type === B2 ? { ...e, contents: Q2(e.contents), expandedStates: (t9 = e.expandedStates) == null ? undefined : t9.map(Q2) } : e.type === k3 ? { type: "fill", parts: e.parts.map(Q2) } : e.contents ? { ...e, contents: Q2(e.contents) } : e;
}
function wr2(e) {
  let t9 = Object.create(null), r = new Set;
  return n(Q2(e));
  function n(o, i2, s) {
    var a, c;
    if (typeof o == "string")
      return JSON.stringify(o);
    if (Array.isArray(o)) {
      let D = o.map(n).filter(Boolean);
      return D.length === 1 ? D[0] : `[${D.join(", ")}]`;
    }
    if (o.type === g) {
      let D = ((a = s == null ? undefined : s[i2 + 1]) == null ? undefined : a.type) === w2;
      return o.literal ? D ? "literalline" : "literallineWithoutBreakParent" : o.hard ? D ? "hardline" : "hardlineWithoutBreakParent" : o.soft ? "softline" : "line";
    }
    if (o.type === w2)
      return ((c = s == null ? undefined : s[i2 - 1]) == null ? undefined : c.type) === g && s[i2 - 1].hard ? undefined : "breakParent";
    if (o.type === P2)
      return "trim";
    if (o.type === N2)
      return "indent(" + n(o.contents) + ")";
    if (o.type === O2)
      return o.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(o.contents) + ")" : o.n < 0 ? "dedent(" + n(o.contents) + ")" : o.n.type === "root" ? "markAsRoot(" + n(o.contents) + ")" : "align(" + JSON.stringify(o.n) + ", " + n(o.contents) + ")";
    if (o.type === _3)
      return "ifBreak(" + n(o.breakContents) + (o.flatContents ? ", " + n(o.flatContents) : "") + (o.groupId ? (o.flatContents ? "" : ', ""') + `, { groupId: ${u(o.groupId)} }` : "") + ")";
    if (o.type === v2) {
      let D = [];
      o.negate && D.push("negate: true"), o.groupId && D.push(`groupId: ${u(o.groupId)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return `indentIfBreak(${n(o.contents)}${p})`;
    }
    if (o.type === B2) {
      let D = [];
      o.break && o.break !== "propagated" && D.push("shouldBreak: true"), o.id && D.push(`id: ${u(o.id)}`);
      let p = D.length > 0 ? `, { ${D.join(", ")} }` : "";
      return o.expandedStates ? `conditionalGroup([${o.expandedStates.map((l2) => n(l2)).join(",")}]${p})` : `group(${n(o.contents)}${p})`;
    }
    if (o.type === k3)
      return `fill([${o.parts.map((D) => n(D)).join(", ")}])`;
    if (o.type === L2)
      return "lineSuffix(" + n(o.contents) + ")";
    if (o.type === I)
      return "lineSuffixBoundary";
    if (o.type === S2)
      return `label(${JSON.stringify(o.label)}, ${n(o.contents)})`;
    if (o.type === j2)
      return "cursor";
    throw new Error("Unknown doc type " + o.type);
  }
  function u(o) {
    if (typeof o != "symbol")
      return JSON.stringify(String(o));
    if (o in t9)
      return t9[o];
    let i2 = o.description || "symbol";
    for (let s = 0;; s++) {
      let a = i2 + (s > 0 ? ` #${s}` : "");
      if (!r.has(a))
        return r.add(a), t9[o] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
function kr2(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Sr2(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
function vu(e) {
  if (!e)
    return 0;
  if (!Pu.test(e))
    return e.length;
  e = e.replace(br2(), "  ");
  let t9 = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t9 += Tr2(n) ? 1 : 2);
  }
  return t9;
}
function Nr2() {
  return { value: "", length: 0, queue: [] };
}
function Lu(e, t9) {
  return xt2(e, { type: "indent" }, t9);
}
function Iu(e, t9, r) {
  return t9 === Number.NEGATIVE_INFINITY ? e.root || Nr2() : t9 < 0 ? xt2(e, { type: "dedent" }, r) : t9 ? t9.type === "root" ? { ...e, root: e } : xt2(e, { type: typeof t9 == "string" ? "stringAlign" : "numberAlign", n: t9 }, r) : e;
}
function xt2(e, t9, r) {
  let n = t9.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t9], u = "", o = 0, i2 = 0, s = 0;
  for (let f of n)
    switch (f.type) {
      case "indent":
        D(), r.useTabs ? a(1) : c(r.tabWidth);
        break;
      case "stringAlign":
        D(), u += f.n, o += f.n.length;
        break;
      case "numberAlign":
        i2 += 1, s += f.n;
        break;
      default:
        throw new Error(`Unexpected type '${f.type}'`);
    }
  return l2(), { ...e, value: u, length: o, queue: n };
  function a(f) {
    u += "\t".repeat(f), o += r.tabWidth * f;
  }
  function c(f) {
    u += " ".repeat(f), o += f;
  }
  function D() {
    r.useTabs ? p() : l2();
  }
  function p() {
    i2 > 0 && a(i2), F();
  }
  function l2() {
    s > 0 && c(s), F();
  }
  function F() {
    i2 = 0, s = 0;
  }
}
function wt2(e) {
  let t9 = 0, r = 0, n = e.length;
  e:
    for (;n--; ) {
      let u = e[n];
      if (u === de2) {
        r++;
        continue;
      }
      for (let o = u.length - 1;o >= 0; o--) {
        let i2 = u[o];
        if (i2 === " " || i2 === "\t")
          t9++;
        else {
          e[n] = u.slice(0, o + 1);
          break e;
        }
      }
    }
  if (t9 > 0 || r > 0)
    for (e.length = n + 1;r-- > 0; )
      e.push(de2);
  return t9;
}
function Ke2(e, t9, r, n, u, o) {
  if (r === Number.POSITIVE_INFINITY)
    return true;
  let i2 = t9.length, s = [e], a = [];
  for (;r >= 0; ) {
    if (s.length === 0) {
      if (i2 === 0)
        return true;
      s.push(t9[--i2]);
      continue;
    }
    let { mode: c, doc: D } = s.pop(), p = M(D);
    switch (p) {
      case W2:
        a.push(D), r -= Ne2(D);
        break;
      case Y3:
      case k3: {
        let l2 = p === Y3 ? D : D.parts, F = D[_t2] ?? 0;
        for (let f = l2.length - 1;f >= F; f--)
          s.push({ mode: c, doc: l2[f] });
        break;
      }
      case N2:
      case O2:
      case v2:
      case S2:
        s.push({ mode: c, doc: D.contents });
        break;
      case P2:
        r += wt2(a);
        break;
      case B2: {
        if (o && D.break)
          return false;
        let l2 = D.break ? R2 : c, F = D.expandedStates && l2 === R2 ? y(false, D.expandedStates, -1) : D.contents;
        s.push({ mode: l2, doc: F });
        break;
      }
      case _3: {
        let F = (D.groupId ? u[D.groupId] || H2 : c) === R2 ? D.breakContents : D.flatContents;
        F && s.push({ mode: c, doc: F });
        break;
      }
      case g:
        if (c === R2 || D.hard)
          return true;
        D.soft || (a.push(" "), r--);
        break;
      case L2:
        n = true;
        break;
      case I:
        if (n)
          return false;
        break;
    }
  }
  return false;
}
function me2(e, t9) {
  let r = {}, n = t9.printWidth, u = xe2(t9.endOfLine), o = 0, i2 = [{ ind: Nr2(), mode: R2, doc: e }], s = [], a = false, c = [], D = 0;
  for (cr2(e);i2.length > 0; ) {
    let { ind: l2, mode: F, doc: f } = i2.pop();
    switch (M(f)) {
      case W2: {
        let d2 = u !== `
` ? te(false, f, `
`, u) : f;
        s.push(d2), i2.length > 0 && (o += Ne2(d2));
        break;
      }
      case Y3:
        for (let d2 = f.length - 1;d2 >= 0; d2--)
          i2.push({ ind: l2, mode: F, doc: f[d2] });
        break;
      case j2:
        if (D >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        s.push(de2), D++;
        break;
      case N2:
        i2.push({ ind: Lu(l2, t9), mode: F, doc: f.contents });
        break;
      case O2:
        i2.push({ ind: Iu(l2, f.n, t9), mode: F, doc: f.contents });
        break;
      case P2:
        o -= wt2(s);
        break;
      case B2:
        switch (F) {
          case H2:
            if (!a) {
              i2.push({ ind: l2, mode: f.break ? R2 : H2, doc: f.contents });
              break;
            }
          case R2: {
            a = false;
            let d2 = { ind: l2, mode: H2, doc: f.contents }, m = n - o, C = c.length > 0;
            if (!f.break && Ke2(d2, i2, m, C, r))
              i2.push(d2);
            else if (f.expandedStates) {
              let E2 = y(false, f.expandedStates, -1);
              if (f.break) {
                i2.push({ ind: l2, mode: R2, doc: E2 });
                break;
              } else
                for (let h2 = 1;h2 < f.expandedStates.length + 1; h2++)
                  if (h2 >= f.expandedStates.length) {
                    i2.push({ ind: l2, mode: R2, doc: E2 });
                    break;
                  } else {
                    let x2 = f.expandedStates[h2], A = { ind: l2, mode: H2, doc: x2 };
                    if (Ke2(A, i2, m, C, r)) {
                      i2.push(A);
                      break;
                    }
                  }
            } else
              i2.push({ ind: l2, mode: R2, doc: f.contents });
            break;
          }
        }
        f.id && (r[f.id] = y(false, i2, -1).mode);
        break;
      case k3: {
        let d2 = n - o, m = f[_t2] ?? 0, { parts: C } = f, E2 = C.length - m;
        if (E2 === 0)
          break;
        let h2 = C[m + 0], x2 = C[m + 1], A = { ind: l2, mode: H2, doc: h2 }, $3 = { ind: l2, mode: R2, doc: h2 }, ue = Ke2(A, [], d2, c.length > 0, r, true);
        if (E2 === 1) {
          ue ? i2.push(A) : i2.push($3);
          break;
        }
        let Be2 = { ind: l2, mode: H2, doc: x2 }, lt3 = { ind: l2, mode: R2, doc: x2 };
        if (E2 === 2) {
          ue ? i2.push(Be2, A) : i2.push(lt3, $3);
          break;
        }
        let lu = C[m + 2], Ft2 = { ind: l2, mode: F, doc: { ...f, [_t2]: m + 2 } };
        Ke2({ ind: l2, mode: H2, doc: [h2, x2, lu] }, [], d2, c.length > 0, r, true) ? i2.push(Ft2, Be2, A) : ue ? i2.push(Ft2, lt3, A) : i2.push(Ft2, lt3, $3);
        break;
      }
      case _3:
      case v2: {
        let d2 = f.groupId ? r[f.groupId] : F;
        if (d2 === R2) {
          let m = f.type === _3 ? f.breakContents : f.negate ? f.contents : ie2(f.contents);
          m && i2.push({ ind: l2, mode: F, doc: m });
        }
        if (d2 === H2) {
          let m = f.type === _3 ? f.flatContents : f.negate ? ie2(f.contents) : f.contents;
          m && i2.push({ ind: l2, mode: F, doc: m });
        }
        break;
      }
      case L2:
        c.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case I:
        c.length > 0 && i2.push({ ind: l2, mode: F, doc: Te2 });
        break;
      case g:
        switch (F) {
          case H2:
            if (f.hard)
              a = true;
            else {
              f.soft || (s.push(" "), o += 1);
              break;
            }
          case R2:
            if (c.length > 0) {
              i2.push({ ind: l2, mode: F, doc: f }, ...c.reverse()), c.length = 0;
              break;
            }
            f.literal ? l2.root ? (s.push(u, l2.root.value), o = l2.root.length) : (s.push(u), o = 0) : (o -= wt2(s), s.push(u + l2.value), o = l2.length);
            break;
        }
        break;
      case S2:
        i2.push({ ind: l2, mode: F, doc: f.contents });
        break;
      case w2:
        break;
      default:
        throw new q(f);
    }
    i2.length === 0 && c.length > 0 && (i2.push(...c.reverse()), c.length = 0);
  }
  let p = s.indexOf(de2);
  if (p !== -1) {
    let l2 = s.indexOf(de2, p + 1);
    if (l2 === -1)
      return { formatted: s.filter((m) => m !== de2).join("") };
    let F = s.slice(0, p).join(""), f = s.slice(p + 1, l2).join(""), d2 = s.slice(l2 + 1).join("");
    return { formatted: F + f + d2, cursorNodeStart: F.length, cursorNodeText: f };
  }
  return { formatted: s.join("") };
}
function Ru(e, t9, r = 0) {
  let n = 0;
  for (let u = r;u < e.length; ++u)
    e[u] === "\t" ? n = n + t9 - n % t9 : n++;
  return n;
}
function Yu(e) {
  return e !== null && typeof e == "object";
}
function* Ce2(e, t9) {
  let { getVisitorKeys: r, filter: n = () => true } = t9, u = (o) => vr2(o) && n(o);
  for (let o of r(e)) {
    let i2 = e[o];
    if (Array.isArray(i2))
      for (let s of i2)
        u(s) && (yield s);
    else
      u(i2) && (yield i2);
  }
}
function* Lr2(e, t9) {
  let r = [e];
  for (let n = 0;n < r.length; n++) {
    let u = r[n];
    for (let o of Ce2(u, t9))
      yield o, r.push(o);
  }
}
function Ir2(e, t9) {
  return Ce2(e, t9).next().done;
}
function he2(e) {
  return (t9, r, n) => {
    let u = !!(n != null && n.backwards);
    if (r === false)
      return false;
    let { length: o } = t9, i2 = r;
    for (;i2 >= 0 && i2 < o; ) {
      let s = t9.charAt(i2);
      if (e instanceof RegExp) {
        if (!e.test(s))
          return i2;
      } else if (!e.includes(s))
        return i2;
      u ? i2-- : i2++;
    }
    return i2 === -1 || i2 === o ? i2 : false;
  };
}
function ju(e, t9, r) {
  let n = !!(r != null && r.backwards);
  if (t9 === false)
    return false;
  let u = e.charAt(t9);
  if (n) {
    if (e.charAt(t9 - 1) === "\r" && u === `
`)
      return t9 - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t9 - 1;
  } else {
    if (u === "\r" && e.charAt(t9 + 1) === `
`)
      return t9 + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029")
      return t9 + 1;
  }
  return t9;
}
function Uu(e, t9, r = {}) {
  let n = T3(e, r.backwards ? t9 - 1 : t9, r), u = U(e, n, r);
  return n !== u;
}
function Vu(e) {
  return Array.isArray(e) && e.length > 0;
}
function Wu(e) {
  return e ? (t9) => e(t9, Yr) : $u;
}
function Mu(e) {
  let t9 = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t9 + (r ? " " + r : "");
}
function St2(e, t9) {
  (e.comments ?? (e.comments = [])).push(t9), t9.printed = false, t9.nodeDescription = Mu(e);
}
function se2(e, t9) {
  t9.leading = true, t9.trailing = false, St2(e, t9);
}
function ee2(e, t9, r) {
  t9.leading = false, t9.trailing = false, r && (t9.marker = r), St2(e, t9);
}
function ae2(e, t9) {
  t9.leading = false, t9.trailing = true, St2(e, t9);
}
function Xe2(e, t9) {
  if (Tt2.has(e))
    return Tt2.get(e);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: o, locEnd: i2 } = t9;
  if (!n)
    return [];
  let s = ((r == null ? undefined : r(e, t9)) ?? [...Ce2(e, { getVisitorKeys: J2(u) })]).flatMap((a) => n(a) ? [a] : Xe2(a, t9));
  return s.sort((a, c) => o(a) - o(c) || i2(a) - i2(c)), Tt2.set(e, s), s;
}
function Ur2(e, t9, r, n) {
  let { locStart: u, locEnd: o } = r, i2 = u(t9), s = o(t9), a = Xe2(e, r), c, D, p = 0, l2 = a.length;
  for (;p < l2; ) {
    let F = p + l2 >> 1, f = a[F], d2 = u(f), m = o(f);
    if (d2 <= i2 && s <= m)
      return Ur2(f, t9, r, f);
    if (m <= i2) {
      c = f, p = F + 1;
      continue;
    }
    if (s <= d2) {
      D = f, l2 = F;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? undefined : n.type) === "TemplateLiteral") {
    let { quasis: F } = n, f = Ot2(F, t9, r);
    c && Ot2(F, c, r) !== f && (c = null), D && Ot2(F, D, r) !== f && (D = null);
  }
  return { enclosingNode: n, precedingNode: c, followingNode: D };
}
function Vr(e, t9) {
  let { comments: r } = e;
  if (delete e.comments, !qe2(r) || !t9.printer.canAttachComment)
    return;
  let n = [], { printer: { experimentalFeatures: { avoidAstMutation: u = false } = {}, handleComments: o = {} }, originalText: i2 } = t9, { ownLine: s = Nt2, endOfLine: a = Nt2, remaining: c = Nt2 } = o, D = r.map((p, l2) => ({ ...Ur2(e, p, t9), comment: p, text: i2, options: t9, ast: e, isLastComment: r.length - 1 === l2 }));
  for (let [p, l2] of D.entries()) {
    let { comment: F, precedingNode: f, enclosingNode: d2, followingNode: m, text: C, options: E2, ast: h2, isLastComment: x2 } = l2, A;
    if (u ? A = [l2] : (F.enclosingNode = d2, F.precedingNode = f, F.followingNode = m, A = [F, C, E2, h2, x2]), Gu(C, E2, D, p))
      F.placement = "ownLine", s(...A) || (m ? se2(m, F) : f ? ae2(f, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (Ku(C, E2, D, p))
      F.placement = "endOfLine", a(...A) || (f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F));
    else if (F.placement = "remaining", !c(...A))
      if (f && m) {
        let $3 = n.length;
        $3 > 0 && n[$3 - 1].followingNode !== m && jr2(n, E2), n.push(l2);
      } else
        f ? ae2(f, F) : m ? se2(m, F) : d2 ? ee2(d2, F) : ee2(h2, F);
  }
  if (jr2(n, t9), !u)
    for (let p of r)
      delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
function Gu(e, t9, r, n) {
  let { comment: u, precedingNode: o } = r[n], { locStart: i2, locEnd: s } = t9, a = i2(u);
  if (o)
    for (let c = n - 1;c >= 0; c--) {
      let { comment: D, precedingNode: p } = r[c];
      if (p !== o || !$r2(e.slice(s(D), a)))
        break;
      a = i2(D);
    }
  return G2(e, a, { backwards: true });
}
function Ku(e, t9, r, n) {
  let { comment: u, followingNode: o } = r[n], { locStart: i2, locEnd: s } = t9, a = s(u);
  if (o)
    for (let c = n + 1;c < r.length; c++) {
      let { comment: D, followingNode: p } = r[c];
      if (p !== o || !$r2(e.slice(a, i2(D))))
        break;
      a = s(D);
    }
  return G2(e, a);
}
function jr2(e, t9) {
  var s, a;
  let r = e.length;
  if (r === 0)
    return;
  let { precedingNode: n, followingNode: u } = e[0], o = t9.locStart(u), i2;
  for (i2 = r;i2 > 0; --i2) {
    let { comment: c, precedingNode: D, followingNode: p } = e[i2 - 1];
    Oe2.strictEqual(D, n), Oe2.strictEqual(p, u);
    let l2 = t9.originalText.slice(t9.locEnd(c), o);
    if (((a = (s = t9.printer).isGap) == null ? undefined : a.call(s, l2, t9)) ?? /^[\s(]*$/u.test(l2))
      o = t9.locStart(c);
    else
      break;
  }
  for (let [c, { comment: D }] of e.entries())
    c < i2 ? ae2(n, D) : se2(u, D);
  for (let c of [n, u])
    c.comments && c.comments.length > 1 && c.comments.sort((D, p) => t9.locStart(D) - t9.locStart(p));
  e.length = 0;
}
function Ot2(e, t9, r) {
  let n = r.locStart(t9) - 1;
  for (let u = 1;u < e.length; ++u)
    if (n < r.locStart(e[u]))
      return u - 1;
  return 0;
}
function zu(e, t9) {
  let r = t9 - 1;
  r = T3(e, r, { backwards: true }), r = U(e, r, { backwards: true }), r = T3(e, r, { backwards: true });
  let n = U(e, r, { backwards: true });
  return r !== n;
}
function Wr2(e, t9) {
  let r = e.node;
  return r.printed = true, t9.printer.printComment(e, t9);
}
function Hu(e, t9) {
  var D;
  let r = e.node, n = [Wr2(e, t9)], { printer: u, originalText: o, locStart: i2, locEnd: s } = t9;
  if ((D = u.isBlockComment) == null ? undefined : D.call(u, r)) {
    let p = G2(o, s(r)) ? G2(o, i2(r), { backwards: true }) ? z2 : Me2 : " ";
    n.push(p);
  } else
    n.push(z2);
  let c = U(o, T3(o, s(r)));
  return c !== false && G2(o, c) && n.push(z2), n;
}
function Ju(e, t9, r) {
  var c;
  let n = e.node, u = Wr2(e, t9), { printer: o, originalText: i2, locStart: s } = t9, a = (c = o.isBlockComment) == null ? undefined : c.call(o, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || G2(i2, s(n), { backwards: true })) {
    let D = Pe2(i2, s(n));
    return { doc: Se2([z2, D ? z2 : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r != null && r.hasLineSuffix ? { doc: [Se2([" ", u]), pe2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function qu(e, t9) {
  let r = e.node;
  if (!r)
    return {};
  let n = t9[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0)
    return { leading: "", trailing: "" };
  let o = [], i2 = [], s;
  return e.each(() => {
    let a = e.node;
    if (n != null && n.has(a))
      return;
    let { leading: c, trailing: D } = a;
    c ? o.push(Hu(e, t9)) : D && (s = Ju(e, t9, s), i2.push(s.doc));
  }, "comments"), { leading: o, trailing: i2 };
}
function Mr(e, t9, r) {
  let { leading: n, trailing: u } = qu(e, r);
  return !n && !u ? t9 : Fe2(t9, (o) => [n, o, u]);
}
function Gr2(e) {
  let { [Symbol.for("comments")]: t9, [Symbol.for("printedComments")]: r } = e;
  for (let n of t9) {
    if (!n.printed && !r.has(n))
      throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
function Xu(e) {
  return () => {};
}
function Qe2({ plugins: e = [], showDeprecated: t9 = false } = {}) {
  let r = e.flatMap((u) => u.languages ?? []), n = [];
  for (let u of Zu(Object.assign({}, ...e.map(({ options: o }) => o), zr)))
    !t9 && u.deprecated || (Array.isArray(u.choices) && (t9 || (u.choices = u.choices.filter((o) => !o.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...Qu(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((o) => {
      var i2;
      return ((i2 = o.defaultOptions) == null ? undefined : i2[u.name]) !== undefined;
    }).map((o) => [o.name, o.defaultOptions[u.name]])), n.push(u));
  return { languages: r, options: n };
}
function* Qu(e, t9, r) {
  let n = new Set(e.map((u) => u.value));
  for (let u of t9)
    if (u.parsers) {
      for (let o of u.parsers)
        if (!n.has(o)) {
          n.add(o);
          let i2 = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, o)), s = u.name;
          i2 != null && i2.name && (s += ` (plugin: ${i2.name})`), yield { value: o, description: s };
        }
    }
}
function Zu(e) {
  let t9 = [];
  for (let [r, n] of Object.entries(e)) {
    let u = { name: r, ...n };
    Array.isArray(u.default) && (u.default = y(false, u.default, -1).value), t9.push(u);
  }
  return t9;
}
function en2(e) {
  if (e = e instanceof URL ? e : new URL(e), e.protocol !== "file:")
    throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
  return e;
}
function ro2(e) {
  return e = en2(e), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function no2(e) {
  e = en2(e);
  let t9 = decodeURIComponent(e.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  return e.hostname !== "" && (t9 = `\\\\${e.hostname}${t9}`), t9;
}
function tn2(e) {
  return to2 ? no2(e) : ro2(e);
}
function nn(e, t9) {
  if (!t9)
    return;
  let r = uo2(t9).toLowerCase();
  return e.find(({ filenames: n }) => n == null ? undefined : n.some((u) => u.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? undefined : n.some((u) => r.endsWith(u)));
}
function oo2(e, t9) {
  if (t9)
    return e.find(({ name: r }) => r.toLowerCase() === t9) ?? e.find(({ aliases: r }) => r == null ? undefined : r.includes(t9)) ?? e.find(({ extensions: r }) => r == null ? undefined : r.includes(`.${t9}`));
}
function un2(e, t9) {
  if (t9) {
    if (String(t9).startsWith("file:"))
      try {
        t9 = rn2(t9);
      } catch {
        return;
      }
    if (typeof t9 == "string")
      return e.find(({ isSupported: r }) => r == null ? undefined : r({ filepath: t9 }));
  }
}
function io2(e, t9) {
  let r = Hr(false, e.plugins).flatMap((u) => u.languages ?? []), n = oo2(r, t9.language) ?? nn(r, t9.physicalFile) ?? nn(r, t9.file) ?? un2(r, t9.physicalFile) ?? un2(r, t9.file) ?? (t9.physicalFile, undefined);
  return n == null ? undefined : n.parsers[0];
}
function cn2(e, t9, r, n) {
  return [`Invalid ${V2.red(n.key(e))} value.`, `Expected ${V2.blue(r)},`, `but received ${t9 === Ze2 ? V2.gray("nothing") : V2.red(n.value(t9))}.`].join(" ");
}
function ln2({ text: e, list: t9 }, r) {
  let n = [];
  return e && n.push(`- ${V2.blue(e)}`), t9 && n.push([`- ${V2.blue(t9.title)}:`].concat(t9.values.map((u) => ln2(u, r - Dn2.length).replace(/^|\n/g, `$&${Dn2}`))).join(`
`)), Fn2(n, r);
}
function Fn2(e, t9) {
  if (e.length === 1)
    return e[0];
  let [r, n] = e, [u, o] = e.map((i2) => i2.split(`
`, 1)[0].length);
  return u > t9 && u > o ? n : r;
}
function vt2(e, t9) {
  if (e === t9)
    return 0;
  let r = e;
  e.length > t9.length && (e = t9, t9 = r);
  let n = e.length, u = t9.length;
  for (;n > 0 && e.charCodeAt(~-n) === t9.charCodeAt(~-u); )
    n--, u--;
  let o = 0;
  for (;o < n && e.charCodeAt(o) === t9.charCodeAt(o); )
    o++;
  if (n -= o, u -= o, n === 0)
    return u;
  let i2, s, a, c, D = 0, p = 0;
  for (;D < n; )
    pn2[D] = e.charCodeAt(o + D), Pt2[D] = ++D;
  for (;p < u; )
    for (i2 = t9.charCodeAt(o + p), a = p++, s = p, D = 0;D < n; D++)
      c = i2 === pn2[D] ? a : a + 1, a = Pt2[D], s = Pt2[D] = a > s ? c > s ? s + 1 : c : c > a ? a + 1 : c;
  return s;
}
function ao2(e, t9) {
  let r = new e(t9), n = Object.create(r);
  for (let u of so2)
    u in t9 && (n[u] = Do(t9[u], r, b4.prototype[u].length));
  return n;
}
function Do(e, t9, r) {
  return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t9, ...n.slice(r - 1)) : () => e;
}
function dn2({ from: e, to: t9 }) {
  return { from: [e], to: t9 };
}
function En2(e, t9) {
  let r = Object.create(null);
  for (let n of e) {
    let u = n[t9];
    if (r[u])
      throw new Error(`Duplicate ${t9} ${JSON.stringify(u)}`);
    r[u] = n;
  }
  return r;
}
function Cn2(e, t9) {
  let r = new Map;
  for (let n of e) {
    let u = n[t9];
    if (r.has(u))
      throw new Error(`Duplicate ${t9} ${JSON.stringify(u)}`);
    r.set(u, n);
  }
  return r;
}
function hn2() {
  let e = Object.create(null);
  return (t9) => {
    let r = JSON.stringify(t9);
    return e[r] ? true : (e[r] = true, false);
  };
}
function gn2(e, t9) {
  let r = [], n = [];
  for (let u of e)
    t9(u) ? r.push(u) : n.push(u);
  return [r, n];
}
function yn2(e) {
  return e === Math.floor(e);
}
function An2(e, t9) {
  if (e === t9)
    return 0;
  let r = typeof e, n = typeof t9, u = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t9) : e.localeCompare(t9);
}
function Bn2(e) {
  return (...t9) => {
    let r = e(...t9);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Lt2(e) {
  return e === undefined ? {} : e;
}
function It2(e) {
  if (typeof e == "string")
    return { text: e };
  let { text: t9, list: r } = e;
  return co2((t9 || r) !== undefined, "Unexpected `expected` result, there should be at least one field."), r ? { text: t9, list: { title: r.title, values: r.values.map(It2) } } : { text: t9 };
}
function Rt2(e, t9) {
  return e === true ? true : e === false ? { value: t9 } : e;
}
function Yt2(e, t9, r = false) {
  return e === false ? false : e === true ? r ? true : [{ value: t9 }] : ("value" in e) ? [e] : e.length === 0 ? false : e;
}
function mn2(e, t9) {
  return typeof e == "string" || "key" in e ? { from: t9, to: e } : ("from" in e) ? { from: e.from, to: e.to } : { from: t9, to: e.to };
}
function ot2(e, t9) {
  return e === undefined ? [] : Array.isArray(e) ? e.map((r) => mn2(r, t9)) : [mn2(e, t9)];
}
function jt2(e, t9) {
  let r = ot2(typeof e == "object" && "redirect" in e ? e.redirect : e, t9);
  return r.length === 0 ? { remain: t9, redirect: r } : typeof e == "object" && ("remain" in e) ? { remain: e.remain, redirect: r } : { redirect: r };
}
function co2(e, t9) {
  if (!e)
    throw new Error(t9);
}
function lo2(e, t9, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: o, descriptor: i2 } = {}) {
  if (n) {
    if (!o)
      throw new Error("'FlagSchema' option is required.");
    if (!i2)
      throw new Error("'descriptor' option is required.");
  } else
    i2 = re2;
  let s = u ? Array.isArray(u) ? (l2, F) => u.includes(l2) ? { [l2]: F } : undefined : (l2, F) => ({ [l2]: F }) : (l2, F, f) => {
    let { _: d2, ...m } = f.schemas;
    return et3(l2, F, { ...f, schemas: m });
  }, a = Fo(t9, { isCLI: n, FlagSchema: o }), c = new Dt2(a, { logger: r, unknown: s, descriptor: i2 }), D = r !== false;
  D && Ut2 && (c._hasDeprecationWarned = Ut2);
  let p = c.normalize(e);
  return D && (Ut2 = c._hasDeprecationWarned), p;
}
function Fo(e, { isCLI: t9, FlagSchema: r }) {
  let n = [];
  t9 && n.push(rt2.create({ name: "_" }));
  for (let u of e)
    n.push(po2(u, { isCLI: t9, optionInfos: e, FlagSchema: r })), u.alias && t9 && n.push(tt2.create({ name: u.alias, sourceName: u.name }));
  return n;
}
function po2(e, { isCLI: t9, optionInfos: r, FlagSchema: n }) {
  let { name: u } = e, o = { name: u }, i2, s = {};
  switch (e.type) {
    case "int":
      i2 = at2, t9 && (o.preprocess = Number);
      break;
    case "string":
      i2 = Ie2;
      break;
    case "choice":
      i2 = it2, o.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i2 = ut2;
      break;
    case "flag":
      i2 = n, o.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i2 = Ie2;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? o.validate = (a, c, D) => e.exception(a) || c.validate(a, D) : o.validate = (a, c, D) => a === undefined || c.validate(a, D), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : undefined), e.deprecated && (s.deprecated = true), t9 && !e.array) {
    let a = o.preprocess || ((c) => c);
    o.preprocess = (c, D, p) => D.preprocess(a(Array.isArray(c) ? y(false, c, -1) : c), p);
  }
  return e.array ? nt2.create({ ...t9 ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: i2.create(o) }) : i2.create({ ...o, ...s });
}
function $t2(e, t9) {
  if (!t9)
    throw new Error("parserName is required.");
  let r = Vt2(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t9));
  if (r)
    return r;
  let n = `Couldn't resolve parser "${t9}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve2(n);
}
function Sn2(e, t9) {
  if (!t9)
    throw new Error("astFormat is required.");
  let r = Vt2(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t9));
  if (r)
    return r;
  let n = `Couldn't find plugin for AST format "${t9}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new ve2(n);
}
function Re2({ plugins: e, parser: t9 }) {
  let r = $t2(e, t9);
  return Wt2(r, t9);
}
function Wt2(e, t9) {
  let r = e.parsers[t9];
  return typeof r == "function" ? r() : r;
}
function Tn2(e, t9) {
  let r = e.printers[t9];
  return typeof r == "function" ? r() : r;
}
async function Eo(e, t9 = {}) {
  var p;
  let r = { ...e };
  if (!r.parser)
    if (r.filepath) {
      if (r.parser = on2(r, { physicalFile: r.filepath }), !r.parser)
        throw new Le2(`No parser could be inferred for file "${r.filepath}".`);
    } else
      throw new Le2("No parser and no file path given, couldn't infer a parser.");
  let n = Qe2({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Nn2, ...Object.fromEntries(n.filter((l2) => l2.default !== undefined).map((l2) => [l2.name, l2.default])) }, o = $t2(r.plugins, r.parser), i2 = await Wt2(o, r.parser);
  r.astFormat = i2.astFormat, r.locEnd = i2.locEnd, r.locStart = i2.locStart;
  let s = (p = o.printers) != null && p[i2.astFormat] ? o : Sn2(r.plugins, i2.astFormat), a = await Tn2(s, i2.astFormat);
  r.printer = a;
  let c = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, l2]) => l2 !== undefined)) : {}, D = { ...u, ...c };
  for (let [l2, F] of Object.entries(D))
    (r[l2] === null || r[l2] === undefined) && (r[l2] = F);
  return r.parser === "json" && (r.trailingComma = "none"), kn2(r, n, { passThrough: Object.keys(Nn2), ...t9 });
}
async function yo(e, t9) {
  let r = await Re2(t9), n = r.preprocess ? r.preprocess(e, t9) : e;
  t9.originalText = n;
  let u;
  try {
    u = await r.parse(n, t9, t9);
  } catch (o) {
    Ao(o, e);
  }
  return { text: n, ast: u };
}
function Ao(e, t9) {
  let { loc: r } = e;
  if (r) {
    let n = (0, vn2.codeFrameColumns)(t9, r, { highlightCode: true });
    throw e.message += `
` + n, e.codeFrame = n, e;
  }
  throw e;
}
async function Ln2(e, t9, r, n, u) {
  let { embeddedLanguageFormatting: o, printer: { embed: i2, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
  if (!i2 || o !== "auto")
    return;
  if (i2.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let c = J2(i2.getVisitorKeys ?? a), D = [];
  F();
  let p = e.stack;
  for (let { print: f, node: d2, pathStack: m } of D)
    try {
      e.stack = m;
      let C = await f(l2, t9, e, r);
      C && u.set(d2, C);
    } catch (C) {
      if (globalThis.PRETTIER_DEBUG)
        throw C;
    }
  e.stack = p;
  function l2(f, d2) {
    return Bo(f, d2, r, n);
  }
  function F() {
    let { node: f } = e;
    if (f === null || typeof f != "object" || s(e))
      return;
    for (let m of c(f))
      Array.isArray(f[m]) ? e.each(F, m) : e.call(F, m);
    let d2 = i2(e, r);
    if (d2) {
      if (typeof d2 == "function") {
        D.push({ print: d2, node: f, pathStack: [...e.stack] });
        return;
      }
      u.set(f, d2);
    }
  }
}
async function Bo(e, t9, r, n) {
  let u = await ne3({ ...r, ...t9, parentParser: r.parser, originalText: e, cursorOffset: undefined, rangeStart: undefined, rangeEnd: undefined }, { passThrough: true }), { ast: o } = await De2(e, u), i2 = await n(o, u);
  return $e(i2);
}
function _o(e, t9) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: o, [Symbol.for("printedComments")]: i2 } = t9, { node: s } = e, a = u(s), c = o(s);
  for (let D of n)
    u(D) >= a && o(D) <= c && i2.add(D);
  return r.slice(a, c);
}
async function Ye2(e, t9) {
  ({ ast: e } = await Gt2(e, t9));
  let r = new Map, n = new Or4(e), u = Kr2(t9), o = new Map;
  await Ln2(n, s, t9, Ye2, o);
  let i2 = await Rn2(n, t9, s, undefined, o);
  if (Gr2(t9), t9.cursorOffset >= 0) {
    if (t9.nodeAfterCursor && !t9.nodeBeforeCursor)
      return [X2, i2];
    if (t9.nodeBeforeCursor && !t9.nodeAfterCursor)
      return [i2, X2];
  }
  return i2;
  function s(c, D) {
    return c === undefined || c === n ? a(D) : Array.isArray(c) ? n.call(() => a(D), ...c) : n.call(() => a(D), c);
  }
  function a(c) {
    u(n);
    let D = n.node;
    if (D == null)
      return "";
    let p = D && typeof D == "object" && c === undefined;
    if (p && r.has(D))
      return r.get(D);
    let l2 = Rn2(n, t9, s, c, o);
    return p && r.set(D, l2), l2;
  }
}
function Rn2(e, t9, r, n, u) {
  var a;
  let { node: o } = e, { printer: i2 } = t9, s;
  switch ((a = i2.hasPrettierIgnore) != null && a.call(i2, e) ? s = In2(e, t9) : u.has(o) ? s = u.get(o) : s = i2.print(e, t9, r, n), o) {
    case t9.cursorNode:
      s = Fe2(s, (c) => [X2, c, X2]);
      break;
    case t9.nodeBeforeCursor:
      s = Fe2(s, (c) => [c, X2]);
      break;
    case t9.nodeAfterCursor:
      s = Fe2(s, (c) => [X2, c]);
      break;
  }
  return i2.printComment && (!i2.willPrintOwnComments || !i2.willPrintOwnComments(e, t9)) && (s = Mr(e, s, t9)), s;
}
async function Gt2(e, t9) {
  let r = e.comments ?? [];
  t9[Symbol.for("comments")] = r, t9[Symbol.for("printedComments")] = new Set, Vr(e, t9);
  let { printer: { preprocess: n } } = t9;
  return e = n ? await n(e, t9) : e, { ast: e, comments: r };
}
function xo(e, t9) {
  let { cursorOffset: r, locStart: n, locEnd: u } = t9, o = J2(t9.printer.getVisitorKeys), i2 = (F) => n(F) <= r && u(F) >= r, s = e, a = [e];
  for (let F of Lr2(e, { getVisitorKeys: o, filter: i2 }))
    a.push(F), s = F;
  if (Ir2(s, { getVisitorKeys: o }))
    return { cursorNode: s };
  let c, D, p = -1, l2 = Number.POSITIVE_INFINITY;
  for (;a.length > 0 && (c === undefined || D === undefined); ) {
    s = a.pop();
    let F = c !== undefined, f = D !== undefined;
    for (let d2 of Ce2(s, { getVisitorKeys: o })) {
      if (!F) {
        let m = u(d2);
        m <= r && m > p && (c = d2, p = m);
      }
      if (!f) {
        let m = n(d2);
        m >= r && m < l2 && (D = d2, l2 = m);
      }
    }
  }
  return { nodeBeforeCursor: c, nodeAfterCursor: D };
}
function wo(e, t9) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = t9;
  if (!r)
    return e;
  let u = J2(n), o = r.ignoredProperties ?? new Set;
  return i2(e);
  function i2(s, a) {
    if (!(s !== null && typeof s == "object"))
      return s;
    if (Array.isArray(s))
      return s.map((l2) => i2(l2, a)).filter(Boolean);
    let c = {}, D = new Set(u(s));
    for (let l2 in s)
      !Object.prototype.hasOwnProperty.call(s, l2) || o.has(l2) || (D.has(l2) ? c[l2] = i2(s[l2], s) : c[l2] = s[l2]);
    let p = r(s, c, a);
    if (p !== null)
      return p ?? c;
  }
}
function So(e, t9) {
  let r = [e.node, ...e.parentNodes], n = new Set([t9.node, ...t9.parentNodes]);
  return r.find((u) => $n2.has(u.type) && n.has(u));
}
function Un2(e) {
  let t9 = jn2(false, e, (r) => r.type !== "Program" && r.type !== "File");
  return t9 === -1 ? e : e.slice(0, t9 + 1);
}
function To(e, t9, { locStart: r, locEnd: n }) {
  let u = e.node, o = t9.node;
  if (u === o)
    return { startNode: u, endNode: o };
  let i2 = r(e.node);
  for (let a of Un2(t9.parentNodes))
    if (r(a) >= i2)
      o = a;
    else
      break;
  let s = n(t9.node);
  for (let a of Un2(e.parentNodes)) {
    if (n(a) <= s)
      u = a;
    else
      break;
    if (u === o)
      break;
  }
  return { startNode: u, endNode: o };
}
function zt2(e, t9, r, n, u = [], o) {
  let { locStart: i2, locEnd: s } = r, a = i2(e), c = s(e);
  if (!(t9 > c || t9 < a || o === "rangeEnd" && t9 === a || o === "rangeStart" && t9 === c)) {
    for (let D of Xe2(e, r)) {
      let p = zt2(D, t9, r, n, [e, ...u], o);
      if (p)
        return p;
    }
    if (!n || n(e, u[0]))
      return { node: e, parentNodes: u };
  }
}
function No(e, t9) {
  return t9 !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
function Vn2(e, t9, r) {
  if (!t9)
    return false;
  switch (e.parser) {
    case "flow":
    case "hermes":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "oxc":
    case "oxc-ts":
    case "__babel_estree":
      return No(t9.type, r == null ? undefined : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return $n2.has(t9.type);
    case "graphql":
      return Oo2.has(t9.kind);
    case "vue":
      return t9.tag !== "root";
  }
  return false;
}
function Wn2(e, t9, r) {
  let { rangeStart: n, rangeEnd: u, locStart: o, locEnd: i2 } = t9;
  Oe2.ok(u > n);
  let s = e.slice(n, u).search(/\S/u), a = s === -1;
  if (!a)
    for (n += s;u > n && !/\S/u.test(e[u - 1]); --u)
      ;
  let c = zt2(r, n, t9, (F, f) => Vn2(t9, F, f), [], "rangeStart"), D = a ? c : zt2(r, u, t9, (F) => Vn2(t9, F), [], "rangeEnd");
  if (!c || !D)
    return { rangeStart: 0, rangeEnd: 0 };
  let p, l2;
  if (ko(t9)) {
    let F = So(c, D);
    p = F, l2 = F;
  } else
    ({ startNode: p, endNode: l2 } = To(c, D, t9));
  return { rangeStart: Math.min(o(p), o(l2)), rangeEnd: Math.max(i2(p), i2(l2)) };
}
async function Hn2(e, t9, r = 0) {
  if (!e || e.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: u } = await De2(e, t9);
  t9.cursorOffset >= 0 && (t9 = { ...t9, ...Kt2(n, t9) });
  let o = await Ye2(n, t9, r);
  r > 0 && (o = Ge3([z2, o], r, t9.tabWidth));
  let i2 = me2(o, t9);
  if (r > 0) {
    let a = i2.formatted.trim();
    i2.cursorNodeStart !== undefined && (i2.cursorNodeStart -= i2.formatted.indexOf(a), i2.cursorNodeStart < 0 && (i2.cursorNodeStart = 0, i2.cursorNodeText = i2.cursorNodeText.trimStart()), i2.cursorNodeStart + i2.cursorNodeText.length > a.length && (i2.cursorNodeText = i2.cursorNodeText.trimEnd())), i2.formatted = a + xe2(t9.endOfLine);
  }
  let s = t9[Symbol.for("comments")];
  if (t9.cursorOffset >= 0) {
    let a, c, D, p;
    if ((t9.cursorNode || t9.nodeBeforeCursor || t9.nodeAfterCursor) && i2.cursorNodeText)
      if (D = i2.cursorNodeStart, p = i2.cursorNodeText, t9.cursorNode)
        a = t9.locStart(t9.cursorNode), c = u.slice(a, t9.locEnd(t9.cursorNode));
      else {
        if (!t9.nodeBeforeCursor && !t9.nodeAfterCursor)
          throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
        a = t9.nodeBeforeCursor ? t9.locEnd(t9.nodeBeforeCursor) : 0;
        let C = t9.nodeAfterCursor ? t9.locStart(t9.nodeAfterCursor) : u.length;
        c = u.slice(a, C);
      }
    else
      a = 0, c = u, D = 0, p = i2.formatted;
    let l2 = t9.cursorOffset - a;
    if (c === p)
      return { formatted: i2.formatted, cursorOffset: D + l2, comments: s };
    let F = c.split("");
    F.splice(l2, 0, Mn2);
    let f = p.split(""), d2 = Et2(F, f), m = D;
    for (let C of d2)
      if (C.removed) {
        if (C.value.includes(Mn2))
          break;
      } else
        m += C.count;
    return { formatted: i2.formatted, cursorOffset: m, comments: s };
  }
  return { formatted: i2.formatted, cursorOffset: -1, comments: s };
}
async function Po(e, t9) {
  let { ast: r, text: n } = await De2(e, t9), { rangeStart: u, rangeEnd: o } = Wn2(n, t9, r), i2 = n.slice(u, o), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], c = Ee2(a, t9.tabWidth), D = await Hn2(i2, { ...t9, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t9.cursorOffset > u && t9.cursorOffset <= o ? t9.cursorOffset - u : -1, endOfLine: "lf" }, c), p = D.formatted.trimEnd(), { cursorOffset: l2 } = t9;
  l2 > o ? l2 += p.length - i2.length : D.cursorOffset >= 0 && (l2 = D.cursorOffset + u);
  let F = n.slice(0, u) + p + n.slice(o);
  if (t9.endOfLine !== "lf") {
    let f = xe2(t9.endOfLine);
    l2 >= 0 && f === `\r
` && (l2 += Ct2(F.slice(0, l2), `
`)), F = te(false, F, `
`, f);
  }
  return { formatted: F, cursorOffset: l2, comments: D.comments };
}
function Ht2(e, t9, r) {
  return typeof t9 != "number" || Number.isNaN(t9) || t9 < 0 || t9 > e.length ? r : t9;
}
function Gn2(e, t9) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t9;
  return r = Ht2(e, r, -1), n = Ht2(e, n, 0), u = Ht2(e, u, e.length), { ...t9, cursorOffset: r, rangeStart: n, rangeEnd: u };
}
function Jn2(e, t9) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o } = Gn2(e, t9), i2 = e.charAt(0) === zn2;
  if (i2 && (e = e.slice(1), r--, n--, u--), o === "auto" && (o = nr2(e)), e.includes("\r")) {
    let s = (a) => Ct2(e.slice(0, Math.max(a, 0)), `\r
`);
    r -= s(r), n -= s(n), u -= s(u), e = ur2(e);
  }
  return { hasBOM: i2, text: e, options: Gn2(e, { ...t9, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: o }) };
}
async function Kn2(e, t9) {
  let r = await Re2(t9);
  return !r.hasPragma || r.hasPragma(e);
}
async function vo(e, t9) {
  var n;
  let r = await Re2(t9);
  return (n = r.hasIgnorePragma) == null ? undefined : n.call(r, e);
}
async function Jt(e, t9) {
  let { hasBOM: r, text: n, options: u } = Jn2(e, await ne3(t9));
  if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await Kn2(n, u) || u.checkIgnorePragma && await vo(n, u))
    return { formatted: e, cursorOffset: t9.cursorOffset, comments: [] };
  let o;
  return u.rangeStart > 0 || u.rangeEnd < n.length ? o = await Po(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await Kn2(n, u) && (n = u.printer.insertPragma(n)), o = await Hn2(n, u)), r && (o.formatted = zn2 + o.formatted, o.cursorOffset >= 0 && o.cursorOffset++), o;
}
async function qn2(e, t9, r) {
  let { text: n, options: u } = Jn2(e, await ne3(t9)), o = await De2(n, u);
  return r && (r.preprocessForPrint && (o.ast = await Gt2(o.ast, u)), r.massage && (o.ast = Yn2(o.ast, u))), o;
}
async function Xn2(e, t9) {
  t9 = await ne3(t9);
  let r = await Ye2(e, t9);
  return me2(r, t9);
}
async function Qn2(e, t9) {
  let r = wr2(e), { formatted: n } = await Jt(r, { ...t9, parser: "__js_expression" });
  return n;
}
async function Zn2(e, t9) {
  t9 = await ne3(t9);
  let { ast: r } = await De2(e, t9);
  return t9.cursorOffset >= 0 && (t9 = { ...t9, ...Kt2(r, t9) }), Ye2(r, t9);
}
async function eu2(e, t9) {
  return me2(e, await ne3(t9));
}
function jo2(e, t9) {
  if (t9 === false)
    return false;
  if (e.charAt(t9) === "/" && e.charAt(t9 + 1) === "*") {
    for (let r = t9 + 2;r < e.length; ++r)
      if (e.charAt(r) === "*" && e.charAt(r + 1) === "/")
        return r + 2;
  }
  return t9;
}
function Uo2(e, t9) {
  return t9 === false ? false : e.charAt(t9) === "/" && e.charAt(t9 + 1) === "/" ? Je2(e, t9) : t9;
}
function Vo2(e, t9) {
  let r = null, n = t9;
  for (;n !== r; )
    r = n, n = T3(e, n), n = ye(e, n), n = Ae2(e, n), n = U(e, n);
  return n;
}
function $o2(e, t9) {
  let r = null, n = t9;
  for (;n !== r; )
    r = n, n = He2(e, n), n = ye(e, n), n = T3(e, n);
  return n = Ae2(e, n), n = U(e, n), n !== false && G2(e, n);
}
function Wo2(e, t9) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : Ee2(e.slice(r + 1).match(/^[\t ]*/u)[0], t9);
}
function Xt2(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Mo2(e, t9) {
  let r = e.match(new RegExp(`(${Xt2(t9)})+`, "gu"));
  return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t9.length), 0);
}
function Go2(e, t9) {
  let r = je2(e, t9);
  return r === false ? "" : e.charAt(r);
}
function Ko2(e, t9) {
  let r = t9 === true || t9 === ft2 ? ft2 : ou2, n = r === ft2 ? ou2 : ft2, u = 0, o = 0;
  for (let i2 of e)
    i2 === r ? u++ : i2 === n && o++;
  return u > o ? n : r;
}
function zo2(e, t9, r) {
  for (let n = t9;n < r; ++n)
    if (e.charAt(n) === `
`)
      return true;
  return false;
}
function Ho2(e, t9, r = {}) {
  return T3(e, r.backwards ? t9 - 1 : t9, r) !== t9;
}
function Jo2(e, t9, r) {
  let n = t9 === '"' ? "'" : '"', o = te(false, e, /\\(.)|(["'])/gsu, (i2, s, a) => s === n ? s : a === t9 ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t9 + o + t9;
}
function qo2(e, t9, r) {
  return je2(e, r(t9));
}
function Xo2(e, t9) {
  return arguments.length === 2 || typeof t9 == "number" ? je2(e, t9) : qo2(...arguments);
}
function Qo2(e, t9, r) {
  return Pe2(e, r(t9));
}
function Zo2(e, t9) {
  return arguments.length === 2 || typeof t9 == "number" ? Pe2(e, t9) : Qo2(...arguments);
}
function ei(e, t9, r) {
  return ct2(e, r(t9));
}
function ti2(e, t9) {
  return arguments.length === 2 || typeof t9 == "number" ? ct2(e, t9) : ei(...arguments);
}
function ce2(e, t9 = 1) {
  return async (...r) => {
    let n = r[t9] ?? {}, u = n.plugins ?? [];
    return r[t9] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
  };
}
async function fu(e, t9) {
  let { formatted: r } = await cu(e, { ...t9, cursorOffset: -1 });
  return r;
}
async function ri2(e, t9) {
  return await fu(e, t9) === e;
}
var Fu, pt2, pu, du, mu, Eu, er = (e) => {
  throw TypeError(e);
}, Cu = (e, t9) => () => (t9 || e((t9 = { exports: {} }).exports, t9), t9.exports), dt = (e, t9) => {
  for (var r in t9)
    pt2(e, r, { get: t9[r], enumerable: true });
}, hu = (e, t9, r, n) => {
  if (t9 && typeof t9 == "object" || typeof t9 == "function")
    for (let u of du(t9))
      !Eu.call(e, u) && u !== r && pt2(e, u, { get: () => t9[u], enumerable: !(n = pu(t9, u)) || n.enumerable });
  return e;
}, gu = (e, t9, r) => (r = e != null ? Fu(mu(e)) : {}, hu(t9 || !e || !e.__esModule ? pt2(r, "default", { value: e, enumerable: true }) : r, e)), yu = (e, t9, r) => t9.has(e) || er("Cannot " + r), tr = (e, t9, r) => t9.has(e) ? er("Cannot add the same private member more than once") : t9 instanceof WeakSet ? t9.add(e) : t9.set(e, r), fe2 = (e, t9, r) => (yu(e, t9, "access private method"), r), Pn2, Zt, Au = (e, t9, r, n) => {
  if (!(e && t9 == null))
    return t9.replaceAll ? t9.replaceAll(r, n) : r.global ? t9.replace(r, n) : t9.split(r).join(n);
}, te, _e2 = class {
  diff(t9, r, n = {}) {
    let u;
    typeof n == "function" ? (u = n, n = {}) : ("callback" in n) && (u = n.callback);
    let o = this.castInput(t9, n), i2 = this.castInput(r, n), s = this.removeEmpty(this.tokenize(o, n)), a = this.removeEmpty(this.tokenize(i2, n));
    return this.diffWithOptionsObj(s, a, n, u);
  }
  diffWithOptionsObj(t9, r, n, u) {
    var o;
    let i2 = (E2) => {
      if (E2 = this.postProcess(E2, n), u) {
        setTimeout(function() {
          u(E2);
        }, 0);
        return;
      } else
        return E2;
    }, s = r.length, a = t9.length, c = 1, D = s + a;
    n.maxEditLength != null && (D = Math.min(D, n.maxEditLength));
    let p = (o = n.timeout) !== null && o !== undefined ? o : 1 / 0, l2 = Date.now() + p, F = [{ oldPos: -1, lastComponent: undefined }], f = this.extractCommon(F[0], r, t9, 0, n);
    if (F[0].oldPos + 1 >= a && f + 1 >= s)
      return i2(this.buildValues(F[0].lastComponent, r, t9));
    let d2 = -1 / 0, m = 1 / 0, C = () => {
      for (let E2 = Math.max(d2, -c);E2 <= Math.min(m, c); E2 += 2) {
        let h2, x2 = F[E2 - 1], A = F[E2 + 1];
        x2 && (F[E2 - 1] = undefined);
        let $3 = false;
        if (A) {
          let Be2 = A.oldPos - E2;
          $3 = A && 0 <= Be2 && Be2 < s;
        }
        let ue = x2 && x2.oldPos + 1 < a;
        if (!$3 && !ue) {
          F[E2] = undefined;
          continue;
        }
        if (!ue || $3 && x2.oldPos < A.oldPos ? h2 = this.addToPath(A, true, false, 0, n) : h2 = this.addToPath(x2, false, true, 1, n), f = this.extractCommon(h2, r, t9, E2, n), h2.oldPos + 1 >= a && f + 1 >= s)
          return i2(this.buildValues(h2.lastComponent, r, t9)) || true;
        F[E2] = h2, h2.oldPos + 1 >= a && (m = Math.min(m, E2 - 1)), f + 1 >= s && (d2 = Math.max(d2, E2 + 1));
      }
      c++;
    };
    if (u)
      (function E() {
        setTimeout(function() {
          if (c > D || Date.now() > l2)
            return u(undefined);
          C() || E();
        }, 0);
      })();
    else
      for (;c <= D && Date.now() <= l2; ) {
        let E2 = C();
        if (E2)
          return E2;
      }
  }
  addToPath(t9, r, n, u, o) {
    let i2 = t9.lastComponent;
    return i2 && !o.oneChangePerToken && i2.added === r && i2.removed === n ? { oldPos: t9.oldPos + u, lastComponent: { count: i2.count + 1, added: r, removed: n, previousComponent: i2.previousComponent } } : { oldPos: t9.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: i2 } };
  }
  extractCommon(t9, r, n, u, o) {
    let i2 = r.length, s = n.length, a = t9.oldPos, c = a - u, D = 0;
    for (;c + 1 < i2 && a + 1 < s && this.equals(n[a + 1], r[c + 1], o); )
      c++, a++, D++, o.oneChangePerToken && (t9.lastComponent = { count: 1, previousComponent: t9.lastComponent, added: false, removed: false });
    return D && !o.oneChangePerToken && (t9.lastComponent = { count: D, previousComponent: t9.lastComponent, added: false, removed: false }), t9.oldPos = a, c;
  }
  equals(t9, r, n) {
    return n.comparator ? n.comparator(t9, r) : t9 === r || !!n.ignoreCase && t9.toLowerCase() === r.toLowerCase();
  }
  removeEmpty(t9) {
    let r = [];
    for (let n = 0;n < t9.length; n++)
      t9[n] && r.push(t9[n]);
    return r;
  }
  castInput(t9, r) {
    return t9;
  }
  tokenize(t9, r) {
    return Array.from(t9);
  }
  join(t9) {
    return t9.join("");
  }
  postProcess(t9, r) {
    return t9;
  }
  get useLongestToken() {
    return false;
  }
  buildValues(t9, r, n) {
    let u = [], o;
    for (;t9; )
      u.push(t9), o = t9.previousComponent, delete t9.previousComponent, t9 = o;
    u.reverse();
    let i2 = u.length, s = 0, a = 0, c = 0;
    for (;s < i2; s++) {
      let D = u[s];
      if (D.removed)
        D.value = this.join(n.slice(c, c + D.count)), c += D.count;
      else {
        if (!D.added && this.useLongestToken) {
          let p = r.slice(a, a + D.count);
          p = p.map(function(l2, F) {
            let f = n[c + F];
            return f.length > l2.length ? f : l2;
          }), D.value = this.join(p);
        } else
          D.value = this.join(r.slice(a, a + D.count));
        a += D.count, D.added || (c += D.count);
      }
    }
    return u;
  }
}, mt2, rr2, W2 = "string", Y3 = "array", j2 = "cursor", N2 = "indent", O2 = "align", P2 = "trim", B2 = "group", k3 = "fill", _3 = "if-break", v2 = "indent-if-break", L2 = "line-suffix", I = "line-suffix-boundary", g = "line", S2 = "label", w2 = "break-parent", Ue2, Bu = (e, t9, r) => {
  if (!(e && t9 == null))
    return Array.isArray(t9) || typeof t9 == "string" ? t9[r < 0 ? t9.length + r : r] : t9.at(r);
}, y, M, xu = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e), ht2, q, ir2, le2, gt3 = () => {}, K2, yt2, pr2, Ar2, pe2, Br2, Te2, Bt2, Me2, _r2, z2, We, X2, br2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, Tr2 = (e) => !(kr2(e) || Sr2(e)), Pu, Ne2, R2, H2, de2, _t2, Ee2, Z2, kt2, ze2, bt2 = class {
  constructor(t9) {
    tr(this, Z2);
    this.stack = [t9];
  }
  get key() {
    let { stack: t9, siblings: r } = this;
    return y(false, t9, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t9 } = this, r = y(false, t9, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: t9 } = this;
    return t9 === null ? null : t9[this.index + 1];
  }
  get previous() {
    let { siblings: t9 } = this;
    return t9 === null ? null : t9[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t9, index: r } = this;
    return t9 !== null && r === t9.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...fe2(this, Z2, ze2).call(this)];
  }
  getName() {
    let { stack: t9 } = this, { length: r } = t9;
    return r > 1 ? y(false, t9, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t9 = 0) {
    let r = fe2(this, Z2, kt2).call(this, t9);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(t9 = 0) {
    return this.getNode(t9 + 1);
  }
  call(t9, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i2 of r)
      o = o[i2], n.push(i2, o);
    try {
      return t9(this);
    } finally {
      n.length = u;
    }
  }
  callParent(t9, r = 0) {
    let n = fe2(this, Z2, kt2).call(this, r + 1), u = this.stack.splice(n + 1);
    try {
      return t9(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t9, ...r) {
    let { stack: n } = this, { length: u } = n, o = y(false, n, -1);
    for (let i2 of r)
      o = o[i2], n.push(i2, o);
    try {
      for (let i2 = 0;i2 < o.length; ++i2)
        n.push(i2, o[i2]), t9(this, i2, o), n.length -= 2;
    } finally {
      n.length = u;
    }
  }
  map(t9, ...r) {
    let n = [];
    return this.each((u, o, i2) => {
      n[o] = t9(u, o, i2);
    }, ...r), n;
  }
  match(...t9) {
    let r = this.stack.length - 1, n = null, u = this.stack[r--];
    for (let o of t9) {
      if (u === undefined)
        return false;
      let i2 = null;
      if (typeof n == "number" && (i2 = n, n = this.stack[r--], u = this.stack[r--]), o && !o(u, n, i2))
        return false;
      n = this.stack[r--], u = this.stack[r--];
    }
    return true;
  }
  findAncestor(t9) {
    for (let r of fe2(this, Z2, ze2).call(this))
      if (t9(r))
        return r;
  }
  hasAncestor(t9) {
    for (let r of fe2(this, Z2, ze2).call(this))
      if (t9(r))
        return true;
    return false;
  }
}, Or4, Pr2, Oe2, vr2, Rr2, T3, He2, Je2, U, G2, qe2, Yr, $u = (e) => Object.keys(e).filter((t9) => !Yr.has(t9)), J2, Tt2, Nt2 = () => false, $r2 = (e) => !/[\S\n\u2028\u2029]/u.test(e), Pe2, Kr2, ve2, Le2, zr, eo2 = (e, t9) => {
  if (!(e && t9 == null))
    return t9.toReversed || !Array.isArray(t9) ? t9.toReversed() : [...t9].reverse();
}, Hr, Jr2, qr, Xr2, Qr2, Zr2, to2, rn2, uo2 = (e) => String(e).split(/[/\\]/u).pop(), on2, re2, sn, V2, an = (e, t9, { descriptor: r }) => {
  let n = [`${V2.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
  return t9 && n.push(`we now treat it as ${V2.blue(typeof t9 == "string" ? r.key(t9) : r.pair(t9))}`), n.join("; ") + ".";
}, Ze2, ge2, Dn2, fn2 = (e, t9, r) => {
  let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), o = [];
  return n && o.push(cn2(e, t9, n, r.descriptor)), u && o.push([cn2(e, t9, u.title, r.descriptor)].concat(u.values.map((i2) => ln2(i2, r.loggerPrintWidth))).join(`
`)), Fn2(o, r.loggerPrintWidth);
}, Pt2, pn2, et3 = (e, t9, { descriptor: r, logger: n, schemas: u }) => {
  let o = [`Ignored unknown option ${V2.yellow(r.pair({ key: e, value: t9 }))}.`], i2 = Object.keys(u).sort().find((s) => vt2(e, s) < 3);
  i2 && o.push(`Did you mean ${V2.blue(r.key(i2))}?`), n.warn(o.join(" "));
}, so2, b4 = class {
  static create(t9) {
    return ao2(this, t9);
  }
  constructor(t9) {
    this.name = t9.name;
  }
  default(t9) {}
  expected(t9) {
    return "nothing";
  }
  validate(t9, r) {
    return false;
  }
  deprecated(t9, r) {
    return false;
  }
  forward(t9, r) {}
  redirect(t9, r) {}
  overlap(t9, r, n) {
    return t9;
  }
  preprocess(t9, r) {
    return t9;
  }
  postprocess(t9, r) {
    return ge2;
  }
}, tt2, rt2, nt2, ut2, it2, st2, at2, Ie2, _n2, xn2, wn2, bn2, Dt2 = class {
  constructor(t9, r) {
    let { logger: n = console, loggerPrintWidth: u = 80, descriptor: o = _n2, unknown: i2 = xn2, invalid: s = wn2, deprecated: a = bn2, missing: c = () => false, required: D = () => false, preprocess: p = (F) => F, postprocess: l2 = () => ge2 } = r || {};
    this._utils = { descriptor: o, logger: n || { warn: () => {} }, loggerPrintWidth: u, schemas: En2(t9, "name"), normalizeDefaultResult: Lt2, normalizeExpectedResult: It2, normalizeDeprecatedResult: Yt2, normalizeForwardResult: ot2, normalizeRedirectResult: jt2, normalizeValidateResult: Rt2 }, this._unknownHandler = i2, this._invalidHandler = Bn2(s), this._deprecatedHandler = a, this._identifyMissing = (F, f) => !(F in f) || c(F, f), this._identifyRequired = D, this._preprocess = p, this._postprocess = l2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = hn2();
  }
  normalize(t9) {
    let r = {}, u = [this._preprocess(t9, this._utils)], o = () => {
      for (;u.length !== 0; ) {
        let i2 = u.shift(), s = this._applyNormalization(i2, r);
        u.push(...s);
      }
    };
    o();
    for (let i2 of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[i2];
      if (!(i2 in r)) {
        let a = Lt2(s.default(this._utils));
        "value" in a && u.push({ [i2]: a.value });
      }
    }
    o();
    for (let i2 of Object.keys(this._utils.schemas)) {
      if (!(i2 in r))
        continue;
      let s = this._utils.schemas[i2], a = r[i2], c = s.postprocess(a, this._utils);
      c !== ge2 && (this._applyValidation(c, i2, s), r[i2] = c);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(t9, r) {
    let n = [], { knownKeys: u, unknownKeys: o } = this._partitionOptionKeys(t9);
    for (let i2 of u) {
      let s = this._utils.schemas[i2], a = s.preprocess(t9[i2], this._utils);
      this._applyValidation(a, i2, s);
      let c = ({ from: F, to: f }) => {
        n.push(typeof f == "string" ? { [f]: F } : { [f.key]: f.value });
      }, D = ({ value: F, redirectTo: f }) => {
        let d2 = Yt2(s.deprecated(F, this._utils), a, true);
        if (d2 !== false)
          if (d2 === true)
            this._hasDeprecationWarned(i2) || this._utils.logger.warn(this._deprecatedHandler(i2, f, this._utils));
          else
            for (let { value: m } of d2) {
              let C = { key: i2, value: m };
              if (!this._hasDeprecationWarned(C)) {
                let E2 = typeof f == "string" ? { key: f, value: m } : f;
                this._utils.logger.warn(this._deprecatedHandler(C, E2, this._utils));
              }
            }
      };
      ot2(s.forward(a, this._utils), a).forEach(c);
      let l2 = jt2(s.redirect(a, this._utils), a);
      if (l2.redirect.forEach(c), "remain" in l2) {
        let F = l2.remain;
        r[i2] = i2 in r ? s.overlap(r[i2], F, this._utils) : F, D({ value: F });
      }
      for (let { from: F, to: f } of l2.redirect)
        D({ value: F, redirectTo: f });
    }
    for (let i2 of o) {
      let s = t9[i2];
      this._applyUnknownHandler(i2, s, r, (a, c) => {
        n.push({ [a]: c });
      });
    }
    return n;
  }
  _applyRequiredCheck(t9) {
    for (let r of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r, t9) && this._identifyRequired(r))
        throw this._invalidHandler(r, Ze2, this._utils);
  }
  _partitionOptionKeys(t9) {
    let [r, n] = gn2(Object.keys(t9).filter((u) => !this._identifyMissing(u, t9)), (u) => (u in this._utils.schemas));
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(t9, r, n) {
    let u = Rt2(n.validate(t9, this._utils), t9);
    if (u !== true)
      throw this._invalidHandler(r, u.value, this._utils);
  }
  _applyUnknownHandler(t9, r, n, u) {
    let o = this._unknownHandler(t9, r, this._utils);
    if (o)
      for (let i2 of Object.keys(o)) {
        if (this._identifyMissing(i2, o))
          continue;
        let s = o[i2];
        i2 in this._utils.schemas ? u(i2, s) : n[i2] = s;
      }
  }
  _applyPostprocess(t9) {
    let r = this._postprocess(t9, this._utils);
    if (r !== ge2) {
      if (r.delete)
        for (let n of r.delete)
          delete t9[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
        for (let o of n) {
          let i2 = r.override[o];
          this._applyValidation(i2, o, this._utils.schemas[o]), t9[o] = i2;
        }
        for (let o of u) {
          let i2 = r.override[o];
          this._applyUnknownHandler(o, i2, t9, (s, a) => {
            let c = this._utils.schemas[s];
            this._applyValidation(a, s, c), t9[s] = a;
          });
        }
      }
    }
  }
}, Ut2, kn2, mo = (e, t9, r) => {
  if (!(e && t9 == null)) {
    if (t9.findLast)
      return t9.findLast(r);
    for (let n = t9.length - 1;n >= 0; n--) {
      let u = t9[n];
      if (r(u, n, t9))
        return u;
    }
  }
}, Vt2, Nn2, ne3, vn2, De2, In2, Kt2, Yn2, bo = (e, t9, r) => {
  if (!(e && t9 == null)) {
    if (t9.findLastIndex)
      return t9.findLastIndex(r);
    for (let n = t9.length - 1;n >= 0; n--) {
      let u = t9[n];
      if (r(u, n, t9))
        return n;
    }
    return -1;
  }
}, jn2, ko = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify", $n2, Oo2, zn2 = "\uFEFF", Mn2, qt2, Io2, Ro2, Yo2, tu2 = "3.6.2", Qt2, ye, Ae2, je2, ct2, ru2, nu2, uu2, ft2 = "'", ou2 = '"', iu2, su2, au2, Du, cu, ni2, ui;
var init_standalone = __esm(() => {
  Fu = Object.create;
  pt2 = Object.defineProperty;
  pu = Object.getOwnPropertyDescriptor;
  du = Object.getOwnPropertyNames;
  mu = Object.getPrototypeOf;
  Eu = Object.prototype.hasOwnProperty;
  Pn2 = Cu((Mt2) => {
    Object.defineProperty(Mt2, "__esModule", { value: true });
    function Co() {
      return new Proxy({}, { get: () => (e) => e });
    }
    var On2 = /\r\n|[\n\r\u2028\u2029]/;
    function ho2(e, t9, r) {
      let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: o = 2, linesBelow: i2 = 3 } = r || {}, s = n.line, a = n.column, c = u.line, D = u.column, p = Math.max(s - (o + 1), 0), l2 = Math.min(t9.length, c + i2);
      s === -1 && (p = 0), c === -1 && (l2 = t9.length);
      let F = c - s, f = {};
      if (F)
        for (let d2 = 0;d2 <= F; d2++) {
          let m = d2 + s;
          if (!a)
            f[m] = true;
          else if (d2 === 0) {
            let C = t9[m - 1].length;
            f[m] = [a, C - a + 1];
          } else if (d2 === F)
            f[m] = [0, D];
          else {
            let C = t9[m - d2].length;
            f[m] = [0, C];
          }
        }
      else
        a === D ? a ? f[s] = [a, 0] : f[s] = true : f[s] = [a, D - a];
      return { start: p, end: l2, markerLines: f };
    }
    function go2(e, t9, r = {}) {
      let u = Co(false), o = e.split(On2), { start: i2, end: s, markerLines: a } = ho2(t9, o, r), c = t9.start && typeof t9.start.column == "number", D = String(s).length, l2 = e.split(On2, s).slice(i2, s).map((F, f) => {
        let d2 = i2 + 1 + f, C = ` ${` ${d2}`.slice(-D)} |`, E2 = a[d2], h2 = !a[d2 + 1];
        if (E2) {
          let x2 = "";
          if (Array.isArray(E2)) {
            let A = F.slice(0, Math.max(E2[0] - 1, 0)).replace(/[^\t]/g, " "), $3 = E2[1] || 1;
            x2 = [`
 `, u.gutter(C.replace(/\d/g, " ")), " ", A, u.marker("^").repeat($3)].join(""), h2 && r.message && (x2 += " " + u.message(r.message));
          }
          return [u.marker(">"), u.gutter(C), F.length > 0 ? ` ${F}` : "", x2].join("");
        } else
          return ` ${u.gutter(C)}${F.length > 0 ? ` ${F}` : ""}`;
      }).join(`
`);
      return r.message && !c && (l2 = `${" ".repeat(D + 1)}${r.message}
${l2}`), l2;
    }
    Mt2.codeFrameColumns = go2;
  });
  Zt = {};
  dt(Zt, { __debug: () => ui, check: () => ri2, doc: () => qt2, format: () => fu, formatWithCursor: () => cu, getSupportInfo: () => ni2, util: () => Qt2, version: () => tu2 });
  te = Au;
  mt2 = class extends _e2 {
    tokenize(t9) {
      return t9.slice();
    }
    join(t9) {
      return t9;
    }
    removeEmpty(t9) {
      return t9;
    }
  };
  rr2 = new mt2;
  Ue2 = new Set([j2, N2, O2, P2, B2, k3, _3, v2, L2, I, g, S2, w2]);
  y = Bu;
  M = _u;
  ht2 = class extends Error {
    name = "InvalidDocError";
    constructor(t9) {
      super(wu(t9)), this.doc = t9;
    }
  };
  q = ht2;
  ir2 = {};
  le2 = bu;
  K2 = gt3;
  yt2 = gt3;
  pr2 = gt3;
  Ar2 = { type: I };
  pe2 = { type: w2 };
  Br2 = { type: P2 };
  Te2 = { type: g, hard: true };
  Bt2 = { type: g, hard: true, literal: true };
  Me2 = { type: g };
  _r2 = { type: g, soft: true };
  z2 = [Te2, pe2];
  We = [Bt2, pe2];
  X2 = { type: j2 };
  Pu = /[^\x20-\x7F]/u;
  Ne2 = vu;
  R2 = Symbol("MODE_BREAK");
  H2 = Symbol("MODE_FLAT");
  de2 = Symbol("cursor");
  _t2 = Symbol("DOC_FILL_PRINTED_LENGTH");
  Ee2 = Ru;
  Z2 = new WeakSet, kt2 = function(t9) {
    let { stack: r } = this;
    for (let n = r.length - 1;n >= 0; n -= 2)
      if (!Array.isArray(r[n]) && --t9 < 0)
        return n;
    return -1;
  }, ze2 = function* () {
    let { stack: t9 } = this;
    for (let r = t9.length - 3;r >= 0; r -= 2) {
      let n = t9[r];
      Array.isArray(n) || (yield n);
    }
  };
  Or4 = bt2;
  Pr2 = new Proxy(() => {}, { get: () => Pr2 });
  Oe2 = Pr2;
  vr2 = Yu;
  Rr2 = he2(/\s/u);
  T3 = he2(" 	");
  He2 = he2(",; 	");
  Je2 = he2(/[^\n\r]/u);
  U = ju;
  G2 = Uu;
  qe2 = Vu;
  Yr = new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
  J2 = Wu;
  Tt2 = new WeakMap;
  Pe2 = zu;
  Kr2 = Xu;
  ve2 = class extends Error {
    name = "ConfigError";
  };
  Le2 = class extends Error {
    name = "UndefinedParserError";
  };
  zr = { checkIgnorePragma: { category: "Special", type: "boolean", default: false, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: "Other" }, cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: undefined, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }, { value: "mjml", description: "MJML" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  Hr = eo2;
  to2 = ((Jr2 = globalThis.Deno) == null ? undefined : Jr2.build.os) === "windows" || ((Xr2 = (qr = globalThis.navigator) == null ? undefined : qr.platform) == null ? undefined : Xr2.startsWith("Win")) || ((Zr2 = (Qr2 = globalThis.process) == null ? undefined : Qr2.platform) == null ? undefined : Zr2.startsWith("win")) || false;
  rn2 = tn2;
  on2 = io2;
  re2 = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
    if (e === null || typeof e != "object")
      return JSON.stringify(e);
    if (Array.isArray(e))
      return `[${e.map((r) => re2.value(r)).join(", ")}]`;
    let t9 = Object.keys(e);
    return t9.length === 0 ? "{}" : `{ ${t9.map((r) => `${re2.key(r)}: ${re2.value(e[r])}`).join(", ")} }`;
  }, pair: ({ key: e, value: t9 }) => re2.value({ [e]: t9 }) };
  sn = new Proxy(String, { get: () => sn });
  V2 = sn;
  Ze2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
  ge2 = Symbol.for("vnopts.VALUE_UNCHANGED");
  Dn2 = " ".repeat(2);
  Pt2 = [];
  pn2 = [];
  so2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  tt2 = class extends b4 {
    constructor(t9) {
      super(t9), this._sourceName = t9.sourceName;
    }
    expected(t9) {
      return t9.schemas[this._sourceName].expected(t9);
    }
    validate(t9, r) {
      return r.schemas[this._sourceName].validate(t9, r);
    }
    redirect(t9, r) {
      return this._sourceName;
    }
  };
  rt2 = class extends b4 {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  };
  nt2 = class extends b4 {
    constructor({ valueSchema: t9, name: r = t9.name, ...n }) {
      super({ ...n, name: r }), this._valueSchema = t9;
    }
    expected(t9) {
      let { text: r, list: n } = t9.normalizeExpectedResult(this._valueSchema.expected(t9));
      return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
    }
    validate(t9, r) {
      if (!Array.isArray(t9))
        return false;
      let n = [];
      for (let u of t9) {
        let o = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
        o !== true && n.push(o.value);
      }
      return n.length === 0 ? true : { value: n };
    }
    deprecated(t9, r) {
      let n = [];
      for (let u of t9) {
        let o = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
        o !== false && n.push(...o.map(({ value: i2 }) => ({ value: [i2] })));
      }
      return n;
    }
    forward(t9, r) {
      let n = [];
      for (let u of t9) {
        let o = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
        n.push(...o.map(dn2));
      }
      return n;
    }
    redirect(t9, r) {
      let n = [], u = [];
      for (let o of t9) {
        let i2 = r.normalizeRedirectResult(this._valueSchema.redirect(o, r), o);
        "remain" in i2 && n.push(i2.remain), u.push(...i2.redirect.map(dn2));
      }
      return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
    }
    overlap(t9, r) {
      return t9.concat(r);
    }
  };
  ut2 = class extends b4 {
    expected() {
      return "true or false";
    }
    validate(t9) {
      return typeof t9 == "boolean";
    }
  };
  it2 = class extends b4 {
    constructor(t9) {
      super(t9), this._choices = Cn2(t9.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
    }
    expected({ descriptor: t9 }) {
      let r = Array.from(this._choices.keys()).map((i2) => this._choices.get(i2)).filter(({ hidden: i2 }) => !i2).map((i2) => i2.value).sort(An2).map(t9.value), n = r.slice(0, -2), u = r.slice(-2);
      return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
    }
    validate(t9) {
      return this._choices.has(t9);
    }
    deprecated(t9) {
      let r = this._choices.get(t9);
      return r && r.deprecated ? { value: t9 } : false;
    }
    forward(t9) {
      let r = this._choices.get(t9);
      return r ? r.forward : undefined;
    }
    redirect(t9) {
      let r = this._choices.get(t9);
      return r ? r.redirect : undefined;
    }
  };
  st2 = class extends b4 {
    expected() {
      return "a number";
    }
    validate(t9, r) {
      return typeof t9 == "number";
    }
  };
  at2 = class extends st2 {
    expected() {
      return "an integer";
    }
    validate(t9, r) {
      return r.normalizeValidateResult(super.validate(t9, r), t9) === true && yn2(t9);
    }
  };
  Ie2 = class extends b4 {
    expected() {
      return "a string";
    }
    validate(t9) {
      return typeof t9 == "string";
    }
  };
  _n2 = re2;
  xn2 = et3;
  wn2 = fn2;
  bn2 = an;
  kn2 = lo2;
  Vt2 = mo;
  Nn2 = { astFormat: "estree", printer: {}, originalText: undefined, locStart: null, locEnd: null };
  ne3 = Eo;
  vn2 = gu(Pn2(), 1);
  De2 = yo;
  In2 = _o;
  Kt2 = xo;
  Yn2 = wo;
  jn2 = bo;
  $n2 = new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
  Oo2 = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  Mn2 = Symbol("cursor");
  qt2 = {};
  dt(qt2, { builders: () => Io2, printer: () => Ro2, utils: () => Yo2 });
  Io2 = { join: ke2, line: Me2, softline: _r2, hardline: z2, literalline: We, group: At2, conditionalGroup: Cr2, fill: hr2, lineSuffix: Se2, lineSuffixBoundary: Ar2, cursor: X2, breakParent: pe2, ifBreak: gr2, trim: Br2, indent: ie2, indentIfBreak: yr2, align: oe, addAlignmentToDoc: Ge3, markAsRoot: mr2, dedentToRoot: dr2, dedent: Er2, hardlineWithoutBreakParent: Te2, literallineWithoutBreakParent: Bt2, label: xr2, concat: (e) => e };
  Ro2 = { printDocToString: me2 };
  Yo2 = { willBreak: Dr2, traverseDoc: le2, findInDoc: Ve2, mapDoc: be2, removeLines: fr2, stripTrailingHardline: $e, replaceEndOfLine: lr2, canBreak: Fr2 };
  Qt2 = {};
  dt(Qt2, { addDanglingComment: () => ee2, addLeadingComment: () => se2, addTrailingComment: () => ae2, getAlignmentSize: () => Ee2, getIndentSize: () => ru2, getMaxContinuousCount: () => nu2, getNextNonSpaceNonCommentCharacter: () => uu2, getNextNonSpaceNonCommentCharacterIndex: () => Xo2, getPreferredQuote: () => iu2, getStringWidth: () => Ne2, hasNewline: () => G2, hasNewlineInRange: () => su2, hasSpaces: () => au2, isNextLineEmpty: () => ti2, isNextLineEmptyAfterIndex: () => ct2, isPreviousLineEmpty: () => Zo2, makeString: () => Du, skip: () => he2, skipEverythingButNewLine: () => Je2, skipInlineComment: () => ye, skipNewline: () => U, skipSpaces: () => T3, skipToLineEnd: () => He2, skipTrailingComment: () => Ae2, skipWhitespace: () => Rr2 });
  ye = jo2;
  Ae2 = Uo2;
  je2 = Vo2;
  ct2 = $o2;
  ru2 = Wo2;
  nu2 = Mo2;
  uu2 = Go2;
  iu2 = Ko2;
  su2 = zo2;
  au2 = Ho2;
  Du = Jo2;
  cu = ce2(Jt);
  ni2 = ce2(Qe2, 0);
  ui = { parse: ce2(qn2), formatAST: ce2(Xn2), formatDoc: ce2(Qn2), printToDoc: ce2(Zn2), printDocToString: ce2(eu2) };
});

// node_modules/domelementtype/lib/esm/index.js
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var ElementType, Root, Text, Directive, Comment, Script, Style, Tag, CDATA, Doctype;
var init_esm2 = __esm(() => {
  (function(ElementType2) {
    ElementType2["Root"] = "root";
    ElementType2["Text"] = "text";
    ElementType2["Directive"] = "directive";
    ElementType2["Comment"] = "comment";
    ElementType2["Script"] = "script";
    ElementType2["Style"] = "style";
    ElementType2["Tag"] = "tag";
    ElementType2["CDATA"] = "cdata";
    ElementType2["Doctype"] = "doctype";
  })(ElementType || (ElementType = {}));
  Root = ElementType.Root;
  Text = ElementType.Text;
  Directive = ElementType.Directive;
  Comment = ElementType.Comment;
  Script = ElementType.Script;
  Style = ElementType.Style;
  Tag = ElementType.Tag;
  CDATA = ElementType.CDATA;
  Doctype = ElementType.Doctype;
});

// node_modules/domhandler/lib/esm/node.js
class Node {
  constructor() {
    this.parent = null;
    this.prev = null;
    this.next = null;
    this.startIndex = null;
    this.endIndex = null;
  }
  get parentNode() {
    return this.parent;
  }
  set parentNode(parent) {
    this.parent = parent;
  }
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(prev) {
    this.prev = prev;
  }
  get nextSibling() {
    return this.next;
  }
  set nextSibling(next) {
    this.next = next;
  }
  cloneNode(recursive = false) {
    return cloneNode(this, recursive);
  }
}
function isTag2(node) {
  return isTag(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDirective(node) {
  return node.type === ElementType.Directive;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function cloneNode(node, recursive = false) {
  let result;
  if (isText(node)) {
    result = new Text2(node.data);
  } else if (isComment(node)) {
    result = new Comment2(node.data);
  } else if (isTag2(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone3 = new Element(node.name, { ...node.attribs }, children);
    children.forEach((child) => child.parent = clone3);
    if (node.namespace != null) {
      clone3.namespace = node.namespace;
    }
    if (node["x-attribsNamespace"]) {
      clone3["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
    }
    if (node["x-attribsPrefix"]) {
      clone3["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
    }
    result = clone3;
  } else if (isCDATA(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone3 = new CDATA2(children);
    children.forEach((child) => child.parent = clone3);
    result = clone3;
  } else if (isDocument(node)) {
    const children = recursive ? cloneChildren(node.children) : [];
    const clone3 = new Document(children);
    children.forEach((child) => child.parent = clone3);
    if (node["x-mode"]) {
      clone3["x-mode"] = node["x-mode"];
    }
    result = clone3;
  } else if (isDirective(node)) {
    const instruction = new ProcessingInstruction(node.name, node.data);
    if (node["x-name"] != null) {
      instruction["x-name"] = node["x-name"];
      instruction["x-publicId"] = node["x-publicId"];
      instruction["x-systemId"] = node["x-systemId"];
    }
    result = instruction;
  } else {
    throw new Error(`Not implemented yet: ${node.type}`);
  }
  result.startIndex = node.startIndex;
  result.endIndex = node.endIndex;
  if (node.sourceCodeLocation != null) {
    result.sourceCodeLocation = node.sourceCodeLocation;
  }
  return result;
}
function cloneChildren(childs) {
  const children = childs.map((child) => cloneNode(child, true));
  for (let i2 = 1;i2 < children.length; i2++) {
    children[i2].prev = children[i2 - 1];
    children[i2 - 1].next = children[i2];
  }
  return children;
}
var DataNode, Text2, Comment2, ProcessingInstruction, NodeWithChildren, CDATA2, Document, Element;
var init_node = __esm(() => {
  init_esm2();
  DataNode = class DataNode extends Node {
    constructor(data) {
      super();
      this.data = data;
    }
    get nodeValue() {
      return this.data;
    }
    set nodeValue(data) {
      this.data = data;
    }
  };
  Text2 = class Text2 extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Text;
    }
    get nodeType() {
      return 3;
    }
  };
  Comment2 = class Comment2 extends DataNode {
    constructor() {
      super(...arguments);
      this.type = ElementType.Comment;
    }
    get nodeType() {
      return 8;
    }
  };
  ProcessingInstruction = class ProcessingInstruction extends DataNode {
    constructor(name, data) {
      super(data);
      this.name = name;
      this.type = ElementType.Directive;
    }
    get nodeType() {
      return 1;
    }
  };
  NodeWithChildren = class NodeWithChildren extends Node {
    constructor(children) {
      super();
      this.children = children;
    }
    get firstChild() {
      var _a3;
      return (_a3 = this.children[0]) !== null && _a3 !== undefined ? _a3 : null;
    }
    get lastChild() {
      return this.children.length > 0 ? this.children[this.children.length - 1] : null;
    }
    get childNodes() {
      return this.children;
    }
    set childNodes(children) {
      this.children = children;
    }
  };
  CDATA2 = class CDATA2 extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.CDATA;
    }
    get nodeType() {
      return 4;
    }
  };
  Document = class Document extends NodeWithChildren {
    constructor() {
      super(...arguments);
      this.type = ElementType.Root;
    }
    get nodeType() {
      return 9;
    }
  };
  Element = class Element extends NodeWithChildren {
    constructor(name, attribs, children = [], type = name === "script" ? ElementType.Script : name === "style" ? ElementType.Style : ElementType.Tag) {
      super(children);
      this.name = name;
      this.attribs = attribs;
      this.type = type;
    }
    get nodeType() {
      return 1;
    }
    get tagName() {
      return this.name;
    }
    set tagName(name) {
      this.name = name;
    }
    get attributes() {
      return Object.keys(this.attribs).map((name) => {
        var _a3, _b2;
        return {
          name,
          value: this.attribs[name],
          namespace: (_a3 = this["x-attribsNamespace"]) === null || _a3 === undefined ? undefined : _a3[name],
          prefix: (_b2 = this["x-attribsPrefix"]) === null || _b2 === undefined ? undefined : _b2[name]
        };
      });
    }
  };
});

// node_modules/domhandler/lib/esm/index.js
class DomHandler {
  constructor(callback, options, elementCB) {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
    if (typeof options === "function") {
      elementCB = options;
      options = defaultOpts;
    }
    if (typeof callback === "object") {
      options = callback;
      callback = undefined;
    }
    this.callback = callback !== null && callback !== undefined ? callback : null;
    this.options = options !== null && options !== undefined ? options : defaultOpts;
    this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
  }
  onparserinit(parser) {
    this.parser = parser;
  }
  onreset() {
    this.dom = [];
    this.root = new Document(this.dom);
    this.done = false;
    this.tagStack = [this.root];
    this.lastNode = null;
    this.parser = null;
  }
  onend() {
    if (this.done)
      return;
    this.done = true;
    this.parser = null;
    this.handleCallback(null);
  }
  onerror(error40) {
    this.handleCallback(error40);
  }
  onclosetag() {
    this.lastNode = null;
    const elem = this.tagStack.pop();
    if (this.options.withEndIndices) {
      elem.endIndex = this.parser.endIndex;
    }
    if (this.elementCB)
      this.elementCB(elem);
  }
  onopentag(name, attribs) {
    const type = this.options.xmlMode ? ElementType.Tag : undefined;
    const element = new Element(name, attribs, undefined, type);
    this.addNode(element);
    this.tagStack.push(element);
  }
  ontext(data) {
    const { lastNode } = this;
    if (lastNode && lastNode.type === ElementType.Text) {
      lastNode.data += data;
      if (this.options.withEndIndices) {
        lastNode.endIndex = this.parser.endIndex;
      }
    } else {
      const node2 = new Text2(data);
      this.addNode(node2);
      this.lastNode = node2;
    }
  }
  oncomment(data) {
    if (this.lastNode && this.lastNode.type === ElementType.Comment) {
      this.lastNode.data += data;
      return;
    }
    const node2 = new Comment2(data);
    this.addNode(node2);
    this.lastNode = node2;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const text2 = new Text2("");
    const node2 = new CDATA2([text2]);
    this.addNode(node2);
    text2.parent = node2;
    this.lastNode = text2;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(name, data) {
    const node2 = new ProcessingInstruction(name, data);
    this.addNode(node2);
  }
  handleCallback(error40) {
    if (typeof this.callback === "function") {
      this.callback(error40, this.dom);
    } else if (error40) {
      throw error40;
    }
  }
  addNode(node2) {
    const parent = this.tagStack[this.tagStack.length - 1];
    const previousSibling = parent.children[parent.children.length - 1];
    if (this.options.withStartIndices) {
      node2.startIndex = this.parser.startIndex;
    }
    if (this.options.withEndIndices) {
      node2.endIndex = this.parser.endIndex;
    }
    parent.children.push(node2);
    if (previousSibling) {
      node2.prev = previousSibling;
      previousSibling.next = node2;
    }
    node2.parent = parent;
    this.lastNode = null;
  }
}
var defaultOpts;
var init_esm3 = __esm(() => {
  init_esm2();
  init_node();
  init_node();
  defaultOpts = {
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false
  };
});

// node_modules/leac/lib/leac.mjs
function n(n2) {
  const o = [...n2.matchAll(e)].map((e2) => e2.index || 0);
  o.unshift(-1);
  const s = t9(o, 0, o.length);
  return (e2) => r(s, e2);
}
function t9(e2, n2, r) {
  if (r - n2 == 1)
    return { offset: e2[n2], index: n2 + 1 };
  const o = Math.ceil((n2 + r) / 2), s = t9(e2, n2, o), l2 = t9(e2, o, r);
  return { offset: s.offset, low: s, high: l2 };
}
function r(e2, n2) {
  return function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "index");
  }(e2) ? { line: e2.index, column: n2 - e2.offset } : r(e2.high.offset < n2 ? e2.high : e2.low, n2);
}
function o(e2, t10 = "", r2 = {}) {
  const o2 = typeof t10 != "string" ? t10 : r2, l2 = typeof t10 == "string" ? t10 : "", c = e2.map(s), f = !!o2.lineNumbers;
  return function(e3, t11 = 0) {
    const r3 = f ? n(e3) : () => ({ line: 0, column: 0 });
    let o3 = t11;
    const s = [];
    e:
      for (;o3 < e3.length; ) {
        let n2 = false;
        for (const t12 of c) {
          t12.regex.lastIndex = o3;
          const c2 = t12.regex.exec(e3);
          if (c2 && c2[0].length > 0) {
            if (!t12.discard) {
              const e4 = r3(o3), n3 = typeof t12.replace == "string" ? c2[0].replace(new RegExp(t12.regex.source, t12.regex.flags), t12.replace) : c2[0];
              s.push({ state: l2, name: t12.name, text: n3, offset: o3, len: c2[0].length, line: e4.line, column: e4.column });
            }
            if (o3 = t12.regex.lastIndex, n2 = true, t12.push) {
              const n3 = t12.push(e3, o3);
              s.push(...n3.tokens), o3 = n3.offset;
            }
            if (t12.pop)
              break e;
            break;
          }
        }
        if (!n2)
          break;
      }
    return { tokens: s, offset: o3, complete: e3.length <= o3 };
  };
}
function s(e2, n2) {
  return { ...e2, regex: l2(e2, n2) };
}
function l2(e2, n2) {
  if (e2.name.length === 0)
    throw new Error(`Rule #${n2} has empty name, which is not allowed.`);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "regex");
  }(e2))
    return function(e3) {
      if (e3.global)
        throw new Error(`Regular expression /${e3.source}/${e3.flags} contains the global flag, which is not allowed.`);
      return e3.sticky ? e3 : new RegExp(e3.source, e3.flags + "y");
    }(e2.regex);
  if (function(e3) {
    return Object.prototype.hasOwnProperty.call(e3, "str");
  }(e2)) {
    if (e2.str.length === 0)
      throw new Error(`Rule #${n2} ("${e2.name}") has empty "str" property, which is not allowed.`);
    return new RegExp(c(e2.str), "y");
  }
  return new RegExp(c(e2.name), "y");
}
function c(e2) {
  return e2.replace(/[-[\]{}()*+!<=:?./\\^$|#\s,]/g, "\\$&");
}
var e;
var init_leac = __esm(() => {
  e = /\n/g;
});

// node_modules/peberminta/lib/core.mjs
function token(onToken, onEnd) {
  return (data, i2) => {
    let position = i2;
    let value = undefined;
    if (i2 < data.tokens.length) {
      value = onToken(data.tokens[i2], data, i2);
      if (value !== undefined) {
        position++;
      }
    } else {
      onEnd?.(data, i2);
    }
    return value === undefined ? { matched: false } : {
      matched: true,
      position,
      value
    };
  };
}
function mapInner(r2, f) {
  return r2.matched ? {
    matched: true,
    position: r2.position,
    value: f(r2.value, r2.position)
  } : r2;
}
function mapOuter(r2, f) {
  return r2.matched ? f(r2) : r2;
}
function map4(p, mapper) {
  return (data, i2) => mapInner(p(data, i2), (v3, j3) => mapper(v3, data, i2, j3));
}
function option(p, def) {
  return (data, i2) => {
    const r2 = p(data, i2);
    return r2.matched ? r2 : {
      matched: true,
      position: i2,
      value: def
    };
  };
}
function choice(...ps2) {
  return (data, i2) => {
    for (const p of ps2) {
      const result = p(data, i2);
      if (result.matched) {
        return result;
      }
    }
    return { matched: false };
  };
}
function otherwise(pa2, pb) {
  return (data, i2) => {
    const r1 = pa2(data, i2);
    return r1.matched ? r1 : pb(data, i2);
  };
}
function takeWhile(p, test) {
  return (data, i2) => {
    const values2 = [];
    let success2 = true;
    do {
      const r2 = p(data, i2);
      if (r2.matched && test(r2.value, values2.length + 1, data, i2, r2.position)) {
        values2.push(r2.value);
        i2 = r2.position;
      } else {
        success2 = false;
      }
    } while (success2);
    return {
      matched: true,
      position: i2,
      value: values2
    };
  };
}
function many(p) {
  return takeWhile(p, () => true);
}
function many1(p) {
  return ab(p, many(p), (head, tail) => [head, ...tail]);
}
function ab(pa2, pb, join) {
  return (data, i2) => mapOuter(pa2(data, i2), (ma2) => mapInner(pb(data, ma2.position), (vb, j3) => join(ma2.value, vb, data, i2, j3)));
}
function left(pa2, pb) {
  return ab(pa2, pb, (va2) => va2);
}
function right(pa2, pb) {
  return ab(pa2, pb, (va2, vb) => vb);
}
function abc(pa2, pb, pc, join) {
  return (data, i2) => mapOuter(pa2(data, i2), (ma2) => mapOuter(pb(data, ma2.position), (mb) => mapInner(pc(data, mb.position), (vc, j3) => join(ma2.value, mb.value, vc, data, i2, j3))));
}
function middle(pa2, pb, pc) {
  return abc(pa2, pb, pc, (ra2, rb) => rb);
}
function all(...ps2) {
  return (data, i2) => {
    const result = [];
    let position = i2;
    for (const p of ps2) {
      const r1 = p(data, position);
      if (r1.matched) {
        result.push(r1.value);
        position = r1.position;
      } else {
        return { matched: false };
      }
    }
    return {
      matched: true,
      position,
      value: result
    };
  };
}
function flatten(...ps2) {
  return flatten1(all(...ps2));
}
function flatten1(p) {
  return map4(p, (vs2) => vs2.flatMap((v3) => v3));
}
function chainReduce(acc, f) {
  return (data, i2) => {
    let loop = true;
    let acc1 = acc;
    let pos = i2;
    do {
      const r2 = f(acc1, data, pos)(data, pos);
      if (r2.matched) {
        acc1 = r2.value;
        pos = r2.position;
      } else {
        loop = false;
      }
    } while (loop);
    return {
      matched: true,
      position: pos,
      value: acc1
    };
  };
}
function reduceLeft(acc, p, reducer) {
  return chainReduce(acc, (acc2) => map4(p, (v3, data, i2, j3) => reducer(acc2, v3, data, i2, j3)));
}
function leftAssoc2(pLeft, pOper, pRight) {
  return chain(pLeft, (v0) => reduceLeft(v0, ab(pOper, pRight, (f, y2) => [f, y2]), (acc, [f, y2]) => f(acc, y2)));
}
function chain(p, f) {
  return (data, i2) => mapOuter(p(data, i2), (m1) => f(m1.value, data, i2, m1.position)(data, m1.position));
}
var init_core3 = () => {};

// node_modules/parseley/lib/parseley.mjs
function sumSpec([a0, a1, a2], [b0, b1, b22]) {
  return [a0 + b0, a1 + b1, a2 + b22];
}
function sumAllSpec(ss2) {
  return ss2.reduce(sumSpec, [0, 0, 0]);
}
function unescape2(escapedString) {
  const lexerResult = lexEscapedString(escapedString);
  const result = escapedString_({ tokens: lexerResult.tokens, options: undefined }, 0);
  return result.value;
}
function literal2(name2) {
  return token((t10) => t10.name === name2 ? true : undefined);
}
function optionallySpaced(parser) {
  return middle(optionalWhitespace_, parser, optionalWhitespace_);
}
function parse_(parser, str) {
  if (!(typeof str === "string" || str instanceof String)) {
    throw new Error("Expected a selector string. Actual input is not a string!");
  }
  const lexerResult = lexSelector(str);
  if (!lexerResult.complete) {
    throw new Error(`The input "${str}" was only partially tokenized, stopped at offset ${lexerResult.offset}!
` + prettyPrintPosition(str, lexerResult.offset));
  }
  const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);
  if (!result.matched) {
    throw new Error(`No match for "${str}" input!`);
  }
  if (result.position < lexerResult.tokens.length) {
    const token2 = lexerResult.tokens[result.position];
    throw new Error(`The input "${str}" was only partially parsed, stopped at offset ${token2.offset}!
` + prettyPrintPosition(str, token2.offset, token2.len));
  }
  return result.value;
}
function prettyPrintPosition(str, offset, len = 1) {
  return `${str.replace(/(\t)|(\r)|(\n)/g, (m, t10, r2) => t10 ? "\u2409" : r2 ? "\u240D" : "\u240A")}
${"".padEnd(offset)}${"^".repeat(len)}`;
}
function parse1(str) {
  return parse_(complexSelector_, str);
}
function serialize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "universal":
      return _serNs(selector.namespace) + "*";
    case "tag":
      return _serNs(selector.namespace) + _serIdent(selector.name);
    case "class":
      return "." + _serIdent(selector.name);
    case "id":
      return "#" + _serIdent(selector.name);
    case "attrPresence":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}]`;
    case "attrValue":
      return `[${_serNs(selector.namespace)}${_serIdent(selector.name)}${selector.matcher}"${_serStr(selector.value)}"${selector.modifier ? selector.modifier : ""}]`;
    case "combinator":
      return serialize(selector.left) + selector.combinator;
    case "compound":
      return selector.list.reduce((acc, node2) => {
        if (node2.type === "combinator") {
          return serialize(node2) + acc;
        } else {
          return acc + serialize(node2);
        }
      }, "");
    case "list":
      return selector.list.map(serialize).join(",");
  }
}
function _serNs(ns2) {
  return ns2 || ns2 === "" ? _serIdent(ns2) + "|" : "";
}
function _codePoint(char2) {
  return `\\${char2.codePointAt(0).toString(16)} `;
}
function _serIdent(str) {
  return str.replace(/(^[0-9])|(^-[0-9])|(^-$)|([-0-9a-zA-Z_]|[^\x00-\x7F])|(\x00)|([\x01-\x1f]|\x7f)|([\s\S])/g, (m, d1, d2, hy, safe, nl2, ctrl, other) => d1 ? _codePoint(d1) : d2 ? "-" + _codePoint(d2.slice(1)) : hy ? "\\-" : safe ? safe : nl2 ? "\uFFFD" : ctrl ? _codePoint(ctrl) : "\\" + other);
}
function _serStr(str) {
  return str.replace(/(")|(\\)|(\x00)|([\x01-\x1f]|\x7f)/g, (m, dq, bs2, nl2, ctrl) => dq ? "\\\"" : bs2 ? "\\\\" : nl2 ? "\uFFFD" : _codePoint(ctrl));
}
function normalize(selector) {
  if (!selector.type) {
    throw new Error("This is not an AST node.");
  }
  switch (selector.type) {
    case "compound": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b5) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b5)));
      break;
    }
    case "combinator": {
      normalize(selector.left);
      break;
    }
    case "list": {
      selector.list.forEach(normalize);
      selector.list.sort((a, b5) => serialize(a) < serialize(b5) ? -1 : 1);
      break;
    }
  }
  return selector;
}
function _getSelectorPriority(selector) {
  switch (selector.type) {
    case "universal":
      return [1];
    case "tag":
      return [1];
    case "id":
      return [2];
    case "class":
      return [3, selector.name];
    case "attrPresence":
      return [4, serialize(selector)];
    case "attrValue":
      return [5, serialize(selector)];
    case "combinator":
      return [15, serialize(selector)];
  }
}
function compareSpecificity(a, b5) {
  return _compareArrays(a, b5);
}
function _compareArrays(a, b5) {
  if (!Array.isArray(a) || !Array.isArray(b5)) {
    throw new Error("Arguments must be arrays.");
  }
  const shorter = a.length < b5.length ? a.length : b5.length;
  for (let i2 = 0;i2 < shorter; i2++) {
    if (a[i2] === b5[i2]) {
      continue;
    }
    return a[i2] < b5[i2] ? -1 : 1;
  }
  return a.length - b5.length;
}
var ws2 = `(?:[ \\t\\r\\n\\f]*)`, nl = `(?:\\n|\\r\\n|\\r|\\f)`, nonascii = `[^\\x00-\\x7F]`, unicode = `(?:\\\\[0-9a-f]{1,6}(?:\\r\\n|[ \\n\\r\\t\\f])?)`, escape2 = `(?:\\\\[^\\n\\r\\f0-9a-f])`, nmstart, nmchar, name, ident, string1, string22, lexSelector, lexEscapedString, unicodeEscapedSequence_, escapedSequence_, anyChar_, escapedString_, whitespace_, optionalWhitespace_, identifier_, hashId_, string_, namespace_, qualifiedName_, uniSelector_, tagSelector_, classSelector_, idSelector_, attrModifier_, attrValue_, attrMatcher_, attrPresenceSelector_, attrValueSelector_, attrSelector_, typeSelector_, subclassSelector_, compoundSelector_, combinator_, combinatorSeparator_, complexSelector_, listSelector_;
var init_parseley = __esm(() => {
  init_leac();
  init_core3();
  nmstart = `(?:[_a-z]|${nonascii}|${unicode}|${escape2})`;
  nmchar = `(?:[_a-z0-9-]|${nonascii}|${unicode}|${escape2})`;
  name = `(?:${nmchar}+)`;
  ident = `(?:[-]?${nmstart}${nmchar}*)`;
  string1 = `'([^\\n\\r\\f\\\\']|\\\\${nl}|${nonascii}|${unicode}|${escape2})*'`;
  string22 = `"([^\\n\\r\\f\\\\"]|\\\\${nl}|${nonascii}|${unicode}|${escape2})*"`;
  lexSelector = o([
    { name: "ws", regex: new RegExp(ws2) },
    { name: "hash", regex: new RegExp(`#${name}`, "i") },
    { name: "ident", regex: new RegExp(ident, "i") },
    { name: "str1", regex: new RegExp(string1, "i") },
    { name: "str2", regex: new RegExp(string22, "i") },
    { name: "*" },
    { name: "." },
    { name: "," },
    { name: "[" },
    { name: "]" },
    { name: "=" },
    { name: ">" },
    { name: "|" },
    { name: "+" },
    { name: "~" },
    { name: "^" },
    { name: "$" }
  ]);
  lexEscapedString = o([
    { name: "unicode", regex: new RegExp(unicode, "i") },
    { name: "escape", regex: new RegExp(escape2, "i") },
    { name: "any", regex: new RegExp("[\\s\\S]", "i") }
  ]);
  unicodeEscapedSequence_ = token((t10) => t10.name === "unicode" ? String.fromCodePoint(parseInt(t10.text.slice(1), 16)) : undefined);
  escapedSequence_ = token((t10) => t10.name === "escape" ? t10.text.slice(1) : undefined);
  anyChar_ = token((t10) => t10.name === "any" ? t10.text : undefined);
  escapedString_ = map4(many(choice(unicodeEscapedSequence_, escapedSequence_, anyChar_)), (cs2) => cs2.join(""));
  whitespace_ = token((t10) => t10.name === "ws" ? null : undefined);
  optionalWhitespace_ = option(whitespace_, null);
  identifier_ = token((t10) => t10.name === "ident" ? unescape2(t10.text) : undefined);
  hashId_ = token((t10) => t10.name === "hash" ? unescape2(t10.text.slice(1)) : undefined);
  string_ = token((t10) => t10.name.startsWith("str") ? unescape2(t10.text.slice(1, -1)) : undefined);
  namespace_ = left(option(identifier_, ""), literal2("|"));
  qualifiedName_ = otherwise(ab(namespace_, identifier_, (ns2, name2) => ({ name: name2, namespace: ns2 })), map4(identifier_, (name2) => ({ name: name2, namespace: null })));
  uniSelector_ = otherwise(ab(namespace_, literal2("*"), (ns2) => ({ type: "universal", namespace: ns2, specificity: [0, 0, 0] })), map4(literal2("*"), () => ({ type: "universal", namespace: null, specificity: [0, 0, 0] })));
  tagSelector_ = map4(qualifiedName_, ({ name: name2, namespace }) => ({
    type: "tag",
    name: name2,
    namespace,
    specificity: [0, 0, 1]
  }));
  classSelector_ = ab(literal2("."), identifier_, (fullstop, name2) => ({
    type: "class",
    name: name2,
    specificity: [0, 1, 0]
  }));
  idSelector_ = map4(hashId_, (name2) => ({
    type: "id",
    name: name2,
    specificity: [1, 0, 0]
  }));
  attrModifier_ = token((t10) => {
    if (t10.name === "ident") {
      if (t10.text === "i" || t10.text === "I") {
        return "i";
      }
      if (t10.text === "s" || t10.text === "S") {
        return "s";
      }
    }
    return;
  });
  attrValue_ = otherwise(ab(string_, option(right(optionalWhitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })), ab(identifier_, option(right(whitespace_, attrModifier_), null), (v3, mod) => ({ value: v3, modifier: mod })));
  attrMatcher_ = choice(map4(literal2("="), () => "="), ab(literal2("~"), literal2("="), () => "~="), ab(literal2("|"), literal2("="), () => "|="), ab(literal2("^"), literal2("="), () => "^="), ab(literal2("$"), literal2("="), () => "$="), ab(literal2("*"), literal2("="), () => "*="));
  attrPresenceSelector_ = abc(literal2("["), optionallySpaced(qualifiedName_), literal2("]"), (lbr, { name: name2, namespace }) => ({
    type: "attrPresence",
    name: name2,
    namespace,
    specificity: [0, 1, 0]
  }));
  attrValueSelector_ = middle(literal2("["), abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name: name2, namespace }, matcher, { value, modifier }) => ({
    type: "attrValue",
    name: name2,
    namespace,
    matcher,
    value,
    modifier,
    specificity: [0, 1, 0]
  })), literal2("]"));
  attrSelector_ = otherwise(attrPresenceSelector_, attrValueSelector_);
  typeSelector_ = otherwise(uniSelector_, tagSelector_);
  subclassSelector_ = choice(idSelector_, classSelector_, attrSelector_);
  compoundSelector_ = map4(otherwise(flatten(typeSelector_, many(subclassSelector_)), many1(subclassSelector_)), (ss2) => {
    return {
      type: "compound",
      list: ss2,
      specificity: sumAllSpec(ss2.map((s2) => s2.specificity))
    };
  });
  combinator_ = choice(map4(literal2(">"), () => ">"), map4(literal2("+"), () => "+"), map4(literal2("~"), () => "~"), ab(literal2("|"), literal2("|"), () => "||"));
  combinatorSeparator_ = otherwise(optionallySpaced(combinator_), map4(whitespace_, () => " "));
  complexSelector_ = leftAssoc2(compoundSelector_, map4(combinatorSeparator_, (c2) => (left2, right2) => ({
    type: "compound",
    list: [...right2.list, { type: "combinator", combinator: c2, left: left2, specificity: left2.specificity }],
    specificity: sumSpec(left2.specificity, right2.specificity)
  })), compoundSelector_);
  listSelector_ = leftAssoc2(map4(complexSelector_, (s2) => ({ type: "list", list: [s2] })), map4(optionallySpaced(literal2(",")), () => (acc, next) => ({ type: "list", list: [...acc.list, next] })), complexSelector_);
});

// node_modules/selderee/lib/selderee.mjs
class DecisionTree {
  constructor(input) {
    this.branches = weave(toAstTerminalPairs(input));
  }
  build(builder) {
    return builder(this.branches);
  }
}
function toAstTerminalPairs(array2) {
  const len = array2.length;
  const results = new Array(len);
  for (let i2 = 0;i2 < len; i2++) {
    const [selectorString, val] = array2[i2];
    const ast = preprocess2(parse1(selectorString));
    results[i2] = {
      ast,
      terminal: {
        type: "terminal",
        valueContainer: { index: i2, value: val, specificity: ast.specificity }
      }
    };
  }
  return results;
}
function preprocess2(ast) {
  reduceSelectorVariants(ast);
  normalize(ast);
  return ast;
}
function reduceSelectorVariants(ast) {
  const newList = [];
  ast.list.forEach((sel) => {
    switch (sel.type) {
      case "class":
        newList.push({
          matcher: "~=",
          modifier: null,
          name: "class",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "id":
        newList.push({
          matcher: "=",
          modifier: null,
          name: "id",
          namespace: null,
          specificity: sel.specificity,
          type: "attrValue",
          value: sel.name
        });
        break;
      case "combinator":
        reduceSelectorVariants(sel.left);
        newList.push(sel);
        break;
      case "universal":
        break;
      default:
        newList.push(sel);
        break;
    }
  });
  ast.list = newList;
}
function weave(items) {
  const branches = [];
  while (items.length) {
    const topKind = findTopKey(items, (sel) => true, getSelectorKind);
    const { matches, nonmatches, empty } = breakByKind(items, topKind);
    items = nonmatches;
    if (matches.length) {
      branches.push(branchOfKind(topKind, matches));
    }
    if (empty.length) {
      branches.push(...terminate(empty));
    }
  }
  return branches;
}
function terminate(items) {
  const results = [];
  for (const item of items) {
    const terminal = item.terminal;
    if (terminal.type === "terminal") {
      results.push(terminal);
    } else {
      const { matches, rest } = partition(terminal.cont, (node2) => node2.type === "terminal");
      matches.forEach((node2) => results.push(node2));
      if (rest.length) {
        terminal.cont = rest;
        results.push(terminal);
      }
    }
  }
  return results;
}
function breakByKind(items, selectedKind) {
  const matches = [];
  const nonmatches = [];
  const empty = [];
  for (const item of items) {
    const simpsels = item.ast.list;
    if (simpsels.length) {
      const isMatch = simpsels.some((node2) => getSelectorKind(node2) === selectedKind);
      (isMatch ? matches : nonmatches).push(item);
    } else {
      empty.push(item);
    }
  }
  return { matches, nonmatches, empty };
}
function getSelectorKind(sel) {
  switch (sel.type) {
    case "attrPresence":
      return `attrPresence ${sel.name}`;
    case "attrValue":
      return `attrValue ${sel.name}`;
    case "combinator":
      return `combinator ${sel.combinator}`;
    default:
      return sel.type;
  }
}
function branchOfKind(kind, items) {
  if (kind === "tag") {
    return tagNameBranch(items);
  }
  if (kind.startsWith("attrValue ")) {
    return attrValueBranch(kind.substring(10), items);
  }
  if (kind.startsWith("attrPresence ")) {
    return attrPresenceBranch(kind.substring(13), items);
  }
  if (kind === "combinator >") {
    return combinatorBranch(">", items);
  }
  if (kind === "combinator +") {
    return combinatorBranch("+", items);
  }
  throw new Error(`Unsupported selector kind: ${kind}`);
}
function tagNameBranch(items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "tag", (x2) => x2.name);
  const variants = Object.entries(groups).map(([name2, group]) => ({
    type: "variant",
    value: name2,
    cont: weave(group.items)
  }));
  return {
    type: "tagName",
    variants
  };
}
function attrPresenceBranch(name2, items) {
  for (const item of items) {
    spliceSimpleSelector(item, (x2) => x2.type === "attrPresence" && x2.name === name2);
  }
  return {
    type: "attrPresence",
    name: name2,
    cont: weave(items)
  };
}
function attrValueBranch(name2, items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "attrValue" && x2.name === name2, (x2) => `${x2.matcher} ${x2.modifier || ""} ${x2.value}`);
  const matchers = [];
  for (const group of Object.values(groups)) {
    const sel = group.oneSimpleSelector;
    const predicate = getAttrPredicate(sel);
    const continuation = weave(group.items);
    matchers.push({
      type: "matcher",
      matcher: sel.matcher,
      modifier: sel.modifier,
      value: sel.value,
      predicate,
      cont: continuation
    });
  }
  return {
    type: "attrValue",
    name: name2,
    matchers
  };
}
function getAttrPredicate(sel) {
  if (sel.modifier === "i") {
    const expected = sel.value.toLowerCase();
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual.toLowerCase();
      case "~=":
        return (actual) => actual.toLowerCase().split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.toLowerCase().startsWith(expected);
      case "$=":
        return (actual) => actual.toLowerCase().endsWith(expected);
      case "*=":
        return (actual) => actual.toLowerCase().includes(expected);
      case "|=":
        return (actual) => {
          const lower = actual.toLowerCase();
          return expected === lower || lower.startsWith(expected) && lower[expected.length] === "-";
        };
    }
  } else {
    const expected = sel.value;
    switch (sel.matcher) {
      case "=":
        return (actual) => expected === actual;
      case "~=":
        return (actual) => actual.split(/[ \t]+/).includes(expected);
      case "^=":
        return (actual) => actual.startsWith(expected);
      case "$=":
        return (actual) => actual.endsWith(expected);
      case "*=":
        return (actual) => actual.includes(expected);
      case "|=":
        return (actual) => expected === actual || actual.startsWith(expected) && actual[expected.length] === "-";
    }
  }
}
function combinatorBranch(combinator, items) {
  const groups = spliceAndGroup(items, (x2) => x2.type === "combinator" && x2.combinator === combinator, (x2) => serialize(x2.left));
  const leftItems = [];
  for (const group of Object.values(groups)) {
    const rightCont = weave(group.items);
    const leftAst = group.oneSimpleSelector.left;
    leftItems.push({
      ast: leftAst,
      terminal: { type: "popElement", cont: rightCont }
    });
  }
  return {
    type: "pushElement",
    combinator,
    cont: weave(leftItems)
  };
}
function spliceAndGroup(items, predicate, keyCallback) {
  const groups = {};
  while (items.length) {
    const bestKey = findTopKey(items, predicate, keyCallback);
    const bestKeyPredicate = (sel) => predicate(sel) && keyCallback(sel) === bestKey;
    const hasBestKeyPredicate = (item) => item.ast.list.some(bestKeyPredicate);
    const { matches, rest } = partition1(items, hasBestKeyPredicate);
    let oneSimpleSelector = null;
    for (const item of matches) {
      const splicedNode = spliceSimpleSelector(item, bestKeyPredicate);
      if (!oneSimpleSelector) {
        oneSimpleSelector = splicedNode;
      }
    }
    if (oneSimpleSelector == null) {
      throw new Error("No simple selector is found.");
    }
    groups[bestKey] = { oneSimpleSelector, items: matches };
    items = rest;
  }
  return groups;
}
function spliceSimpleSelector(item, predicate) {
  const simpsels = item.ast.list;
  const matches = new Array(simpsels.length);
  let firstIndex = -1;
  for (let i2 = simpsels.length;i2-- > 0; ) {
    if (predicate(simpsels[i2])) {
      matches[i2] = true;
      firstIndex = i2;
    }
  }
  if (firstIndex == -1) {
    throw new Error(`Couldn't find the required simple selector.`);
  }
  const result = simpsels[firstIndex];
  item.ast.list = simpsels.filter((sel, i2) => !matches[i2]);
  return result;
}
function findTopKey(items, predicate, keyCallback) {
  const candidates = {};
  for (const item of items) {
    const candidates1 = {};
    for (const node2 of item.ast.list.filter(predicate)) {
      candidates1[keyCallback(node2)] = true;
    }
    for (const key of Object.keys(candidates1)) {
      if (candidates[key]) {
        candidates[key]++;
      } else {
        candidates[key] = 1;
      }
    }
  }
  let topKind = "";
  let topCounter = 0;
  for (const entry of Object.entries(candidates)) {
    if (entry[1] > topCounter) {
      topKind = entry[0];
      topCounter = entry[1];
    }
  }
  return topKind;
}
function partition(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x2 of src) {
    if (predicate(x2)) {
      matches.push(x2);
    } else {
      rest.push(x2);
    }
  }
  return { matches, rest };
}
function partition1(src, predicate) {
  const matches = [];
  const rest = [];
  for (const x2 of src) {
    if (predicate(x2)) {
      matches.push(x2);
    } else {
      rest.push(x2);
    }
  }
  return { matches, rest };
}

class Picker {
  constructor(f) {
    this.f = f;
  }
  pickAll(el) {
    return this.f(el);
  }
  pick1(el, preferFirst = false) {
    const results = this.f(el);
    const len = results.length;
    if (len === 0) {
      return null;
    }
    if (len === 1) {
      return results[0].value;
    }
    const comparator = preferFirst ? comparatorPreferFirst : comparatorPreferLast;
    let result = results[0];
    for (let i2 = 1;i2 < len; i2++) {
      const next = results[i2];
      if (comparator(result, next)) {
        result = next;
      }
    }
    return result.value;
  }
}
function comparatorPreferFirst(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index < acc.index;
}
function comparatorPreferLast(acc, next) {
  const diff = compareSpecificity(next.specificity, acc.specificity);
  return diff > 0 || diff === 0 && next.index > acc.index;
}
var init_selderee = __esm(() => {
  init_parseley();
  init_parseley();
});

// node_modules/@selderee/plugin-htmlparser2/lib/hp2-builder.mjs
function hp2Builder(nodes) {
  return new Picker(handleArray(nodes));
}
function handleArray(nodes) {
  const matchers = nodes.map(handleNode);
  return (el, ...tail) => matchers.flatMap((m) => m(el, ...tail));
}
function handleNode(node2) {
  switch (node2.type) {
    case "terminal": {
      const result = [node2.valueContainer];
      return (el, ...tail) => result;
    }
    case "tagName":
      return handleTagName(node2);
    case "attrValue":
      return handleAttrValueName(node2);
    case "attrPresence":
      return handleAttrPresenceName(node2);
    case "pushElement":
      return handlePushElementNode(node2);
    case "popElement":
      return handlePopElementNode(node2);
  }
}
function handleTagName(node2) {
  const variants = {};
  for (const variant of node2.variants) {
    variants[variant.value] = handleArray(variant.cont);
  }
  return (el, ...tail) => {
    const continuation = variants[el.name];
    return continuation ? continuation(el, ...tail) : [];
  };
}
function handleAttrPresenceName(node2) {
  const attrName = node2.name;
  const continuation = handleArray(node2.cont);
  return (el, ...tail) => Object.prototype.hasOwnProperty.call(el.attribs, attrName) ? continuation(el, ...tail) : [];
}
function handleAttrValueName(node2) {
  const callbacks = [];
  for (const matcher of node2.matchers) {
    const predicate = matcher.predicate;
    const continuation = handleArray(matcher.cont);
    callbacks.push((attr, el, ...tail) => predicate(attr) ? continuation(el, ...tail) : []);
  }
  const attrName = node2.name;
  return (el, ...tail) => {
    const attr = el.attribs[attrName];
    return attr || attr === "" ? callbacks.flatMap((cb) => cb(attr, el, ...tail)) : [];
  };
}
function handlePushElementNode(node2) {
  const continuation = handleArray(node2.cont);
  const leftElementGetter = node2.combinator === "+" ? getPrecedingElement : getParentElement;
  return (el, ...tail) => {
    const next = leftElementGetter(el);
    if (next === null) {
      return [];
    }
    return continuation(next, el, ...tail);
  };
}
function handlePopElementNode(node2) {
  const continuation = handleArray(node2.cont);
  return (el, next, ...tail) => continuation(next, ...tail);
}
var getPrecedingElement = (el) => {
  const prev = el.prev;
  if (prev === null) {
    return null;
  }
  return isTag2(prev) ? prev : getPrecedingElement(prev);
}, getParentElement = (el) => {
  const parent = el.parent;
  return parent && isTag2(parent) ? parent : null;
};
var init_hp2_builder = __esm(() => {
  init_esm3();
  init_selderee();
});

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default;
var init_decode_data_html = __esm(() => {
  decode_data_html_default = new Uint16Array("\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\x00\x00\x00\x00\x00\x00\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\x00\x00\x00\u0342\u0354\x00\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\x00\x00\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\x00\x00\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\x00\u0446\x00\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\x00\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\x00\x00\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\x00\x00\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\x00\u05BF\x00\x00\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\x00\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\x00\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\x00\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\x00\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\x00\u08C3bleBracket;\u67E6n\u01D4\u08C8\x00\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B\"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\x00\u1005bleBracket;\u67E7n\u01D4\u100A\x00\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\x00\x00\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\x00\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\x00\u132C\u1331\x00\x00\x00\x00\x00\u1338\u133D\u1377\u1385\x00\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\x00\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\x00\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\x00\u15B0\u15B6\u15BF\x00\x00\x00\x00\u15C6\u15DB\u15EB\u165F\u166D\x00\u1695\u169B\u16B2\u16B9\x00\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\x00\x00\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\x00\x00\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\x00\u1833\u01B2\u182F\x00\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\x00\u19E8\u1A11\u1A15\u1A32\x00\u1A37\u1A50\x00\x00\u1AB4\x00\x00\u1AC1\x00\x00\u1B21\u1B2E\u1B4D\u1B52\x00\u1BFD\x00\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\x00\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\x00\x00\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\x00\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\x00\x00\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\x00\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\x00\x00\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\x00\x00\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\x00\x00\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\x00\x00\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\x00\x00\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\x00\u1F9E\x00\u1FA1\u1FA7\x00\x00\u1FC6\u1FCC\x00\u1FD3\x00\u1FE6\u1FEA\u2000\x00\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\x00\x00\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\x00\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\x00\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\x00\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\x00\u2036;\u6154;\u6156\u02B4\u203E\u2041\x00\x00\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\x00\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\x00\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\x00\u22AA\x00\u22B8\u22C5\u22CE\x00\u22D5\u22F3\x00\x00\u22F8\u2322\u2367\u2362\u237F\x00\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\x00\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\x00\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\x00\u24AA\x00\u24B1\x00\x00\x00\x00\x00\u24B5\u24BA\x00\u24C6\u24C8\u24CD\x00\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\x00\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\x00\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\x00\x00\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\u2D2D\x00\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\x00\x00\u2D8D\u2DAB\x00\u2DC8\u2DCE\x00\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\x00\x00\u2D7C\x00\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\x00\u2E7D\x00\u2E80\u2E9D\x00\u2EA2\u2EB9\x00\x00\u2ECB\u0E9C\x00\u2F13\x00\x00\u2F2B\u2FBC\x00\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\x00\x00\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\x00\u337A\u33A4\x00\x00\u33EC\u33F0\x00\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\x00\u3616\x00\x00\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\x00\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\x00\x00\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\x00\u367E\u36C2\x00\x00\x00\x00\x00\u36DB\u3703\x00\u3709\u376C\x00\x00\x00\u3787\u0272\u3656\x00\x00\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\x00\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\x00\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\x00\x00\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\x00\x00\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\x00\u3A8B\x00\u3A90\u3A9B\x00\x00\u3A9D\u3AA8\u3AAB\u3AAF\x00\x00\u3AC3\u3ACE\x00\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C".split("").map((c2) => c2.charCodeAt(0)));
});

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default;
var init_decode_data_xml = __esm(() => {
  decode_data_xml_default = new Uint16Array("\u0200aglq\t\x15\x18\x1B\u026D\x0F\x00\x00\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c2) => c2.charCodeAt(0)));
});

// node_modules/entities/lib/esm/decode_codepoint.js
function replaceCodePoint(codePoint) {
  var _a4;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a4 = decodeMap.get(codePoint)) !== null && _a4 !== undefined ? _a4 : codePoint;
}
var _a3, decodeMap, fromCodePoint;
var init_decode_codepoint = __esm(() => {
  decodeMap = new Map([
    [0, 65533],
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  fromCodePoint = (_a3 = String.fromCodePoint) !== null && _a3 !== undefined ? _a3 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  };
});

// node_modules/entities/lib/esm/decode.js
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}

class EntityDecoder {
  constructor(decodeTree, emitCodePoint, errors3) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors3;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2) || isHexadecimalCharacter(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char2, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char2 = str.charCodeAt(offset);
      if (isNumber(char2)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char2, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  emitNumericEntity(lastCp, expectedLength) {
    var _a4;
    if (this.consumed <= expectedLength) {
      (_a4 = this.errors) === null || _a4 === undefined || _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (;offset < str.length; offset++, this.excess++) {
      const char2 = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char2);
      if (this.treeIndex < 0) {
        return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char2)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char2 === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  emitNotTerminatedNamedEntity() {
    var _a4;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a4 = this.errors) === null || _a4 === undefined || _a4.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  end() {
    var _a4;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a4 = this.errors) === null || _a4 === undefined || _a4.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
}
function getDecoder(decodeTree) {
  let ret = "";
  const decoder2 = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder2.startEntity(decodeMode);
      const len = decoder2.write(str, offset + 1);
      if (len < 0) {
        lastIndex = offset + decoder2.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char2) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char2 === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char2 - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo3 = nodeIdx;
  let hi2 = lo3 + branchCount - 1;
  while (lo3 <= hi2) {
    const mid = lo3 + hi2 >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char2) {
      lo3 = mid + 1;
    } else if (midVal > char2) {
      hi2 = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var CharCodes, TO_LOWER_BIT = 32, BinTrieFlags, EntityDecoderState, DecodingMode, htmlDecoder, xmlDecoder;
var init_decode = __esm(() => {
  init_decode_data_html();
  init_decode_data_xml();
  init_decode_codepoint();
  init_decode_codepoint();
  (function(CharCodes2) {
    CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
    CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
    CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
    CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
    CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
    CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
    CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
    CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
    CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
    CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
    CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
    CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
  })(CharCodes || (CharCodes = {}));
  (function(BinTrieFlags2) {
    BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
    BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
    BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
  })(BinTrieFlags || (BinTrieFlags = {}));
  (function(EntityDecoderState2) {
    EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
    EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
    EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
    EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
    EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
  })(EntityDecoderState || (EntityDecoderState = {}));
  (function(DecodingMode2) {
    DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
    DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
    DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
  })(DecodingMode || (DecodingMode = {}));
  htmlDecoder = getDecoder(decode_data_html_default);
  xmlDecoder = getDecoder(decode_data_xml_default);
});

// node_modules/htmlparser2/lib/esm/Tokenizer.js
function isWhitespace(c2) {
  return c2 === CharCodes2.Space || c2 === CharCodes2.NewLine || c2 === CharCodes2.Tab || c2 === CharCodes2.FormFeed || c2 === CharCodes2.CarriageReturn;
}
function isEndOfTagSection(c2) {
  return c2 === CharCodes2.Slash || c2 === CharCodes2.Gt || isWhitespace(c2);
}
function isNumber2(c2) {
  return c2 >= CharCodes2.Zero && c2 <= CharCodes2.Nine;
}
function isASCIIAlpha(c2) {
  return c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerZ || c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperZ;
}
function isHexDigit(c2) {
  return c2 >= CharCodes2.UpperA && c2 <= CharCodes2.UpperF || c2 >= CharCodes2.LowerA && c2 <= CharCodes2.LowerF;
}

class Tokenizer {
  constructor({ xmlMode = false, decodeEntities = true }, cbs) {
    this.cbs = cbs;
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.isSpecial = false;
    this.running = true;
    this.offset = 0;
    this.currentSequence = undefined;
    this.sequenceIndex = 0;
    this.trieIndex = 0;
    this.trieCurrent = 0;
    this.entityResult = 0;
    this.entityExcess = 0;
    this.xmlMode = xmlMode;
    this.decodeEntities = decodeEntities;
    this.entityTrie = xmlMode ? decode_data_xml_default : decode_data_html_default;
  }
  reset() {
    this.state = State.Text;
    this.buffer = "";
    this.sectionStart = 0;
    this.index = 0;
    this.baseState = State.Text;
    this.currentSequence = undefined;
    this.running = true;
    this.offset = 0;
  }
  write(chunk) {
    this.offset += this.buffer.length;
    this.buffer = chunk;
    this.parse();
  }
  end() {
    if (this.running)
      this.finish();
  }
  pause() {
    this.running = false;
  }
  resume() {
    this.running = true;
    if (this.index < this.buffer.length + this.offset) {
      this.parse();
    }
  }
  getIndex() {
    return this.index;
  }
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(c2) {
    if (c2 === CharCodes2.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes2.Lt)) {
      if (this.index > this.sectionStart) {
        this.cbs.ontext(this.sectionStart, this.index);
      }
      this.state = State.BeforeTagName;
      this.sectionStart = this.index;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.state = State.BeforeEntity;
    }
  }
  stateSpecialStartSequence(c2) {
    const isEnd = this.sequenceIndex === this.currentSequence.length;
    const isMatch = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
    if (!isMatch) {
      this.isSpecial = false;
    } else if (!isEnd) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0;
    this.state = State.InTagName;
    this.stateInTagName(c2);
  }
  stateInSpecialTag(c2) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
        const endOfText = this.index - this.currentSequence.length;
        if (this.sectionStart < endOfText) {
          const actualIndex = this.index;
          this.index = endOfText;
          this.cbs.ontext(this.sectionStart, endOfText);
          this.index = actualIndex;
        }
        this.isSpecial = false;
        this.sectionStart = endOfText + 2;
        this.stateInClosingTagName(c2);
        return;
      }
      this.sequenceIndex = 0;
    }
    if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
      this.sequenceIndex += 1;
    } else if (this.sequenceIndex === 0) {
      if (this.currentSequence === Sequences.TitleEnd) {
        if (this.decodeEntities && c2 === CharCodes2.Amp) {
          this.state = State.BeforeEntity;
        }
      } else if (this.fastForwardTo(CharCodes2.Lt)) {
        this.sequenceIndex = 1;
      }
    } else {
      this.sequenceIndex = Number(c2 === CharCodes2.Lt);
    }
  }
  stateCDATASequence(c2) {
    if (c2 === Sequences.Cdata[this.sequenceIndex]) {
      if (++this.sequenceIndex === Sequences.Cdata.length) {
        this.state = State.InCommentLike;
        this.currentSequence = Sequences.CdataEnd;
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
      }
    } else {
      this.sequenceIndex = 0;
      this.state = State.InDeclaration;
      this.stateInDeclaration(c2);
    }
  }
  fastForwardTo(c2) {
    while (++this.index < this.buffer.length + this.offset) {
      if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
        return true;
      }
    }
    this.index = this.buffer.length + this.offset - 1;
    return false;
  }
  stateInCommentLike(c2) {
    if (c2 === this.currentSequence[this.sequenceIndex]) {
      if (++this.sequenceIndex === this.currentSequence.length) {
        if (this.currentSequence === Sequences.CdataEnd) {
          this.cbs.oncdata(this.sectionStart, this.index, 2);
        } else {
          this.cbs.oncomment(this.sectionStart, this.index, 2);
        }
        this.sequenceIndex = 0;
        this.sectionStart = this.index + 1;
        this.state = State.Text;
      }
    } else if (this.sequenceIndex === 0) {
      if (this.fastForwardTo(this.currentSequence[0])) {
        this.sequenceIndex = 1;
      }
    } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
      this.sequenceIndex = 0;
    }
  }
  isTagStartChar(c2) {
    return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
  }
  startSpecial(sequence, offset) {
    this.isSpecial = true;
    this.currentSequence = sequence;
    this.sequenceIndex = offset;
    this.state = State.SpecialStartSequence;
  }
  stateBeforeTagName(c2) {
    if (c2 === CharCodes2.ExclamationMark) {
      this.state = State.BeforeDeclaration;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Questionmark) {
      this.state = State.InProcessingInstruction;
      this.sectionStart = this.index + 1;
    } else if (this.isTagStartChar(c2)) {
      const lower = c2 | 32;
      this.sectionStart = this.index;
      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
        this.startSpecial(Sequences.TitleEnd, 3);
      } else {
        this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State.BeforeSpecialS : State.InTagName;
      }
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.BeforeClosingTagName;
    } else {
      this.state = State.Text;
      this.stateText(c2);
    }
  }
  stateInTagName(c2) {
    if (isEndOfTagSection(c2)) {
      this.cbs.onopentagname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateBeforeClosingTagName(c2) {
    if (isWhitespace(c2)) {} else if (c2 === CharCodes2.Gt) {
      this.state = State.Text;
    } else {
      this.state = this.isTagStartChar(c2) ? State.InClosingTagName : State.InSpecialComment;
      this.sectionStart = this.index;
    }
  }
  stateInClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || isWhitespace(c2)) {
      this.cbs.onclosetag(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterClosingTagName;
      this.stateAfterClosingTagName(c2);
    }
  }
  stateAfterClosingTagName(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeAttributeName(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onopentagend(this.index);
      if (this.isSpecial) {
        this.state = State.InSpecialTag;
        this.sequenceIndex = 0;
      } else {
        this.state = State.Text;
      }
      this.baseState = this.state;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.Slash) {
      this.state = State.InSelfClosingTag;
    } else if (!isWhitespace(c2)) {
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateInSelfClosingTag(c2) {
    if (c2 === CharCodes2.Gt) {
      this.cbs.onselfclosingtag(this.index);
      this.state = State.Text;
      this.baseState = State.Text;
      this.sectionStart = this.index + 1;
      this.isSpecial = false;
    } else if (!isWhitespace(c2)) {
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    }
  }
  stateInAttributeName(c2) {
    if (c2 === CharCodes2.Eq || isEndOfTagSection(c2)) {
      this.cbs.onattribname(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.state = State.AfterAttributeName;
      this.stateAfterAttributeName(c2);
    }
  }
  stateAfterAttributeName(c2) {
    if (c2 === CharCodes2.Eq) {
      this.state = State.BeforeAttributeValue;
    } else if (c2 === CharCodes2.Slash || c2 === CharCodes2.Gt) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (!isWhitespace(c2)) {
      this.cbs.onattribend(QuoteType.NoValue, this.index);
      this.state = State.InAttributeName;
      this.sectionStart = this.index;
    }
  }
  stateBeforeAttributeValue(c2) {
    if (c2 === CharCodes2.DoubleQuote) {
      this.state = State.InAttributeValueDq;
      this.sectionStart = this.index + 1;
    } else if (c2 === CharCodes2.SingleQuote) {
      this.state = State.InAttributeValueSq;
      this.sectionStart = this.index + 1;
    } else if (!isWhitespace(c2)) {
      this.sectionStart = this.index;
      this.state = State.InAttributeValueNq;
      this.stateInAttributeValueNoQuotes(c2);
    }
  }
  handleInAttributeValue(c2, quote) {
    if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(quote === CharCodes2.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
      this.state = State.BeforeAttributeName;
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateInAttributeValueDoubleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(c2) {
    this.handleInAttributeValue(c2, CharCodes2.SingleQuote);
  }
  stateInAttributeValueNoQuotes(c2) {
    if (isWhitespace(c2) || c2 === CharCodes2.Gt) {
      this.cbs.onattribdata(this.sectionStart, this.index);
      this.sectionStart = -1;
      this.cbs.onattribend(QuoteType.Unquoted, this.index);
      this.state = State.BeforeAttributeName;
      this.stateBeforeAttributeName(c2);
    } else if (this.decodeEntities && c2 === CharCodes2.Amp) {
      this.baseState = this.state;
      this.state = State.BeforeEntity;
    }
  }
  stateBeforeDeclaration(c2) {
    if (c2 === CharCodes2.OpeningSquareBracket) {
      this.state = State.CDATASequence;
      this.sequenceIndex = 0;
    } else {
      this.state = c2 === CharCodes2.Dash ? State.BeforeComment : State.InDeclaration;
    }
  }
  stateInDeclaration(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.ondeclaration(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateInProcessingInstruction(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.onprocessinginstruction(this.sectionStart, this.index);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeComment(c2) {
    if (c2 === CharCodes2.Dash) {
      this.state = State.InCommentLike;
      this.currentSequence = Sequences.CommentEnd;
      this.sequenceIndex = 2;
      this.sectionStart = this.index + 1;
    } else {
      this.state = State.InDeclaration;
    }
  }
  stateInSpecialComment(c2) {
    if (c2 === CharCodes2.Gt || this.fastForwardTo(CharCodes2.Gt)) {
      this.cbs.oncomment(this.sectionStart, this.index, 0);
      this.state = State.Text;
      this.sectionStart = this.index + 1;
    }
  }
  stateBeforeSpecialS(c2) {
    const lower = c2 | 32;
    if (lower === Sequences.ScriptEnd[3]) {
      this.startSpecial(Sequences.ScriptEnd, 4);
    } else if (lower === Sequences.StyleEnd[3]) {
      this.startSpecial(Sequences.StyleEnd, 4);
    } else {
      this.state = State.InTagName;
      this.stateInTagName(c2);
    }
  }
  stateBeforeEntity(c2) {
    this.entityExcess = 1;
    this.entityResult = 0;
    if (c2 === CharCodes2.Number) {
      this.state = State.BeforeNumericEntity;
    } else if (c2 === CharCodes2.Amp) {} else {
      this.trieIndex = 0;
      this.trieCurrent = this.entityTrie[0];
      this.state = State.InNamedEntity;
      this.stateInNamedEntity(c2);
    }
  }
  stateInNamedEntity(c2) {
    this.entityExcess += 1;
    this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
    if (this.trieIndex < 0) {
      this.emitNamedEntity();
      this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
    if (masked) {
      const valueLength = (masked >> 14) - 1;
      if (!this.allowLegacyEntity() && c2 !== CharCodes2.Semi) {
        this.trieIndex += valueLength;
      } else {
        const entityStart = this.index - this.entityExcess + 1;
        if (entityStart > this.sectionStart) {
          this.emitPartial(this.sectionStart, entityStart);
        }
        this.entityResult = this.trieIndex;
        this.trieIndex += valueLength;
        this.entityExcess = 0;
        this.sectionStart = this.index + 1;
        if (valueLength === 0) {
          this.emitNamedEntity();
        }
      }
    }
  }
  emitNamedEntity() {
    this.state = this.baseState;
    if (this.entityResult === 0) {
      return;
    }
    const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >> 14;
    switch (valueLength) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
      }
    }
  }
  stateBeforeNumericEntity(c2) {
    if ((c2 | 32) === CharCodes2.LowerX) {
      this.entityExcess++;
      this.state = State.InHexEntity;
    } else {
      this.state = State.InNumericEntity;
      this.stateInNumericEntity(c2);
    }
  }
  emitNumericEntity(strict) {
    const entityStart = this.index - this.entityExcess - 1;
    const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
    if (numberStart !== this.index) {
      if (entityStart > this.sectionStart) {
        this.emitPartial(this.sectionStart, entityStart);
      }
      this.sectionStart = this.index + Number(strict);
      this.emitCodePoint(replaceCodePoint(this.entityResult));
    }
    this.state = this.baseState;
  }
  stateInNumericEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 10 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  stateInHexEntity(c2) {
    if (c2 === CharCodes2.Semi) {
      this.emitNumericEntity(true);
    } else if (isNumber2(c2)) {
      this.entityResult = this.entityResult * 16 + (c2 - CharCodes2.Zero);
      this.entityExcess++;
    } else if (isHexDigit(c2)) {
      this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes2.LowerA + 10);
      this.entityExcess++;
    } else {
      if (this.allowLegacyEntity()) {
        this.emitNumericEntity(false);
      } else {
        this.state = this.baseState;
      }
      this.index--;
    }
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag);
  }
  cleanup() {
    if (this.running && this.sectionStart !== this.index) {
      if (this.state === State.Text || this.state === State.InSpecialTag && this.sequenceIndex === 0) {
        this.cbs.ontext(this.sectionStart, this.index);
        this.sectionStart = this.index;
      } else if (this.state === State.InAttributeValueDq || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueNq) {
        this.cbs.onattribdata(this.sectionStart, this.index);
        this.sectionStart = this.index;
      }
    }
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  parse() {
    while (this.shouldContinue()) {
      const c2 = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case State.Text: {
          this.stateText(c2);
          break;
        }
        case State.SpecialStartSequence: {
          this.stateSpecialStartSequence(c2);
          break;
        }
        case State.InSpecialTag: {
          this.stateInSpecialTag(c2);
          break;
        }
        case State.CDATASequence: {
          this.stateCDATASequence(c2);
          break;
        }
        case State.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(c2);
          break;
        }
        case State.InAttributeName: {
          this.stateInAttributeName(c2);
          break;
        }
        case State.InCommentLike: {
          this.stateInCommentLike(c2);
          break;
        }
        case State.InSpecialComment: {
          this.stateInSpecialComment(c2);
          break;
        }
        case State.BeforeAttributeName: {
          this.stateBeforeAttributeName(c2);
          break;
        }
        case State.InTagName: {
          this.stateInTagName(c2);
          break;
        }
        case State.InClosingTagName: {
          this.stateInClosingTagName(c2);
          break;
        }
        case State.BeforeTagName: {
          this.stateBeforeTagName(c2);
          break;
        }
        case State.AfterAttributeName: {
          this.stateAfterAttributeName(c2);
          break;
        }
        case State.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(c2);
          break;
        }
        case State.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(c2);
          break;
        }
        case State.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(c2);
          break;
        }
        case State.AfterClosingTagName: {
          this.stateAfterClosingTagName(c2);
          break;
        }
        case State.BeforeSpecialS: {
          this.stateBeforeSpecialS(c2);
          break;
        }
        case State.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(c2);
          break;
        }
        case State.InSelfClosingTag: {
          this.stateInSelfClosingTag(c2);
          break;
        }
        case State.InDeclaration: {
          this.stateInDeclaration(c2);
          break;
        }
        case State.BeforeDeclaration: {
          this.stateBeforeDeclaration(c2);
          break;
        }
        case State.BeforeComment: {
          this.stateBeforeComment(c2);
          break;
        }
        case State.InProcessingInstruction: {
          this.stateInProcessingInstruction(c2);
          break;
        }
        case State.InNamedEntity: {
          this.stateInNamedEntity(c2);
          break;
        }
        case State.BeforeEntity: {
          this.stateBeforeEntity(c2);
          break;
        }
        case State.InHexEntity: {
          this.stateInHexEntity(c2);
          break;
        }
        case State.InNumericEntity: {
          this.stateInNumericEntity(c2);
          break;
        }
        default: {
          this.stateBeforeNumericEntity(c2);
        }
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    if (this.state === State.InNamedEntity) {
      this.emitNamedEntity();
    }
    if (this.sectionStart < this.index) {
      this.handleTrailingData();
    }
    this.cbs.onend();
  }
  handleTrailingData() {
    const endIndex = this.buffer.length + this.offset;
    if (this.state === State.InCommentLike) {
      if (this.currentSequence === Sequences.CdataEnd) {
        this.cbs.oncdata(this.sectionStart, endIndex, 0);
      } else {
        this.cbs.oncomment(this.sectionStart, endIndex, 0);
      }
    } else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
      this.emitNumericEntity(false);
    } else if (this.state === State.InTagName || this.state === State.BeforeAttributeName || this.state === State.BeforeAttributeValue || this.state === State.AfterAttributeName || this.state === State.InAttributeName || this.state === State.InAttributeValueSq || this.state === State.InAttributeValueDq || this.state === State.InAttributeValueNq || this.state === State.InClosingTagName) {} else {
      this.cbs.ontext(this.sectionStart, endIndex);
    }
  }
  emitPartial(start, endIndex) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribdata(start, endIndex);
    } else {
      this.cbs.ontext(start, endIndex);
    }
  }
  emitCodePoint(cp) {
    if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
      this.cbs.onattribentity(cp);
    } else {
      this.cbs.ontextentity(cp);
    }
  }
}
var CharCodes2, State, QuoteType, Sequences;
var init_Tokenizer = __esm(() => {
  init_decode();
  (function(CharCodes3) {
    CharCodes3[CharCodes3["Tab"] = 9] = "Tab";
    CharCodes3[CharCodes3["NewLine"] = 10] = "NewLine";
    CharCodes3[CharCodes3["FormFeed"] = 12] = "FormFeed";
    CharCodes3[CharCodes3["CarriageReturn"] = 13] = "CarriageReturn";
    CharCodes3[CharCodes3["Space"] = 32] = "Space";
    CharCodes3[CharCodes3["ExclamationMark"] = 33] = "ExclamationMark";
    CharCodes3[CharCodes3["Number"] = 35] = "Number";
    CharCodes3[CharCodes3["Amp"] = 38] = "Amp";
    CharCodes3[CharCodes3["SingleQuote"] = 39] = "SingleQuote";
    CharCodes3[CharCodes3["DoubleQuote"] = 34] = "DoubleQuote";
    CharCodes3[CharCodes3["Dash"] = 45] = "Dash";
    CharCodes3[CharCodes3["Slash"] = 47] = "Slash";
    CharCodes3[CharCodes3["Zero"] = 48] = "Zero";
    CharCodes3[CharCodes3["Nine"] = 57] = "Nine";
    CharCodes3[CharCodes3["Semi"] = 59] = "Semi";
    CharCodes3[CharCodes3["Lt"] = 60] = "Lt";
    CharCodes3[CharCodes3["Eq"] = 61] = "Eq";
    CharCodes3[CharCodes3["Gt"] = 62] = "Gt";
    CharCodes3[CharCodes3["Questionmark"] = 63] = "Questionmark";
    CharCodes3[CharCodes3["UpperA"] = 65] = "UpperA";
    CharCodes3[CharCodes3["LowerA"] = 97] = "LowerA";
    CharCodes3[CharCodes3["UpperF"] = 70] = "UpperF";
    CharCodes3[CharCodes3["LowerF"] = 102] = "LowerF";
    CharCodes3[CharCodes3["UpperZ"] = 90] = "UpperZ";
    CharCodes3[CharCodes3["LowerZ"] = 122] = "LowerZ";
    CharCodes3[CharCodes3["LowerX"] = 120] = "LowerX";
    CharCodes3[CharCodes3["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
  })(CharCodes2 || (CharCodes2 = {}));
  (function(State2) {
    State2[State2["Text"] = 1] = "Text";
    State2[State2["BeforeTagName"] = 2] = "BeforeTagName";
    State2[State2["InTagName"] = 3] = "InTagName";
    State2[State2["InSelfClosingTag"] = 4] = "InSelfClosingTag";
    State2[State2["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
    State2[State2["InClosingTagName"] = 6] = "InClosingTagName";
    State2[State2["AfterClosingTagName"] = 7] = "AfterClosingTagName";
    State2[State2["BeforeAttributeName"] = 8] = "BeforeAttributeName";
    State2[State2["InAttributeName"] = 9] = "InAttributeName";
    State2[State2["AfterAttributeName"] = 10] = "AfterAttributeName";
    State2[State2["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
    State2[State2["InAttributeValueDq"] = 12] = "InAttributeValueDq";
    State2[State2["InAttributeValueSq"] = 13] = "InAttributeValueSq";
    State2[State2["InAttributeValueNq"] = 14] = "InAttributeValueNq";
    State2[State2["BeforeDeclaration"] = 15] = "BeforeDeclaration";
    State2[State2["InDeclaration"] = 16] = "InDeclaration";
    State2[State2["InProcessingInstruction"] = 17] = "InProcessingInstruction";
    State2[State2["BeforeComment"] = 18] = "BeforeComment";
    State2[State2["CDATASequence"] = 19] = "CDATASequence";
    State2[State2["InSpecialComment"] = 20] = "InSpecialComment";
    State2[State2["InCommentLike"] = 21] = "InCommentLike";
    State2[State2["BeforeSpecialS"] = 22] = "BeforeSpecialS";
    State2[State2["SpecialStartSequence"] = 23] = "SpecialStartSequence";
    State2[State2["InSpecialTag"] = 24] = "InSpecialTag";
    State2[State2["BeforeEntity"] = 25] = "BeforeEntity";
    State2[State2["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
    State2[State2["InNamedEntity"] = 27] = "InNamedEntity";
    State2[State2["InNumericEntity"] = 28] = "InNumericEntity";
    State2[State2["InHexEntity"] = 29] = "InHexEntity";
  })(State || (State = {}));
  (function(QuoteType2) {
    QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
    QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
    QuoteType2[QuoteType2["Single"] = 2] = "Single";
    QuoteType2[QuoteType2["Double"] = 3] = "Double";
  })(QuoteType || (QuoteType = {}));
  Sequences = {
    Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
    CdataEnd: new Uint8Array([93, 93, 62]),
    CommentEnd: new Uint8Array([45, 45, 62]),
    ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
    StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
    TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  };
});

// node_modules/htmlparser2/lib/esm/Parser.js
class Parser {
  constructor(cbs, options = {}) {
    var _a4, _b2, _c, _d, _e3;
    this.options = options;
    this.startIndex = 0;
    this.endIndex = 0;
    this.openTagStart = 0;
    this.tagname = "";
    this.attribname = "";
    this.attribvalue = "";
    this.attribs = null;
    this.stack = [];
    this.foreignContext = [];
    this.buffers = [];
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
    this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
    this.lowerCaseTagNames = (_a4 = options.lowerCaseTags) !== null && _a4 !== undefined ? _a4 : !options.xmlMode;
    this.lowerCaseAttributeNames = (_b2 = options.lowerCaseAttributeNames) !== null && _b2 !== undefined ? _b2 : !options.xmlMode;
    this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer)(this.options, this);
    (_e3 = (_d = this.cbs).onparserinit) === null || _e3 === undefined || _e3.call(_d, this);
  }
  ontext(start, endIndex) {
    var _a4, _b2;
    const data = this.getSlice(start, endIndex);
    this.endIndex = endIndex - 1;
    (_b2 = (_a4 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a4, data);
    this.startIndex = endIndex;
  }
  ontextentity(cp) {
    var _a4, _b2;
    const index = this.tokenizer.getSectionStart();
    this.endIndex = index - 1;
    (_b2 = (_a4 = this.cbs).ontext) === null || _b2 === undefined || _b2.call(_a4, fromCodePoint(cp));
    this.startIndex = index;
  }
  isVoidElement(name2) {
    return !this.options.xmlMode && voidElements.has(name2);
  }
  onopentagname(start, endIndex) {
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    this.emitOpenTag(name2);
  }
  emitOpenTag(name2) {
    var _a4, _b2, _c, _d;
    this.openTagStart = this.startIndex;
    this.tagname = name2;
    const impliesClose = !this.options.xmlMode && openImpliesClose.get(name2);
    if (impliesClose) {
      while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
        const element = this.stack.pop();
        (_b2 = (_a4 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a4, element, true);
      }
    }
    if (!this.isVoidElement(name2)) {
      this.stack.push(name2);
      if (foreignContextElements.has(name2)) {
        this.foreignContext.push(true);
      } else if (htmlIntegrationElements.has(name2)) {
        this.foreignContext.push(false);
      }
    }
    (_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name2);
    if (this.cbs.onopentag)
      this.attribs = {};
  }
  endOpenTag(isImplied) {
    var _a4, _b2;
    this.startIndex = this.openTagStart;
    if (this.attribs) {
      (_b2 = (_a4 = this.cbs).onopentag) === null || _b2 === undefined || _b2.call(_a4, this.tagname, this.attribs, isImplied);
      this.attribs = null;
    }
    if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
      this.cbs.onclosetag(this.tagname, true);
    }
    this.tagname = "";
  }
  onopentagend(endIndex) {
    this.endIndex = endIndex;
    this.endOpenTag(false);
    this.startIndex = endIndex + 1;
  }
  onclosetag(start, endIndex) {
    var _a4, _b2, _c, _d, _e3, _f;
    this.endIndex = endIndex;
    let name2 = this.getSlice(start, endIndex);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    if (foreignContextElements.has(name2) || htmlIntegrationElements.has(name2)) {
      this.foreignContext.pop();
    }
    if (!this.isVoidElement(name2)) {
      const pos = this.stack.lastIndexOf(name2);
      if (pos !== -1) {
        if (this.cbs.onclosetag) {
          let count = this.stack.length - pos;
          while (count--) {
            this.cbs.onclosetag(this.stack.pop(), count !== 0);
          }
        } else
          this.stack.length = pos;
      } else if (!this.options.xmlMode && name2 === "p") {
        this.emitOpenTag("p");
        this.closeCurrentTag(true);
      }
    } else if (!this.options.xmlMode && name2 === "br") {
      (_b2 = (_a4 = this.cbs).onopentagname) === null || _b2 === undefined || _b2.call(_a4, "br");
      (_d = (_c = this.cbs).onopentag) === null || _d === undefined || _d.call(_c, "br", {}, true);
      (_f = (_e3 = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e3, "br", false);
    }
    this.startIndex = endIndex + 1;
  }
  onselfclosingtag(endIndex) {
    this.endIndex = endIndex;
    if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
      this.closeCurrentTag(false);
      this.startIndex = endIndex + 1;
    } else {
      this.onopentagend(endIndex);
    }
  }
  closeCurrentTag(isOpenImplied) {
    var _a4, _b2;
    const name2 = this.tagname;
    this.endOpenTag(isOpenImplied);
    if (this.stack[this.stack.length - 1] === name2) {
      (_b2 = (_a4 = this.cbs).onclosetag) === null || _b2 === undefined || _b2.call(_a4, name2, !isOpenImplied);
      this.stack.pop();
    }
  }
  onattribname(start, endIndex) {
    this.startIndex = start;
    const name2 = this.getSlice(start, endIndex);
    this.attribname = this.lowerCaseAttributeNames ? name2.toLowerCase() : name2;
  }
  onattribdata(start, endIndex) {
    this.attribvalue += this.getSlice(start, endIndex);
  }
  onattribentity(cp) {
    this.attribvalue += fromCodePoint(cp);
  }
  onattribend(quote, endIndex) {
    var _a4, _b2;
    this.endIndex = endIndex;
    (_b2 = (_a4 = this.cbs).onattribute) === null || _b2 === undefined || _b2.call(_a4, this.attribname, this.attribvalue, quote === QuoteType.Double ? '"' : quote === QuoteType.Single ? "'" : quote === QuoteType.NoValue ? undefined : null);
    if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
      this.attribs[this.attribname] = this.attribvalue;
    }
    this.attribvalue = "";
  }
  getInstructionName(value) {
    const index = value.search(reNameEnd);
    let name2 = index < 0 ? value : value.substr(0, index);
    if (this.lowerCaseTagNames) {
      name2 = name2.toLowerCase();
    }
    return name2;
  }
  ondeclaration(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`!${name2}`, `!${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  onprocessinginstruction(start, endIndex) {
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex);
    if (this.cbs.onprocessinginstruction) {
      const name2 = this.getInstructionName(value);
      this.cbs.onprocessinginstruction(`?${name2}`, `?${value}`);
    }
    this.startIndex = endIndex + 1;
  }
  oncomment(start, endIndex, offset) {
    var _a4, _b2, _c, _d;
    this.endIndex = endIndex;
    (_b2 = (_a4 = this.cbs).oncomment) === null || _b2 === undefined || _b2.call(_a4, this.getSlice(start, endIndex - offset));
    (_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
    this.startIndex = endIndex + 1;
  }
  oncdata(start, endIndex, offset) {
    var _a4, _b2, _c, _d, _e3, _f, _g, _h, _j, _k;
    this.endIndex = endIndex;
    const value = this.getSlice(start, endIndex - offset);
    if (this.options.xmlMode || this.options.recognizeCDATA) {
      (_b2 = (_a4 = this.cbs).oncdatastart) === null || _b2 === undefined || _b2.call(_a4);
      (_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
      (_f = (_e3 = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e3);
    } else {
      (_h = (_g = this.cbs).oncomment) === null || _h === undefined || _h.call(_g, `[CDATA[${value}]]`);
      (_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
    }
    this.startIndex = endIndex + 1;
  }
  onend() {
    var _a4, _b2;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let index = this.stack.length;index > 0; this.cbs.onclosetag(this.stack[--index], true))
        ;
    }
    (_b2 = (_a4 = this.cbs).onend) === null || _b2 === undefined || _b2.call(_a4);
  }
  reset() {
    var _a4, _b2, _c, _d;
    (_b2 = (_a4 = this.cbs).onreset) === null || _b2 === undefined || _b2.call(_a4);
    this.tokenizer.reset();
    this.tagname = "";
    this.attribname = "";
    this.attribs = null;
    this.stack.length = 0;
    this.startIndex = 0;
    this.endIndex = 0;
    (_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
    this.buffers.length = 0;
    this.bufferOffset = 0;
    this.writeIndex = 0;
    this.ended = false;
  }
  parseComplete(data) {
    this.reset();
    this.end(data);
  }
  getSlice(start, end) {
    while (start - this.bufferOffset >= this.buffers[0].length) {
      this.shiftBuffer();
    }
    let slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
    while (end - this.bufferOffset > this.buffers[0].length) {
      this.shiftBuffer();
      slice += this.buffers[0].slice(0, end - this.bufferOffset);
    }
    return slice;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length;
    this.writeIndex--;
    this.buffers.shift();
  }
  write(chunk) {
    var _a4, _b2;
    if (this.ended) {
      (_b2 = (_a4 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a4, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(chunk);
    if (this.tokenizer.running) {
      this.tokenizer.write(chunk);
      this.writeIndex++;
    }
  }
  end(chunk) {
    var _a4, _b2;
    if (this.ended) {
      (_b2 = (_a4 = this.cbs).onerror) === null || _b2 === undefined || _b2.call(_a4, new Error(".end() after done!"));
      return;
    }
    if (chunk)
      this.write(chunk);
    this.ended = true;
    this.tokenizer.end();
  }
  pause() {
    this.tokenizer.pause();
  }
  resume() {
    this.tokenizer.resume();
    while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    }
    if (this.ended)
      this.tokenizer.end();
  }
  parseChunk(chunk) {
    this.write(chunk);
  }
  done(chunk) {
    this.end(chunk);
  }
}
var formTags, pTag, tableSectionTags, ddtTags, rtpTags, openImpliesClose, voidElements, foreignContextElements, htmlIntegrationElements, reNameEnd;
var init_Parser = __esm(() => {
  init_Tokenizer();
  init_decode();
  formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea"
  ]);
  pTag = new Set(["p"]);
  tableSectionTags = new Set(["thead", "tbody"]);
  ddtTags = new Set(["dd", "dt"]);
  rtpTags = new Set(["rt", "rp"]);
  openImpliesClose = new Map([
    ["tr", new Set(["tr", "th", "td"])],
    ["th", new Set(["th"])],
    ["td", new Set(["thead", "th", "td"])],
    ["body", new Set(["head", "link", "script"])],
    ["li", new Set(["li"])],
    ["p", pTag],
    ["h1", pTag],
    ["h2", pTag],
    ["h3", pTag],
    ["h4", pTag],
    ["h5", pTag],
    ["h6", pTag],
    ["select", formTags],
    ["input", formTags],
    ["output", formTags],
    ["button", formTags],
    ["datalist", formTags],
    ["textarea", formTags],
    ["option", new Set(["option"])],
    ["optgroup", new Set(["optgroup", "option"])],
    ["dd", ddtTags],
    ["dt", ddtTags],
    ["address", pTag],
    ["article", pTag],
    ["aside", pTag],
    ["blockquote", pTag],
    ["details", pTag],
    ["div", pTag],
    ["dl", pTag],
    ["fieldset", pTag],
    ["figcaption", pTag],
    ["figure", pTag],
    ["footer", pTag],
    ["form", pTag],
    ["header", pTag],
    ["hr", pTag],
    ["main", pTag],
    ["nav", pTag],
    ["ol", pTag],
    ["pre", pTag],
    ["section", pTag],
    ["table", pTag],
    ["ul", pTag],
    ["rt", rtpTags],
    ["rp", rtpTags],
    ["tbody", tableSectionTags],
    ["tfoot", tableSectionTags]
  ]);
  voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  foreignContextElements = new Set(["math", "svg"]);
  htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignobject",
    "desc",
    "title"
  ]);
  reNameEnd = /\s|\//;
});

// node_modules/entities/lib/esm/escape.js
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i2 = match.index;
    const char2 = str.charCodeAt(i2);
    const next = xmlCodeMap.get(char2);
    if (next !== undefined) {
      ret += str.substring(lastIdx, i2) + next;
      lastIdx = i2 + 1;
    } else {
      ret += `${str.substring(lastIdx, i2)}&#x${getCodePoint(str, i2).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char2 & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex2, map5) {
  return function escape(data) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex2.exec(data)) {
      if (lastIdx !== match.index) {
        result += data.substring(lastIdx, match.index);
      }
      result += map5.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var xmlReplacer, xmlCodeMap, getCodePoint, escapeUTF8, escapeAttribute, escapeText;
var init_escape = __esm(() => {
  xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
  xmlCodeMap = new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [39, "&apos;"],
    [60, "&lt;"],
    [62, "&gt;"]
  ]);
  getCodePoint = String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (c2, index) => (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
  escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
  escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
    [34, "&quot;"],
    [38, "&amp;"],
    [160, "&nbsp;"]
  ]));
  escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
    [38, "&amp;"],
    [60, "&lt;"],
    [62, "&gt;"],
    [160, "&nbsp;"]
  ]));
});

// node_modules/entities/lib/esm/index.js
var EntityLevel, EncodingMode;
var init_esm4 = __esm(() => {
  init_escape();
  (function(EntityLevel2) {
    EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
    EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
  })(EntityLevel || (EntityLevel = {}));
  (function(EncodingMode2) {
    EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
    EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
    EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
    EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
    EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
  })(EncodingMode || (EncodingMode = {}));
});

// node_modules/dom-serializer/lib/esm/foreignNames.js
var elementNames, attributeNames;
var init_foreignNames = __esm(() => {
  elementNames = new Map([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "glyphRef",
    "linearGradient",
    "radialGradient",
    "textPath"
  ].map((val) => [val.toLowerCase(), val]));
  attributeNames = new Map([
    "definitionURL",
    "attributeName",
    "attributeType",
    "baseFrequency",
    "baseProfile",
    "calcMode",
    "clipPathUnits",
    "diffuseConstant",
    "edgeMode",
    "filterUnits",
    "glyphRef",
    "gradientTransform",
    "gradientUnits",
    "kernelMatrix",
    "kernelUnitLength",
    "keyPoints",
    "keySplines",
    "keyTimes",
    "lengthAdjust",
    "limitingConeAngle",
    "markerHeight",
    "markerUnits",
    "markerWidth",
    "maskContentUnits",
    "maskUnits",
    "numOctaves",
    "pathLength",
    "patternContentUnits",
    "patternTransform",
    "patternUnits",
    "pointsAtX",
    "pointsAtY",
    "pointsAtZ",
    "preserveAlpha",
    "preserveAspectRatio",
    "primitiveUnits",
    "refX",
    "refY",
    "repeatCount",
    "repeatDur",
    "requiredExtensions",
    "requiredFeatures",
    "specularConstant",
    "specularExponent",
    "spreadMethod",
    "startOffset",
    "stdDeviation",
    "stitchTiles",
    "surfaceScale",
    "systemLanguage",
    "tableValues",
    "targetX",
    "targetY",
    "textLength",
    "viewBox",
    "viewTarget",
    "xChannelSelector",
    "yChannelSelector",
    "zoomAndPan"
  ].map((val) => [val.toLowerCase(), val]));
});

// node_modules/dom-serializer/lib/esm/index.js
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a4;
  if (!attributes)
    return;
  const encode3 = ((_a4 = opts.encodeEntities) !== null && _a4 !== undefined ? _a4 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a5, _b2;
    const value = (_a5 = attributes[key]) !== null && _a5 !== undefined ? _a5 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b2 = attributeNames.get(key)) !== null && _b2 !== undefined ? _b2 : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode3(value)}"`;
  }).join(" ");
}
function render(node2, options = {}) {
  const nodes = "length" in node2 ? node2 : [node2];
  let output = "";
  for (let i2 = 0;i2 < nodes.length; i2++) {
    output += renderNode2(nodes[i2], options);
  }
  return output;
}
function renderNode2(node2, options) {
  switch (node2.type) {
    case Root:
      return render(node2.children, options);
    case Doctype:
    case Directive:
      return renderDirective(node2);
    case Comment:
      return renderComment(node2);
    case CDATA:
      return renderCdata(node2);
    case Script:
    case Style:
    case Tag:
      return renderTag(node2, options);
    case Text:
      return renderText(node2, options);
  }
}
function renderTag(elem, opts) {
  var _a4;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a4 = elementNames.get(elem.name)) !== null && _a4 !== undefined ? _a4 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag2 = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag2 += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
    if (!opts.xmlMode)
      tag2 += " ";
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children.length > 0) {
      tag2 += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag2 += `</${elem.name}>`;
    }
  }
  return tag2;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a4;
  let data = elem.data || "";
  if (((_a4 = opts.encodeEntities) !== null && _a4 !== undefined ? _a4 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data) : escapeText(data);
  }
  return data;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
var unencodedElements, singleTag, foreignModeIntegrationPoints, foreignElements;
var init_esm5 = __esm(() => {
  init_esm2();
  init_esm4();
  init_foreignNames();
  unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript"
  ]);
  singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title"
  ]);
  foreignElements = new Set(["svg", "math"]);
});

// node_modules/domutils/lib/esm/stringify.js
var init_stringify = () => {};

// node_modules/domutils/lib/esm/traversal.js
var init_traversal = () => {};

// node_modules/domutils/lib/esm/querying.js
var init_querying = () => {};

// node_modules/domutils/lib/esm/legacy.js
var init_legacy = () => {};

// node_modules/domutils/lib/esm/helpers.js
var DocumentPosition;
var init_helpers = __esm(() => {
  (function(DocumentPosition2) {
    DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
    DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
    DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
    DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
    DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
  })(DocumentPosition || (DocumentPosition = {}));
});

// node_modules/domutils/lib/esm/feeds.js
var init_feeds = () => {};

// node_modules/domutils/lib/esm/index.js
var init_esm6 = __esm(() => {
  init_stringify();
  init_traversal();
  init_querying();
  init_legacy();
  init_helpers();
  init_feeds();
});

// node_modules/htmlparser2/lib/esm/index.js
function parseDocument(data, options) {
  const handler = new DomHandler(undefined, options);
  new Parser(handler, options).end(data);
  return handler.root;
}
var init_esm7 = __esm(() => {
  init_Parser();
  init_esm3();
  init_esm2();
  init_esm6();
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE2 = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE2;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol2) {
      return Object.propertyIsEnumerable.call(target, symbol2);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object2, property) {
    try {
      return property in object2;
    } catch (_4) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array2, options) {
    if (!Array.isArray(array2)) {
      throw new Error("first argument should be an array");
    }
    return array2.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// node_modules/html-to-text/lib/html-to-text.mjs
function limitedDepthRecursive(n2, f, g2 = () => {
  return;
}) {
  if (n2 === undefined) {
    const f1 = function(...args) {
      return f(f1, ...args);
    };
    return f1;
  }
  if (n2 >= 0) {
    return function(...args) {
      return f(limitedDepthRecursive(n2 - 1, f, g2), ...args);
    };
  }
  return g2;
}
function trimCharacter(str, char2) {
  let start = 0;
  let end = str.length;
  while (start < end && str[start] === char2) {
    ++start;
  }
  while (end > start && str[end - 1] === char2) {
    --end;
  }
  return start > 0 || end < str.length ? str.substring(start, end) : str;
}
function trimCharacterEnd(str, char2) {
  let end = str.length;
  while (end > 0 && str[end - 1] === char2) {
    --end;
  }
  return end < str.length ? str.substring(0, end) : str;
}
function unicodeEscape(str) {
  return str.replace(/[\s\S]/g, (c2) => "\\u" + c2.charCodeAt().toString(16).padStart(4, "0"));
}
function mergeDuplicatesPreferLast(items, getKey) {
  const map5 = new Map;
  for (let i2 = items.length;i2-- > 0; ) {
    const item = items[i2];
    const key = getKey(item);
    map5.set(key, map5.has(key) ? import_deepmerge.default(item, map5.get(key), { arrayMerge: overwriteMerge$1 }) : item);
  }
  return [...map5.values()].reverse();
}
function get(obj, path) {
  for (const key of path) {
    if (!obj) {
      return;
    }
    obj = obj[key];
  }
  return obj;
}
function numberToLetterSequence(num, baseChar = "a", base = 26) {
  const digits = [];
  do {
    num -= 1;
    digits.push(num % base);
    num = num / base >> 0;
  } while (num > 0);
  const baseCode = baseChar.charCodeAt(0);
  return digits.reverse().map((n2) => String.fromCharCode(baseCode + n2)).join("");
}
function numberToRoman(num) {
  return [...num + ""].map((n2) => +n2).reverse().map((v3, i2) => v3 % 5 < 4 ? (v3 < 5 ? "" : V3[i2]) + I2[i2].repeat(v3 % 5) : I2[i2] + (v3 < 5 ? V3[i2] : I2[i2 + 1])).reverse().join("");
}

class InlineTextBuilder {
  constructor(options, maxLineLength = undefined) {
    this.lines = [];
    this.nextLineWords = [];
    this.maxLineLength = maxLineLength || options.wordwrap || Number.MAX_VALUE;
    this.nextLineAvailableChars = this.maxLineLength;
    this.wrapCharacters = get(options, ["longWordSplit", "wrapCharacters"]) || [];
    this.forceWrapOnLimit = get(options, ["longWordSplit", "forceWrapOnLimit"]) || false;
    this.stashedSpace = false;
    this.wordBreakOpportunity = false;
  }
  pushWord(word, noWrap = false) {
    if (this.nextLineAvailableChars <= 0 && !noWrap) {
      this.startNewLine();
    }
    const isLineStart = this.nextLineWords.length === 0;
    const cost = word.length + (isLineStart ? 0 : 1);
    if (cost <= this.nextLineAvailableChars || noWrap) {
      this.nextLineWords.push(word);
      this.nextLineAvailableChars -= cost;
    } else {
      const [first, ...rest] = this.splitLongWord(word);
      if (!isLineStart) {
        this.startNewLine();
      }
      this.nextLineWords.push(first);
      this.nextLineAvailableChars -= first.length;
      for (const part of rest) {
        this.startNewLine();
        this.nextLineWords.push(part);
        this.nextLineAvailableChars -= part.length;
      }
    }
  }
  popWord() {
    const lastWord = this.nextLineWords.pop();
    if (lastWord !== undefined) {
      const isLineStart = this.nextLineWords.length === 0;
      const cost = lastWord.length + (isLineStart ? 0 : 1);
      this.nextLineAvailableChars += cost;
    }
    return lastWord;
  }
  concatWord(word, noWrap = false) {
    if (this.wordBreakOpportunity && word.length > this.nextLineAvailableChars) {
      this.pushWord(word, noWrap);
      this.wordBreakOpportunity = false;
    } else {
      const lastWord = this.popWord();
      this.pushWord(lastWord ? lastWord.concat(word) : word, noWrap);
    }
  }
  startNewLine(n2 = 1) {
    this.lines.push(this.nextLineWords);
    if (n2 > 1) {
      this.lines.push(...Array.from({ length: n2 - 1 }, () => []));
    }
    this.nextLineWords = [];
    this.nextLineAvailableChars = this.maxLineLength;
  }
  isEmpty() {
    return this.lines.length === 0 && this.nextLineWords.length === 0;
  }
  clear() {
    this.lines.length = 0;
    this.nextLineWords.length = 0;
    this.nextLineAvailableChars = this.maxLineLength;
  }
  toString() {
    return [...this.lines, this.nextLineWords].map((words) => words.join(" ")).join(`
`);
  }
  splitLongWord(word) {
    const parts = [];
    let idx = 0;
    while (word.length > this.maxLineLength) {
      const firstLine = word.substring(0, this.maxLineLength);
      const remainingChars = word.substring(this.maxLineLength);
      const splitIndex = firstLine.lastIndexOf(this.wrapCharacters[idx]);
      if (splitIndex > -1) {
        word = firstLine.substring(splitIndex + 1) + remainingChars;
        parts.push(firstLine.substring(0, splitIndex + 1));
      } else {
        idx++;
        if (idx < this.wrapCharacters.length) {
          word = firstLine + remainingChars;
        } else {
          if (this.forceWrapOnLimit) {
            parts.push(firstLine);
            word = remainingChars;
            if (word.length > this.maxLineLength) {
              continue;
            }
          } else {
            word = firstLine + remainingChars;
          }
          break;
        }
      }
    }
    parts.push(word);
    return parts;
  }
}

class StackItem {
  constructor(next = null) {
    this.next = next;
  }
  getRoot() {
    return this.next ? this.next : this;
  }
}
function charactersToCodes(str) {
  return [...str].map((c2) => "\\u" + c2.charCodeAt(0).toString(16).padStart(4, "0")).join("");
}

class WhitespaceProcessor {
  constructor(options) {
    this.whitespaceChars = options.preserveNewlines ? options.whitespaceCharacters.replace(/\n/g, "") : options.whitespaceCharacters;
    const whitespaceCodes = charactersToCodes(this.whitespaceChars);
    this.leadingWhitespaceRe = new RegExp(`^[${whitespaceCodes}]`);
    this.trailingWhitespaceRe = new RegExp(`[${whitespaceCodes}]$`);
    this.allWhitespaceOrEmptyRe = new RegExp(`^[${whitespaceCodes}]*$`);
    this.newlineOrNonWhitespaceRe = new RegExp(`(\\n|[^\\n${whitespaceCodes}])`, "g");
    this.newlineOrNonNewlineStringRe = new RegExp(`(\\n|[^\\n]+)`, "g");
    if (options.preserveNewlines) {
      const wordOrNewlineRe = new RegExp(`\\n|[^\\n${whitespaceCodes}]+`, "gm");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform3 = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordOrNewlineRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (m[0] === `
`) {
            inlineTextBuilder.startNewLine();
          } else if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform3(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform3(m[0]), noWrap);
          }
          while ((m = wordOrNewlineRe.exec(text2)) !== null) {
            if (m[0] === `
`) {
              inlineTextBuilder.startNewLine();
            } else {
              inlineTextBuilder.pushWord(transform3(m[0]), noWrap);
            }
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    } else {
      const wordRe = new RegExp(`[^${whitespaceCodes}]+`, "g");
      this.shrinkWrapAdd = function(text2, inlineTextBuilder, transform3 = (str) => str, noWrap = false) {
        if (!text2) {
          return;
        }
        const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
        let anyMatch = false;
        let m = wordRe.exec(text2);
        if (m) {
          anyMatch = true;
          if (previouslyStashedSpace || this.testLeadingWhitespace(text2)) {
            inlineTextBuilder.pushWord(transform3(m[0]), noWrap);
          } else {
            inlineTextBuilder.concatWord(transform3(m[0]), noWrap);
          }
          while ((m = wordRe.exec(text2)) !== null) {
            inlineTextBuilder.pushWord(transform3(m[0]), noWrap);
          }
        }
        inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch || this.testTrailingWhitespace(text2);
      };
    }
  }
  addLiteral(text2, inlineTextBuilder, noWrap = true) {
    if (!text2) {
      return;
    }
    const previouslyStashedSpace = inlineTextBuilder.stashedSpace;
    let anyMatch = false;
    let m = this.newlineOrNonNewlineStringRe.exec(text2);
    if (m) {
      anyMatch = true;
      if (m[0] === `
`) {
        inlineTextBuilder.startNewLine();
      } else if (previouslyStashedSpace) {
        inlineTextBuilder.pushWord(m[0], noWrap);
      } else {
        inlineTextBuilder.concatWord(m[0], noWrap);
      }
      while ((m = this.newlineOrNonNewlineStringRe.exec(text2)) !== null) {
        if (m[0] === `
`) {
          inlineTextBuilder.startNewLine();
        } else {
          inlineTextBuilder.pushWord(m[0], noWrap);
        }
      }
    }
    inlineTextBuilder.stashedSpace = previouslyStashedSpace && !anyMatch;
  }
  testLeadingWhitespace(text2) {
    return this.leadingWhitespaceRe.test(text2);
  }
  testTrailingWhitespace(text2) {
    return this.trailingWhitespaceRe.test(text2);
  }
  testContainsWords(text2) {
    return !this.allWhitespaceOrEmptyRe.test(text2);
  }
  countNewlinesNoWords(text2) {
    this.newlineOrNonWhitespaceRe.lastIndex = 0;
    let counter = 0;
    let match;
    while ((match = this.newlineOrNonWhitespaceRe.exec(text2)) !== null) {
      if (match[0] === `
`) {
        counter++;
      } else {
        return 0;
      }
    }
    return counter;
  }
}

class BlockTextBuilder {
  constructor(options, picker, metadata = undefined) {
    this.options = options;
    this.picker = picker;
    this.metadata = metadata;
    this.whitespaceProcessor = new WhitespaceProcessor(options);
    this._stackItem = new BlockStackItem(options);
    this._wordTransformer = undefined;
  }
  pushWordTransform(wordTransform) {
    this._wordTransformer = new TransformerStackItem(this._wordTransformer, wordTransform);
  }
  popWordTransform() {
    if (!this._wordTransformer) {
      return;
    }
    const transform3 = this._wordTransformer.transform;
    this._wordTransformer = this._wordTransformer.next;
    return transform3;
  }
  startNoWrap() {
    this._stackItem.isNoWrap = true;
  }
  stopNoWrap() {
    this._stackItem.isNoWrap = false;
  }
  _getCombinedWordTransformer() {
    const wt3 = this._wordTransformer ? (str) => applyTransformer(str, this._wordTransformer) : undefined;
    const ce3 = this.options.encodeCharacters;
    return wt3 ? ce3 ? (str) => ce3(wt3(str)) : wt3 : ce3;
  }
  _popStackItem() {
    const item = this._stackItem;
    this._stackItem = item.next;
    return item;
  }
  addLineBreak() {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += `
`;
    } else {
      this._stackItem.inlineTextBuilder.startNewLine();
    }
  }
  addWordBreakOpportunity() {
    if (this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem) {
      this._stackItem.inlineTextBuilder.wordBreakOpportunity = true;
    }
  }
  addInline(str, { noWordTransform = false } = {}) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (str.length === 0 || this._stackItem.stashedLineBreaks && !this.whitespaceProcessor.testContainsWords(str)) {
      return;
    }
    if (this.options.preserveNewlines) {
      const newlinesNumber = this.whitespaceProcessor.countNewlinesNoWords(str);
      if (newlinesNumber > 0) {
        this._stackItem.inlineTextBuilder.startNewLine(newlinesNumber);
        return;
      }
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.shrinkWrapAdd(str, this._stackItem.inlineTextBuilder, noWordTransform ? undefined : this._getCombinedWordTransformer(), this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  addLiteral(str) {
    if (!(this._stackItem instanceof BlockStackItem || this._stackItem instanceof ListItemStackItem || this._stackItem instanceof TableCellStackItem)) {
      return;
    }
    if (str.length === 0) {
      return;
    }
    if (this._stackItem.isPre) {
      this._stackItem.rawText += str;
      return;
    }
    if (this._stackItem.stashedLineBreaks) {
      this._stackItem.inlineTextBuilder.startNewLine(this._stackItem.stashedLineBreaks);
    }
    this.whitespaceProcessor.addLiteral(str, this._stackItem.inlineTextBuilder, this._stackItem.isNoWrap);
    this._stackItem.stashedLineBreaks = 0;
  }
  openBlock({ leadingLineBreaks = 1, reservedLineLength = 0, isPre = false } = {}) {
    const maxLineLength = Math.max(20, this._stackItem.inlineTextBuilder.maxLineLength - reservedLineLength);
    this._stackItem = new BlockStackItem(this.options, this._stackItem, leadingLineBreaks, maxLineLength);
    if (isPre) {
      this._stackItem.isPre = true;
    }
  }
  closeBlock({ trailingLineBreaks = 1, blockTransform = undefined } = {}) {
    const block = this._popStackItem();
    const blockText = blockTransform ? blockTransform(getText(block)) : getText(block);
    addText(this._stackItem, blockText, block.leadingLineBreaks, Math.max(block.stashedLineBreaks, trailingLineBreaks));
  }
  openList({ maxPrefixLength = 0, prefixAlign = "left", interRowLineBreaks = 1, leadingLineBreaks = 2 } = {}) {
    this._stackItem = new ListStackItem(this.options, this._stackItem, {
      interRowLineBreaks,
      leadingLineBreaks,
      maxLineLength: this._stackItem.inlineTextBuilder.maxLineLength,
      maxPrefixLength,
      prefixAlign
    });
  }
  openListItem({ prefix: prefix2 = "" } = {}) {
    if (!(this._stackItem instanceof ListStackItem)) {
      throw new Error("Can't add a list item to something that is not a list! Check the formatter.");
    }
    const list = this._stackItem;
    const prefixLength = Math.max(prefix2.length, list.maxPrefixLength);
    const maxLineLength = Math.max(20, list.inlineTextBuilder.maxLineLength - prefixLength);
    this._stackItem = new ListItemStackItem(this.options, list, {
      prefix: prefix2,
      maxLineLength,
      leadingLineBreaks: list.interRowLineBreaks
    });
  }
  closeListItem() {
    const listItem = this._popStackItem();
    const list = listItem.next;
    const prefixLength = Math.max(listItem.prefix.length, list.maxPrefixLength);
    const spacing = `
` + " ".repeat(prefixLength);
    const prefix2 = list.prefixAlign === "right" ? listItem.prefix.padStart(prefixLength) : listItem.prefix.padEnd(prefixLength);
    const text2 = prefix2 + getText(listItem).replace(/\n/g, spacing);
    addText(list, text2, listItem.leadingLineBreaks, Math.max(listItem.stashedLineBreaks, list.interRowLineBreaks));
  }
  closeList({ trailingLineBreaks = 2 } = {}) {
    const list = this._popStackItem();
    const text2 = getText(list);
    if (text2) {
      addText(this._stackItem, text2, list.leadingLineBreaks, trailingLineBreaks);
    }
  }
  openTable() {
    this._stackItem = new TableStackItem(this._stackItem);
  }
  openTableRow() {
    if (!(this._stackItem instanceof TableStackItem)) {
      throw new Error("Can't add a table row to something that is not a table! Check the formatter.");
    }
    this._stackItem = new TableRowStackItem(this._stackItem);
  }
  openTableCell({ maxColumnWidth = undefined } = {}) {
    if (!(this._stackItem instanceof TableRowStackItem)) {
      throw new Error("Can't add a table cell to something that is not a table row! Check the formatter.");
    }
    this._stackItem = new TableCellStackItem(this.options, this._stackItem, maxColumnWidth);
  }
  closeTableCell({ colspan = 1, rowspan = 1 } = {}) {
    const cell = this._popStackItem();
    const text2 = trimCharacter(getText(cell), `
`);
    cell.next.cells.push({ colspan, rowspan, text: text2 });
  }
  closeTableRow() {
    const row = this._popStackItem();
    row.next.rows.push(row.cells);
  }
  closeTable({ tableToString, leadingLineBreaks = 2, trailingLineBreaks = 2 }) {
    const table = this._popStackItem();
    const output = tableToString(table.rows);
    if (output) {
      addText(this._stackItem, output, leadingLineBreaks, trailingLineBreaks);
    }
  }
  toString() {
    return getText(this._stackItem.getRoot());
  }
}
function getText(stackItem) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can be requested for text contents.");
  }
  return stackItem.inlineTextBuilder.isEmpty() ? stackItem.rawText : stackItem.rawText + stackItem.inlineTextBuilder.toString();
}
function addText(stackItem, text2, leadingLineBreaks, trailingLineBreaks) {
  if (!(stackItem instanceof BlockStackItem || stackItem instanceof ListItemStackItem || stackItem instanceof TableCellStackItem)) {
    throw new Error("Only blocks, list items and table cells can contain text.");
  }
  const parentText = getText(stackItem);
  const lineBreaks = Math.max(stackItem.stashedLineBreaks, leadingLineBreaks);
  stackItem.inlineTextBuilder.clear();
  if (parentText) {
    stackItem.rawText = parentText + `
`.repeat(lineBreaks) + text2;
  } else {
    stackItem.rawText = text2;
    stackItem.leadingLineBreaks = lineBreaks;
  }
  stackItem.stashedLineBreaks = trailingLineBreaks;
}
function applyTransformer(str, transformer) {
  return transformer ? applyTransformer(transformer.transform(str), transformer.next) : str;
}
function compile$1(options = {}) {
  const selectorsWithoutFormat = options.selectors.filter((s2) => !s2.format);
  if (selectorsWithoutFormat.length) {
    throw new Error("Following selectors have no specified format: " + selectorsWithoutFormat.map((s2) => `\`${s2.selector}\``).join(", "));
  }
  const picker = new DecisionTree(options.selectors.map((s2) => [s2.selector, s2])).build(hp2Builder);
  if (typeof options.encodeCharacters !== "function") {
    options.encodeCharacters = makeReplacerFromDict(options.encodeCharacters);
  }
  const baseSelectorsPicker = new DecisionTree(options.baseElements.selectors.map((s2, i2) => [s2, i2 + 1])).build(hp2Builder);
  function findBaseElements(dom) {
    return findBases(dom, options, baseSelectorsPicker);
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk, function(dom, builder) {
    builder.addInline(options.limits.ellipsis || "");
  });
  return function(html, metadata = undefined) {
    return process2(html, metadata, options, picker, findBaseElements, limitedWalk);
  };
}
function process2(html, metadata, options, picker, findBaseElements, walk) {
  const maxInputLength = options.limits.maxInputLength;
  if (maxInputLength && html && html.length > maxInputLength) {
    console.warn(`Input length ${html.length} is above allowed limit of ${maxInputLength}. Truncating without ellipsis.`);
    html = html.substring(0, maxInputLength);
  }
  const document2 = parseDocument(html, { decodeEntities: options.decodeEntities });
  const bases = findBaseElements(document2.children);
  const builder = new BlockTextBuilder(options, picker, metadata);
  walk(bases, builder);
  return builder.toString();
}
function findBases(dom, options, baseSelectorsPicker) {
  const results = [];
  function recursiveWalk(walk, dom2) {
    dom2 = dom2.slice(0, options.limits.maxChildNodes);
    for (const elem of dom2) {
      if (elem.type !== "tag") {
        continue;
      }
      const pickedSelectorIndex = baseSelectorsPicker.pick1(elem);
      if (pickedSelectorIndex > 0) {
        results.push({ selectorIndex: pickedSelectorIndex, element: elem });
      } else if (elem.children) {
        walk(elem.children);
      }
      if (results.length >= options.limits.maxBaseElements) {
        return;
      }
    }
  }
  const limitedWalk = limitedDepthRecursive(options.limits.maxDepth, recursiveWalk);
  limitedWalk(dom);
  if (options.baseElements.orderBy !== "occurrence") {
    results.sort((a, b5) => a.selectorIndex - b5.selectorIndex);
  }
  return options.baseElements.returnDomByDefault && results.length === 0 ? dom : results.map((x2) => x2.element);
}
function recursiveWalk(walk, dom, builder) {
  if (!dom) {
    return;
  }
  const options = builder.options;
  const tooManyChildNodes = dom.length > options.limits.maxChildNodes;
  if (tooManyChildNodes) {
    dom = dom.slice(0, options.limits.maxChildNodes);
    dom.push({
      data: options.limits.ellipsis,
      type: "text"
    });
  }
  for (const elem of dom) {
    switch (elem.type) {
      case "text": {
        builder.addInline(elem.data);
        break;
      }
      case "tag": {
        const tagDefinition = builder.picker.pick1(elem);
        const format = options.formatters[tagDefinition.format];
        format(elem, walk, builder, tagDefinition.options || {});
        break;
      }
    }
  }
  return;
}
function makeReplacerFromDict(dict) {
  if (!dict || Object.keys(dict).length === 0) {
    return;
  }
  const entries = Object.entries(dict).filter(([, v3]) => v3 !== false);
  const regex2 = new RegExp(entries.map(([c2]) => `(${unicodeEscape([...c2][0])})`).join("|"), "g");
  const values2 = entries.map(([, v3]) => v3);
  const replacer = (m, ...cgs) => values2[cgs.findIndex((cg) => cg)];
  return (str) => str.replace(regex2, replacer);
}
function formatSkip(elem, walk, builder, formatOptions) {}
function formatInlineString(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.string || "");
}
function formatBlockString(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addLiteral(formatOptions.string || "");
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInline(elem, walk, builder, formatOptions) {
  walk(elem.children, builder);
}
function formatBlock$1(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function renderOpenTag(elem) {
  const attrs = elem.attribs && elem.attribs.length ? " " + Object.entries(elem.attribs).map(([k4, v3]) => v3 === "" ? k4 : `${k4}=${v3.replace(/"/g, "&quot;")}`).join(" ") : "";
  return `<${elem.name}${attrs}>`;
}
function renderCloseTag(elem) {
  return `</${elem.name}>`;
}
function formatInlineTag(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
}
function formatBlockTag(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(renderOpenTag(elem));
  builder.stopNoWrap();
  walk(elem.children, builder);
  builder.startNoWrap();
  builder.addLiteral(renderCloseTag(elem));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineHtml(elem, walk, builder, formatOptions) {
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
}
function formatBlockHtml(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.startNoWrap();
  builder.addLiteral(render(elem, { decodeEntities: builder.options.decodeEntities }));
  builder.stopNoWrap();
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatInlineSurround(elem, walk, builder, formatOptions) {
  builder.addLiteral(formatOptions.prefix || "");
  walk(elem.children, builder);
  builder.addLiteral(formatOptions.suffix || "");
}
function getRow(matrix, j3) {
  if (!matrix[j3]) {
    matrix[j3] = [];
  }
  return matrix[j3];
}
function findFirstVacantIndex(row, x2 = 0) {
  while (row[x2]) {
    x2++;
  }
  return x2;
}
function transposeInPlace(matrix, maxSize) {
  for (let i2 = 0;i2 < maxSize; i2++) {
    const rowI = getRow(matrix, i2);
    for (let j3 = 0;j3 < i2; j3++) {
      const rowJ = getRow(matrix, j3);
      if (rowI[j3] || rowJ[i2]) {
        const temp = rowI[j3];
        rowI[j3] = rowJ[i2];
        rowJ[i2] = temp;
      }
    }
  }
}
function putCellIntoLayout(cell, layout, baseRow, baseCol) {
  for (let r2 = 0;r2 < cell.rowspan; r2++) {
    const layoutRow = getRow(layout, baseRow + r2);
    for (let c2 = 0;c2 < cell.colspan; c2++) {
      layoutRow[baseCol + c2] = cell;
    }
  }
}
function getOrInitOffset(offsets, index) {
  if (offsets[index] === undefined) {
    offsets[index] = index === 0 ? 0 : 1 + getOrInitOffset(offsets, index - 1);
  }
  return offsets[index];
}
function updateOffset(offsets, base, span, value) {
  offsets[base + span] = Math.max(getOrInitOffset(offsets, base + span), getOrInitOffset(offsets, base) + value);
}
function tableToString(tableRows, rowSpacing, colSpacing) {
  const layout = [];
  let colNumber = 0;
  const rowNumber = tableRows.length;
  const rowOffsets = [0];
  for (let j3 = 0;j3 < rowNumber; j3++) {
    const layoutRow = getRow(layout, j3);
    const cells = tableRows[j3];
    let x2 = 0;
    for (let i2 = 0;i2 < cells.length; i2++) {
      const cell = cells[i2];
      x2 = findFirstVacantIndex(layoutRow, x2);
      putCellIntoLayout(cell, layout, j3, x2);
      x2 += cell.colspan;
      cell.lines = cell.text.split(`
`);
      const cellHeight = cell.lines.length;
      updateOffset(rowOffsets, j3, cell.rowspan, cellHeight + rowSpacing);
    }
    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;
  }
  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);
  const outputLines = [];
  const colOffsets = [0];
  for (let x2 = 0;x2 < colNumber; x2++) {
    let y2 = 0;
    let cell;
    const rowsInThisColumn = Math.min(rowNumber, layout[x2].length);
    while (y2 < rowsInThisColumn) {
      cell = layout[x2][y2];
      if (cell) {
        if (!cell.rendered) {
          let cellWidth = 0;
          for (let j3 = 0;j3 < cell.lines.length; j3++) {
            const line2 = cell.lines[j3];
            const lineOffset = rowOffsets[y2] + j3;
            outputLines[lineOffset] = (outputLines[lineOffset] || "").padEnd(colOffsets[x2]) + line2;
            cellWidth = line2.length > cellWidth ? line2.length : cellWidth;
          }
          updateOffset(colOffsets, x2, cell.colspan, cellWidth + colSpacing);
          cell.rendered = true;
        }
        y2 += cell.rowspan;
      } else {
        const lineOffset = rowOffsets[y2];
        outputLines[lineOffset] = outputLines[lineOffset] || "";
        y2++;
      }
    }
  }
  return outputLines.join(`
`);
}
function formatLineBreak(elem, walk, builder, formatOptions) {
  builder.addLineBreak();
}
function formatWbr(elem, walk, builder, formatOptions) {
  builder.addWordBreakOpportunity();
}
function formatHorizontalLine(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  builder.addInline("-".repeat(formatOptions.length || builder.options.wordwrap || 40));
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatParagraph(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatPre(elem, walk, builder, formatOptions) {
  builder.openBlock({
    isPre: true,
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2
  });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatHeading(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks || 2 });
  if (formatOptions.uppercase !== false) {
    builder.pushWordTransform((str) => str.toUpperCase());
    walk(elem.children, builder);
    builder.popWordTransform();
  } else {
    walk(elem.children, builder);
  }
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks || 2 });
}
function formatBlockquote(elem, walk, builder, formatOptions) {
  builder.openBlock({
    leadingLineBreaks: formatOptions.leadingLineBreaks || 2,
    reservedLineLength: 2
  });
  walk(elem.children, builder);
  builder.closeBlock({
    trailingLineBreaks: formatOptions.trailingLineBreaks || 2,
    blockTransform: (str) => (formatOptions.trimEmptyLines !== false ? trimCharacter(str, `
`) : str).split(`
`).map((line2) => "> " + line2).join(`
`)
  });
}
function withBrackets(str, brackets) {
  if (!brackets) {
    return str;
  }
  const lbr = typeof brackets[0] === "string" ? brackets[0] : "[";
  const rbr = typeof brackets[1] === "string" ? brackets[1] : "]";
  return lbr + str + rbr;
}
function pathRewrite(path, rewriter, baseUrl, metadata, elem) {
  const modifiedPath = typeof rewriter === "function" ? rewriter(path, metadata, elem) : path;
  return modifiedPath[0] === "/" && baseUrl ? trimCharacterEnd(baseUrl, "/") + modifiedPath : modifiedPath;
}
function formatImage(elem, walk, builder, formatOptions) {
  const attribs = elem.attribs || {};
  const alt = attribs.alt ? attribs.alt : "";
  const src = !attribs.src ? "" : pathRewrite(attribs.src, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
  const text2 = !src ? alt : !alt ? withBrackets(src, formatOptions.linkBrackets) : alt + " " + withBrackets(src, formatOptions.linkBrackets);
  builder.addInline(text2, { noWordTransform: true });
}
function formatAnchor(elem, walk, builder, formatOptions) {
  function getHref() {
    if (formatOptions.ignoreHref) {
      return "";
    }
    if (!elem.attribs || !elem.attribs.href) {
      return "";
    }
    let href2 = elem.attribs.href.replace(/^mailto:/, "");
    if (formatOptions.noAnchorUrl && href2[0] === "#") {
      return "";
    }
    href2 = pathRewrite(href2, formatOptions.pathRewrite, formatOptions.baseUrl, builder.metadata, elem);
    return href2;
  }
  const href = getHref();
  if (!href) {
    walk(elem.children, builder);
  } else {
    let text2 = "";
    builder.pushWordTransform((str) => {
      if (str) {
        text2 += str;
      }
      return str;
    });
    walk(elem.children, builder);
    builder.popWordTransform();
    const hideSameLink = formatOptions.hideLinkHrefIfSameAsText && href === text2;
    if (!hideSameLink) {
      builder.addInline(!text2 ? href : " " + withBrackets(href, formatOptions.linkBrackets), { noWordTransform: true });
    }
  }
}
function formatList(elem, walk, builder, formatOptions, nextPrefixCallback) {
  const isNestedList = get(elem, ["parent", "name"]) === "li";
  let maxPrefixLength = 0;
  const listItems = (elem.children || []).filter((child) => child.type !== "text" || !/^\s*$/.test(child.data)).map(function(child) {
    if (child.name !== "li") {
      return { node: child, prefix: "" };
    }
    const prefix2 = isNestedList ? nextPrefixCallback().trimStart() : nextPrefixCallback();
    if (prefix2.length > maxPrefixLength) {
      maxPrefixLength = prefix2.length;
    }
    return { node: child, prefix: prefix2 };
  });
  if (!listItems.length) {
    return;
  }
  builder.openList({
    interRowLineBreaks: 1,
    leadingLineBreaks: isNestedList ? 1 : formatOptions.leadingLineBreaks || 2,
    maxPrefixLength,
    prefixAlign: "left"
  });
  for (const { node: node2, prefix: prefix2 } of listItems) {
    builder.openListItem({ prefix: prefix2 });
    walk([node2], builder);
    builder.closeListItem();
  }
  builder.closeList({ trailingLineBreaks: isNestedList ? 1 : formatOptions.trailingLineBreaks || 2 });
}
function formatUnorderedList(elem, walk, builder, formatOptions) {
  const prefix2 = formatOptions.itemPrefix || " * ";
  return formatList(elem, walk, builder, formatOptions, () => prefix2);
}
function formatOrderedList(elem, walk, builder, formatOptions) {
  let nextIndex = Number(elem.attribs.start || "1");
  const indexFunction = getOrderedListIndexFunction(elem.attribs.type);
  const nextPrefixCallback = () => " " + indexFunction(nextIndex++) + ". ";
  return formatList(elem, walk, builder, formatOptions, nextPrefixCallback);
}
function getOrderedListIndexFunction(olType = "1") {
  switch (olType) {
    case "a":
      return (i2) => numberToLetterSequence(i2, "a");
    case "A":
      return (i2) => numberToLetterSequence(i2, "A");
    case "i":
      return (i2) => numberToRoman(i2).toLowerCase();
    case "I":
      return (i2) => numberToRoman(i2);
    case "1":
    default:
      return (i2) => i2.toString();
  }
}
function splitClassesAndIds(selectors) {
  const classes = [];
  const ids = [];
  for (const selector of selectors) {
    if (selector.startsWith(".")) {
      classes.push(selector.substring(1));
    } else if (selector.startsWith("#")) {
      ids.push(selector.substring(1));
    }
  }
  return { classes, ids };
}
function isDataTable(attr, tables) {
  if (tables === true) {
    return true;
  }
  if (!attr) {
    return false;
  }
  const { classes, ids } = splitClassesAndIds(tables);
  const attrClasses = (attr["class"] || "").split(" ");
  const attrIds = (attr["id"] || "").split(" ");
  return attrClasses.some((x2) => classes.includes(x2)) || attrIds.some((x2) => ids.includes(x2));
}
function formatTable(elem, walk, builder, formatOptions) {
  return isDataTable(elem.attribs, builder.options.tables) ? formatDataTable(elem, walk, builder, formatOptions) : formatBlock(elem, walk, builder, formatOptions);
}
function formatBlock(elem, walk, builder, formatOptions) {
  builder.openBlock({ leadingLineBreaks: formatOptions.leadingLineBreaks });
  walk(elem.children, builder);
  builder.closeBlock({ trailingLineBreaks: formatOptions.trailingLineBreaks });
}
function formatDataTable(elem, walk, builder, formatOptions) {
  builder.openTable();
  elem.children.forEach(walkTable);
  builder.closeTable({
    tableToString: (rows) => tableToString(rows, formatOptions.rowSpacing ?? 0, formatOptions.colSpacing ?? 3),
    leadingLineBreaks: formatOptions.leadingLineBreaks,
    trailingLineBreaks: formatOptions.trailingLineBreaks
  });
  function formatCell(cellNode) {
    const colspan = +get(cellNode, ["attribs", "colspan"]) || 1;
    const rowspan = +get(cellNode, ["attribs", "rowspan"]) || 1;
    builder.openTableCell({ maxColumnWidth: formatOptions.maxColumnWidth });
    walk(cellNode.children, builder);
    builder.closeTableCell({ colspan, rowspan });
  }
  function walkTable(elem2) {
    if (elem2.type !== "tag") {
      return;
    }
    const formatHeaderCell = formatOptions.uppercaseHeaderCells !== false ? (cellNode) => {
      builder.pushWordTransform((str) => str.toUpperCase());
      formatCell(cellNode);
      builder.popWordTransform();
    } : formatCell;
    switch (elem2.name) {
      case "thead":
      case "tbody":
      case "tfoot":
      case "center":
        elem2.children.forEach(walkTable);
        return;
      case "tr": {
        builder.openTableRow();
        for (const childOfTr of elem2.children) {
          if (childOfTr.type !== "tag") {
            continue;
          }
          switch (childOfTr.name) {
            case "th": {
              formatHeaderCell(childOfTr);
              break;
            }
            case "td": {
              formatCell(childOfTr);
              break;
            }
          }
        }
        builder.closeTableRow();
        break;
      }
    }
  }
}
function compile2(options = {}) {
  options = import_deepmerge.default(DEFAULT_OPTIONS, options, {
    arrayMerge: overwriteMerge,
    customMerge: (key) => key === "selectors" ? selectorsMerge : undefined
  });
  options.formatters = Object.assign({}, genericFormatters, textFormatters, options.formatters);
  options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  handleDeprecatedOptions(options);
  return compile$1(options);
}
function convert2(html, options = {}, metadata = undefined) {
  return compile2(options)(html, metadata);
}
function handleDeprecatedOptions(options) {
  if (options.tags) {
    const tagDefinitions = Object.entries(options.tags).map(([selector, definition]) => ({ ...definition, selector: selector || "*" }));
    options.selectors.push(...tagDefinitions);
    options.selectors = mergeDuplicatesPreferLast(options.selectors, (s2) => s2.selector);
  }
  function set3(obj, path, value) {
    const valueKey = path.pop();
    for (const key of path) {
      let nested = obj[key];
      if (!nested) {
        nested = {};
        obj[key] = nested;
      }
      obj = nested;
    }
    obj[valueKey] = value;
  }
  if (options["baseElement"]) {
    const baseElement = options["baseElement"];
    set3(options, ["baseElements", "selectors"], Array.isArray(baseElement) ? baseElement : [baseElement]);
  }
  if (options["returnDomByDefault"] !== undefined) {
    set3(options, ["baseElements", "returnDomByDefault"], options["returnDomByDefault"]);
  }
  for (const definition of options.selectors) {
    if (definition.format === "anchor" && get(definition, ["options", "noLinkBrackets"])) {
      set3(definition, ["options", "linkBrackets"], false);
    }
  }
}
var import_deepmerge, overwriteMerge$1 = (acc, src, options) => [...src], I2, V3, BlockStackItem, ListStackItem, ListItemStackItem, TableStackItem, TableRowStackItem, TableCellStackItem, TransformerStackItem, genericFormatters, textFormatters, DEFAULT_OPTIONS, concatMerge = (acc, src, options) => [...acc, ...src], overwriteMerge = (acc, src, options) => [...src], selectorsMerge = (acc, src, options) => acc.some((s2) => typeof s2 === "object") ? concatMerge(acc, src) : overwriteMerge(acc, src);
var init_html_to_text = __esm(() => {
  init_hp2_builder();
  init_esm7();
  init_selderee();
  import_deepmerge = __toESM(require_cjs(), 1);
  init_esm5();
  I2 = ["I", "X", "C", "M"];
  V3 = ["V", "L", "D"];
  BlockStackItem = class BlockStackItem extends StackItem {
    constructor(options, next = null, leadingLineBreaks = 1, maxLineLength = undefined) {
      super(next);
      this.leadingLineBreaks = leadingLineBreaks;
      this.inlineTextBuilder = new InlineTextBuilder(options, maxLineLength);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  ListStackItem = class ListStackItem extends BlockStackItem {
    constructor(options, next = null, {
      interRowLineBreaks = 1,
      leadingLineBreaks = 2,
      maxLineLength = undefined,
      maxPrefixLength = 0,
      prefixAlign = "left"
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.maxPrefixLength = maxPrefixLength;
      this.prefixAlign = prefixAlign;
      this.interRowLineBreaks = interRowLineBreaks;
    }
  };
  ListItemStackItem = class ListItemStackItem extends BlockStackItem {
    constructor(options, next = null, {
      leadingLineBreaks = 1,
      maxLineLength = undefined,
      prefix: prefix2 = ""
    } = {}) {
      super(options, next, leadingLineBreaks, maxLineLength);
      this.prefix = prefix2;
    }
  };
  TableStackItem = class TableStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.rows = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TableRowStackItem = class TableRowStackItem extends StackItem {
    constructor(next = null) {
      super(next);
      this.cells = [];
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TableCellStackItem = class TableCellStackItem extends StackItem {
    constructor(options, next = null, maxColumnWidth = undefined) {
      super(next);
      this.inlineTextBuilder = new InlineTextBuilder(options, maxColumnWidth);
      this.rawText = "";
      this.stashedLineBreaks = 0;
      this.isPre = next && next.isPre;
      this.isNoWrap = next && next.isNoWrap;
    }
  };
  TransformerStackItem = class TransformerStackItem extends StackItem {
    constructor(next = null, transform3) {
      super(next);
      this.transform = transform3;
    }
  };
  genericFormatters = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block: formatBlock$1,
    blockHtml: formatBlockHtml,
    blockString: formatBlockString,
    blockTag: formatBlockTag,
    inline: formatInline,
    inlineHtml: formatInlineHtml,
    inlineString: formatInlineString,
    inlineSurround: formatInlineSurround,
    inlineTag: formatInlineTag,
    skip: formatSkip
  });
  textFormatters = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    anchor: formatAnchor,
    blockquote: formatBlockquote,
    dataTable: formatDataTable,
    heading: formatHeading,
    horizontalLine: formatHorizontalLine,
    image: formatImage,
    lineBreak: formatLineBreak,
    orderedList: formatOrderedList,
    paragraph: formatParagraph,
    pre: formatPre,
    table: formatTable,
    unorderedList: formatUnorderedList,
    wbr: formatWbr
  });
  DEFAULT_OPTIONS = {
    baseElements: {
      selectors: ["body"],
      orderBy: "selectors",
      returnDomByDefault: true
    },
    decodeEntities: true,
    encodeCharacters: {},
    formatters: {},
    limits: {
      ellipsis: "...",
      maxBaseElements: undefined,
      maxChildNodes: undefined,
      maxDepth: undefined,
      maxInputLength: 1 << 24
    },
    longWordSplit: {
      forceWrapOnLimit: false,
      wrapCharacters: []
    },
    preserveNewlines: false,
    selectors: [
      { selector: "*", format: "inline" },
      {
        selector: "a",
        format: "anchor",
        options: {
          baseUrl: null,
          hideLinkHrefIfSameAsText: false,
          ignoreHref: false,
          linkBrackets: ["[", "]"],
          noAnchorUrl: true
        }
      },
      { selector: "article", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "aside", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "blockquote",
        format: "blockquote",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2, trimEmptyLines: true }
      },
      { selector: "br", format: "lineBreak" },
      { selector: "div", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "footer", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "form", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "h1", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h2", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h3", format: "heading", options: { leadingLineBreaks: 3, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h4", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h5", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "h6", format: "heading", options: { leadingLineBreaks: 2, trailingLineBreaks: 2, uppercase: true } },
      { selector: "header", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "hr",
        format: "horizontalLine",
        options: { leadingLineBreaks: 2, length: undefined, trailingLineBreaks: 2 }
      },
      {
        selector: "img",
        format: "image",
        options: { baseUrl: null, linkBrackets: ["[", "]"] }
      },
      { selector: "main", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      { selector: "nav", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "ol",
        format: "orderedList",
        options: { leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "p", format: "paragraph", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "pre", format: "pre", options: { leadingLineBreaks: 2, trailingLineBreaks: 2 } },
      { selector: "section", format: "block", options: { leadingLineBreaks: 1, trailingLineBreaks: 1 } },
      {
        selector: "table",
        format: "table",
        options: {
          colSpacing: 3,
          leadingLineBreaks: 2,
          maxColumnWidth: 60,
          rowSpacing: 0,
          trailingLineBreaks: 2,
          uppercaseHeaderCells: true
        }
      },
      {
        selector: "ul",
        format: "unorderedList",
        options: { itemPrefix: " * ", leadingLineBreaks: 2, trailingLineBreaks: 2 }
      },
      { selector: "wbr", format: "wbr" }
    ],
    tables: [],
    whitespaceCharacters: ` 	\r
\f\u200B`,
    wordwrap: 80
  };
});

// node_modules/@react-email/render/dist/node/index.mjs
var exports_node = {};
__export(exports_node, {
  toPlainText: () => toPlainText,
  renderAsync: () => renderAsync,
  render: () => render2,
  pretty: () => pretty,
  plainTextSelectors: () => plainTextSelectors
});
import { Writable } from "stream";
function recursivelyMapDoc(doc2, callback) {
  if (Array.isArray(doc2))
    return doc2.map((innerDoc) => recursivelyMapDoc(innerDoc, callback));
  if (typeof doc2 === "object") {
    if (doc2.type === "group")
      return {
        ...doc2,
        contents: recursivelyMapDoc(doc2.contents, callback),
        expandedStates: recursivelyMapDoc(doc2.expandedStates, callback)
      };
    if ("contents" in doc2)
      return {
        ...doc2,
        contents: recursivelyMapDoc(doc2.contents, callback)
      };
    if ("parts" in doc2)
      return {
        ...doc2,
        parts: recursivelyMapDoc(doc2.parts, callback)
      };
    if (doc2.type === "if-break")
      return {
        ...doc2,
        breakContents: recursivelyMapDoc(doc2.breakContents, callback),
        flatContents: recursivelyMapDoc(doc2.flatContents, callback)
      };
  }
  return callback(doc2);
}
function toPlainText(html$1, options) {
  return convert2(html$1, {
    selectors: plainTextSelectors,
    wordwrap: false,
    ...options
  });
}
var import_react, import_jsx_runtime4, modifiedHtml, defaults, pretty = (str, options = {}) => {
  return fu(str.replaceAll("\x00", ""), {
    ...defaults,
    ...options
  });
}, plainTextSelectors, readStream = async (stream) => {
  let result = "";
  const decoder2 = new TextDecoder("utf-8");
  if ("pipeTo" in stream) {
    const writableStream = new WritableStream({
      write(chunk) {
        result += decoder2.decode(chunk, { stream: true });
      },
      close() {
        result += decoder2.decode();
      }
    });
    await stream.pipeTo(writableStream);
  } else {
    const writable = new Writable({
      write(chunk, _encoding, callback) {
        result += decoder2.decode(chunk, { stream: true });
        callback();
      },
      final(callback) {
        result += decoder2.decode();
        callback();
      }
    });
    stream.pipe(writable);
    await new Promise((resolve, reject) => {
      writable.on("error", reject);
      writable.on("close", () => {
        resolve();
      });
    });
  }
  return result;
}, render2 = async (node2, options) => {
  const suspendedElement = /* @__PURE__ */ import_jsx_runtime4.jsx(import_react.Suspense, { children: node2 });
  const reactDOMServer = await Promise.resolve().then(() => (init_server_bun(), exports_server_bun)).then((m) => m.default);
  let html$1;
  if (Object.hasOwn(reactDOMServer, "renderToReadableStream") && typeof WritableStream !== "undefined")
    html$1 = await readStream(await reactDOMServer.renderToReadableStream(suspendedElement, { progressiveChunkSize: Number.POSITIVE_INFINITY }));
  else
    await new Promise((resolve, reject) => {
      const stream = reactDOMServer.renderToPipeableStream(suspendedElement, {
        async onAllReady() {
          html$1 = await readStream(stream);
          resolve();
        },
        onError(error40) {
          reject(error40);
        },
        progressiveChunkSize: Number.POSITIVE_INFINITY
      });
    });
  if (options?.plainText)
    return toPlainText(html$1, options.htmlToTextOptions);
  const document2 = `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">${html$1.replace(/<!DOCTYPE.*?>/, "")}`;
  if (options?.pretty)
    return pretty(document2);
  return document2;
}, renderAsync = (element, options) => {
  return render2(element, options);
};
var init_node2 = __esm(() => {
  import_react = __toESM(require_react(), 1);
  init_html();
  init_standalone();
  init_html_to_text();
  import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
  modifiedHtml = { ...exports_html };
  if (modifiedHtml.printers) {
    const previousPrint = modifiedHtml.printers.html.print;
    modifiedHtml.printers.html.print = (path, options, print, args) => {
      const node2 = path.getNode();
      const rawPrintingResult = previousPrint(path, options, print, args);
      if (node2.type === "ieConditionalComment")
        return recursivelyMapDoc(rawPrintingResult, (doc2) => {
          if (typeof doc2 === "object" && doc2.type === "line")
            return doc2.soft ? "" : " ";
          return doc2;
        });
      return rawPrintingResult;
    };
  }
  defaults = {
    endOfLine: "lf",
    tabWidth: 2,
    plugins: [modifiedHtml],
    bracketSameLine: true,
    parser: "html"
  };
  plainTextSelectors = [
    {
      selector: "img",
      format: "skip"
    },
    {
      selector: "[data-skip-in-text=true]",
      format: "skip"
    },
    {
      selector: "a",
      options: {
        linkBrackets: false,
        hideLinkHrefIfSameAsText: true
      }
    }
  ];
});

// node_modules/svix/dist/models/applicationIn.js
var require_applicationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationInSerializer = undefined;
  exports.ApplicationInSerializer = {
    _fromJsonObject(object2) {
      return {
        metadata: object2["metadata"],
        name: object2["name"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/applicationOut.js
var require_applicationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationOutSerializer = undefined;
  exports.ApplicationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        id: object2["id"],
        metadata: object2["metadata"],
        name: object2["name"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        id: self2.id,
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/applicationPatch.js
var require_applicationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationPatchSerializer = undefined;
  exports.ApplicationPatchSerializer = {
    _fromJsonObject(object2) {
      return {
        metadata: object2["metadata"],
        name: object2["name"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"]
      };
    },
    _toJsonObject(self2) {
      return {
        metadata: self2.metadata,
        name: self2.name,
        rateLimit: self2.rateLimit,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseApplicationOut.js
var require_listResponseApplicationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseApplicationOutSerializer = undefined;
  var applicationOut_1 = require_applicationOut();
  exports.ListResponseApplicationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => applicationOut_1.ApplicationOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => applicationOut_1.ApplicationOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApiException = undefined;

  class ApiException extends Error {
    constructor(code, body, headers) {
      super(`HTTP-Code: ${code}
Headers: ${JSON.stringify(headers)}`);
      this.code = code;
      this.body = body;
      this.headers = {};
      headers.forEach((value, name2) => {
        this.headers[name2] = value;
      });
    }
  }
  exports.ApiException = ApiException;
});

// node_modules/svix/node_modules/uuid/dist/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default3 = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});

// node_modules/svix/node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default3 = exports.default = "00000000-0000-0000-0000-000000000000";
});

// node_modules/svix/node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default3 = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});

// node_modules/svix/node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex2 = _interopRequireDefault(require_regex());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function validate(uuid5) {
    return typeof uuid5 === "string" && _regex2.default.test(uuid5);
  }
  var _default3 = exports.default = validate;
});

// node_modules/svix/node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function parse7(uuid5) {
    if (!(0, _validate.default)(uuid5)) {
      throw TypeError("Invalid UUID");
    }
    let v3;
    const arr = new Uint8Array(16);
    arr[0] = (v3 = parseInt(uuid5.slice(0, 8), 16)) >>> 24;
    arr[1] = v3 >>> 16 & 255;
    arr[2] = v3 >>> 8 & 255;
    arr[3] = v3 & 255;
    arr[4] = (v3 = parseInt(uuid5.slice(9, 13), 16)) >>> 8;
    arr[5] = v3 & 255;
    arr[6] = (v3 = parseInt(uuid5.slice(14, 18), 16)) >>> 8;
    arr[7] = v3 & 255;
    arr[8] = (v3 = parseInt(uuid5.slice(19, 23), 16)) >>> 8;
    arr[9] = v3 & 255;
    arr[10] = (v3 = parseInt(uuid5.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v3 / 4294967296 & 255;
    arr[12] = v3 >>> 24 & 255;
    arr[13] = v3 >>> 16 & 255;
    arr[14] = v3 >>> 8 & 255;
    arr[15] = v3 & 255;
    return arr;
  }
  var _default3 = exports.default = parse7;
});

// node_modules/svix/node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var byteToHex = [];
  for (let i2 = 0;i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  function stringify3(arr, offset = 0) {
    const uuid5 = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid5)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid5;
  }
  var _default3 = exports.default = stringify3;
});

// node_modules/svix/node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/svix/node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i2 = buf && offset || 0;
    const b5 = buf || new Array(16);
    options = options || {};
    let node2 = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node2) {
        node2 = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node2 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node2 == null) {
        node2 = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node2[0] |= 1;
          _nodeId = node2;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === undefined && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt2 < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b5[i2++] = tl2 >>> 24 & 255;
    b5[i2++] = tl2 >>> 16 & 255;
    b5[i2++] = tl2 >>> 8 & 255;
    b5[i2++] = tl2 & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b5[i2++] = tmh >>> 8 & 255;
    b5[i2++] = tmh & 255;
    b5[i2++] = tmh >>> 24 & 15 | 16;
    b5[i2++] = tmh >>> 16 & 255;
    b5[i2++] = clockseq >>> 8 | 128;
    b5[i2++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b5[i2 + n2] = node2[n2];
    }
    return buf || (0, _stringify.unsafeStringify)(b5);
  }
  var _default3 = exports.default = v1;
});

// node_modules/svix/node_modules/uuid/dist/v1ToV6.js
var require_v1ToV6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v1ToV6;
  var _parse2 = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function v1ToV6(uuid5) {
    const v1Bytes = typeof uuid5 === "string" ? (0, _parse2.default)(uuid5) : uuid5;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid5 === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  function _v1ToV6(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
});

// node_modules/svix/node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse2 = _interopRequireDefault(require_parse());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function stringToBytes2(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      bytes.push(str.charCodeAt(i2));
    }
    return bytes;
  }
  var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL2 = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35(name2, version4, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes2(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse2.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version4;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0;i2 < 16; ++i2) {
          buf[offset + i2] = bytes[i2];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name2;
    } catch (err2) {}
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/svix/node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function md52(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  }
  var _default3 = exports.default = md52;
});

// node_modules/svix/node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default3 = exports.default = v3;
});

// node_modules/svix/node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var _default3 = exports.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
});

// node_modules/svix/node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0;i2 < 16; ++i2) {
        buf[offset + i2] = rnds[i2];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default3 = exports.default = v4;
});

// node_modules/svix/node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(__require("crypto"));
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default3 = exports.default = sha1;
});

// node_modules/svix/node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default3 = exports.default = v5;
});

// node_modules/svix/node_modules/uuid/dist/v6.js
var require_v6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6;
  var _stringify = require_stringify();
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function v6(options = {}, buf, offset = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i2 = 0;i2 < 16; i2++) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  }
});

// node_modules/svix/node_modules/uuid/dist/v6ToV1.js
var require_v6ToV1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6ToV1;
  var _parse2 = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function v6ToV1(uuid5) {
    const v6Bytes = typeof uuid5 === "string" ? (0, _parse2.default)(uuid5) : uuid5;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid5 === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
});

// node_modules/svix/node_modules/uuid/dist/v7.js
var require_v7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  var _seqLow = null;
  var _seqHigh = null;
  var _msecs = 0;
  function v7(options, buf, offset) {
    options = options || {};
    let i2 = buf && offset || 0;
    const b5 = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let seq = options.seq !== undefined ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === undefined) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b5[i2++] = _msecs / 1099511627776 & 255;
    b5[i2++] = _msecs / 4294967296 & 255;
    b5[i2++] = _msecs / 16777216 & 255;
    b5[i2++] = _msecs / 65536 & 255;
    b5[i2++] = _msecs / 256 & 255;
    b5[i2++] = _msecs & 255;
    b5[i2++] = seqHigh >>> 4 & 15 | 112;
    b5[i2++] = seqHigh & 255;
    b5[i2++] = seqLow >>> 13 & 63 | 128;
    b5[i2++] = seqLow >>> 5 & 255;
    b5[i2++] = seqLow << 3 & 255 | rnds[10] & 7;
    b5[i2++] = rnds[11];
    b5[i2++] = rnds[12];
    b5[i2++] = rnds[13];
    b5[i2++] = rnds[14];
    b5[i2++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b5);
  }
  var _default3 = exports.default = v7;
});

// node_modules/svix/node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
  function version4(uuid5) {
    if (!(0, _validate.default)(uuid5)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid5.slice(14, 15), 16);
  }
  var _default3 = exports.default = version4;
});

// node_modules/svix/node_modules/uuid/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "MAX", {
    enumerable: true,
    get: function() {
      return _max.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse2.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v1ToV6", {
    enumerable: true,
    get: function() {
      return _v1ToV.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "v6", {
    enumerable: true,
    get: function() {
      return _v5.default;
    }
  });
  Object.defineProperty(exports, "v6ToV1", {
    enumerable: true,
    get: function() {
      return _v6ToV.default;
    }
  });
  Object.defineProperty(exports, "v7", {
    enumerable: true,
    get: function() {
      return _v6.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _max = _interopRequireDefault(require_max());
  var _nil = _interopRequireDefault(require_nil());
  var _parse2 = _interopRequireDefault(require_parse());
  var _stringify = _interopRequireDefault(require_stringify());
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _v5 = _interopRequireDefault(require_v6());
  var _v6ToV = _interopRequireDefault(require_v6ToV1());
  var _v6 = _interopRequireDefault(require_v7());
  var _validate = _interopRequireDefault(require_validate());
  var _version = _interopRequireDefault(require_version());
  function _interopRequireDefault(e2) {
    return e2 && e2.__esModule ? e2 : { default: e2 };
  }
});

// node_modules/svix/dist/request.js
var require_request = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixRequest = exports.HttpMethod = exports.LIB_VERSION = undefined;
  var util_1 = require_util();
  var uuid_1 = require_dist2();
  exports.LIB_VERSION = "1.76.1";
  var USER_AGENT = `svix-libs/${exports.LIB_VERSION}/javascript`;
  var HttpMethod;
  (function(HttpMethod2) {
    HttpMethod2["GET"] = "GET";
    HttpMethod2["HEAD"] = "HEAD";
    HttpMethod2["POST"] = "POST";
    HttpMethod2["PUT"] = "PUT";
    HttpMethod2["DELETE"] = "DELETE";
    HttpMethod2["CONNECT"] = "CONNECT";
    HttpMethod2["OPTIONS"] = "OPTIONS";
    HttpMethod2["TRACE"] = "TRACE";
    HttpMethod2["PATCH"] = "PATCH";
  })(HttpMethod = exports.HttpMethod || (exports.HttpMethod = {}));

  class SvixRequest {
    constructor(method, path) {
      this.method = method;
      this.path = path;
      this.queryParams = {};
      this.headerParams = {};
    }
    setPathParam(name2, value) {
      const newPath = this.path.replace(`{${name2}}`, encodeURIComponent(value));
      if (this.path === newPath) {
        throw new Error(`path parameter ${name2} not found`);
      }
      this.path = newPath;
    }
    setQueryParam(name2, value) {
      if (value === undefined || value === null) {
        return;
      }
      if (typeof value === "string") {
        this.queryParams[name2] = value;
      } else if (typeof value === "boolean" || typeof value === "number") {
        this.queryParams[name2] = value.toString();
      } else if (value instanceof Date) {
        this.queryParams[name2] = value.toISOString();
      } else if (value instanceof Array) {
        if (value.length > 0) {
          this.queryParams[name2] = value.join(",");
        }
      } else {
        const _assert_unreachable = value;
        throw new Error(`query parameter ${name2} has unsupported type`);
      }
    }
    setHeaderParam(name2, value) {
      if (value === undefined) {
        return;
      }
      this.headerParams[name2] = value;
    }
    setBody(value) {
      this.body = JSON.stringify(value);
    }
    send(ctx, parseResponseBody) {
      return __awaiter(this, undefined, undefined, function* () {
        const response = yield this.sendInner(ctx);
        if (response.status == 204) {
          return null;
        }
        const responseBody = yield response.text();
        return parseResponseBody(JSON.parse(responseBody));
      });
    }
    sendNoResponseBody(ctx) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.sendInner(ctx);
      });
    }
    sendInner(ctx) {
      var _a5, _b2;
      return __awaiter(this, undefined, undefined, function* () {
        const url2 = new URL(ctx.baseUrl + this.path);
        for (const [name2, value] of Object.entries(this.queryParams)) {
          url2.searchParams.set(name2, value);
        }
        if (this.headerParams["idempotency-key"] === undefined && this.method.toUpperCase() === "POST") {
          this.headerParams["idempotency-key"] = "auto_" + (0, uuid_1.v4)();
        }
        const randomId2 = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        if (this.body != null) {
          this.headerParams["content-type"] = "application/json";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        const response = yield sendWithRetry(url2, {
          method: this.method.toString(),
          body: this.body,
          headers: Object.assign({ accept: "application/json, */*;q=0.8", authorization: `Bearer ${ctx.token}`, "user-agent": USER_AGENT, "svix-req-id": randomId2.toString() }, this.headerParams),
          credentials: isCredentialsSupported ? "same-origin" : undefined,
          signal: ctx.timeout !== undefined ? AbortSignal.timeout(ctx.timeout) : undefined
        }, ctx.retryScheduleInMs, (_a5 = ctx.retryScheduleInMs) === null || _a5 === undefined ? undefined : _a5[0], ((_b2 = ctx.retryScheduleInMs) === null || _b2 === undefined ? undefined : _b2.length) || ctx.numRetries);
        return filterResponseForErrors(response);
      });
    }
  }
  exports.SvixRequest = SvixRequest;
  function filterResponseForErrors(response) {
    return __awaiter(this, undefined, undefined, function* () {
      if (response.status < 300) {
        return response;
      }
      const responseBody = yield response.text();
      if (response.status === 422) {
        throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
      }
      if (response.status >= 400 && response.status <= 499) {
        throw new util_1.ApiException(response.status, JSON.parse(responseBody), response.headers);
      }
      throw new util_1.ApiException(response.status, responseBody, response.headers);
    });
  }
  function sendWithRetry(url2, init, retryScheduleInMs, nextInterval = 50, triesLeft = 2, retryCount = 1) {
    return __awaiter(this, undefined, undefined, function* () {
      const sleep = (interval2) => new Promise((resolve) => setTimeout(resolve, interval2));
      try {
        const response = yield fetch(url2, init);
        if (triesLeft <= 0 || response.status < 500) {
          return response;
        }
      } catch (e2) {
        if (triesLeft <= 0) {
          throw e2;
        }
      }
      yield sleep(nextInterval);
      init.headers["svix-retry-count"] = retryCount.toString();
      nextInterval = (retryScheduleInMs === null || retryScheduleInMs === undefined ? undefined : retryScheduleInMs[retryCount]) || nextInterval * 2;
      return yield sendWithRetry(url2, init, retryScheduleInMs, nextInterval, --triesLeft, ++retryCount);
    });
  }
});

// node_modules/svix/dist/api/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Application = undefined;
  var applicationIn_1 = require_applicationIn();
  var applicationOut_1 = require_applicationOut();
  var applicationPatch_1 = require_applicationPatch();
  var listResponseApplicationOut_1 = require_listResponseApplicationOut();
  var request_1 = require_request();

  class Application {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app");
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseApplicationOut_1.ListResponseApplicationOutSerializer._fromJsonObject);
    }
    create(applicationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    getOrCreate(applicationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app");
      request.setQueryParam("get_if_exists", true);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    get(appId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    update(appId, applicationIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      request.setBody(applicationIn_1.ApplicationInSerializer._toJsonObject(applicationIn));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
    delete(appId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, applicationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}");
      request.setPathParam("app_id", appId);
      request.setBody(applicationPatch_1.ApplicationPatchSerializer._toJsonObject(applicationPatch));
      return request.send(this.requestCtx, applicationOut_1.ApplicationOutSerializer._fromJsonObject);
    }
  }
  exports.Application = Application;
});

// node_modules/svix/dist/models/appPortalCapability.js
var require_appPortalCapability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalCapabilitySerializer = exports.AppPortalCapability = undefined;
  var AppPortalCapability;
  (function(AppPortalCapability2) {
    AppPortalCapability2["ViewBase"] = "ViewBase";
    AppPortalCapability2["ViewEndpointSecret"] = "ViewEndpointSecret";
    AppPortalCapability2["ManageEndpointSecret"] = "ManageEndpointSecret";
    AppPortalCapability2["ManageTransformations"] = "ManageTransformations";
    AppPortalCapability2["CreateAttempts"] = "CreateAttempts";
    AppPortalCapability2["ManageEndpoint"] = "ManageEndpoint";
  })(AppPortalCapability = exports.AppPortalCapability || (exports.AppPortalCapability = {}));
  exports.AppPortalCapabilitySerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/appPortalAccessIn.js
var require_appPortalAccessIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalAccessInSerializer = undefined;
  var appPortalCapability_1 = require_appPortalCapability();
  var applicationIn_1 = require_applicationIn();
  exports.AppPortalAccessInSerializer = {
    _fromJsonObject(object2) {
      var _a5;
      return {
        application: object2["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object2["application"]) : undefined,
        capabilities: (_a5 = object2["capabilities"]) === null || _a5 === undefined ? undefined : _a5.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._fromJsonObject(item)),
        expiry: object2["expiry"],
        featureFlags: object2["featureFlags"],
        readOnly: object2["readOnly"],
        sessionId: object2["sessionId"]
      };
    },
    _toJsonObject(self2) {
      var _a5;
      return {
        application: self2.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self2.application) : undefined,
        capabilities: (_a5 = self2.capabilities) === null || _a5 === undefined ? undefined : _a5.map((item) => appPortalCapability_1.AppPortalCapabilitySerializer._toJsonObject(item)),
        expiry: self2.expiry,
        featureFlags: self2.featureFlags,
        readOnly: self2.readOnly,
        sessionId: self2.sessionId
      };
    }
  };
});

// node_modules/svix/dist/models/appPortalAccessOut.js
var require_appPortalAccessOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppPortalAccessOutSerializer = undefined;
  exports.AppPortalAccessOutSerializer = {
    _fromJsonObject(object2) {
      return {
        token: object2["token"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        token: self2.token,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/applicationTokenExpireIn.js
var require_applicationTokenExpireIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationTokenExpireInSerializer = undefined;
  exports.ApplicationTokenExpireInSerializer = {
    _fromJsonObject(object2) {
      return {
        expiry: object2["expiry"],
        sessionIds: object2["sessionIds"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        sessionIds: self2.sessionIds
      };
    }
  };
});

// node_modules/svix/dist/models/dashboardAccessOut.js
var require_dashboardAccessOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DashboardAccessOutSerializer = undefined;
  exports.DashboardAccessOutSerializer = {
    _fromJsonObject(object2) {
      return {
        token: object2["token"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        token: self2.token,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/api/authentication.js
var require_authentication = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Authentication = undefined;
  var appPortalAccessIn_1 = require_appPortalAccessIn();
  var appPortalAccessOut_1 = require_appPortalAccessOut();
  var applicationTokenExpireIn_1 = require_applicationTokenExpireIn();
  var dashboardAccessOut_1 = require_dashboardAccessOut();
  var request_1 = require_request();

  class Authentication {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    appPortalAccess(appId, appPortalAccessIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app-portal-access/{app_id}");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(appPortalAccessIn_1.AppPortalAccessInSerializer._toJsonObject(appPortalAccessIn));
      return request.send(this.requestCtx, appPortalAccessOut_1.AppPortalAccessOutSerializer._fromJsonObject);
    }
    expireAll(appId, applicationTokenExpireIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/app/{app_id}/expire-all");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(applicationTokenExpireIn_1.ApplicationTokenExpireInSerializer._toJsonObject(applicationTokenExpireIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    dashboardAccess(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/dashboard-access/{app_id}");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
    logout(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/auth/logout");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Authentication = Authentication;
});

// node_modules/svix/dist/models/backgroundTaskStatus.js
var require_backgroundTaskStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskStatusSerializer = exports.BackgroundTaskStatus = undefined;
  var BackgroundTaskStatus;
  (function(BackgroundTaskStatus2) {
    BackgroundTaskStatus2["Running"] = "running";
    BackgroundTaskStatus2["Finished"] = "finished";
    BackgroundTaskStatus2["Failed"] = "failed";
  })(BackgroundTaskStatus = exports.BackgroundTaskStatus || (exports.BackgroundTaskStatus = {}));
  exports.BackgroundTaskStatusSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/backgroundTaskType.js
var require_backgroundTaskType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskTypeSerializer = exports.BackgroundTaskType = undefined;
  var BackgroundTaskType;
  (function(BackgroundTaskType2) {
    BackgroundTaskType2["EndpointReplay"] = "endpoint.replay";
    BackgroundTaskType2["EndpointRecover"] = "endpoint.recover";
    BackgroundTaskType2["ApplicationStats"] = "application.stats";
    BackgroundTaskType2["MessageBroadcast"] = "message.broadcast";
    BackgroundTaskType2["SdkGenerate"] = "sdk.generate";
    BackgroundTaskType2["EventTypeAggregate"] = "event-type.aggregate";
    BackgroundTaskType2["ApplicationPurgeContent"] = "application.purge_content";
  })(BackgroundTaskType = exports.BackgroundTaskType || (exports.BackgroundTaskType = {}));
  exports.BackgroundTaskTypeSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/backgroundTaskOut.js
var require_backgroundTaskOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTaskOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.BackgroundTaskOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"],
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data,
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseBackgroundTaskOut.js
var require_listResponseBackgroundTaskOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseBackgroundTaskOutSerializer = undefined;
  var backgroundTaskOut_1 = require_backgroundTaskOut();
  exports.ListResponseBackgroundTaskOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => backgroundTaskOut_1.BackgroundTaskOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/backgroundTask.js
var require_backgroundTask = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BackgroundTask = undefined;
  var backgroundTaskOut_1 = require_backgroundTaskOut();
  var listResponseBackgroundTaskOut_1 = require_listResponseBackgroundTaskOut();
  var request_1 = require_request();

  class BackgroundTask {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task");
      request.setQueryParam("status", options === null || options === undefined ? undefined : options.status);
      request.setQueryParam("task", options === null || options === undefined ? undefined : options.task);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseBackgroundTaskOut_1.ListResponseBackgroundTaskOutSerializer._fromJsonObject);
    }
    listByEndpoint(options) {
      return this.list(options);
    }
    get(taskId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/background-task/{task_id}");
      request.setPathParam("task_id", taskId);
      return request.send(this.requestCtx, backgroundTaskOut_1.BackgroundTaskOutSerializer._fromJsonObject);
    }
  }
  exports.BackgroundTask = BackgroundTask;
});

// node_modules/svix/dist/models/endpointHeadersIn.js
var require_endpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersInSerializer = undefined;
  exports.EndpointHeadersInSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/endpointHeadersOut.js
var require_endpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersOutSerializer = undefined;
  exports.EndpointHeadersOutSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"],
        sensitive: object2["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/endpointHeadersPatchIn.js
var require_endpointHeadersPatchIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointHeadersPatchInSerializer = undefined;
  exports.EndpointHeadersPatchInSerializer = {
    _fromJsonObject(object2) {
      return {
        deleteHeaders: object2["deleteHeaders"],
        headers: object2["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        deleteHeaders: self2.deleteHeaders,
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/endpointIn.js
var require_endpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointInSerializer = undefined;
  exports.EndpointInSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        headers: object2["headers"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        secret: object2["secret"],
        uid: object2["uid"],
        url: object2["url"],
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        headers: self2.headers,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointOut.js
var require_endpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointOutSerializer = undefined;
  exports.EndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        createdAt: new Date(object2["createdAt"]),
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        id: object2["id"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"]),
        url: object2["url"],
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointPatch.js
var require_endpointPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointPatchSerializer = undefined;
  exports.EndpointPatchSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        secret: object2["secret"],
        uid: object2["uid"],
        url: object2["url"],
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/endpointSecretOut.js
var require_endpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointSecretOutSerializer = undefined;
  exports.EndpointSecretOutSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/endpointSecretRotateIn.js
var require_endpointSecretRotateIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointSecretRotateInSerializer = undefined;
  exports.EndpointSecretRotateInSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/endpointStats.js
var require_endpointStats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointStatsSerializer = undefined;
  exports.EndpointStatsSerializer = {
    _fromJsonObject(object2) {
      return {
        fail: object2["fail"],
        pending: object2["pending"],
        sending: object2["sending"],
        success: object2["success"]
      };
    },
    _toJsonObject(self2) {
      return {
        fail: self2.fail,
        pending: self2.pending,
        sending: self2.sending,
        success: self2.success
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationIn.js
var require_endpointTransformationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationInSerializer = undefined;
  exports.EndpointTransformationInSerializer = {
    _fromJsonObject(object2) {
      return {
        code: object2["code"],
        enabled: object2["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationOut.js
var require_endpointTransformationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationOutSerializer = undefined;
  exports.EndpointTransformationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        code: object2["code"],
        enabled: object2["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/endpointTransformationPatch.js
var require_endpointTransformationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointTransformationPatchSerializer = undefined;
  exports.EndpointTransformationPatchSerializer = {
    _fromJsonObject(object2) {
      return {
        code: object2["code"],
        enabled: object2["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/endpointUpdate.js
var require_endpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointUpdateSerializer = undefined;
  exports.EndpointUpdateSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        url: object2["url"],
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/eventExampleIn.js
var require_eventExampleIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventExampleInSerializer = undefined;
  exports.EventExampleInSerializer = {
    _fromJsonObject(object2) {
      return {
        eventType: object2["eventType"],
        exampleIndex: object2["exampleIndex"]
      };
    },
    _toJsonObject(self2) {
      return {
        eventType: self2.eventType,
        exampleIndex: self2.exampleIndex
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEndpointOut.js
var require_listResponseEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEndpointOutSerializer = undefined;
  var endpointOut_1 = require_endpointOut();
  exports.ListResponseEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => endpointOut_1.EndpointOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => endpointOut_1.EndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageOut.js
var require_messageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageOutSerializer = undefined;
  exports.MessageOutSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        eventId: object2["eventId"],
        eventType: object2["eventType"],
        id: object2["id"],
        payload: object2["payload"],
        tags: object2["tags"],
        timestamp: new Date(object2["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        eventId: self2.eventId,
        eventType: self2.eventType,
        id: self2.id,
        payload: self2.payload,
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/recoverIn.js
var require_recoverIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecoverInSerializer = undefined;
  exports.RecoverInSerializer = {
    _fromJsonObject(object2) {
      return {
        since: new Date(object2["since"]),
        until: object2["until"] ? new Date(object2["until"]) : null
      };
    },
    _toJsonObject(self2) {
      return {
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/recoverOut.js
var require_recoverOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RecoverOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.RecoverOutSerializer = {
    _fromJsonObject(object2) {
      return {
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/replayIn.js
var require_replayIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplayInSerializer = undefined;
  exports.ReplayInSerializer = {
    _fromJsonObject(object2) {
      return {
        since: new Date(object2["since"]),
        until: object2["until"] ? new Date(object2["until"]) : null
      };
    },
    _toJsonObject(self2) {
      return {
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/replayOut.js
var require_replayOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplayOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.ReplayOutSerializer = {
    _fromJsonObject(object2) {
      return {
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/api/endpoint.js
var require_endpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Endpoint = undefined;
  var endpointHeadersIn_1 = require_endpointHeadersIn();
  var endpointHeadersOut_1 = require_endpointHeadersOut();
  var endpointHeadersPatchIn_1 = require_endpointHeadersPatchIn();
  var endpointIn_1 = require_endpointIn();
  var endpointOut_1 = require_endpointOut();
  var endpointPatch_1 = require_endpointPatch();
  var endpointSecretOut_1 = require_endpointSecretOut();
  var endpointSecretRotateIn_1 = require_endpointSecretRotateIn();
  var endpointStats_1 = require_endpointStats();
  var endpointTransformationIn_1 = require_endpointTransformationIn();
  var endpointTransformationOut_1 = require_endpointTransformationOut();
  var endpointTransformationPatch_1 = require_endpointTransformationPatch();
  var endpointUpdate_1 = require_endpointUpdate();
  var eventExampleIn_1 = require_eventExampleIn();
  var listResponseEndpointOut_1 = require_listResponseEndpointOut();
  var messageOut_1 = require_messageOut();
  var recoverIn_1 = require_recoverIn();
  var recoverOut_1 = require_recoverOut();
  var replayIn_1 = require_replayIn();
  var replayOut_1 = require_replayOut();
  var request_1 = require_request();

  class Endpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseEndpointOut_1.ListResponseEndpointOutSerializer._fromJsonObject);
    }
    create(appId, endpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(endpointIn_1.EndpointInSerializer._toJsonObject(endpointIn));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    get(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    update(appId, endpointId, endpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointUpdate_1.EndpointUpdateSerializer._toJsonObject(endpointUpdate));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    delete(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(appId, endpointId, endpointPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointPatch_1.EndpointPatchSerializer._toJsonObject(endpointPatch));
      return request.send(this.requestCtx, endpointOut_1.EndpointOutSerializer._fromJsonObject);
    }
    getHeaders(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointHeadersOut_1.EndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(appId, endpointId, endpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointHeadersIn_1.EndpointHeadersInSerializer._toJsonObject(endpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    headersUpdate(appId, endpointId, endpointHeadersIn) {
      return this.updateHeaders(appId, endpointId, endpointHeadersIn);
    }
    patchHeaders(appId, endpointId, endpointHeadersPatchIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointHeadersPatchIn_1.EndpointHeadersPatchInSerializer._toJsonObject(endpointHeadersPatchIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    headersPatch(appId, endpointId, endpointHeadersPatchIn) {
      return this.patchHeaders(appId, endpointId, endpointHeadersPatchIn);
    }
    recover(appId, endpointId, recoverIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/recover");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(recoverIn_1.RecoverInSerializer._toJsonObject(recoverIn));
      return request.send(this.requestCtx, recoverOut_1.RecoverOutSerializer._fromJsonObject);
    }
    replayMissing(appId, endpointId, replayIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/replay-missing");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(replayIn_1.ReplayInSerializer._toJsonObject(replayIn));
      return request.send(this.requestCtx, replayOut_1.ReplayOutSerializer._fromJsonObject);
    }
    getSecret(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointSecretOut_1.EndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(appId, endpointId, endpointSecretRotateIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(endpointSecretRotateIn_1.EndpointSecretRotateInSerializer._toJsonObject(endpointSecretRotateIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    sendExample(appId, endpointId, eventExampleIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/send-example");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventExampleIn_1.EventExampleInSerializer._toJsonObject(eventExampleIn));
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    getStats(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/stats");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParam("since", options === null || options === undefined ? undefined : options.since);
      request.setQueryParam("until", options === null || options === undefined ? undefined : options.until);
      return request.send(this.requestCtx, endpointStats_1.EndpointStatsSerializer._fromJsonObject);
    }
    transformationGet(appId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, endpointTransformationOut_1.EndpointTransformationOutSerializer._fromJsonObject);
    }
    patchTransformation(appId, endpointId, endpointTransformationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointTransformationPatch_1.EndpointTransformationPatchSerializer._toJsonObject(endpointTransformationPatch));
      return request.sendNoResponseBody(this.requestCtx);
    }
    transformationPartialUpdate(appId, endpointId, endpointTransformationIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(endpointTransformationIn_1.EndpointTransformationInSerializer._toJsonObject(endpointTransformationIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Endpoint = Endpoint;
});

// node_modules/svix/dist/models/connectorKind.js
var require_connectorKind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorKindSerializer = exports.ConnectorKind = undefined;
  var ConnectorKind;
  (function(ConnectorKind2) {
    ConnectorKind2["Custom"] = "Custom";
    ConnectorKind2["CloseCrm"] = "CloseCRM";
    ConnectorKind2["CustomerIo"] = "CustomerIO";
    ConnectorKind2["Discord"] = "Discord";
    ConnectorKind2["Hubspot"] = "Hubspot";
    ConnectorKind2["Inngest"] = "Inngest";
    ConnectorKind2["Loops"] = "Loops";
    ConnectorKind2["Resend"] = "Resend";
    ConnectorKind2["Salesforce"] = "Salesforce";
    ConnectorKind2["Segment"] = "Segment";
    ConnectorKind2["Sendgrid"] = "Sendgrid";
    ConnectorKind2["Slack"] = "Slack";
    ConnectorKind2["Teams"] = "Teams";
    ConnectorKind2["TriggerDev"] = "TriggerDev";
    ConnectorKind2["Windmill"] = "Windmill";
    ConnectorKind2["Zapier"] = "Zapier";
  })(ConnectorKind = exports.ConnectorKind || (exports.ConnectorKind = {}));
  exports.ConnectorKindSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/connectorIn.js
var require_connectorIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorInSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  exports.ConnectorInSerializer = {
    _fromJsonObject(object2) {
      return {
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        filterTypes: object2["filterTypes"],
        instructions: object2["instructions"],
        instructionsLink: object2["instructionsLink"],
        kind: object2["kind"] ? connectorKind_1.ConnectorKindSerializer._fromJsonObject(object2["kind"]) : undefined,
        logo: object2["logo"],
        name: object2["name"],
        transformation: object2["transformation"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        filterTypes: self2.filterTypes,
        instructions: self2.instructions,
        instructionsLink: self2.instructionsLink,
        kind: self2.kind ? connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind) : undefined,
        logo: self2.logo,
        name: self2.name,
        transformation: self2.transformation
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeIn.js
var require_eventTypeIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeInSerializer = undefined;
  exports.EventTypeInSerializer = {
    _fromJsonObject(object2) {
      return {
        archived: object2["archived"],
        deprecated: object2["deprecated"],
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        groupName: object2["groupName"],
        name: object2["name"],
        schemas: object2["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/environmentIn.js
var require_environmentIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnvironmentInSerializer = undefined;
  var connectorIn_1 = require_connectorIn();
  var eventTypeIn_1 = require_eventTypeIn();
  exports.EnvironmentInSerializer = {
    _fromJsonObject(object2) {
      var _a5, _b2;
      return {
        connectors: (_a5 = object2["connectors"]) === null || _a5 === undefined ? undefined : _a5.map((item) => connectorIn_1.ConnectorInSerializer._fromJsonObject(item)),
        eventTypes: (_b2 = object2["eventTypes"]) === null || _b2 === undefined ? undefined : _b2.map((item) => eventTypeIn_1.EventTypeInSerializer._fromJsonObject(item)),
        settings: object2["settings"]
      };
    },
    _toJsonObject(self2) {
      var _a5, _b2;
      return {
        connectors: (_a5 = self2.connectors) === null || _a5 === undefined ? undefined : _a5.map((item) => connectorIn_1.ConnectorInSerializer._toJsonObject(item)),
        eventTypes: (_b2 = self2.eventTypes) === null || _b2 === undefined ? undefined : _b2.map((item) => eventTypeIn_1.EventTypeInSerializer._toJsonObject(item)),
        settings: self2.settings
      };
    }
  };
});

// node_modules/svix/dist/models/connectorOut.js
var require_connectorOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectorOutSerializer = undefined;
  var connectorKind_1 = require_connectorKind();
  exports.ConnectorOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        filterTypes: object2["filterTypes"],
        id: object2["id"],
        instructions: object2["instructions"],
        instructionsLink: object2["instructionsLink"],
        kind: connectorKind_1.ConnectorKindSerializer._fromJsonObject(object2["kind"]),
        logo: object2["logo"],
        name: object2["name"],
        orgId: object2["orgId"],
        transformation: object2["transformation"],
        updatedAt: new Date(object2["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        filterTypes: self2.filterTypes,
        id: self2.id,
        instructions: self2.instructions,
        instructionsLink: self2.instructionsLink,
        kind: connectorKind_1.ConnectorKindSerializer._toJsonObject(self2.kind),
        logo: self2.logo,
        name: self2.name,
        orgId: self2.orgId,
        transformation: self2.transformation,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeOut.js
var require_eventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeOutSerializer = undefined;
  exports.EventTypeOutSerializer = {
    _fromJsonObject(object2) {
      return {
        archived: object2["archived"],
        createdAt: new Date(object2["createdAt"]),
        deprecated: object2["deprecated"],
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        groupName: object2["groupName"],
        name: object2["name"],
        schemas: object2["schemas"],
        updatedAt: new Date(object2["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        createdAt: self2.createdAt,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/environmentOut.js
var require_environmentOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnvironmentOutSerializer = undefined;
  var connectorOut_1 = require_connectorOut();
  var eventTypeOut_1 = require_eventTypeOut();
  exports.EnvironmentOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        eventTypes: object2["eventTypes"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        settings: object2["settings"],
        transformationTemplates: object2["transformationTemplates"].map((item) => connectorOut_1.ConnectorOutSerializer._fromJsonObject(item)),
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        eventTypes: self2.eventTypes.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        settings: self2.settings,
        transformationTemplates: self2.transformationTemplates.map((item) => connectorOut_1.ConnectorOutSerializer._toJsonObject(item)),
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/api/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Environment = undefined;
  var environmentIn_1 = require_environmentIn();
  var environmentOut_1 = require_environmentOut();
  var request_1 = require_request();

  class Environment {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    export(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/export");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, environmentOut_1.EnvironmentOutSerializer._fromJsonObject);
    }
    import(environmentIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/environment/import");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(environmentIn_1.EnvironmentInSerializer._toJsonObject(environmentIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Environment = Environment;
});

// node_modules/svix/dist/models/eventTypeImportOpenApiIn.js
var require_eventTypeImportOpenApiIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiInSerializer = undefined;
  exports.EventTypeImportOpenApiInSerializer = {
    _fromJsonObject(object2) {
      return {
        dryRun: object2["dryRun"],
        replaceAll: object2["replaceAll"],
        spec: object2["spec"],
        specRaw: object2["specRaw"]
      };
    },
    _toJsonObject(self2) {
      return {
        dryRun: self2.dryRun,
        replaceAll: self2.replaceAll,
        spec: self2.spec,
        specRaw: self2.specRaw
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeFromOpenApi.js
var require_eventTypeFromOpenApi = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeFromOpenApiSerializer = undefined;
  exports.EventTypeFromOpenApiSerializer = {
    _fromJsonObject(object2) {
      return {
        deprecated: object2["deprecated"],
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        groupName: object2["groupName"],
        name: object2["name"],
        schemas: object2["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        name: self2.name,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeImportOpenApiOutData.js
var require_eventTypeImportOpenApiOutData = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiOutDataSerializer = undefined;
  var eventTypeFromOpenApi_1 = require_eventTypeFromOpenApi();
  exports.EventTypeImportOpenApiOutDataSerializer = {
    _fromJsonObject(object2) {
      var _a5;
      return {
        modified: object2["modified"],
        toModify: (_a5 = object2["to_modify"]) === null || _a5 === undefined ? undefined : _a5.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._fromJsonObject(item))
      };
    },
    _toJsonObject(self2) {
      var _a5;
      return {
        modified: self2.modified,
        to_modify: (_a5 = self2.toModify) === null || _a5 === undefined ? undefined : _a5.map((item) => eventTypeFromOpenApi_1.EventTypeFromOpenApiSerializer._toJsonObject(item))
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeImportOpenApiOut.js
var require_eventTypeImportOpenApiOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeImportOpenApiOutSerializer = undefined;
  var eventTypeImportOpenApiOutData_1 = require_eventTypeImportOpenApiOutData();
  exports.EventTypeImportOpenApiOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._fromJsonObject(object2["data"])
      };
    },
    _toJsonObject(self2) {
      return {
        data: eventTypeImportOpenApiOutData_1.EventTypeImportOpenApiOutDataSerializer._toJsonObject(self2.data)
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypePatch.js
var require_eventTypePatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypePatchSerializer = undefined;
  exports.EventTypePatchSerializer = {
    _fromJsonObject(object2) {
      return {
        archived: object2["archived"],
        deprecated: object2["deprecated"],
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        groupName: object2["groupName"],
        schemas: object2["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/eventTypeUpdate.js
var require_eventTypeUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventTypeUpdateSerializer = undefined;
  exports.EventTypeUpdateSerializer = {
    _fromJsonObject(object2) {
      return {
        archived: object2["archived"],
        deprecated: object2["deprecated"],
        description: object2["description"],
        featureFlag: object2["featureFlag"],
        featureFlags: object2["featureFlags"],
        groupName: object2["groupName"],
        schemas: object2["schemas"]
      };
    },
    _toJsonObject(self2) {
      return {
        archived: self2.archived,
        deprecated: self2.deprecated,
        description: self2.description,
        featureFlag: self2.featureFlag,
        featureFlags: self2.featureFlags,
        groupName: self2.groupName,
        schemas: self2.schemas
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEventTypeOut.js
var require_listResponseEventTypeOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEventTypeOutSerializer = undefined;
  var eventTypeOut_1 = require_eventTypeOut();
  exports.ListResponseEventTypeOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => eventTypeOut_1.EventTypeOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => eventTypeOut_1.EventTypeOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/eventType.js
var require_eventType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EventType = undefined;
  var eventTypeImportOpenApiIn_1 = require_eventTypeImportOpenApiIn();
  var eventTypeImportOpenApiOut_1 = require_eventTypeImportOpenApiOut();
  var eventTypeIn_1 = require_eventTypeIn();
  var eventTypeOut_1 = require_eventTypeOut();
  var eventTypePatch_1 = require_eventTypePatch();
  var eventTypeUpdate_1 = require_eventTypeUpdate();
  var listResponseEventTypeOut_1 = require_listResponseEventTypeOut();
  var request_1 = require_request();

  class EventType {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type");
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      request.setQueryParam("include_archived", options === null || options === undefined ? undefined : options.includeArchived);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      return request.send(this.requestCtx, listResponseEventTypeOut_1.ListResponseEventTypeOutSerializer._fromJsonObject);
    }
    create(eventTypeIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventTypeIn_1.EventTypeInSerializer._toJsonObject(eventTypeIn));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    importOpenapi(eventTypeImportOpenApiIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/event-type/import/openapi");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(eventTypeImportOpenApiIn_1.EventTypeImportOpenApiInSerializer._toJsonObject(eventTypeImportOpenApiIn));
      return request.send(this.requestCtx, eventTypeImportOpenApiOut_1.EventTypeImportOpenApiOutSerializer._fromJsonObject);
    }
    get(eventTypeName) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    update(eventTypeName, eventTypeUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setBody(eventTypeUpdate_1.EventTypeUpdateSerializer._toJsonObject(eventTypeUpdate));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
    delete(eventTypeName, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setQueryParam("expunge", options === null || options === undefined ? undefined : options.expunge);
      return request.sendNoResponseBody(this.requestCtx);
    }
    patch(eventTypeName, eventTypePatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/api/v1/event-type/{event_type_name}");
      request.setPathParam("event_type_name", eventTypeName);
      request.setBody(eventTypePatch_1.EventTypePatchSerializer._toJsonObject(eventTypePatch));
      return request.send(this.requestCtx, eventTypeOut_1.EventTypeOutSerializer._fromJsonObject);
    }
  }
  exports.EventType = EventType;
});

// node_modules/svix/dist/api/health.js
var require_health = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Health = undefined;
  var request_1 = require_request();

  class Health {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get() {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/health");
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Health = Health;
});

// node_modules/svix/dist/models/ingestSourceConsumerPortalAccessIn.js
var require_ingestSourceConsumerPortalAccessIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceConsumerPortalAccessInSerializer = undefined;
  exports.IngestSourceConsumerPortalAccessInSerializer = {
    _fromJsonObject(object2) {
      return {
        expiry: object2["expiry"],
        readOnly: object2["readOnly"]
      };
    },
    _toJsonObject(self2) {
      return {
        expiry: self2.expiry,
        readOnly: self2.readOnly
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointHeadersIn.js
var require_ingestEndpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointHeadersInSerializer = undefined;
  exports.IngestEndpointHeadersInSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointHeadersOut.js
var require_ingestEndpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointHeadersOutSerializer = undefined;
  exports.IngestEndpointHeadersOutSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"],
        sensitive: object2["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointIn.js
var require_ingestEndpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointInSerializer = undefined;
  exports.IngestEndpointInSerializer = {
    _fromJsonObject(object2) {
      return {
        description: object2["description"],
        disabled: object2["disabled"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        secret: object2["secret"],
        uid: object2["uid"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointOut.js
var require_ingestEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointOutSerializer = undefined;
  exports.IngestEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        description: object2["description"],
        disabled: object2["disabled"],
        id: object2["id"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"]),
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointSecretIn.js
var require_ingestEndpointSecretIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointSecretInSerializer = undefined;
  exports.IngestEndpointSecretInSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointSecretOut.js
var require_ingestEndpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointSecretOutSerializer = undefined;
  exports.IngestEndpointSecretOutSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointTransformationOut.js
var require_ingestEndpointTransformationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointTransformationOutSerializer = undefined;
  exports.IngestEndpointTransformationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        code: object2["code"],
        enabled: object2["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointTransformationPatch.js
var require_ingestEndpointTransformationPatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointTransformationPatchSerializer = undefined;
  exports.IngestEndpointTransformationPatchSerializer = {
    _fromJsonObject(object2) {
      return {
        code: object2["code"],
        enabled: object2["enabled"]
      };
    },
    _toJsonObject(self2) {
      return {
        code: self2.code,
        enabled: self2.enabled
      };
    }
  };
});

// node_modules/svix/dist/models/ingestEndpointUpdate.js
var require_ingestEndpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpointUpdateSerializer = undefined;
  exports.IngestEndpointUpdateSerializer = {
    _fromJsonObject(object2) {
      return {
        description: object2["description"],
        disabled: object2["disabled"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIngestEndpointOut.js
var require_listResponseIngestEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIngestEndpointOutSerializer = undefined;
  var ingestEndpointOut_1 = require_ingestEndpointOut();
  exports.ListResponseIngestEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => ingestEndpointOut_1.IngestEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/ingestEndpoint.js
var require_ingestEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestEndpoint = undefined;
  var ingestEndpointHeadersIn_1 = require_ingestEndpointHeadersIn();
  var ingestEndpointHeadersOut_1 = require_ingestEndpointHeadersOut();
  var ingestEndpointIn_1 = require_ingestEndpointIn();
  var ingestEndpointOut_1 = require_ingestEndpointOut();
  var ingestEndpointSecretIn_1 = require_ingestEndpointSecretIn();
  var ingestEndpointSecretOut_1 = require_ingestEndpointSecretOut();
  var ingestEndpointTransformationOut_1 = require_ingestEndpointTransformationOut();
  var ingestEndpointTransformationPatch_1 = require_ingestEndpointTransformationPatch();
  var ingestEndpointUpdate_1 = require_ingestEndpointUpdate();
  var listResponseIngestEndpointOut_1 = require_listResponseIngestEndpointOut();
  var request_1 = require_request();

  class IngestEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(sourceId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint");
      request.setPathParam("source_id", sourceId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseIngestEndpointOut_1.ListResponseIngestEndpointOutSerializer._fromJsonObject);
    }
    create(sourceId, ingestEndpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestEndpointIn_1.IngestEndpointInSerializer._toJsonObject(ingestEndpointIn));
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    get(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    update(sourceId, endpointId, ingestEndpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointUpdate_1.IngestEndpointUpdateSerializer._toJsonObject(ingestEndpointUpdate));
      return request.send(this.requestCtx, ingestEndpointOut_1.IngestEndpointOutSerializer._fromJsonObject);
    }
    delete(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointHeadersOut_1.IngestEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(sourceId, endpointId, ingestEndpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/headers");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointHeadersIn_1.IngestEndpointHeadersInSerializer._toJsonObject(ingestEndpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getSecret(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointSecretOut_1.IngestEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(sourceId, endpointId, ingestEndpointSecretIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestEndpointSecretIn_1.IngestEndpointSecretInSerializer._toJsonObject(ingestEndpointSecretIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getTransformation(sourceId, endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, ingestEndpointTransformationOut_1.IngestEndpointTransformationOutSerializer._fromJsonObject);
    }
    setTransformation(sourceId, endpointId, ingestEndpointTransformationPatch) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PATCH, "/ingest/api/v1/source/{source_id}/endpoint/{endpoint_id}/transformation");
      request.setPathParam("source_id", sourceId);
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(ingestEndpointTransformationPatch_1.IngestEndpointTransformationPatchSerializer._toJsonObject(ingestEndpointTransformationPatch));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.IngestEndpoint = IngestEndpoint;
});

// node_modules/svix/dist/models/adobeSignConfig.js
var require_adobeSignConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdobeSignConfigSerializer = undefined;
  exports.AdobeSignConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        clientId: object2["clientId"]
      };
    },
    _toJsonObject(self2) {
      return {
        clientId: self2.clientId
      };
    }
  };
});

// node_modules/svix/dist/models/airwallexConfig.js
var require_airwallexConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AirwallexConfigSerializer = undefined;
  exports.AirwallexConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/checkbookConfig.js
var require_checkbookConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CheckbookConfigSerializer = undefined;
  exports.CheckbookConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/cronConfig.js
var require_cronConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CronConfigSerializer = undefined;
  exports.CronConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        contentType: object2["contentType"],
        payload: object2["payload"],
        schedule: object2["schedule"]
      };
    },
    _toJsonObject(self2) {
      return {
        contentType: self2.contentType,
        payload: self2.payload,
        schedule: self2.schedule
      };
    }
  };
});

// node_modules/svix/dist/models/docusignConfig.js
var require_docusignConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocusignConfigSerializer = undefined;
  exports.DocusignConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/easypostConfig.js
var require_easypostConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EasypostConfigSerializer = undefined;
  exports.EasypostConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/githubConfig.js
var require_githubConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GithubConfigSerializer = undefined;
  exports.GithubConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/hubspotConfig.js
var require_hubspotConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HubspotConfigSerializer = undefined;
  exports.HubspotConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/orumIoConfig.js
var require_orumIoConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrumIoConfigSerializer = undefined;
  exports.OrumIoConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        publicKey: object2["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/pandaDocConfig.js
var require_pandaDocConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PandaDocConfigSerializer = undefined;
  exports.PandaDocConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/portIoConfig.js
var require_portIoConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PortIoConfigSerializer = undefined;
  exports.PortIoConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/rutterConfig.js
var require_rutterConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RutterConfigSerializer = undefined;
  exports.RutterConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/segmentConfig.js
var require_segmentConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SegmentConfigSerializer = undefined;
  exports.SegmentConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/shopifyConfig.js
var require_shopifyConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShopifyConfigSerializer = undefined;
  exports.ShopifyConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/slackConfig.js
var require_slackConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SlackConfigSerializer = undefined;
  exports.SlackConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/stripeConfig.js
var require_stripeConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StripeConfigSerializer = undefined;
  exports.StripeConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/svixConfig.js
var require_svixConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixConfigSerializer = undefined;
  exports.SvixConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/telnyxConfig.js
var require_telnyxConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelnyxConfigSerializer = undefined;
  exports.TelnyxConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        publicKey: object2["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/vapiConfig.js
var require_vapiConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VapiConfigSerializer = undefined;
  exports.VapiConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/veriffConfig.js
var require_veriffConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VeriffConfigSerializer = undefined;
  exports.VeriffConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/zoomConfig.js
var require_zoomConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZoomConfigSerializer = undefined;
  exports.ZoomConfigSerializer = {
    _fromJsonObject(object2) {
      return {
        secret: object2["secret"]
      };
    },
    _toJsonObject(self2) {
      return {
        secret: self2.secret
      };
    }
  };
});

// node_modules/svix/dist/models/ingestSourceIn.js
var require_ingestSourceIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceInSerializer = undefined;
  var adobeSignConfig_1 = require_adobeSignConfig();
  var airwallexConfig_1 = require_airwallexConfig();
  var checkbookConfig_1 = require_checkbookConfig();
  var cronConfig_1 = require_cronConfig();
  var docusignConfig_1 = require_docusignConfig();
  var easypostConfig_1 = require_easypostConfig();
  var githubConfig_1 = require_githubConfig();
  var hubspotConfig_1 = require_hubspotConfig();
  var orumIoConfig_1 = require_orumIoConfig();
  var pandaDocConfig_1 = require_pandaDocConfig();
  var portIoConfig_1 = require_portIoConfig();
  var rutterConfig_1 = require_rutterConfig();
  var segmentConfig_1 = require_segmentConfig();
  var shopifyConfig_1 = require_shopifyConfig();
  var slackConfig_1 = require_slackConfig();
  var stripeConfig_1 = require_stripeConfig();
  var svixConfig_1 = require_svixConfig();
  var telnyxConfig_1 = require_telnyxConfig();
  var vapiConfig_1 = require_vapiConfig();
  var veriffConfig_1 = require_veriffConfig();
  var zoomConfig_1 = require_zoomConfig();
  exports.IngestSourceInSerializer = {
    _fromJsonObject(object2) {
      const type = object2["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object2["config"]);
          case "adobe-sign":
            return adobeSignConfig_1.AdobeSignConfigSerializer._fromJsonObject(object2["config"]);
          case "beehiiv":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "brex":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "checkbook":
            return checkbookConfig_1.CheckbookConfigSerializer._fromJsonObject(object2["config"]);
          case "clerk":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "docusign":
            return docusignConfig_1.DocusignConfigSerializer._fromJsonObject(object2["config"]);
          case "easypost":
            return easypostConfig_1.EasypostConfigSerializer._fromJsonObject(object2["config"]);
          case "github":
            return githubConfig_1.GithubConfigSerializer._fromJsonObject(object2["config"]);
          case "guesty":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "hubspot":
            return hubspotConfig_1.HubspotConfigSerializer._fromJsonObject(object2["config"]);
          case "incident-io":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "lithic":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "nash":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "orum-io":
            return orumIoConfig_1.OrumIoConfigSerializer._fromJsonObject(object2["config"]);
          case "panda-doc":
            return pandaDocConfig_1.PandaDocConfigSerializer._fromJsonObject(object2["config"]);
          case "port-io":
            return portIoConfig_1.PortIoConfigSerializer._fromJsonObject(object2["config"]);
          case "pleo":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "replicate":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "resend":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "rutter":
            return rutterConfig_1.RutterConfigSerializer._fromJsonObject(object2["config"]);
          case "safebase":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "sardine":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "segment":
            return segmentConfig_1.SegmentConfigSerializer._fromJsonObject(object2["config"]);
          case "shopify":
            return shopifyConfig_1.ShopifyConfigSerializer._fromJsonObject(object2["config"]);
          case "slack":
            return slackConfig_1.SlackConfigSerializer._fromJsonObject(object2["config"]);
          case "stripe":
            return stripeConfig_1.StripeConfigSerializer._fromJsonObject(object2["config"]);
          case "stych":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "svix":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "zoom":
            return zoomConfig_1.ZoomConfigSerializer._fromJsonObject(object2["config"]);
          case "telnyx":
            return telnyxConfig_1.TelnyxConfigSerializer._fromJsonObject(object2["config"]);
          case "vapi":
            return vapiConfig_1.VapiConfigSerializer._fromJsonObject(object2["config"]);
          case "open-ai":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "render":
            return svixConfig_1.SvixConfigSerializer._fromJsonObject(object2["config"]);
          case "veriff":
            return veriffConfig_1.VeriffConfigSerializer._fromJsonObject(object2["config"]);
          case "airwallex":
            return airwallexConfig_1.AirwallexConfigSerializer._fromJsonObject(object2["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        metadata: object2["metadata"],
        name: object2["name"],
        uid: object2["uid"]
      };
    },
    _toJsonObject(self2) {
      let config2;
      switch (self2.type) {
        case "generic-webhook":
          config2 = {};
          break;
        case "cron":
          config2 = cronConfig_1.CronConfigSerializer._toJsonObject(self2.config);
          break;
        case "adobe-sign":
          config2 = adobeSignConfig_1.AdobeSignConfigSerializer._toJsonObject(self2.config);
          break;
        case "beehiiv":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "brex":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "checkbook":
          config2 = checkbookConfig_1.CheckbookConfigSerializer._toJsonObject(self2.config);
          break;
        case "clerk":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "docusign":
          config2 = docusignConfig_1.DocusignConfigSerializer._toJsonObject(self2.config);
          break;
        case "easypost":
          config2 = easypostConfig_1.EasypostConfigSerializer._toJsonObject(self2.config);
          break;
        case "github":
          config2 = githubConfig_1.GithubConfigSerializer._toJsonObject(self2.config);
          break;
        case "guesty":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "hubspot":
          config2 = hubspotConfig_1.HubspotConfigSerializer._toJsonObject(self2.config);
          break;
        case "incident-io":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "lithic":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "nash":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "orum-io":
          config2 = orumIoConfig_1.OrumIoConfigSerializer._toJsonObject(self2.config);
          break;
        case "panda-doc":
          config2 = pandaDocConfig_1.PandaDocConfigSerializer._toJsonObject(self2.config);
          break;
        case "port-io":
          config2 = portIoConfig_1.PortIoConfigSerializer._toJsonObject(self2.config);
          break;
        case "pleo":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "replicate":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "resend":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "rutter":
          config2 = rutterConfig_1.RutterConfigSerializer._toJsonObject(self2.config);
          break;
        case "safebase":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "sardine":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "segment":
          config2 = segmentConfig_1.SegmentConfigSerializer._toJsonObject(self2.config);
          break;
        case "shopify":
          config2 = shopifyConfig_1.ShopifyConfigSerializer._toJsonObject(self2.config);
          break;
        case "slack":
          config2 = slackConfig_1.SlackConfigSerializer._toJsonObject(self2.config);
          break;
        case "stripe":
          config2 = stripeConfig_1.StripeConfigSerializer._toJsonObject(self2.config);
          break;
        case "stych":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "svix":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "zoom":
          config2 = zoomConfig_1.ZoomConfigSerializer._toJsonObject(self2.config);
          break;
        case "telnyx":
          config2 = telnyxConfig_1.TelnyxConfigSerializer._toJsonObject(self2.config);
          break;
        case "vapi":
          config2 = vapiConfig_1.VapiConfigSerializer._toJsonObject(self2.config);
          break;
        case "open-ai":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "render":
          config2 = svixConfig_1.SvixConfigSerializer._toJsonObject(self2.config);
          break;
        case "veriff":
          config2 = veriffConfig_1.VeriffConfigSerializer._toJsonObject(self2.config);
          break;
        case "airwallex":
          config2 = airwallexConfig_1.AirwallexConfigSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config: config2,
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid
      };
    }
  };
});

// node_modules/svix/dist/models/adobeSignConfigOut.js
var require_adobeSignConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AdobeSignConfigOutSerializer = undefined;
  exports.AdobeSignConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/airwallexConfigOut.js
var require_airwallexConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AirwallexConfigOutSerializer = undefined;
  exports.AirwallexConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/checkbookConfigOut.js
var require_checkbookConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CheckbookConfigOutSerializer = undefined;
  exports.CheckbookConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/docusignConfigOut.js
var require_docusignConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DocusignConfigOutSerializer = undefined;
  exports.DocusignConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/easypostConfigOut.js
var require_easypostConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EasypostConfigOutSerializer = undefined;
  exports.EasypostConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/githubConfigOut.js
var require_githubConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GithubConfigOutSerializer = undefined;
  exports.GithubConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/hubspotConfigOut.js
var require_hubspotConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HubspotConfigOutSerializer = undefined;
  exports.HubspotConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/orumIoConfigOut.js
var require_orumIoConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrumIoConfigOutSerializer = undefined;
  exports.OrumIoConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {
        publicKey: object2["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/pandaDocConfigOut.js
var require_pandaDocConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PandaDocConfigOutSerializer = undefined;
  exports.PandaDocConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/portIoConfigOut.js
var require_portIoConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PortIoConfigOutSerializer = undefined;
  exports.PortIoConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/rutterConfigOut.js
var require_rutterConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RutterConfigOutSerializer = undefined;
  exports.RutterConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/segmentConfigOut.js
var require_segmentConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SegmentConfigOutSerializer = undefined;
  exports.SegmentConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/shopifyConfigOut.js
var require_shopifyConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ShopifyConfigOutSerializer = undefined;
  exports.ShopifyConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/slackConfigOut.js
var require_slackConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SlackConfigOutSerializer = undefined;
  exports.SlackConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/stripeConfigOut.js
var require_stripeConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StripeConfigOutSerializer = undefined;
  exports.StripeConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/svixConfigOut.js
var require_svixConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SvixConfigOutSerializer = undefined;
  exports.SvixConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/telnyxConfigOut.js
var require_telnyxConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelnyxConfigOutSerializer = undefined;
  exports.TelnyxConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {
        publicKey: object2["publicKey"]
      };
    },
    _toJsonObject(self2) {
      return {
        publicKey: self2.publicKey
      };
    }
  };
});

// node_modules/svix/dist/models/vapiConfigOut.js
var require_vapiConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VapiConfigOutSerializer = undefined;
  exports.VapiConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/veriffConfigOut.js
var require_veriffConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VeriffConfigOutSerializer = undefined;
  exports.VeriffConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/zoomConfigOut.js
var require_zoomConfigOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ZoomConfigOutSerializer = undefined;
  exports.ZoomConfigOutSerializer = {
    _fromJsonObject(object2) {
      return {};
    },
    _toJsonObject(self2) {
      return {};
    }
  };
});

// node_modules/svix/dist/models/ingestSourceOut.js
var require_ingestSourceOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSourceOutSerializer = undefined;
  var adobeSignConfigOut_1 = require_adobeSignConfigOut();
  var airwallexConfigOut_1 = require_airwallexConfigOut();
  var checkbookConfigOut_1 = require_checkbookConfigOut();
  var cronConfig_1 = require_cronConfig();
  var docusignConfigOut_1 = require_docusignConfigOut();
  var easypostConfigOut_1 = require_easypostConfigOut();
  var githubConfigOut_1 = require_githubConfigOut();
  var hubspotConfigOut_1 = require_hubspotConfigOut();
  var orumIoConfigOut_1 = require_orumIoConfigOut();
  var pandaDocConfigOut_1 = require_pandaDocConfigOut();
  var portIoConfigOut_1 = require_portIoConfigOut();
  var rutterConfigOut_1 = require_rutterConfigOut();
  var segmentConfigOut_1 = require_segmentConfigOut();
  var shopifyConfigOut_1 = require_shopifyConfigOut();
  var slackConfigOut_1 = require_slackConfigOut();
  var stripeConfigOut_1 = require_stripeConfigOut();
  var svixConfigOut_1 = require_svixConfigOut();
  var telnyxConfigOut_1 = require_telnyxConfigOut();
  var vapiConfigOut_1 = require_vapiConfigOut();
  var veriffConfigOut_1 = require_veriffConfigOut();
  var zoomConfigOut_1 = require_zoomConfigOut();
  exports.IngestSourceOutSerializer = {
    _fromJsonObject(object2) {
      const type = object2["type"];
      function getConfig(type2) {
        switch (type2) {
          case "generic-webhook":
            return {};
          case "cron":
            return cronConfig_1.CronConfigSerializer._fromJsonObject(object2["config"]);
          case "adobe-sign":
            return adobeSignConfigOut_1.AdobeSignConfigOutSerializer._fromJsonObject(object2["config"]);
          case "beehiiv":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "brex":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "checkbook":
            return checkbookConfigOut_1.CheckbookConfigOutSerializer._fromJsonObject(object2["config"]);
          case "clerk":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "docusign":
            return docusignConfigOut_1.DocusignConfigOutSerializer._fromJsonObject(object2["config"]);
          case "easypost":
            return easypostConfigOut_1.EasypostConfigOutSerializer._fromJsonObject(object2["config"]);
          case "github":
            return githubConfigOut_1.GithubConfigOutSerializer._fromJsonObject(object2["config"]);
          case "guesty":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "hubspot":
            return hubspotConfigOut_1.HubspotConfigOutSerializer._fromJsonObject(object2["config"]);
          case "incident-io":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "lithic":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "nash":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "orum-io":
            return orumIoConfigOut_1.OrumIoConfigOutSerializer._fromJsonObject(object2["config"]);
          case "panda-doc":
            return pandaDocConfigOut_1.PandaDocConfigOutSerializer._fromJsonObject(object2["config"]);
          case "port-io":
            return portIoConfigOut_1.PortIoConfigOutSerializer._fromJsonObject(object2["config"]);
          case "pleo":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "replicate":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "resend":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "rutter":
            return rutterConfigOut_1.RutterConfigOutSerializer._fromJsonObject(object2["config"]);
          case "safebase":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "sardine":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "segment":
            return segmentConfigOut_1.SegmentConfigOutSerializer._fromJsonObject(object2["config"]);
          case "shopify":
            return shopifyConfigOut_1.ShopifyConfigOutSerializer._fromJsonObject(object2["config"]);
          case "slack":
            return slackConfigOut_1.SlackConfigOutSerializer._fromJsonObject(object2["config"]);
          case "stripe":
            return stripeConfigOut_1.StripeConfigOutSerializer._fromJsonObject(object2["config"]);
          case "stych":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "svix":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "zoom":
            return zoomConfigOut_1.ZoomConfigOutSerializer._fromJsonObject(object2["config"]);
          case "telnyx":
            return telnyxConfigOut_1.TelnyxConfigOutSerializer._fromJsonObject(object2["config"]);
          case "vapi":
            return vapiConfigOut_1.VapiConfigOutSerializer._fromJsonObject(object2["config"]);
          case "open-ai":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "render":
            return svixConfigOut_1.SvixConfigOutSerializer._fromJsonObject(object2["config"]);
          case "veriff":
            return veriffConfigOut_1.VeriffConfigOutSerializer._fromJsonObject(object2["config"]);
          case "airwallex":
            return airwallexConfigOut_1.AirwallexConfigOutSerializer._fromJsonObject(object2["config"]);
          default:
            throw new Error(`Unexpected type: ${type2}`);
        }
      }
      return {
        type,
        config: getConfig(type),
        createdAt: new Date(object2["createdAt"]),
        id: object2["id"],
        ingestUrl: object2["ingestUrl"],
        metadata: object2["metadata"],
        name: object2["name"],
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      let config2;
      switch (self2.type) {
        case "generic-webhook":
          config2 = {};
          break;
        case "cron":
          config2 = cronConfig_1.CronConfigSerializer._toJsonObject(self2.config);
          break;
        case "adobe-sign":
          config2 = adobeSignConfigOut_1.AdobeSignConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "beehiiv":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "brex":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "checkbook":
          config2 = checkbookConfigOut_1.CheckbookConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "clerk":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "docusign":
          config2 = docusignConfigOut_1.DocusignConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "easypost":
          config2 = easypostConfigOut_1.EasypostConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "github":
          config2 = githubConfigOut_1.GithubConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "guesty":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "hubspot":
          config2 = hubspotConfigOut_1.HubspotConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "incident-io":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "lithic":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "nash":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "orum-io":
          config2 = orumIoConfigOut_1.OrumIoConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "panda-doc":
          config2 = pandaDocConfigOut_1.PandaDocConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "port-io":
          config2 = portIoConfigOut_1.PortIoConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "pleo":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "replicate":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "resend":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "rutter":
          config2 = rutterConfigOut_1.RutterConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "safebase":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "sardine":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "segment":
          config2 = segmentConfigOut_1.SegmentConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "shopify":
          config2 = shopifyConfigOut_1.ShopifyConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "slack":
          config2 = slackConfigOut_1.SlackConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "stripe":
          config2 = stripeConfigOut_1.StripeConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "stych":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "svix":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "zoom":
          config2 = zoomConfigOut_1.ZoomConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "telnyx":
          config2 = telnyxConfigOut_1.TelnyxConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "vapi":
          config2 = vapiConfigOut_1.VapiConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "open-ai":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "render":
          config2 = svixConfigOut_1.SvixConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "veriff":
          config2 = veriffConfigOut_1.VeriffConfigOutSerializer._toJsonObject(self2.config);
          break;
        case "airwallex":
          config2 = airwallexConfigOut_1.AirwallexConfigOutSerializer._toJsonObject(self2.config);
          break;
      }
      return {
        type: self2.type,
        config: config2,
        createdAt: self2.createdAt,
        id: self2.id,
        ingestUrl: self2.ingestUrl,
        metadata: self2.metadata,
        name: self2.name,
        uid: self2.uid,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIngestSourceOut.js
var require_listResponseIngestSourceOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIngestSourceOutSerializer = undefined;
  var ingestSourceOut_1 = require_ingestSourceOut();
  exports.ListResponseIngestSourceOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => ingestSourceOut_1.IngestSourceOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/rotateTokenOut.js
var require_rotateTokenOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RotateTokenOutSerializer = undefined;
  exports.RotateTokenOutSerializer = {
    _fromJsonObject(object2) {
      return {
        ingestUrl: object2["ingestUrl"]
      };
    },
    _toJsonObject(self2) {
      return {
        ingestUrl: self2.ingestUrl
      };
    }
  };
});

// node_modules/svix/dist/api/ingestSource.js
var require_ingestSource = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IngestSource = undefined;
  var ingestSourceIn_1 = require_ingestSourceIn();
  var ingestSourceOut_1 = require_ingestSourceOut();
  var listResponseIngestSourceOut_1 = require_listResponseIngestSourceOut();
  var rotateTokenOut_1 = require_rotateTokenOut();
  var request_1 = require_request();

  class IngestSource {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source");
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseIngestSourceOut_1.ListResponseIngestSourceOutSerializer._fromJsonObject);
    }
    create(ingestSourceIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn));
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    get(sourceId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    update(sourceId, ingestSourceIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      request.setBody(ingestSourceIn_1.IngestSourceInSerializer._toJsonObject(ingestSourceIn));
      return request.send(this.requestCtx, ingestSourceOut_1.IngestSourceOutSerializer._fromJsonObject);
    }
    delete(sourceId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/ingest/api/v1/source/{source_id}");
      request.setPathParam("source_id", sourceId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    rotateToken(sourceId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/token/rotate");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, rotateTokenOut_1.RotateTokenOutSerializer._fromJsonObject);
    }
  }
  exports.IngestSource = IngestSource;
});

// node_modules/svix/dist/api/ingest.js
var require_ingest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ingest = undefined;
  var dashboardAccessOut_1 = require_dashboardAccessOut();
  var ingestSourceConsumerPortalAccessIn_1 = require_ingestSourceConsumerPortalAccessIn();
  var ingestEndpoint_1 = require_ingestEndpoint();
  var ingestSource_1 = require_ingestSource();
  var request_1 = require_request();

  class Ingest {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new ingestEndpoint_1.IngestEndpoint(this.requestCtx);
    }
    get source() {
      return new ingestSource_1.IngestSource(this.requestCtx);
    }
    dashboard(sourceId, ingestSourceConsumerPortalAccessIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/ingest/api/v1/source/{source_id}/dashboard");
      request.setPathParam("source_id", sourceId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(ingestSourceConsumerPortalAccessIn_1.IngestSourceConsumerPortalAccessInSerializer._toJsonObject(ingestSourceConsumerPortalAccessIn));
      return request.send(this.requestCtx, dashboardAccessOut_1.DashboardAccessOutSerializer._fromJsonObject);
    }
  }
  exports.Ingest = Ingest;
});

// node_modules/svix/dist/models/integrationIn.js
var require_integrationIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationInSerializer = undefined;
  exports.IntegrationInSerializer = {
    _fromJsonObject(object2) {
      return {
        featureFlags: object2["featureFlags"],
        name: object2["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/models/integrationKeyOut.js
var require_integrationKeyOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationKeyOutSerializer = undefined;
  exports.IntegrationKeyOutSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/integrationOut.js
var require_integrationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationOutSerializer = undefined;
  exports.IntegrationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        featureFlags: object2["featureFlags"],
        id: object2["id"],
        name: object2["name"],
        updatedAt: new Date(object2["updatedAt"])
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        featureFlags: self2.featureFlags,
        id: self2.id,
        name: self2.name,
        updatedAt: self2.updatedAt
      };
    }
  };
});

// node_modules/svix/dist/models/integrationUpdate.js
var require_integrationUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntegrationUpdateSerializer = undefined;
  exports.IntegrationUpdateSerializer = {
    _fromJsonObject(object2) {
      return {
        featureFlags: object2["featureFlags"],
        name: object2["name"]
      };
    },
    _toJsonObject(self2) {
      return {
        featureFlags: self2.featureFlags,
        name: self2.name
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseIntegrationOut.js
var require_listResponseIntegrationOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseIntegrationOutSerializer = undefined;
  var integrationOut_1 = require_integrationOut();
  exports.ListResponseIntegrationOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => integrationOut_1.IntegrationOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => integrationOut_1.IntegrationOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/integration.js
var require_integration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integration = undefined;
  var integrationIn_1 = require_integrationIn();
  var integrationKeyOut_1 = require_integrationKeyOut();
  var integrationOut_1 = require_integrationOut();
  var integrationUpdate_1 = require_integrationUpdate();
  var listResponseIntegrationOut_1 = require_listResponseIntegrationOut();
  var request_1 = require_request();

  class Integration {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration");
      request.setPathParam("app_id", appId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseIntegrationOut_1.ListResponseIntegrationOutSerializer._fromJsonObject);
    }
    create(appId, integrationIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(integrationIn_1.IntegrationInSerializer._toJsonObject(integrationIn));
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    get(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    update(appId, integId, integrationUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      request.setBody(integrationUpdate_1.IntegrationUpdateSerializer._toJsonObject(integrationUpdate));
      return request.send(this.requestCtx, integrationOut_1.IntegrationOutSerializer._fromJsonObject);
    }
    delete(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/integration/{integ_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getKey(appId, integId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/integration/{integ_id}/key");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      return request.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
    rotateKey(appId, integId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/integration/{integ_id}/key/rotate");
      request.setPathParam("app_id", appId);
      request.setPathParam("integ_id", integId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, integrationKeyOut_1.IntegrationKeyOutSerializer._fromJsonObject);
    }
  }
  exports.Integration = Integration;
});

// node_modules/svix/dist/models/expungeAllContentsOut.js
var require_expungeAllContentsOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExpungeAllContentsOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.ExpungeAllContentsOutSerializer = {
    _fromJsonObject(object2) {
      return {
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageOut.js
var require_listResponseMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageOutSerializer = undefined;
  var messageOut_1 = require_messageOut();
  exports.ListResponseMessageOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => messageOut_1.MessageOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageOut_1.MessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointConsumerSeekIn.js
var require_pollingEndpointConsumerSeekIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointConsumerSeekInSerializer = undefined;
  exports.PollingEndpointConsumerSeekInSerializer = {
    _fromJsonObject(object2) {
      return {
        after: new Date(object2["after"])
      };
    },
    _toJsonObject(self2) {
      return {
        after: self2.after
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointConsumerSeekOut.js
var require_pollingEndpointConsumerSeekOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointConsumerSeekOutSerializer = undefined;
  exports.PollingEndpointConsumerSeekOutSerializer = {
    _fromJsonObject(object2) {
      return {
        iterator: object2["iterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        iterator: self2.iterator
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointMessageOut.js
var require_pollingEndpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointMessageOutSerializer = undefined;
  exports.PollingEndpointMessageOutSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        eventId: object2["eventId"],
        eventType: object2["eventType"],
        headers: object2["headers"],
        id: object2["id"],
        payload: object2["payload"],
        tags: object2["tags"],
        timestamp: new Date(object2["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        eventId: self2.eventId,
        eventType: self2.eventType,
        headers: self2.headers,
        id: self2.id,
        payload: self2.payload,
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/pollingEndpointOut.js
var require_pollingEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PollingEndpointOutSerializer = undefined;
  var pollingEndpointMessageOut_1 = require_pollingEndpointMessageOut();
  exports.PollingEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => pollingEndpointMessageOut_1.PollingEndpointMessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator
      };
    }
  };
});

// node_modules/svix/dist/api/messagePoller.js
var require_messagePoller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessagePoller = undefined;
  var pollingEndpointConsumerSeekIn_1 = require_pollingEndpointConsumerSeekIn();
  var pollingEndpointConsumerSeekOut_1 = require_pollingEndpointConsumerSeekOut();
  var pollingEndpointOut_1 = require_pollingEndpointOut();
  var request_1 = require_request();

  class MessagePoller {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    poll(appId, sinkId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("event_type", options === null || options === undefined ? undefined : options.eventType);
      request.setQueryParam("channel", options === null || options === undefined ? undefined : options.channel);
      request.setQueryParam("after", options === null || options === undefined ? undefined : options.after);
      return request.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerPoll(appId, sinkId, consumerId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setPathParam("consumer_id", consumerId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      return request.send(this.requestCtx, pollingEndpointOut_1.PollingEndpointOutSerializer._fromJsonObject);
    }
    consumerSeek(appId, sinkId, consumerId, pollingEndpointConsumerSeekIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/poller/{sink_id}/consumer/{consumer_id}/seek");
      request.setPathParam("app_id", appId);
      request.setPathParam("sink_id", sinkId);
      request.setPathParam("consumer_id", consumerId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(pollingEndpointConsumerSeekIn_1.PollingEndpointConsumerSeekInSerializer._toJsonObject(pollingEndpointConsumerSeekIn));
      return request.send(this.requestCtx, pollingEndpointConsumerSeekOut_1.PollingEndpointConsumerSeekOutSerializer._fromJsonObject);
    }
  }
  exports.MessagePoller = MessagePoller;
});

// node_modules/svix/dist/models/messageIn.js
var require_messageIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageInSerializer = undefined;
  var applicationIn_1 = require_applicationIn();
  exports.MessageInSerializer = {
    _fromJsonObject(object2) {
      return {
        application: object2["application"] ? applicationIn_1.ApplicationInSerializer._fromJsonObject(object2["application"]) : undefined,
        channels: object2["channels"],
        eventId: object2["eventId"],
        eventType: object2["eventType"],
        payload: object2["payload"],
        payloadRetentionHours: object2["payloadRetentionHours"],
        payloadRetentionPeriod: object2["payloadRetentionPeriod"],
        tags: object2["tags"],
        transformationsParams: object2["transformationsParams"]
      };
    },
    _toJsonObject(self2) {
      return {
        application: self2.application ? applicationIn_1.ApplicationInSerializer._toJsonObject(self2.application) : undefined,
        channels: self2.channels,
        eventId: self2.eventId,
        eventType: self2.eventType,
        payload: self2.payload,
        payloadRetentionHours: self2.payloadRetentionHours,
        payloadRetentionPeriod: self2.payloadRetentionPeriod,
        tags: self2.tags,
        transformationsParams: self2.transformationsParams
      };
    }
  };
});

// node_modules/svix/dist/api/message.js
var require_message = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.messageInRaw = exports.Message = undefined;
  var expungeAllContentsOut_1 = require_expungeAllContentsOut();
  var listResponseMessageOut_1 = require_listResponseMessageOut();
  var messageOut_1 = require_messageOut();
  var messagePoller_1 = require_messagePoller();
  var request_1 = require_request();
  var messageIn_1 = require_messageIn();

  class Message {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get poller() {
      return new messagePoller_1.MessagePoller(this.requestCtx);
    }
    list(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg");
      request.setPathParam("app_id", appId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("channel", options === null || options === undefined ? undefined : options.channel);
      request.setQueryParam("before", options === null || options === undefined ? undefined : options.before);
      request.setQueryParam("after", options === null || options === undefined ? undefined : options.after);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      request.setQueryParam("tag", options === null || options === undefined ? undefined : options.tag);
      request.setQueryParam("event_types", options === null || options === undefined ? undefined : options.eventTypes);
      return request.send(this.requestCtx, listResponseMessageOut_1.ListResponseMessageOutSerializer._fromJsonObject);
    }
    create(appId, messageIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg");
      request.setPathParam("app_id", appId);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(messageIn_1.MessageInSerializer._toJsonObject(messageIn));
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeAllContents(appId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/expunge-all-contents");
      request.setPathParam("app_id", appId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.send(this.requestCtx, expungeAllContentsOut_1.ExpungeAllContentsOutSerializer._fromJsonObject);
    }
    get(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      return request.send(this.requestCtx, messageOut_1.MessageOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/content");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.Message = Message;
  function messageInRaw(eventType, payload, contentType) {
    const headers = contentType ? { "content-type": contentType } : undefined;
    return {
      eventType,
      payload: {},
      transformationsParams: {
        rawPayload: payload,
        headers
      }
    };
  }
  exports.messageInRaw = messageInRaw;
});

// node_modules/svix/dist/models/messageStatus.js
var require_messageStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStatusSerializer = exports.MessageStatus = undefined;
  var MessageStatus;
  (function(MessageStatus2) {
    MessageStatus2[MessageStatus2["Success"] = 0] = "Success";
    MessageStatus2[MessageStatus2["Pending"] = 1] = "Pending";
    MessageStatus2[MessageStatus2["Fail"] = 2] = "Fail";
    MessageStatus2[MessageStatus2["Sending"] = 3] = "Sending";
  })(MessageStatus = exports.MessageStatus || (exports.MessageStatus = {}));
  exports.MessageStatusSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/messageStatusText.js
var require_messageStatusText = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageStatusTextSerializer = exports.MessageStatusText = undefined;
  var MessageStatusText;
  (function(MessageStatusText2) {
    MessageStatusText2["Success"] = "success";
    MessageStatusText2["Pending"] = "pending";
    MessageStatusText2["Fail"] = "fail";
    MessageStatusText2["Sending"] = "sending";
  })(MessageStatusText = exports.MessageStatusText || (exports.MessageStatusText = {}));
  exports.MessageStatusTextSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/endpointMessageOut.js
var require_endpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointMessageOutSerializer = undefined;
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.EndpointMessageOutSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        eventId: object2["eventId"],
        eventType: object2["eventType"],
        id: object2["id"],
        nextAttempt: object2["nextAttempt"] ? new Date(object2["nextAttempt"]) : null,
        payload: object2["payload"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object2["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object2["statusText"]),
        tags: object2["tags"],
        timestamp: new Date(object2["timestamp"])
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        eventId: self2.eventId,
        eventType: self2.eventType,
        id: self2.id,
        nextAttempt: self2.nextAttempt,
        payload: self2.payload,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        tags: self2.tags,
        timestamp: self2.timestamp
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseEndpointMessageOut.js
var require_listResponseEndpointMessageOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseEndpointMessageOutSerializer = undefined;
  var endpointMessageOut_1 = require_endpointMessageOut();
  exports.ListResponseEndpointMessageOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => endpointMessageOut_1.EndpointMessageOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageAttemptTriggerType.js
var require_messageAttemptTriggerType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttemptTriggerTypeSerializer = exports.MessageAttemptTriggerType = undefined;
  var MessageAttemptTriggerType;
  (function(MessageAttemptTriggerType2) {
    MessageAttemptTriggerType2[MessageAttemptTriggerType2["Scheduled"] = 0] = "Scheduled";
    MessageAttemptTriggerType2[MessageAttemptTriggerType2["Manual"] = 1] = "Manual";
  })(MessageAttemptTriggerType = exports.MessageAttemptTriggerType || (exports.MessageAttemptTriggerType = {}));
  exports.MessageAttemptTriggerTypeSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/messageAttemptOut.js
var require_messageAttemptOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttemptOutSerializer = undefined;
  var messageAttemptTriggerType_1 = require_messageAttemptTriggerType();
  var messageOut_1 = require_messageOut();
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.MessageAttemptOutSerializer = {
    _fromJsonObject(object2) {
      return {
        endpointId: object2["endpointId"],
        id: object2["id"],
        msg: object2["msg"] ? messageOut_1.MessageOutSerializer._fromJsonObject(object2["msg"]) : undefined,
        msgId: object2["msgId"],
        response: object2["response"],
        responseDurationMs: object2["responseDurationMs"],
        responseStatusCode: object2["responseStatusCode"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object2["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object2["statusText"]),
        timestamp: new Date(object2["timestamp"]),
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._fromJsonObject(object2["triggerType"]),
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        endpointId: self2.endpointId,
        id: self2.id,
        msg: self2.msg ? messageOut_1.MessageOutSerializer._toJsonObject(self2.msg) : undefined,
        msgId: self2.msgId,
        response: self2.response,
        responseDurationMs: self2.responseDurationMs,
        responseStatusCode: self2.responseStatusCode,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        timestamp: self2.timestamp,
        triggerType: messageAttemptTriggerType_1.MessageAttemptTriggerTypeSerializer._toJsonObject(self2.triggerType),
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageAttemptOut.js
var require_listResponseMessageAttemptOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageAttemptOutSerializer = undefined;
  var messageAttemptOut_1 = require_messageAttemptOut();
  exports.ListResponseMessageAttemptOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageAttemptOut_1.MessageAttemptOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/messageEndpointOut.js
var require_messageEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageEndpointOutSerializer = undefined;
  var messageStatus_1 = require_messageStatus();
  var messageStatusText_1 = require_messageStatusText();
  exports.MessageEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        channels: object2["channels"],
        createdAt: new Date(object2["createdAt"]),
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        id: object2["id"],
        nextAttempt: object2["nextAttempt"] ? new Date(object2["nextAttempt"]) : null,
        rateLimit: object2["rateLimit"],
        status: messageStatus_1.MessageStatusSerializer._fromJsonObject(object2["status"]),
        statusText: messageStatusText_1.MessageStatusTextSerializer._fromJsonObject(object2["statusText"]),
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"]),
        url: object2["url"],
        version: object2["version"]
      };
    },
    _toJsonObject(self2) {
      return {
        channels: self2.channels,
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        nextAttempt: self2.nextAttempt,
        rateLimit: self2.rateLimit,
        status: messageStatus_1.MessageStatusSerializer._toJsonObject(self2.status),
        statusText: messageStatusText_1.MessageStatusTextSerializer._toJsonObject(self2.statusText),
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url,
        version: self2.version
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseMessageEndpointOut.js
var require_listResponseMessageEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseMessageEndpointOutSerializer = undefined;
  var messageEndpointOut_1 = require_messageEndpointOut();
  exports.ListResponseMessageEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => messageEndpointOut_1.MessageEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/api/messageAttempt.js
var require_messageAttempt = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageAttempt = undefined;
  var listResponseEndpointMessageOut_1 = require_listResponseEndpointMessageOut();
  var listResponseMessageAttemptOut_1 = require_listResponseMessageAttemptOut();
  var listResponseMessageEndpointOut_1 = require_listResponseMessageEndpointOut();
  var messageAttemptOut_1 = require_messageAttemptOut();
  var request_1 = require_request();

  class MessageAttempt {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    listByEndpoint(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/endpoint/{endpoint_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("status", options === null || options === undefined ? undefined : options.status);
      request.setQueryParam("status_code_class", options === null || options === undefined ? undefined : options.statusCodeClass);
      request.setQueryParam("channel", options === null || options === undefined ? undefined : options.channel);
      request.setQueryParam("tag", options === null || options === undefined ? undefined : options.tag);
      request.setQueryParam("before", options === null || options === undefined ? undefined : options.before);
      request.setQueryParam("after", options === null || options === undefined ? undefined : options.after);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      request.setQueryParam("with_msg", options === null || options === undefined ? undefined : options.withMsg);
      request.setQueryParam("event_types", options === null || options === undefined ? undefined : options.eventTypes);
      return request.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listByMsg(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/attempt/msg/{msg_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("status", options === null || options === undefined ? undefined : options.status);
      request.setQueryParam("status_code_class", options === null || options === undefined ? undefined : options.statusCodeClass);
      request.setQueryParam("channel", options === null || options === undefined ? undefined : options.channel);
      request.setQueryParam("tag", options === null || options === undefined ? undefined : options.tag);
      request.setQueryParam("endpoint_id", options === null || options === undefined ? undefined : options.endpointId);
      request.setQueryParam("before", options === null || options === undefined ? undefined : options.before);
      request.setQueryParam("after", options === null || options === undefined ? undefined : options.after);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      request.setQueryParam("event_types", options === null || options === undefined ? undefined : options.eventTypes);
      return request.send(this.requestCtx, listResponseMessageAttemptOut_1.ListResponseMessageAttemptOutSerializer._fromJsonObject);
    }
    listAttemptedMessages(appId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/endpoint/{endpoint_id}/msg");
      request.setPathParam("app_id", appId);
      request.setPathParam("endpoint_id", endpointId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("channel", options === null || options === undefined ? undefined : options.channel);
      request.setQueryParam("tag", options === null || options === undefined ? undefined : options.tag);
      request.setQueryParam("status", options === null || options === undefined ? undefined : options.status);
      request.setQueryParam("before", options === null || options === undefined ? undefined : options.before);
      request.setQueryParam("after", options === null || options === undefined ? undefined : options.after);
      request.setQueryParam("with_content", options === null || options === undefined ? undefined : options.withContent);
      request.setQueryParam("event_types", options === null || options === undefined ? undefined : options.eventTypes);
      return request.send(this.requestCtx, listResponseEndpointMessageOut_1.ListResponseEndpointMessageOutSerializer._fromJsonObject);
    }
    get(appId, msgId, attemptId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("attempt_id", attemptId);
      return request.send(this.requestCtx, messageAttemptOut_1.MessageAttemptOutSerializer._fromJsonObject);
    }
    expungeContent(appId, msgId, attemptId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/app/{app_id}/msg/{msg_id}/attempt/{attempt_id}/content");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("attempt_id", attemptId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    listAttemptedDestinations(appId, msgId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      return request.send(this.requestCtx, listResponseMessageEndpointOut_1.ListResponseMessageEndpointOutSerializer._fromJsonObject);
    }
    resend(appId, msgId, endpointId, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/app/{app_id}/msg/{msg_id}/endpoint/{endpoint_id}/resend");
      request.setPathParam("app_id", appId);
      request.setPathParam("msg_id", msgId);
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.MessageAttempt = MessageAttempt;
});

// node_modules/svix/dist/models/operationalWebhookEndpointOut.js
var require_operationalWebhookEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointOutSerializer = undefined;
  exports.OperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        createdAt: new Date(object2["createdAt"]),
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        id: object2["id"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        updatedAt: new Date(object2["updatedAt"]),
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        createdAt: self2.createdAt,
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        id: self2.id,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        updatedAt: self2.updatedAt,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/listResponseOperationalWebhookEndpointOut.js
var require_listResponseOperationalWebhookEndpointOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseOperationalWebhookEndpointOutSerializer = undefined;
  var operationalWebhookEndpointOut_1 = require_operationalWebhookEndpointOut();
  exports.ListResponseOperationalWebhookEndpointOutSerializer = {
    _fromJsonObject(object2) {
      return {
        data: object2["data"].map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject(item)),
        done: object2["done"],
        iterator: object2["iterator"],
        prevIterator: object2["prevIterator"]
      };
    },
    _toJsonObject(self2) {
      return {
        data: self2.data.map((item) => operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._toJsonObject(item)),
        done: self2.done,
        iterator: self2.iterator,
        prevIterator: self2.prevIterator
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointHeadersIn.js
var require_operationalWebhookEndpointHeadersIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointHeadersInSerializer = undefined;
  exports.OperationalWebhookEndpointHeadersInSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointHeadersOut.js
var require_operationalWebhookEndpointHeadersOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointHeadersOutSerializer = undefined;
  exports.OperationalWebhookEndpointHeadersOutSerializer = {
    _fromJsonObject(object2) {
      return {
        headers: object2["headers"],
        sensitive: object2["sensitive"]
      };
    },
    _toJsonObject(self2) {
      return {
        headers: self2.headers,
        sensitive: self2.sensitive
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointIn.js
var require_operationalWebhookEndpointIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointInSerializer = undefined;
  exports.OperationalWebhookEndpointInSerializer = {
    _fromJsonObject(object2) {
      return {
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        secret: object2["secret"],
        uid: object2["uid"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        secret: self2.secret,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointSecretIn.js
var require_operationalWebhookEndpointSecretIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointSecretInSerializer = undefined;
  exports.OperationalWebhookEndpointSecretInSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointSecretOut.js
var require_operationalWebhookEndpointSecretOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointSecretOutSerializer = undefined;
  exports.OperationalWebhookEndpointSecretOutSerializer = {
    _fromJsonObject(object2) {
      return {
        key: object2["key"]
      };
    },
    _toJsonObject(self2) {
      return {
        key: self2.key
      };
    }
  };
});

// node_modules/svix/dist/models/operationalWebhookEndpointUpdate.js
var require_operationalWebhookEndpointUpdate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpointUpdateSerializer = undefined;
  exports.OperationalWebhookEndpointUpdateSerializer = {
    _fromJsonObject(object2) {
      return {
        description: object2["description"],
        disabled: object2["disabled"],
        filterTypes: object2["filterTypes"],
        metadata: object2["metadata"],
        rateLimit: object2["rateLimit"],
        uid: object2["uid"],
        url: object2["url"]
      };
    },
    _toJsonObject(self2) {
      return {
        description: self2.description,
        disabled: self2.disabled,
        filterTypes: self2.filterTypes,
        metadata: self2.metadata,
        rateLimit: self2.rateLimit,
        uid: self2.uid,
        url: self2.url
      };
    }
  };
});

// node_modules/svix/dist/api/operationalWebhookEndpoint.js
var require_operationalWebhookEndpoint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhookEndpoint = undefined;
  var listResponseOperationalWebhookEndpointOut_1 = require_listResponseOperationalWebhookEndpointOut();
  var operationalWebhookEndpointHeadersIn_1 = require_operationalWebhookEndpointHeadersIn();
  var operationalWebhookEndpointHeadersOut_1 = require_operationalWebhookEndpointHeadersOut();
  var operationalWebhookEndpointIn_1 = require_operationalWebhookEndpointIn();
  var operationalWebhookEndpointOut_1 = require_operationalWebhookEndpointOut();
  var operationalWebhookEndpointSecretIn_1 = require_operationalWebhookEndpointSecretIn();
  var operationalWebhookEndpointSecretOut_1 = require_operationalWebhookEndpointSecretOut();
  var operationalWebhookEndpointUpdate_1 = require_operationalWebhookEndpointUpdate();
  var request_1 = require_request();

  class OperationalWebhookEndpoint {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    list(options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint");
      request.setQueryParam("limit", options === null || options === undefined ? undefined : options.limit);
      request.setQueryParam("iterator", options === null || options === undefined ? undefined : options.iterator);
      request.setQueryParam("order", options === null || options === undefined ? undefined : options.order);
      return request.send(this.requestCtx, listResponseOperationalWebhookEndpointOut_1.ListResponseOperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    create(operationalWebhookEndpointIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(operationalWebhookEndpointIn_1.OperationalWebhookEndpointInSerializer._toJsonObject(operationalWebhookEndpointIn));
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    get(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    update(endpointId, operationalWebhookEndpointUpdate) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(operationalWebhookEndpointUpdate_1.OperationalWebhookEndpointUpdateSerializer._toJsonObject(operationalWebhookEndpointUpdate));
      return request.send(this.requestCtx, operationalWebhookEndpointOut_1.OperationalWebhookEndpointOutSerializer._fromJsonObject);
    }
    delete(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.DELETE, "/api/v1/operational-webhook/endpoint/{endpoint_id}");
      request.setPathParam("endpoint_id", endpointId);
      return request.sendNoResponseBody(this.requestCtx);
    }
    getHeaders(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointHeadersOut_1.OperationalWebhookEndpointHeadersOutSerializer._fromJsonObject);
    }
    updateHeaders(endpointId, operationalWebhookEndpointHeadersIn) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/operational-webhook/endpoint/{endpoint_id}/headers");
      request.setPathParam("endpoint_id", endpointId);
      request.setBody(operationalWebhookEndpointHeadersIn_1.OperationalWebhookEndpointHeadersInSerializer._toJsonObject(operationalWebhookEndpointHeadersIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
    getSecret(endpointId) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.GET, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret");
      request.setPathParam("endpoint_id", endpointId);
      return request.send(this.requestCtx, operationalWebhookEndpointSecretOut_1.OperationalWebhookEndpointSecretOutSerializer._fromJsonObject);
    }
    rotateSecret(endpointId, operationalWebhookEndpointSecretIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/operational-webhook/endpoint/{endpoint_id}/secret/rotate");
      request.setPathParam("endpoint_id", endpointId);
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(operationalWebhookEndpointSecretIn_1.OperationalWebhookEndpointSecretInSerializer._toJsonObject(operationalWebhookEndpointSecretIn));
      return request.sendNoResponseBody(this.requestCtx);
    }
  }
  exports.OperationalWebhookEndpoint = OperationalWebhookEndpoint;
});

// node_modules/svix/dist/api/operationalWebhook.js
var require_operationalWebhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperationalWebhook = undefined;
  var operationalWebhookEndpoint_1 = require_operationalWebhookEndpoint();

  class OperationalWebhook {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    get endpoint() {
      return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
    }
  }
  exports.OperationalWebhook = OperationalWebhook;
});

// node_modules/svix/dist/models/aggregateEventTypesOut.js
var require_aggregateEventTypesOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AggregateEventTypesOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.AggregateEventTypesOutSerializer = {
    _fromJsonObject(object2) {
      return {
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"])
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task)
      };
    }
  };
});

// node_modules/svix/dist/models/appUsageStatsIn.js
var require_appUsageStatsIn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppUsageStatsInSerializer = undefined;
  exports.AppUsageStatsInSerializer = {
    _fromJsonObject(object2) {
      return {
        appIds: object2["appIds"],
        since: new Date(object2["since"]),
        until: new Date(object2["until"])
      };
    },
    _toJsonObject(self2) {
      return {
        appIds: self2.appIds,
        since: self2.since,
        until: self2.until
      };
    }
  };
});

// node_modules/svix/dist/models/appUsageStatsOut.js
var require_appUsageStatsOut = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AppUsageStatsOutSerializer = undefined;
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  var backgroundTaskType_1 = require_backgroundTaskType();
  exports.AppUsageStatsOutSerializer = {
    _fromJsonObject(object2) {
      return {
        id: object2["id"],
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._fromJsonObject(object2["status"]),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._fromJsonObject(object2["task"]),
        unresolvedAppIds: object2["unresolvedAppIds"]
      };
    },
    _toJsonObject(self2) {
      return {
        id: self2.id,
        status: backgroundTaskStatus_1.BackgroundTaskStatusSerializer._toJsonObject(self2.status),
        task: backgroundTaskType_1.BackgroundTaskTypeSerializer._toJsonObject(self2.task),
        unresolvedAppIds: self2.unresolvedAppIds
      };
    }
  };
});

// node_modules/svix/dist/api/statistics.js
var require_statistics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Statistics = undefined;
  var aggregateEventTypesOut_1 = require_aggregateEventTypesOut();
  var appUsageStatsIn_1 = require_appUsageStatsIn();
  var appUsageStatsOut_1 = require_appUsageStatsOut();
  var request_1 = require_request();

  class Statistics {
    constructor(requestCtx) {
      this.requestCtx = requestCtx;
    }
    aggregateAppStats(appUsageStatsIn, options) {
      const request = new request_1.SvixRequest(request_1.HttpMethod.POST, "/api/v1/stats/usage/app");
      request.setHeaderParam("idempotency-key", options === null || options === undefined ? undefined : options.idempotencyKey);
      request.setBody(appUsageStatsIn_1.AppUsageStatsInSerializer._toJsonObject(appUsageStatsIn));
      return request.send(this.requestCtx, appUsageStatsOut_1.AppUsageStatsOutSerializer._fromJsonObject);
    }
    aggregateEventTypes() {
      const request = new request_1.SvixRequest(request_1.HttpMethod.PUT, "/api/v1/stats/usage/event-types");
      return request.send(this.requestCtx, aggregateEventTypesOut_1.AggregateEventTypesOutSerializer._fromJsonObject);
    }
  }
  exports.Statistics = Statistics;
});

// node_modules/svix/dist/HttpErrors.js
var require_HttpErrors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HTTPValidationError = exports.ValidationError = exports.HttpErrorOut = undefined;

  class HttpErrorOut {
    static getAttributeTypeMap() {
      return HttpErrorOut.attributeTypeMap;
    }
  }
  exports.HttpErrorOut = HttpErrorOut;
  HttpErrorOut.discriminator = undefined;
  HttpErrorOut.mapping = undefined;
  HttpErrorOut.attributeTypeMap = [
    {
      name: "code",
      baseName: "code",
      type: "string",
      format: ""
    },
    {
      name: "detail",
      baseName: "detail",
      type: "string",
      format: ""
    }
  ];

  class ValidationError2 {
    static getAttributeTypeMap() {
      return ValidationError2.attributeTypeMap;
    }
  }
  exports.ValidationError = ValidationError2;
  ValidationError2.discriminator = undefined;
  ValidationError2.mapping = undefined;
  ValidationError2.attributeTypeMap = [
    {
      name: "loc",
      baseName: "loc",
      type: "Array<string>",
      format: ""
    },
    {
      name: "msg",
      baseName: "msg",
      type: "string",
      format: ""
    },
    {
      name: "type",
      baseName: "type",
      type: "string",
      format: ""
    }
  ];

  class HTTPValidationError {
    static getAttributeTypeMap() {
      return HTTPValidationError.attributeTypeMap;
    }
  }
  exports.HTTPValidationError = HTTPValidationError;
  HTTPValidationError.discriminator = undefined;
  HTTPValidationError.mapping = undefined;
  HTTPValidationError.attributeTypeMap = [
    {
      name: "detail",
      baseName: "detail",
      type: "Array<ValidationError>",
      format: ""
    }
  ];
});

// node_modules/svix/dist/timing_safe_equal.js
var require_timing_safe_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timingSafeEqual = undefined;
  function assert3(expr, msg = "") {
    if (!expr) {
      throw new Error(msg);
    }
  }
  function timingSafeEqual(a, b5) {
    if (a.byteLength !== b5.byteLength) {
      return false;
    }
    if (!(a instanceof DataView)) {
      a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b5 instanceof DataView)) {
      b5 = new DataView(ArrayBuffer.isView(b5) ? b5.buffer : b5);
    }
    assert3(a instanceof DataView);
    assert3(b5 instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i2 = -1;
    while (++i2 < length) {
      out |= a.getUint8(i2) ^ b5.getUint8(i2);
    }
    return out === 0;
  }
  exports.timingSafeEqual = timingSafeEqual;
});

// node_modules/@stablelib/base64/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d2, b5) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b6) {
        d3.__proto__ = b6;
      } || function(d3, b6) {
        for (var p in b6)
          if (b6.hasOwnProperty(p))
            d3[p] = b6[p];
      };
      return extendStatics(d2, b5);
    };
    return function(d2, b5) {
      extendStatics(d2, b5);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  var INVALID_BYTE = 256;
  var Coder = function() {
    function Coder2(_paddingCharacter) {
      if (_paddingCharacter === undefined) {
        _paddingCharacter = "=";
      }
      this._paddingCharacter = _paddingCharacter;
    }
    Coder2.prototype.encodedLength = function(length) {
      if (!this._paddingCharacter) {
        return (length * 8 + 5) / 6 | 0;
      }
      return (length + 2) / 3 * 4 | 0;
    };
    Coder2.prototype.encode = function(data) {
      var out = "";
      var i2 = 0;
      for (;i2 < data.length - 2; i2 += 3) {
        var c2 = data[i2] << 16 | data[i2 + 1] << 8 | data[i2 + 2];
        out += this._encodeByte(c2 >>> 3 * 6 & 63);
        out += this._encodeByte(c2 >>> 2 * 6 & 63);
        out += this._encodeByte(c2 >>> 1 * 6 & 63);
        out += this._encodeByte(c2 >>> 0 * 6 & 63);
      }
      var left2 = data.length - i2;
      if (left2 > 0) {
        var c2 = data[i2] << 16 | (left2 === 2 ? data[i2 + 1] << 8 : 0);
        out += this._encodeByte(c2 >>> 3 * 6 & 63);
        out += this._encodeByte(c2 >>> 2 * 6 & 63);
        if (left2 === 2) {
          out += this._encodeByte(c2 >>> 1 * 6 & 63);
        } else {
          out += this._paddingCharacter || "";
        }
        out += this._paddingCharacter || "";
      }
      return out;
    };
    Coder2.prototype.maxDecodedLength = function(length) {
      if (!this._paddingCharacter) {
        return (length * 6 + 7) / 8 | 0;
      }
      return length / 4 * 3 | 0;
    };
    Coder2.prototype.decodedLength = function(s2) {
      return this.maxDecodedLength(s2.length - this._getPaddingLength(s2));
    };
    Coder2.prototype.decode = function(s2) {
      if (s2.length === 0) {
        return new Uint8Array(0);
      }
      var paddingLength = this._getPaddingLength(s2);
      var length = s2.length - paddingLength;
      var out = new Uint8Array(this.maxDecodedLength(length));
      var op = 0;
      var i2 = 0;
      var haveBad = 0;
      var v0 = 0, v1 = 0, v22 = 0, v3 = 0;
      for (;i2 < length - 4; i2 += 4) {
        v0 = this._decodeChar(s2.charCodeAt(i2 + 0));
        v1 = this._decodeChar(s2.charCodeAt(i2 + 1));
        v22 = this._decodeChar(s2.charCodeAt(i2 + 2));
        v3 = this._decodeChar(s2.charCodeAt(i2 + 3));
        out[op++] = v0 << 2 | v1 >>> 4;
        out[op++] = v1 << 4 | v22 >>> 2;
        out[op++] = v22 << 6 | v3;
        haveBad |= v0 & INVALID_BYTE;
        haveBad |= v1 & INVALID_BYTE;
        haveBad |= v22 & INVALID_BYTE;
        haveBad |= v3 & INVALID_BYTE;
      }
      if (i2 < length - 1) {
        v0 = this._decodeChar(s2.charCodeAt(i2));
        v1 = this._decodeChar(s2.charCodeAt(i2 + 1));
        out[op++] = v0 << 2 | v1 >>> 4;
        haveBad |= v0 & INVALID_BYTE;
        haveBad |= v1 & INVALID_BYTE;
      }
      if (i2 < length - 2) {
        v22 = this._decodeChar(s2.charCodeAt(i2 + 2));
        out[op++] = v1 << 4 | v22 >>> 2;
        haveBad |= v22 & INVALID_BYTE;
      }
      if (i2 < length - 3) {
        v3 = this._decodeChar(s2.charCodeAt(i2 + 3));
        out[op++] = v22 << 6 | v3;
        haveBad |= v3 & INVALID_BYTE;
      }
      if (haveBad !== 0) {
        throw new Error("Base64Coder: incorrect characters for decoding");
      }
      return out;
    };
    Coder2.prototype._encodeByte = function(b5) {
      var result = b5;
      result += 65;
      result += 25 - b5 >>> 8 & 0 - 65 - 26 + 97;
      result += 51 - b5 >>> 8 & 26 - 97 - 52 + 48;
      result += 61 - b5 >>> 8 & 52 - 48 - 62 + 43;
      result += 62 - b5 >>> 8 & 62 - 43 - 63 + 47;
      return String.fromCharCode(result);
    };
    Coder2.prototype._decodeChar = function(c2) {
      var result = INVALID_BYTE;
      result += (42 - c2 & c2 - 44) >>> 8 & -INVALID_BYTE + c2 - 43 + 62;
      result += (46 - c2 & c2 - 48) >>> 8 & -INVALID_BYTE + c2 - 47 + 63;
      result += (47 - c2 & c2 - 58) >>> 8 & -INVALID_BYTE + c2 - 48 + 52;
      result += (64 - c2 & c2 - 91) >>> 8 & -INVALID_BYTE + c2 - 65 + 0;
      result += (96 - c2 & c2 - 123) >>> 8 & -INVALID_BYTE + c2 - 97 + 26;
      return result;
    };
    Coder2.prototype._getPaddingLength = function(s2) {
      var paddingLength = 0;
      if (this._paddingCharacter) {
        for (var i2 = s2.length - 1;i2 >= 0; i2--) {
          if (s2[i2] !== this._paddingCharacter) {
            break;
          }
          paddingLength++;
        }
        if (s2.length < 4 || paddingLength > 2) {
          throw new Error("Base64Coder: incorrect padding");
        }
      }
      return paddingLength;
    };
    return Coder2;
  }();
  exports.Coder = Coder;
  var stdCoder = new Coder;
  function encode3(data) {
    return stdCoder.encode(data);
  }
  exports.encode = encode3;
  function decode3(s2) {
    return stdCoder.decode(s2);
  }
  exports.decode = decode3;
  var URLSafeCoder = function(_super) {
    __extends(URLSafeCoder2, _super);
    function URLSafeCoder2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    URLSafeCoder2.prototype._encodeByte = function(b5) {
      var result = b5;
      result += 65;
      result += 25 - b5 >>> 8 & 0 - 65 - 26 + 97;
      result += 51 - b5 >>> 8 & 26 - 97 - 52 + 48;
      result += 61 - b5 >>> 8 & 52 - 48 - 62 + 45;
      result += 62 - b5 >>> 8 & 62 - 45 - 63 + 95;
      return String.fromCharCode(result);
    };
    URLSafeCoder2.prototype._decodeChar = function(c2) {
      var result = INVALID_BYTE;
      result += (44 - c2 & c2 - 46) >>> 8 & -INVALID_BYTE + c2 - 45 + 62;
      result += (94 - c2 & c2 - 96) >>> 8 & -INVALID_BYTE + c2 - 95 + 63;
      result += (47 - c2 & c2 - 58) >>> 8 & -INVALID_BYTE + c2 - 48 + 52;
      result += (64 - c2 & c2 - 91) >>> 8 & -INVALID_BYTE + c2 - 65 + 0;
      result += (96 - c2 & c2 - 123) >>> 8 & -INVALID_BYTE + c2 - 97 + 26;
      return result;
    };
    return URLSafeCoder2;
  }(Coder);
  exports.URLSafeCoder = URLSafeCoder;
  var urlSafeCoder = new URLSafeCoder;
  function encodeURLSafe(data) {
    return urlSafeCoder.encode(data);
  }
  exports.encodeURLSafe = encodeURLSafe;
  function decodeURLSafe(s2) {
    return urlSafeCoder.decode(s2);
  }
  exports.decodeURLSafe = decodeURLSafe;
  exports.encodedLength = function(length) {
    return stdCoder.encodedLength(length);
  };
  exports.maxDecodedLength = function(length) {
    return stdCoder.maxDecodedLength(length);
  };
  exports.decodedLength = function(s2) {
    return stdCoder.decodedLength(s2);
  };
});

// node_modules/fast-sha256/sha256.js
var require_sha256 = __commonJS((exports, module) => {
  (function(root, factory) {
    var exports2 = {};
    factory(exports2);
    var sha2562 = exports2["default"];
    for (var k4 in exports2) {
      sha2562[k4] = exports2[k4];
    }
    if (typeof module === "object" && typeof module.exports === "object") {
      module.exports = sha2562;
    } else if (typeof define === "function" && define.amd) {
      define(function() {
        return sha2562;
      });
    } else {
      root.sha256 = sha2562;
    }
  })(exports, function(exports2) {
    exports2.__esModule = true;
    exports2.digestLength = 32;
    exports2.blockSize = 64;
    var K3 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w3, v3, p, pos, len) {
      var a, b5, c2, d2, e2, f, g2, h2, u, i2, j3, t1, t22;
      while (len >= 64) {
        a = v3[0];
        b5 = v3[1];
        c2 = v3[2];
        d2 = v3[3];
        e2 = v3[4];
        f = v3[5];
        g2 = v3[6];
        h2 = v3[7];
        for (i2 = 0;i2 < 16; i2++) {
          j3 = pos + i2 * 4;
          w3[i2] = (p[j3] & 255) << 24 | (p[j3 + 1] & 255) << 16 | (p[j3 + 2] & 255) << 8 | p[j3 + 3] & 255;
        }
        for (i2 = 16;i2 < 64; i2++) {
          u = w3[i2 - 2];
          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w3[i2 - 15];
          t22 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w3[i2] = (t1 + w3[i2 - 7] | 0) + (t22 + w3[i2 - 16] | 0);
        }
        for (i2 = 0;i2 < 64; i2++) {
          t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f ^ ~e2 & g2) | 0) + (h2 + (K3[i2] + w3[i2] | 0) | 0) | 0;
          t22 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b5 ^ a & c2 ^ b5 & c2) | 0;
          h2 = g2;
          g2 = f;
          f = e2;
          e2 = d2 + t1 | 0;
          d2 = c2;
          c2 = b5;
          b5 = a;
          a = t1 + t22 | 0;
        }
        v3[0] += a;
        v3[1] += b5;
        v3[2] += c2;
        v3[3] += d2;
        v3[4] += e2;
        v3[5] += f;
        v3[6] += g2;
        v3[7] += h2;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    var Hash2 = function() {
      function Hash3() {
        this.digestLength = exports2.digestLength;
        this.blockSize = exports2.blockSize;
        this.state = new Int32Array(8);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(128);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        this.reset();
      }
      Hash3.prototype.reset = function() {
        this.state[0] = 1779033703;
        this.state[1] = 3144134277;
        this.state[2] = 1013904242;
        this.state[3] = 2773480762;
        this.state[4] = 1359893119;
        this.state[5] = 2600822924;
        this.state[6] = 528734635;
        this.state[7] = 1541459225;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
      };
      Hash3.prototype.clean = function() {
        for (var i2 = 0;i2 < this.buffer.length; i2++) {
          this.buffer[i2] = 0;
        }
        for (var i2 = 0;i2 < this.temp.length; i2++) {
          this.temp[i2] = 0;
        }
        this.reset();
      };
      Hash3.prototype.update = function(data, dataLength) {
        if (dataLength === undefined) {
          dataLength = data.length;
        }
        if (this.finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
          while (this.bufferLength < 64 && dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this.bufferLength === 64) {
            hashBlocks(this.temp, this.state, this.buffer, 0, 64);
            this.bufferLength = 0;
          }
        }
        if (dataLength >= 64) {
          dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
          dataLength %= 64;
        }
        while (dataLength > 0) {
          this.buffer[this.bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      Hash3.prototype.finish = function(out) {
        if (!this.finished) {
          var bytesHashed = this.bytesHashed;
          var left2 = this.bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this.buffer[left2] = 128;
          for (var i2 = left2 + 1;i2 < padLength - 8; i2++) {
            this.buffer[i2] = 0;
          }
          this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
          this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
          this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
          this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
          this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
          this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
          this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
          this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
          hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
          this.finished = true;
        }
        for (var i2 = 0;i2 < 8; i2++) {
          out[i2 * 4 + 0] = this.state[i2] >>> 24 & 255;
          out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
          out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
          out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
        }
        return this;
      };
      Hash3.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      Hash3.prototype._saveState = function(out) {
        for (var i2 = 0;i2 < this.state.length; i2++) {
          out[i2] = this.state[i2];
        }
      };
      Hash3.prototype._restoreState = function(from, bytesHashed) {
        for (var i2 = 0;i2 < this.state.length; i2++) {
          this.state[i2] = from[i2];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
      };
      return Hash3;
    }();
    exports2.Hash = Hash2;
    var HMAC = function() {
      function HMAC2(key) {
        this.inner = new Hash2;
        this.outer = new Hash2;
        this.blockSize = this.inner.blockSize;
        this.digestLength = this.inner.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          new Hash2().update(key).finish(pad).clean();
        } else {
          for (var i2 = 0;i2 < key.length; i2++) {
            pad[i2] = key[i2];
          }
        }
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] ^= 54;
        }
        this.inner.update(pad);
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] ^= 54 ^ 92;
        }
        this.outer.update(pad);
        this.istate = new Uint32Array(8);
        this.ostate = new Uint32Array(8);
        this.inner._saveState(this.istate);
        this.outer._saveState(this.ostate);
        for (var i2 = 0;i2 < pad.length; i2++) {
          pad[i2] = 0;
        }
      }
      HMAC2.prototype.reset = function() {
        this.inner._restoreState(this.istate, this.inner.blockSize);
        this.outer._restoreState(this.ostate, this.outer.blockSize);
        return this;
      };
      HMAC2.prototype.clean = function() {
        for (var i2 = 0;i2 < this.istate.length; i2++) {
          this.ostate[i2] = this.istate[i2] = 0;
        }
        this.inner.clean();
        this.outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this.inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this.outer.finished) {
          this.outer.finish(out);
        } else {
          this.inner.finish(out);
          this.outer.update(out, this.digestLength).finish(out);
        }
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      return HMAC2;
    }();
    exports2.HMAC = HMAC;
    function hash2(data) {
      var h2 = new Hash2().update(data);
      var digest = h2.digest();
      h2.clean();
      return digest;
    }
    exports2.hash = hash2;
    exports2["default"] = hash2;
    function hmac2(key, data) {
      var h2 = new HMAC(key).update(data);
      var digest = h2.digest();
      h2.clean();
      return digest;
    }
    exports2.hmac = hmac2;
    function fillBuffer(buffer2, hmac3, info, counter) {
      var num = counter[0];
      if (num === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      hmac3.reset();
      if (num > 1) {
        hmac3.update(buffer2);
      }
      if (info) {
        hmac3.update(info);
      }
      hmac3.update(counter);
      hmac3.finish(buffer2);
      counter[0]++;
    }
    var hkdfSalt = new Uint8Array(exports2.digestLength);
    function hkdf(key, salt, info, length) {
      if (salt === undefined) {
        salt = hkdfSalt;
      }
      if (length === undefined) {
        length = 32;
      }
      var counter = new Uint8Array([1]);
      var okm = hmac2(salt, key);
      var hmac_ = new HMAC(okm);
      var buffer2 = new Uint8Array(hmac_.digestLength);
      var bufpos = buffer2.length;
      var out = new Uint8Array(length);
      for (var i2 = 0;i2 < length; i2++) {
        if (bufpos === buffer2.length) {
          fillBuffer(buffer2, hmac_, info, counter);
          bufpos = 0;
        }
        out[i2] = buffer2[bufpos++];
      }
      hmac_.clean();
      buffer2.fill(0);
      counter.fill(0);
      return out;
    }
    exports2.hkdf = hkdf;
    function pbkdf2(password, salt, iterations, dkLen) {
      var prf = new HMAC(password);
      var len = prf.digestLength;
      var ctr = new Uint8Array(4);
      var t10 = new Uint8Array(len);
      var u = new Uint8Array(len);
      var dk = new Uint8Array(dkLen);
      for (var i2 = 0;i2 * len < dkLen; i2++) {
        var c2 = i2 + 1;
        ctr[0] = c2 >>> 24 & 255;
        ctr[1] = c2 >>> 16 & 255;
        ctr[2] = c2 >>> 8 & 255;
        ctr[3] = c2 >>> 0 & 255;
        prf.reset();
        prf.update(salt);
        prf.update(ctr);
        prf.finish(u);
        for (var j3 = 0;j3 < len; j3++) {
          t10[j3] = u[j3];
        }
        for (var j3 = 2;j3 <= iterations; j3++) {
          prf.reset();
          prf.update(u).finish(u);
          for (var k4 = 0;k4 < len; k4++) {
            t10[k4] ^= u[k4];
          }
        }
        for (var j3 = 0;j3 < len && i2 * len + j3 < dkLen; j3++) {
          dk[i2 * len + j3] = t10[j3];
        }
      }
      for (var i2 = 0;i2 < len; i2++) {
        t10[i2] = u[i2] = 0;
      }
      for (var i2 = 0;i2 < 4; i2++) {
        ctr[i2] = 0;
      }
      prf.clean();
      return dk;
    }
    exports2.pbkdf2 = pbkdf2;
  });
});

// node_modules/svix/dist/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Webhook = exports.WebhookVerificationError = undefined;
  var timing_safe_equal_1 = require_timing_safe_equal();
  var base643 = require_base64();
  var sha2562 = require_sha256();
  var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;

  class ExtendableError extends Error {
    constructor(message2) {
      super(message2);
      Object.setPrototypeOf(this, ExtendableError.prototype);
      this.name = "ExtendableError";
      this.stack = new Error(message2).stack;
    }
  }

  class WebhookVerificationError extends ExtendableError {
    constructor(message2) {
      super(message2);
      Object.setPrototypeOf(this, WebhookVerificationError.prototype);
      this.name = "WebhookVerificationError";
    }
  }
  exports.WebhookVerificationError = WebhookVerificationError;

  class Webhook {
    constructor(secret, options) {
      if (!secret) {
        throw new Error("Secret can't be empty.");
      }
      if ((options === null || options === undefined ? undefined : options.format) === "raw") {
        if (secret instanceof Uint8Array) {
          this.key = secret;
        } else {
          this.key = Uint8Array.from(secret, (c2) => c2.charCodeAt(0));
        }
      } else {
        if (typeof secret !== "string") {
          throw new Error("Expected secret to be of type string");
        }
        if (secret.startsWith(Webhook.prefix)) {
          secret = secret.substring(Webhook.prefix.length);
        }
        this.key = base643.decode(secret);
      }
    }
    verify(payload, headers_) {
      const headers = {};
      for (const key of Object.keys(headers_)) {
        headers[key.toLowerCase()] = headers_[key];
      }
      let msgId = headers["svix-id"];
      let msgSignature = headers["svix-signature"];
      let msgTimestamp = headers["svix-timestamp"];
      if (!msgSignature || !msgId || !msgTimestamp) {
        msgId = headers["webhook-id"];
        msgSignature = headers["webhook-signature"];
        msgTimestamp = headers["webhook-timestamp"];
        if (!msgSignature || !msgId || !msgTimestamp) {
          throw new WebhookVerificationError("Missing required headers");
        }
      }
      const timestamp2 = this.verifyTimestamp(msgTimestamp);
      const computedSignature = this.sign(msgId, timestamp2, payload);
      const expectedSignature = computedSignature.split(",")[1];
      const passedSignatures = msgSignature.split(" ");
      const encoder3 = new globalThis.TextEncoder;
      for (const versionedSignature of passedSignatures) {
        const [version4, signature] = versionedSignature.split(",");
        if (version4 !== "v1") {
          continue;
        }
        if ((0, timing_safe_equal_1.timingSafeEqual)(encoder3.encode(signature), encoder3.encode(expectedSignature))) {
          return JSON.parse(payload.toString());
        }
      }
      throw new WebhookVerificationError("No matching signature found");
    }
    sign(msgId, timestamp2, payload) {
      if (typeof payload === "string") {} else if (payload.constructor.name === "Buffer") {
        payload = payload.toString();
      } else {
        throw new Error("Expected payload to be of type string or Buffer. Please refer to https://docs.svix.com/receiving/verifying-payloads/how for more information.");
      }
      const encoder3 = new TextEncoder;
      const timestampNumber = Math.floor(timestamp2.getTime() / 1000);
      const toSign = encoder3.encode(`${msgId}.${timestampNumber}.${payload}`);
      const expectedSignature = base643.encode(sha2562.hmac(this.key, toSign));
      return `v1,${expectedSignature}`;
    }
    verifyTimestamp(timestampHeader) {
      const now = Math.floor(Date.now() / 1000);
      const timestamp2 = parseInt(timestampHeader, 10);
      if (isNaN(timestamp2)) {
        throw new WebhookVerificationError("Invalid Signature Headers");
      }
      if (now - timestamp2 > WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too old");
      }
      if (timestamp2 > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
        throw new WebhookVerificationError("Message timestamp too new");
      }
      return new Date(timestamp2 * 1000);
    }
  }
  exports.Webhook = Webhook;
  Webhook.prefix = "whsec_";
});

// node_modules/svix/dist/models/endpointDisabledTrigger.js
var require_endpointDisabledTrigger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EndpointDisabledTriggerSerializer = exports.EndpointDisabledTrigger = undefined;
  var EndpointDisabledTrigger;
  (function(EndpointDisabledTrigger2) {
    EndpointDisabledTrigger2["Manual"] = "manual";
    EndpointDisabledTrigger2["Automatic"] = "automatic";
  })(EndpointDisabledTrigger = exports.EndpointDisabledTrigger || (exports.EndpointDisabledTrigger = {}));
  exports.EndpointDisabledTriggerSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/ordering.js
var require_ordering = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OrderingSerializer = exports.Ordering = undefined;
  var Ordering;
  (function(Ordering2) {
    Ordering2["Ascending"] = "ascending";
    Ordering2["Descending"] = "descending";
  })(Ordering = exports.Ordering || (exports.Ordering = {}));
  exports.OrderingSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/statusCodeClass.js
var require_statusCodeClass = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatusCodeClassSerializer = exports.StatusCodeClass = undefined;
  var StatusCodeClass;
  (function(StatusCodeClass2) {
    StatusCodeClass2[StatusCodeClass2["CodeNone"] = 0] = "CodeNone";
    StatusCodeClass2[StatusCodeClass2["Code1xx"] = 100] = "Code1xx";
    StatusCodeClass2[StatusCodeClass2["Code2xx"] = 200] = "Code2xx";
    StatusCodeClass2[StatusCodeClass2["Code3xx"] = 300] = "Code3xx";
    StatusCodeClass2[StatusCodeClass2["Code4xx"] = 400] = "Code4xx";
    StatusCodeClass2[StatusCodeClass2["Code5xx"] = 500] = "Code5xx";
  })(StatusCodeClass = exports.StatusCodeClass || (exports.StatusCodeClass = {}));
  exports.StatusCodeClassSerializer = {
    _fromJsonObject(object2) {
      return object2;
    },
    _toJsonObject(self2) {
      return self2;
    }
  };
});

// node_modules/svix/dist/models/index.js
var require_models = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StatusCodeClass = exports.Ordering = exports.MessageStatusText = exports.MessageStatus = exports.MessageAttemptTriggerType = exports.EndpointDisabledTrigger = exports.ConnectorKind = exports.BackgroundTaskType = exports.BackgroundTaskStatus = exports.AppPortalCapability = undefined;
  var appPortalCapability_1 = require_appPortalCapability();
  Object.defineProperty(exports, "AppPortalCapability", { enumerable: true, get: function() {
    return appPortalCapability_1.AppPortalCapability;
  } });
  var backgroundTaskStatus_1 = require_backgroundTaskStatus();
  Object.defineProperty(exports, "BackgroundTaskStatus", { enumerable: true, get: function() {
    return backgroundTaskStatus_1.BackgroundTaskStatus;
  } });
  var backgroundTaskType_1 = require_backgroundTaskType();
  Object.defineProperty(exports, "BackgroundTaskType", { enumerable: true, get: function() {
    return backgroundTaskType_1.BackgroundTaskType;
  } });
  var connectorKind_1 = require_connectorKind();
  Object.defineProperty(exports, "ConnectorKind", { enumerable: true, get: function() {
    return connectorKind_1.ConnectorKind;
  } });
  var endpointDisabledTrigger_1 = require_endpointDisabledTrigger();
  Object.defineProperty(exports, "EndpointDisabledTrigger", { enumerable: true, get: function() {
    return endpointDisabledTrigger_1.EndpointDisabledTrigger;
  } });
  var messageAttemptTriggerType_1 = require_messageAttemptTriggerType();
  Object.defineProperty(exports, "MessageAttemptTriggerType", { enumerable: true, get: function() {
    return messageAttemptTriggerType_1.MessageAttemptTriggerType;
  } });
  var messageStatus_1 = require_messageStatus();
  Object.defineProperty(exports, "MessageStatus", { enumerable: true, get: function() {
    return messageStatus_1.MessageStatus;
  } });
  var messageStatusText_1 = require_messageStatusText();
  Object.defineProperty(exports, "MessageStatusText", { enumerable: true, get: function() {
    return messageStatusText_1.MessageStatusText;
  } });
  var ordering_1 = require_ordering();
  Object.defineProperty(exports, "Ordering", { enumerable: true, get: function() {
    return ordering_1.Ordering;
  } });
  var statusCodeClass_1 = require_statusCodeClass();
  Object.defineProperty(exports, "StatusCodeClass", { enumerable: true, get: function() {
    return statusCodeClass_1.StatusCodeClass;
  } });
});

// node_modules/svix/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    var desc2 = Object.getOwnPropertyDescriptor(m, k4);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k4];
      } };
    }
    Object.defineProperty(o2, k22, desc2);
  } : function(o2, m, k4, k22) {
    if (k22 === undefined)
      k22 = k4;
    o2[k22] = m[k4];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Svix = exports.messageInRaw = exports.ValidationError = exports.HttpErrorOut = exports.HTTPValidationError = exports.ApiException = undefined;
  var application_1 = require_application();
  var authentication_1 = require_authentication();
  var backgroundTask_1 = require_backgroundTask();
  var endpoint_1 = require_endpoint();
  var environment_1 = require_environment();
  var eventType_1 = require_eventType();
  var health_1 = require_health();
  var ingest_1 = require_ingest();
  var integration_1 = require_integration();
  var message_1 = require_message();
  var messageAttempt_1 = require_messageAttempt();
  var operationalWebhook_1 = require_operationalWebhook();
  var statistics_1 = require_statistics();
  var operationalWebhookEndpoint_1 = require_operationalWebhookEndpoint();
  var util_1 = require_util();
  Object.defineProperty(exports, "ApiException", { enumerable: true, get: function() {
    return util_1.ApiException;
  } });
  var HttpErrors_1 = require_HttpErrors();
  Object.defineProperty(exports, "HTTPValidationError", { enumerable: true, get: function() {
    return HttpErrors_1.HTTPValidationError;
  } });
  Object.defineProperty(exports, "HttpErrorOut", { enumerable: true, get: function() {
    return HttpErrors_1.HttpErrorOut;
  } });
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return HttpErrors_1.ValidationError;
  } });
  __exportStar(require_webhook(), exports);
  __exportStar(require_models(), exports);
  var message_2 = require_message();
  Object.defineProperty(exports, "messageInRaw", { enumerable: true, get: function() {
    return message_2.messageInRaw;
  } });
  var REGIONS = [
    { region: "us", url: "https://api.us.svix.com" },
    { region: "eu", url: "https://api.eu.svix.com" },
    { region: "in", url: "https://api.in.svix.com" },
    { region: "ca", url: "https://api.ca.svix.com" },
    { region: "au", url: "https://api.au.svix.com" }
  ];

  class Svix {
    constructor(token2, options = {}) {
      var _a5, _b2, _c;
      const regionalUrl = (_a5 = REGIONS.find((x2) => x2.region === token2.split(".")[1])) === null || _a5 === undefined ? undefined : _a5.url;
      const baseUrl = (_c = (_b2 = options.serverUrl) !== null && _b2 !== undefined ? _b2 : regionalUrl) !== null && _c !== undefined ? _c : "https://api.svix.com";
      if (options.retryScheduleInMs) {
        this.requestCtx = {
          baseUrl,
          token: token2,
          timeout: options.requestTimeout,
          retryScheduleInMs: options.retryScheduleInMs
        };
        return;
      }
      if (options.numRetries) {
        this.requestCtx = {
          baseUrl,
          token: token2,
          timeout: options.requestTimeout,
          numRetries: options.numRetries
        };
        return;
      }
      this.requestCtx = {
        baseUrl,
        token: token2,
        timeout: options.requestTimeout
      };
    }
    get application() {
      return new application_1.Application(this.requestCtx);
    }
    get authentication() {
      return new authentication_1.Authentication(this.requestCtx);
    }
    get backgroundTask() {
      return new backgroundTask_1.BackgroundTask(this.requestCtx);
    }
    get endpoint() {
      return new endpoint_1.Endpoint(this.requestCtx);
    }
    get environment() {
      return new environment_1.Environment(this.requestCtx);
    }
    get eventType() {
      return new eventType_1.EventType(this.requestCtx);
    }
    get health() {
      return new health_1.Health(this.requestCtx);
    }
    get ingest() {
      return new ingest_1.Ingest(this.requestCtx);
    }
    get integration() {
      return new integration_1.Integration(this.requestCtx);
    }
    get message() {
      return new message_1.Message(this.requestCtx);
    }
    get messageAttempt() {
      return new messageAttempt_1.MessageAttempt(this.requestCtx);
    }
    get operationalWebhook() {
      return new operationalWebhook_1.OperationalWebhook(this.requestCtx);
    }
    get statistics() {
      return new statistics_1.Statistics(this.requestCtx);
    }
    get operationalWebhookEndpoint() {
      return new operationalWebhookEndpoint_1.OperationalWebhookEndpoint(this.requestCtx);
    }
  }
  exports.Svix = Svix;
});

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value, key) {
  return key in value;
}
function IsAsyncIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
}
function IsArray(value) {
  return Array.isArray(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsDate(value) {
  return value instanceof globalThis.Date;
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsIterator(value) {
  return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
  return value === null;
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsObject(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString(value) {
  return typeof value === "string";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray(value) ? ArrayType(value) : IsDate(value) ? DateType(value) : IsUint8Array(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
  return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject2(value) && (globalThis.Object.getPrototypeOf(value) === Object.prototype || globalThis.Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof globalThis.Promise;
}
function IsDate2(value) {
  return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
  return value instanceof globalThis.Map;
}
function IsSet(value) {
  return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
  return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
  return key in value;
}
function IsObject2(value) {
  return value !== null && typeof value === "object";
}
function IsArray2(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
  return value === undefined;
}
function IsNull2(value) {
  return value === null;
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsString2(value) {
  return typeof value === "string";
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNull2(value) || IsNumber2(value) || IsString2(value) || IsSymbol2(value) || IsUndefined2(value);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject2(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined2(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
  return value;
}
function ImmutableUint8Array(value) {
  return value;
}
function ImmutableRegExp(value) {
  return value;
}
function ImmutableObject(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value) {
  return IsArray(value) ? ImmutableArray(value) : IsDate(value) ? ImmutableDate(value) : IsUint8Array(value) ? ImmutableUint8Array(value) : IsRegExp(value) ? ImmutableRegExp(value) : IsObject(value) ? ImmutableObject(value) : value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArgument(value) {
  return IsKindOf(value, "Argument");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
  return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArgument(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsComputed(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsArgument: () => IsArgument2,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
  return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
  return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined(value) || IsString(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
  return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
  return IsKindOf2(value, "Computed") && IsString(value.target) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsImport(value) {
  return IsKindOf2(value, "Import") && HasPropertyKey(value, "$defs") && IsObject(value.$defs) && IsProperties(value.$defs) && HasPropertyKey(value, "$ref") && IsString(value.$ref) && value.$ref in value.$defs;
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString(value.type) && value.type !== "object" ? false : true) && IsArray(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
  return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray(value.keys) && value.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString(value.source) && IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
  return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber(value.minItems) && IsNumber(value.maxItems) && value.minItems === value.maxItems && (IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0 || IsArray(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject(value) && IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject(value) && (IsAny2(value) || IsArgument2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsComputed2(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType(left) : left);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value,
    type: typeof value
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal) => Literal(literal.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
  const pattern = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys = TemplateLiteralGenerate(templateLiteral);
  return keys.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type of types)
    result.push(...IndexPropertyKeys(type));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
  return [...new Set(IsTemplateLiteral(type) ? FromTemplateLiteral(type) : IsUnion(type) ? FromUnion2(type.anyOf) : IsLiteral(type) ? FromLiteral(type.const) : IsNumber3(type) ? ["[number]"] : IsInteger2(type) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type, mappedResult, options) {
  return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
  const properties = FromMappedResult(type, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
  return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
  return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
  return IsIntersect(type) ? FromIntersect(type.allOf, propertyKey) : IsUnion(type) ? FromUnion3(type.anyOf, propertyKey) : IsTuple(type) ? FromTuple(type.items ?? [], propertyKey) : IsArray3(type) ? FromArray(type.items, propertyKey) : IsObject3(type) ? FromProperty(type.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
  if (IsRef(type) || IsRef(key)) {
    const error = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type) || !IsSchema(key))
      throw new TypeBoxError(error);
    return Computed("Index", [type, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
  return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey(type, left, options) };
  }, {});
}
function MappedIndexProperties(type, mappedKey, options) {
  return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
  const properties = MappedIndexProperties(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object(properties, options) {
  const required = RequiredKeys(properties);
  const schematic = required.length > 0 ? { [Kind]: "Object", type: "object", properties, required } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
  return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left) => IsOptional(left) ? RemoveOptionalFromType2(left) : left);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union(FromRest3(types));
}
function FromPromise(type) {
  return Awaited(type);
}
function FromRest3(types) {
  return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
  return CreateType(IsComputed(type) ? FromComputed(type.target, type.parameters) : IsIntersect(type) ? FromIntersect2(type.allOf) : IsUnion(type) ? FromUnion4(type.anyOf) : IsPromise2(type) ? FromPromise(type.item) : IsRef(type) ? FromRef(type.$ref) : type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type) {
  return IsIntersect(type) ? FromIntersect3(type.allOf) : IsUnion(type) ? FromUnion5(type.anyOf) : IsTuple(type) ? FromTuple2(type.items ?? []) : IsArray3(type) ? FromArray2(type.items) : IsObject3(type) ? FromProperties5(type.properties) : IsRecord(type) ? FromPatternProperties(type.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern = keys.map((key) => `(${key})`);
  return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
  const propertyKeys = KeyOfPropertyKeys(type);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(type, options) {
  return IsComputed(type) ? FromComputed2(type.target, type.parameters) : IsRef(type) ? FromRef2(type.$ref) : IsMappedResult(type) ? KeyOfFromMappedResult(type, options) : KeyOfFromType(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly(FromValue(value[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
  return IsAsyncIterator(value) ? ConditionalReadonly(Any(), root) : IsIterator(value) ? ConditionalReadonly(Any(), root) : IsArray(value) ? Readonly(Tuple(FromArray3(value))) : IsUint8Array(value) ? Uint8Array2() : IsDate(value) ? Date2() : IsObject(value) ? ConditionalReadonly(Object2(FromProperties7(value)), root) : IsFunction(value) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value) ? Undefined() : IsNull(value) ? Null() : IsSymbol(value) ? Symbol2() : IsBigInt(value) ? BigInt2() : IsNumber(value) ? Literal(value) : IsBoolean(value) ? Literal(value) : IsString(value) ? Literal(value) : Object2({});
}
function Const(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal(value));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type.IsNever(right) || exports_type.IsIntersect(right) || exports_type.IsUnion(right) || exports_type.IsUnknown(right) || exports_type.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) && right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right) ? ExtendsResult.Union : exports_type.IsUnknown(right) ? ExtendsResult.True : exports_type.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left, right) {
  return exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
  return exports_type.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
  return exports_type.IsNot(left) ? Visit3(UnwrapTNot(left), right) : exports_type.IsNot(right) ? Visit3(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type.IsLiteralNumber(left) ? ExtendsResult.True : exports_type.IsNumber(left) || exports_type.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsInteger(right) || exports_type.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit3(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left) && !exports_type.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : exports_type.IsNever(left) || exports_type.IsLiteralString(left) && IsObjectStringLike(right) || exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type.IsString(left) && IsObjectStringLike(right) || exports_type.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type.IsNumber(left) && IsObjectNumberLike(right) || exports_type.IsInteger(left) && IsObjectNumberLike(right) || exports_type.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type.IsDate(left) && IsObjectDateLike(right) || exports_type.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : !exports_type.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type.IsLiteralString(left) && exports_type.IsNumber(Key) && IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsString(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsArray(left) && exports_type.IsNumber(Key) ? Visit3(left, Value) : exports_type.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : !exports_type.IsRecord(right) ? ExtendsResult.False : Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
  const L = exports_type.IsRegExp(left) ? String2() : left;
  const R = exports_type.IsRegExp(right) ? String2() : right;
  return Visit3(L, R);
}
function FromStringRight(left, right) {
  return exports_type.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
  return exports_type.IsTemplateLiteral(left) ? Visit3(TemplateLiteralToUnion(left), right) : exports_type.IsTemplateLiteral(right) ? Visit3(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type.IsNever(left) ? ExtendsResult.True : exports_type.IsUnknown(left) ? ExtendsResult.False : exports_type.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsRecord(right) ? FromRecordRight(left, right) : exports_type.IsVoid(right) ? FromVoidRight(left, right) : exports_type.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown(left, right) {
  return exports_type.IsNever(right) ? FromNeverRight(left, right) : exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsString(right) ? FromStringRight(left, right) : exports_type.IsNumber(right) ? FromNumberRight(left, right) : exports_type.IsInteger(right) ? FromIntegerRight(left, right) : exports_type.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type.IsArray(right) ? FromArrayRight(left, right) : exports_type.IsTuple(right) ? FromTupleRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type.IsUndefined(left) ? ExtendsResult.True : exports_type.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left, right) {
  return exports_type.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type.IsUnion(right) ? FromUnionRight(left, right) : exports_type.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type.IsAny(right) ? FromAnyRight(left, right) : exports_type.IsObject(right) ? FromObjectRight(left, right) : exports_type.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left, right) {
  return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right) ? FromTemplateLiteral2(left, right) : exports_type.IsRegExp(left) || exports_type.IsRegExp(right) ? FromRegExp(left, right) : exports_type.IsNot(left) || exports_type.IsNot(right) ? FromNot(left, right) : exports_type.IsAny(left) ? FromAny(left, right) : exports_type.IsArray(left) ? FromArray4(left, right) : exports_type.IsBigInt(left) ? FromBigInt(left, right) : exports_type.IsBoolean(left) ? FromBoolean(left, right) : exports_type.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : exports_type.IsConstructor(left) ? FromConstructor(left, right) : exports_type.IsDate(left) ? FromDate(left, right) : exports_type.IsFunction(left) ? FromFunction(left, right) : exports_type.IsInteger(left) ? FromInteger(left, right) : exports_type.IsIntersect(left) ? FromIntersect4(left, right) : exports_type.IsIterator(left) ? FromIterator(left, right) : exports_type.IsLiteral(left) ? FromLiteral2(left, right) : exports_type.IsNever(left) ? FromNever(left, right) : exports_type.IsNull(left) ? FromNull(left, right) : exports_type.IsNumber(left) ? FromNumber(left, right) : exports_type.IsObject(left) ? FromObject(left, right) : exports_type.IsRecord(left) ? FromRecord(left, right) : exports_type.IsString(left) ? FromString(left, right) : exports_type.IsSymbol(left) ? FromSymbol(left, right) : exports_type.IsTuple(left) ? FromTuple3(left, right) : exports_type.IsPromise(left) ? FromPromise2(left, right) : exports_type.IsUint8Array(left) ? FromUint8Array(left, right) : exports_type.IsUndefined(left) ? FromUndefined(left, right) : exports_type.IsUnion(left) ? FromUnion6(left, right) : exports_type.IsUnknown(left) ? FromUnknown(left, right) : exports_type.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit3(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
  return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
  return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
  const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
  return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
  return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
  return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type, options) : IsLiteral(key) ? FromLiteralKey(key.const, type, options) : IsBoolean3(key) ? FromBooleanKey(key, type, options) : IsInteger2(key) ? FromIntegerKey(key, type, options) : IsNumber3(key) ? FromNumberKey(key, type, options) : IsRegExp2(key) ? FromRegExpKey(key, type, options) : IsString3(key) ? FromStringKey(key, type, options) : IsAny(key) ? FromAnyKey(key, type, options) : IsNever(key) ? FromNeverKey(key, type, options) : Never(options);
}
function RecordPattern(record) {
  return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
  const pattern = RecordPattern(type);
  return pattern === PatternStringExact ? String2() : pattern === PatternNumberExact ? Number2() : String2({ pattern });
}
function RecordValue2(type) {
  return type.patternProperties[RecordPattern(type)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromFunction2(args, type) {
  type.parameters = FromTypes(args, type.parameters);
  type.returns = FromType(args, type.returns);
  return type;
}
function FromIntersect5(args, type) {
  type.allOf = FromTypes(args, type.allOf);
  return type;
}
function FromUnion7(args, type) {
  type.anyOf = FromTypes(args, type.anyOf);
  return type;
}
function FromTuple4(args, type) {
  if (IsUndefined(type.items))
    return type;
  type.items = FromTypes(args, type.items);
  return type;
}
function FromArray5(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromAsyncIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromIterator2(args, type) {
  type.items = FromType(args, type.items);
  return type;
}
function FromPromise3(args, type) {
  type.item = FromType(args, type.item);
  return type;
}
function FromObject2(args, type) {
  const mappedProperties = FromProperties11(args, type.properties);
  return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
  const mappedKey = FromType(args, RecordKey2(type));
  const mappedValue = FromType(args, RecordValue2(type));
  const result = Record(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
  const isReadonly = IsReadonly(type);
  const isOptional = IsOptional(type);
  const mapped = FromType(args, type);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args, properties[key]) };
  }, {});
}
function FromTypes(args, types) {
  return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
  return IsConstructor(type) ? FromConstructor2(args, type) : IsFunction3(type) ? FromFunction2(args, type) : IsIntersect(type) ? FromIntersect5(args, type) : IsUnion(type) ? FromUnion7(args, type) : IsTuple(type) ? FromTuple4(args, type) : IsArray3(type) ? FromArray5(args, type) : IsAsyncIterator3(type) ? FromAsyncIterator2(args, type) : IsIterator3(type) ? FromIterator2(args, type) : IsPromise2(type) ? FromPromise3(args, type) : IsObject3(type) ? FromObject2(args, type) : IsRecord(type) ? FromRecord2(args, type) : IsArgument(type) ? FromArgument(args, type) : type;
}
function Instantiate(type, args) {
  return FromType(args, CloneType(type));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
  return value.toUpperCase();
}
function ApplyLowercase(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value) => Literal(value));
  const mapped = FromRest5(literals, mode);
  const union = Union(mapped);
  return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? OmitFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type, typeKey], options) : CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
  return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type, LK, options) };
  }, {});
}
function FromMappedKey3(type, mappedKey, options) {
  return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey3(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal(key)] : result2, []);
  return Union(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type) ? PickFromMappedResult(type, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type, typeKey], options) : CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
  return {
    [key]: Pick(type, [key], Clone(options))
  };
}
function FromPropertyKeys3(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type, leftKey, options) };
  }, {});
}
function FromMappedKey4(type, mappedKey, options) {
  return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
  const properties = FromMappedKey4(type, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
  return IsComputed(type) ? FromComputed3(type.target, type.parameters) : IsRef(type) ? FromRef3(type.$ref) : IsIntersect(type) ? Intersect(FromRest6(type.allOf)) : IsUnion(type) ? Union(FromRest6(type.anyOf)) : IsObject3(type) ? FromObject5(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Partial(type, options) {
  if (IsMappedResult(type)) {
    return PartialFromMappedResult(type, options);
  } else {
    return CreateType({ ...PartialResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type) {
  const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
  return IsComputed(type) ? FromComputed4(type.target, type.parameters) : IsRef(type) ? FromRef4(type.$ref) : IsIntersect(type) ? Intersect(FromRest7(type.allOf)) : IsUnion(type) ? Union(FromRest7(type.anyOf)) : IsObject3(type) ? FromObject6(type) : IsBigInt3(type) ? type : IsBoolean3(type) ? type : IsInteger2(type) ? type : IsLiteral(type) ? type : IsNull3(type) ? type : IsNumber3(type) ? type : IsString3(type) ? type : IsSymbol3(type) ? type : IsUndefined3(type) ? type : Object2({});
}
function Required(type, options) {
  if (IsMappedResult(type)) {
    return RequiredFromMappedResult(type, options);
  } else {
    return CreateType({ ...RequiredResolve(type), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type) => {
    return IsRef(type) ? Dereference(moduleProperties, type.$ref) : FromType2(moduleProperties, type);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type) {
  return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
  return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
  return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type) {
  const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
  const result = CloneType(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform(moduleProperties, transform) {
  return IsRef(transform) ? { ...Dereference(moduleProperties, transform.$ref), [TransformKind]: transform[TransformKind] } : transform;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
  return IsOptional(type) ? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type) : IsReadonly(type) ? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type) : IsTransform(type) ? CreateType(FromTransform(moduleProperties, type), type) : IsArray3(type) ? CreateType(FromArray6(moduleProperties, type.items), type) : IsAsyncIterator3(type) ? CreateType(FromAsyncIterator3(moduleProperties, type.items), type) : IsComputed(type) ? CreateType(FromComputed5(moduleProperties, type.target, type.parameters)) : IsConstructor(type) ? CreateType(FromConstructor3(moduleProperties, type.parameters, type.returns), type) : IsFunction3(type) ? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type) : IsIntersect(type) ? CreateType(FromIntersect8(moduleProperties, type.allOf), type) : IsIterator3(type) ? CreateType(FromIterator3(moduleProperties, type.items), type) : IsObject3(type) ? CreateType(FromObject7(moduleProperties, type.properties), type) : IsRecord(type) ? CreateType(FromRecord3(moduleProperties, type)) : IsTuple(type) ? CreateType(FromTuple5(moduleProperties, type.items || []), type) : IsUnion(type) ? CreateType(FromUnion10(moduleProperties, type.anyOf), type) : type;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}
function Module(properties) {
  return new TModule(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
  return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode) {
    return new TransformEncodeBuilder(this.schema, decode);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode) {
    this.schema = schema;
    this.decode = decode;
  }
  EncodeTransform(encode, schema) {
    const Encode = (value) => schema[TransformKind].Encode(encode(value));
    const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode, schema) {
    const Codec = { Decode: this.decode, Encode: encode };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode, this.schema) : this.EncodeSchema(encode, this.schema);
  }
}
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  Instantiate: () => Instantiate,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Argument: () => Argument,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
  switch (error.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$ref}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit4(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit4(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit4(key);
    Visit4(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
  if (IsArray2(value))
    return ArrayType2(value);
  if (IsBoolean2(value))
    return BooleanType(value);
  if (IsBigInt2(value))
    return BigIntType(value);
  if (IsDate2(value))
    return DateType2(value);
  if (IsNull2(value))
    return NullType(value);
  if (IsNumber2(value))
    return NumberType(value);
  if (IsObject2(value))
    return ObjectType2(value);
  if (IsString2(value))
    return StringType(value);
  if (IsSymbol2(value))
    return SymbolType(value);
  if (IsUint8Array2(value))
    return Uint8ArrayType2(value);
  if (IsUndefined2(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value);
  return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
  return value !== undefined;
}
function FromAny2(schema, references, value) {
  return true;
}
function FromArgument2(schema, references, value) {
  return true;
}
function FromArray7(schema, references, value) {
  if (!IsArray2(value))
    return false;
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit5(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit5(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value) {
  return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
  if (!IsBigInt2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value) {
  return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
  return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
  if (!IsDate2(value))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value) {
  return IsFunction2(value);
}
function FromImport(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value) {
  return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
  return value === schema.const;
}
function FromNever2(schema, references, value) {
  return false;
}
function FromNot2(schema, references, value) {
  return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
  return IsNull2(value);
}
function FromNumber2(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit5(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value) {
  return IsPromise(value);
}
function FromRecord4(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString2(schema, references, value) {
  if (!IsString2(value)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol2(schema, references, value) {
  return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
  return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
  if (!IsArray2(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value) {
  return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
  if (!IsUint8Array2(value)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value) {
  return true;
}
function FromVoid2(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value);
}
function Visit5(schema, references, value) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value);
    case "Argument":
      return FromArgument2(schema_, references_, value);
    case "Array":
      return FromArray7(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value);
    case "BigInt":
      return FromBigInt2(schema_, references_, value);
    case "Boolean":
      return FromBoolean2(schema_, references_, value);
    case "Constructor":
      return FromConstructor4(schema_, references_, value);
    case "Date":
      return FromDate2(schema_, references_, value);
    case "Function":
      return FromFunction4(schema_, references_, value);
    case "Import":
      return FromImport(schema_, references_, value);
    case "Integer":
      return FromInteger2(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Iterator":
      return FromIterator4(schema_, references_, value);
    case "Literal":
      return FromLiteral3(schema_, references_, value);
    case "Never":
      return FromNever2(schema_, references_, value);
    case "Not":
      return FromNot2(schema_, references_, value);
    case "Null":
      return FromNull2(schema_, references_, value);
    case "Number":
      return FromNumber2(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Promise":
      return FromPromise4(schema_, references_, value);
    case "Record":
      return FromRecord4(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "RegExp":
      return FromRegExp2(schema_, references_, value);
    case "String":
      return FromString2(schema_, references_, value);
    case "Symbol":
      return FromSymbol2(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis(schema_, references_, value);
    case "Tuple":
      return FromTuple6(schema_, references_, value);
    case "Undefined":
      return FromUndefined2(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value);
    case "Unknown":
      return FromUnknown2(schema_, references_, value);
    case "Void":
      return FromVoid2(schema_, references_, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value,
    message: GetErrorFunction()({ errorType, path, schema, value, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value) {}
function* FromArgument3(schema, references, path, value) {}
function* FromArray8(schema, references, path, value) {
  if (!IsArray2(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator5(schema, references, path, value) {
  if (!IsAsyncIterator2(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
  if (!IsBigInt2(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean3(schema, references, path, value) {
  if (!IsBoolean2(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
  yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
  if (!IsDate2(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction5(schema, references, path, value) {
  if (!IsFunction2(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect10(schema, references, path, value) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error of Visit6(inner, references, path, value)) {
      hasError = true;
      yield error;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value) {
  if (!IsIterator2(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
  if (Visit6(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
  if (!IsNull2(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject9(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString3(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value) {
  if (!IsSymbol2(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
  if (!IsString2(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis2(schema, references, path, value) {
  yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
  if (!IsArray2(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined3(schema, references, path, value) {
  if (!IsUndefined2(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
  if (Check(schema, references, value))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value)));
  yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
  if (!IsUint8Array2(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown3(schema, references, path, value) {}
function* FromVoid3(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
  const check = exports_type2.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value);
    case "String":
      return yield* FromString3(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value);
    case "This":
      return yield* FromThis2(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator = args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator);
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error = iterator.First();
    super(error === undefined ? "Invalid Value" : error.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
function AssertValue(schema, references, value) {
  if (Check(schema, references, value))
    return;
  throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
  return args.length === 3 ? AssertValue(args[0], args[1], args[2]) : AssertValue(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject10(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function FromArray9(value) {
  return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
  return value.slice();
}
function FromMap(value) {
  return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
  return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
  return new Date(value.toISOString());
}
function FromValue2(value) {
  return value;
}
function Clone2(value) {
  if (IsArray2(value))
    return FromArray9(value);
  if (IsDate2(value))
    return FromDate4(value);
  if (IsTypedArray(value))
    return FromTypedArray(value);
  if (IsMap(value))
    return FromMap(value);
  if (IsSet(value))
    return FromSet(value);
  if (IsObject2(value))
    return FromObject10(value);
  if (IsValueType(value))
    return FromValue2(value);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray10(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {}();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromImport3(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit7(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {}();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromRef7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple8(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport3(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect11(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord6(schema_, references_);
    case "Ref":
      return FromRef7(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple8(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion13(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
    const object = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object.properties);
    return entries.reduce((acc, [key, schema2]) => {
      const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? 100 : 0;
      const checks = Check(schema2, references, value[key]) ? 10 : 0;
      const exists = keys.includes(key) ? 1 : 0;
      return acc + (literal + checks + exists);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union, references, value) {
  const schemas = union.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union, references, value) {
  if ("default" in union) {
    return typeof value === "function" ? union.default : Clone2(union.default);
  } else {
    const schema = SelectUnion(union, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray11(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor7(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {};
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromImport4(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit8(target, [...references, ...definitions], value);
}
function IntersectAssign(correct, value) {
  if (IsObject2(correct) && !IsObject2(value) || !IsObject2(correct) && IsObject2(value))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value))
    return value;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
}
function FromIntersect12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value);
  return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject12(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef8(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray2(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion14(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value);
    case "Constructor":
      return FromConstructor7(schema_, references_, value);
    case "Import":
      return FromImport4(schema_, references_, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject12(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef8(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Union":
      return FromUnion14(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray12(schema, references, value) {
  if (!IsArray2(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromImport5(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit9(target, [...references, ...definitions], value);
}
function FromIntersect13(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject2(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject13(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord8(schema, references, value) {
  if (!IsObject2(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef9(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  if (!IsArray2(value))
    return value;
  if (IsUndefined2(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion15(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value);
    case "Import":
      return FromImport5(schema_, references_, value);
    case "Intersect":
      return FromIntersect13(schema_, references_, value);
    case "Object":
      return FromObject13(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef9(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion15(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber2(value) && value === 1 || IsBigInt2(value) && value === BigInt("1") || IsString2(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber2(value) && (value === 0 || Object.is(value, -0)) || IsBigInt2(value) && value === BigInt("0") || IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString2(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : value;
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  const truncateInteger = (value2) => value2.split(".")[0];
  return IsStringNumeric(value) ? BigInt(truncateInteger(value)) : IsNumber2(value) ? BigInt(Math.trunc(value)) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsSymbol2(value) && value.description !== undefined ? value.description.toString() : IsValueToString(value) ? value.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber2(value) ? Math.trunc(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate2(value) ? value : IsNumber2(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray13(schema, references, value) {
  const elements = IsArray2(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
  return TryConvertDate(value);
}
function FromImport6(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect14(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject14(schema, references, value) {
  if (!IsObject2(value) || IsArray2(value))
    return value;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value, propertyKey))
      continue;
    value[propertyKey] = Visit10(schema.properties[propertyKey], references, value[propertyKey]);
  }
  return value;
}
function FromRecord9(schema, references, value) {
  const isConvertable = IsObject2(value) && !IsArray2(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value)) {
    value[propKey] = Visit10(property, references, propValue);
  }
  return value;
}
function FromRef10(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple11(schema, references, value) {
  const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion16(schema, references, value) {
  for (const subschema of schema.anyOf) {
    if (Check(subschema, references, value)) {
      return value;
    }
  }
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, Clone2(value));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate6(schema_, references_, value);
    case "Import":
      return FromImport6(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect14(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject14(schema_, references_, value);
    case "Record":
      return FromRecord9(schema_, references_, value);
    case "Ref":
      return FromRef10(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple11(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion16(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(error instanceof Error ? error.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default3(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error) {
    throw new TransformDecodeError(schema, path, value, error);
  }
}
function FromArray14(schema, references, path, value) {
  return IsArray2(value) ? Default3(schema, path, value.map((value2, index) => Visit11(schema.items, references, `${path}/${index}`, value2))) : Default3(schema, path, value);
}
function FromIntersect15(schema, references, path, value) {
  if (!IsObject2(value) || IsValueType(value))
    return Default3(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit11(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromImport7(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit11(target, [...references, ...additional], path, value);
  return Default3(schema, path, result);
}
function FromNot5(schema, references, path, value) {
  return Default3(schema, path, Visit11(schema.not, references, path, value));
}
function FromObject15(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit11(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRecord10(schema, references, path, value) {
  if (!IsObject2(value))
    return Default3(schema, path, value);
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit11(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRef11(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromThis7(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value));
}
function FromTuple12(schema, references, path, value) {
  return IsArray2(value) && IsArray2(schema.items) ? Default3(schema, path, schema.items.map((schema2, index) => Visit11(schema2, references, `${path}/${index}`, value[index]))) : Default3(schema, path, value);
}
function FromUnion17(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit11(subschema, references, path, value);
    return Default3(schema, path, decoded);
  }
  return Default3(schema, path, value);
}
function Visit11(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, path, value);
    case "Import":
      return FromImport7(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect15(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject15(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef11(schema_, references_, path, value);
    case "Symbol":
      return Default3(schema_, path, value);
    case "This":
      return FromThis7(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion17(schema_, references_, path, value);
    default:
      return Default3(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit11(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error) {
    throw new TransformEncodeError(schema, path, value, error);
  }
}
function FromArray15(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  return IsArray2(defaulted) ? defaulted.map((value2, index) => Visit12(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromImport8(schema, references, path, value) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default4(schema, path, value);
  return Visit12(target, [...references, ...additional], path, result);
}
function FromIntersect16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit12(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default4(schema.not, path, Default4(schema, path, value));
}
function FromObject16(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit12(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord11(schema, references, path, value) {
  const defaulted = Default4(schema, path, value);
  if (!IsObject2(value))
    return defaulted;
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit12(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef12(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value);
  return Default4(schema, path, resolved);
}
function FromTuple13(schema, references, path, value) {
  const value1 = Default4(schema, path, value);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit12(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion18(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit12(subschema, references, path, value);
    return Default4(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit12(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default4(schema, path, value1);
  }
  return Default4(schema, path, value);
}
function Visit12(schema, references, path, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, path, value);
    case "Import":
      return FromImport8(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect16(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject16(schema_, references_, path, value);
    case "Record":
      return FromRecord11(schema_, references_, path, value);
    case "Ref":
      return FromRef12(schema_, references_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple13(schema_, references_, path, value);
    case "Union":
      return FromUnion18(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit12(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray16(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromAsyncIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromConstructor8(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromFunction7(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromIntersect17(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit13(schema2, references));
}
function FromImport9(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit13(target, [...additional, ...references]);
}
function FromIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform(schema) || Visit13(schema.not, references);
}
function FromObject17(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) || IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references);
}
function FromPromise7(schema, references) {
  return IsTransform(schema) || Visit13(schema.item, references);
}
function FromRecord12(schema, references) {
  const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern];
  return IsTransform(schema) || Visit13(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef13(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromThis9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromTuple14(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references));
}
function FromUnion19(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
}
function Visit13(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "Constructor":
      return FromConstructor8(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport9(schema_, references_);
    case "Intersect":
      return FromIntersect17(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord12(schema_, references_);
    case "Ref":
      return FromRef13(schema_, references_);
    case "This":
      return FromThis9(schema_, references_);
    case "Tuple":
      return FromTuple14(schema_, references_);
    case "Union":
      return FromUnion19(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit13(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value) ? clone : IsObject2(value) && IsObject2(clone) ? Object.assign(clone, value) : value;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
  if (IsArray2(value)) {
    for (let i = 0;i < value.length; i++) {
      value[i] = Visit14(schema.items, references, value[i]);
    }
    return value;
  }
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value) {
  return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit14(schema2, references, defaulted);
    return IsObject2(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject18(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
  return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value);
    case "Date":
      return FromDate7(schema_, references_, value);
    case "Import":
      return FromImport10(schema_, references_, value);
    case "Intersect":
      return FromIntersect18(schema_, references_, value);
    case "Object":
      return FromObject18(schema_, references_, value);
    case "Record":
      return FromRecord13(schema_, references_, value);
    case "Ref":
      return FromRef14(schema_, references_, value);
    case "This":
      return FromThis10(schema_, references_, value);
    case "Tuple":
      return FromTuple15(schema_, references_, value);
    case "Union":
      return FromUnion20(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default5(...args) {
  return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
  if (!IsObject2(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
  return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
  if (!IsArray2(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsDate2(left))
    return DateType3(left, right);
  if (IsTypedArray(left))
    return TypedArrayType(left, right);
  if (IsArray2(left))
    return ArrayType3(left, right);
  if (IsObject2(left))
    return ObjectType3(left, right);
  if (IsValueType(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value) {
  if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
    throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
  AssertDiffable(current);
  AssertDiffable(next);
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next, key))
      continue;
    if (Equal(current, next))
      continue;
    yield* Visit15(`${path}/${key}`, current[key], next[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray2(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit15(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray2(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
  return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone, edit.path);
        break;
      }
    }
  }
  return clone;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
  return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType5(root, path, current, next) {
  if (!IsStandardObject2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType5(root, path, current, next) {
  if (!IsArray2(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit16(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType3(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType3(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
  if (IsArray2(next))
    return ArrayType5(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType3(root, path, current, next);
  if (IsStandardObject2(next))
    return ObjectType5(root, path, current, next);
  if (IsValueType(next))
    return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject2(current) && IsArray2(next) || IsArray2(current) && IsStandardObject2(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Assert", (type, references, value) => {
      Assert(type, references, value);
      return value;
    }],
    ["Cast", (type, references, value) => Cast(type, references, value)],
    ["Clean", (type, references, value) => Clean(type, references, value)],
    ["Clone", (_type, _references, value) => Clone2(value)],
    ["Convert", (type, references, value) => Convert(type, references, value)],
    ["Decode", (type, references, value) => HasTransform(type, references) ? TransformDecode(type, references, value) : value],
    ["Default", (type, references, value) => Default5(type, references, value)],
    ["Encode", (type, references, value) => HasTransform(type, references) ? TransformEncode(type, references, value) : value]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
function ParseValue(operations, type, references, value) {
  return operations.reduce((value2, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
    return operation(type, references, value2);
  }, value);
}
function Parse(...args) {
  const [operations, schema, references, value] = args.length === 4 ? [args[0], args[1], args[2], args[3]] : args.length === 3 ? IsArray2(args[0]) ? [args[0], args[1], [], args[2]] : [ParseDefault, args[0], args[1], args[2]] : args.length === 2 ? [ParseDefault, args[0], [], args[1]] : (() => {
    throw new ParseError("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value) {
    return Errors(this.schema, this.references, value);
  }
  Check(value) {
    return this.checkFunc(value);
  }
  Decode(value) {
    if (!this.checkFunc(value))
      throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
  }
  Encode(value) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value) : value;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value) {
    if (value.length === 0)
      return false;
    return Character.IsNumeric(value.charCodeAt(0));
  }
  function IsAccessor(value) {
    if (IsFirstCharacterNumeric(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      const check2 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value) {
    yield "true";
  }
  function* FromArgument5(schema, references, value) {
    yield "true";
  }
  function* FromArray18(schema, references, value) {
    yield `Array.isArray(${value})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
  }
  function* FromBigInt6(schema, references, value) {
    yield `(typeof ${value} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value) {
    yield `(typeof ${value} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value) {
    yield* Visit17(schema.returns, references, `${value}.prototype`);
  }
  function* FromDate8(schema, references, value) {
    yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value) {
    yield `(typeof ${value} === 'function')`;
  }
  function* FromImport11(schema, references, value) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
  }
  function* FromInteger6(schema, references, value) {
    yield `Number.isInteger(${value})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
  }
  function* FromLiteral7(schema, references, value) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value} === ${schema.const})`;
    } else {
      yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value) {
    yield `false`;
  }
  function* FromNot8(schema, references, value) {
    const expression = CreateExpression(schema.not, references, value);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value) {
    yield `(${value} === null)`;
  }
  function* FromNumber6(schema, references, value) {
    yield Policy.IsNumberLike(value);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value) {
    yield Policy.IsObjectLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value) {
    yield `${value} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value) {
    yield Policy.IsRecordLike(value);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value})`;
    yield* Visit17(target, references, value);
  }
  function* FromRegExp5(schema, references, value) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value})`;
  }
  function* FromString6(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value})`;
    }
  }
  function* FromSymbol6(schema, references, value) {
    yield `(typeof ${value} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value) {
    yield `(typeof ${value} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value})`;
  }
  function* FromThis11(schema, references, value) {
    yield `${CreateFunctionName(schema.$ref)}(${value})`;
  }
  function* FromTuple16(schema, references, value) {
    yield `Array.isArray(${value})`;
    if (schema.items === undefined)
      return yield `${value}.length === 0`;
    yield `(${value}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value) {
    yield `${value} === undefined`;
  }
  function* FromUnion21(schema, references, value) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value) {
    yield `${value} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value) {
    yield "true";
  }
  function* FromVoid5(schema, references, value) {
    yield Policy.IsVoidLike(value);
  }
  function* FromKind4(schema, references, value) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value})`;
  }
  function* Visit17(schema, references, value, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value);
      case "Array":
        return yield* FromArray18(schema_, references_, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value);
      case "Date":
        return yield* FromDate8(schema_, references_, value);
      case "Function":
        return yield* FromFunction8(schema_, references_, value);
      case "Import":
        return yield* FromImport11(schema_, references_, value);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value);
      case "Never":
        return yield* FromNever6(schema_, references_, value);
      case "Not":
        return yield* FromNot8(schema_, references_, value);
      case "Null":
        return yield* FromNull6(schema_, references_, value);
      case "Number":
        return yield* FromNumber6(schema_, references_, value);
      case "Object":
        return yield* FromObject19(schema_, references_, value);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value);
      case "Record":
        return yield* FromRecord14(schema_, references_, value);
      case "Ref":
        return yield* FromRef15(schema_, references_, value);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value);
      case "String":
        return yield* FromString6(schema_, references_, value);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value);
      case "This":
        return yield* FromThis11(schema_, references_, value);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value);
      case "Union":
        return yield* FromUnion21(schema_, references_, value);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value);
      case "Void":
        return yield* FromVoid5(schema_, references_, value);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value, useHoisting = true) {
    return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && IsArray2(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray2(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value);
    }
    function formatRegistryFunction(format, value) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value);
    }
    function hashFunction(value) {
      return Hash(value);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/bun/index.js
var __create2 = Object.create;
var { getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
  var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4), low = hexCodeToInt(uri[percentPosition + 2], 0), byte = high | low, type = UTF8_DATA[byte];
      if (state = UTF8_DATA[256 + state + type], codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type], state === UTF8_ACCEPT)
        decoded += uri.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri.indexOf("%", last);
      else if (state === UTF8_REJECT)
        return null;
      else {
        if (percentPosition += 3, percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function hexCodeToInt(c, shift) {
    var i2 = HEX[c];
    return i2 === undefined ? 255 : i2 << shift;
  }
  module.exports = decodeURIComponent2;
});
var require_dist = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/, domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/, __toString = Object.prototype.toString, NullObject = (() => {
    let C = function() {};
    return C.prototype = Object.create(null), C;
  })();
  function parse2(str, options) {
    let obj = new NullObject, len = str.length;
    if (len < 2)
      return obj;
    let dec = options?.decode || decode2, index = 0;
    do {
      let eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      let colonIdx = str.indexOf(";", index), endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      let keyStartIdx = startIndex(str, index, eqIdx), keyEndIdx = endIndex(str, eqIdx, keyStartIdx), key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx), valEndIdx = endIndex(str, endIdx, valStartIdx), value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max2) {
    do {
      let code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max2);
    return max2;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      let code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    let enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name))
      throw TypeError(`argument name is invalid: ${name}`);
    let value = enc(val);
    if (!cookieValueRegExp.test(value))
      throw TypeError(`argument val is invalid: ${val}`);
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge))
        throw TypeError(`option maxAge is invalid: ${options.maxAge}`);
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain))
        throw TypeError(`option domain is invalid: ${options.domain}`);
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path))
        throw TypeError(`option path is invalid: ${options.path}`);
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf()))
        throw TypeError(`option expires is invalid: ${options.expires}`);
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly)
      str += "; HttpOnly";
    if (options.secure)
      str += "; Secure";
    if (options.partitioned)
      str += "; Partitioned";
    if (options.priority)
      switch (typeof options.priority === "string" ? options.priority.toLowerCase() : undefined) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw TypeError(`option priority is invalid: ${options.priority}`);
      }
    if (options.sameSite)
      switch (typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});
var Y = (v, b) => {
  let A = b?.length ? {} : null;
  if (A)
    for (let Q of b)
      A[Q.part.charCodeAt(0)] = Q;
  return { part: v, store: null, inert: A, params: null, wildcardStore: null };
};
var k = (v, b) => ({ ...v, part: b });
var T = (v) => ({ name: v, store: null, inert: null });

class _ {
  config;
  root = {};
  history = [];
  deferred = [];
  constructor(v = {}) {
    if (this.config = v, v.lazy)
      this.find = this.lazyFind;
    if (v.onParam && !Array.isArray(v.onParam))
      this.config.onParam = [this.config.onParam];
  }
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /(\/:\w+\?)/g };
  lazyFind = (v, b) => {
    if (!this.config.lazy)
      return this.find;
    return this.build(), this.find(v, b);
  };
  build() {
    if (!this.config.lazy)
      return;
    for (let [v, b, A] of this.deferred)
      this.add(v, b, A, { lazy: false, ignoreHistory: true });
    this.deferred = [], this.find = (v, b) => {
      let A = this.root[v];
      if (!A)
        return null;
      return $(b, b.length, A, 0, this.config.onParam);
    };
  }
  add(v, b, A, { ignoreError: Q = false, ignoreHistory: O = false, lazy: V = this.config.lazy } = {}) {
    if (V)
      return this.find = this.lazyFind, this.deferred.push([v, b, A]), A;
    if (typeof b !== "string")
      throw TypeError("Route path must be a string");
    if (b === "")
      b = "/";
    else if (b[0] !== "/")
      b = `/${b}`;
    let X = b[b.length - 1] === "*", J = b.match(_.regex.optionalParams);
    if (J) {
      let F = b.replaceAll("?", "");
      this.add(v, F, A, { ignoreError: Q, ignoreHistory: O, lazy: V });
      for (let B = 0;B < J.length; B++) {
        let D = b.replace(J[B], "");
        this.add(v, D, A, { ignoreError: true, ignoreHistory: O, lazy: V });
      }
      return A;
    }
    if (J)
      b = b.replaceAll("?", "");
    if (this.history.find(([F, B, D]) => F === v && B === b))
      return A;
    if (X || J && b.charCodeAt(b.length - 1) === 63)
      b = b.slice(0, -1);
    if (!O)
      this.history.push([v, b, A]);
    let K = b.split(_.regex.static), G = b.match(_.regex.params) || [];
    if (K[K.length - 1] === "")
      K.pop();
    let q;
    if (!this.root[v])
      q = this.root[v] = Y("/");
    else
      q = this.root[v];
    let U = 0;
    for (let F = 0;F < K.length; ++F) {
      let B = K[F];
      if (F > 0) {
        let D = G[U++].slice(1);
        if (q.params === null)
          q.params = T(D);
        else if (q.params.name !== D)
          if (Q)
            return A;
          else
            throw Error(`Cannot create route "${b}" with parameter "${D}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
        let S = q.params;
        if (S.inert === null) {
          q = S.inert = Y(B);
          continue;
        }
        q = S.inert;
      }
      for (let D = 0;; ) {
        if (D === B.length) {
          if (D < q.part.length) {
            let S = k(q, q.part.slice(D));
            Object.assign(q, Y(B, [S]));
          }
          break;
        }
        if (D === q.part.length) {
          if (q.inert === null)
            q.inert = {};
          let S = q.inert[B.charCodeAt(D)];
          if (S) {
            q = S, B = B.slice(D), D = 0;
            continue;
          }
          let Z = Y(B.slice(D));
          q.inert[B.charCodeAt(D)] = Z, q = Z;
          break;
        }
        if (B[D] !== q.part[D]) {
          let S = k(q, q.part.slice(D)), Z = Y(B.slice(D));
          Object.assign(q, Y(q.part.slice(0, D), [S, Z])), q = Z;
          break;
        }
        ++D;
      }
    }
    if (U < G.length) {
      let B = G[U].slice(1);
      if (q.params === null)
        q.params = T(B);
      else if (q.params.name !== B)
        if (Q)
          return A;
        else
          throw Error(`Cannot create route "${b}" with parameter "${B}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
      if (q.params.store === null)
        q.params.store = A;
      return q.params.store;
    }
    if (X) {
      if (q.wildcardStore === null)
        q.wildcardStore = A;
      return q.wildcardStore;
    }
    if (q.store === null)
      q.store = A;
    return q.store;
  }
  find(v, b) {
    let A = this.root[v];
    if (!A)
      return null;
    return $(b, b.length, A, 0, this.config.onParam);
  }
}
var $ = (v, b, A, Q, O) => {
  let V = A.part, X = V.length, J = Q + X;
  if (X > 1) {
    if (J > b)
      return null;
    if (X < 15) {
      for (let K = 1, G = Q + 1;K < X; ++K, ++G)
        if (V.charCodeAt(K) !== v.charCodeAt(G))
          return null;
    } else if (v.slice(Q, J) !== V)
      return null;
  }
  if (J === b) {
    if (A.store !== null)
      return { store: A.store, params: {} };
    if (A.wildcardStore !== null)
      return { store: A.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (A.inert !== null) {
    let K = A.inert[v.charCodeAt(J)];
    if (K !== undefined) {
      let G = $(v, b, K, J, O);
      if (G !== null)
        return G;
    }
  }
  if (A.params !== null) {
    let { store: K, name: G, inert: q } = A.params, U = v.indexOf("/", J);
    if (U !== J) {
      if (U === -1 || U >= b) {
        if (K !== null) {
          let F = {};
          if (F[G] = v.substring(J, b), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F[G], G);
              if (D !== undefined)
                F[G] = D;
            }
          return { store: K, params: F };
        }
      } else if (q !== null) {
        let F = $(v, b, q, U, O);
        if (F !== null) {
          if (F.params[G] = v.substring(J, U), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F.params[G], G);
              if (D !== undefined)
                F.params[G] = D;
            }
          return F;
        }
      }
    }
  }
  if (A.wildcardStore !== null)
    return { store: A.wildcardStore, params: { "*": v.substring(J, b) } };
  return null;
};
var import_fast_decode_uri_component4 = __toESM2(require_fast_decode_uri_component(), 1);
var isBun = typeof Bun < "u";
var mime = { aac: "audio/aac", abw: "application/x-abiword", ai: "application/postscript", arc: "application/octet-stream", avi: "video/x-msvideo", azw: "application/vnd.amazon.ebook", bin: "application/octet-stream", bz: "application/x-bzip", bz2: "application/x-bzip2", csh: "application/x-csh", css: "text/css", csv: "text/csv", doc: "application/msword", dll: "application/octet-stream", eot: "application/vnd.ms-fontobject", epub: "application/epub+zip", gif: "image/gif", htm: "text/html", html: "text/html", ico: "image/x-icon", ics: "text/calendar", jar: "application/java-archive", jpeg: "image/jpeg", jpg: "image/jpeg", js: "application/javascript", json: "application/json", mid: "audio/midi", midi: "audio/midi", mp2: "audio/mpeg", mp3: "audio/mpeg", mp4: "video/mp4", mpa: "video/mpeg", mpe: "video/mpeg", mpeg: "video/mpeg", mpkg: "application/vnd.apple.installer+xml", odp: "application/vnd.oasis.opendocument.presentation", ods: "application/vnd.oasis.opendocument.spreadsheet", odt: "application/vnd.oasis.opendocument.text", oga: "audio/ogg", ogv: "video/ogg", ogx: "application/ogg", otf: "font/otf", png: "image/png", pdf: "application/pdf", ppt: "application/vnd.ms-powerpoint", rar: "application/x-rar-compressed", rtf: "application/rtf", sh: "application/x-sh", svg: "image/svg+xml", swf: "application/x-shockwave-flash", tar: "application/x-tar", tif: "image/tiff", tiff: "image/tiff", ts: "application/typescript", ttf: "font/ttf", txt: "text/plain", vsd: "application/vnd.visio", wav: "audio/x-wav", weba: "audio/webm", webm: "video/webm", webp: "image/webp", woff: "font/woff", woff2: "font/woff2", xhtml: "application/xhtml+xml", xls: "application/vnd.ms-excel", xlsx: "application/vnd.ms-excel", xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xml: "application/xml", xul: "application/vnd.mozilla.xul+xml", zip: "application/zip", "3gp": "video/3gpp", "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp", "3gp2": "video/3gpp2", "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2", "7z": "application/x-7z-compressed" };
var getFileExtension = (path) => {
  let index = path.lastIndexOf(".");
  if (index === -1)
    return "";
  return path.slice(index + 1);
};
var createReadStream;
var stat;

class ElysiaFile {
  path;
  value;
  stats;
  constructor(path) {
    this.path = path;
    if (isBun)
      this.value = Bun.file(path);
    else {
      if (!createReadStream || !stat) {
        if (typeof window < "u") {
          console.warn("Browser environment does not support file");
          return;
        }
        let warnMissing = (name) => console.warn(Error(`[elysia] \`file\` require \`fs${name ? "." + name : ""}\` ${name?.includes(".") ? "module " : ""}which is not available in this environment`));
        if (typeof process > "u" || typeof process.getBuiltinModule !== "function") {
          warnMissing();
          return;
        }
        let fs = process.getBuiltinModule("fs");
        if (!fs) {
          warnMissing();
          return;
        }
        if (typeof fs.createReadStream !== "function") {
          warnMissing();
          return;
        }
        if (typeof fs.promises?.stat !== "function") {
          warnMissing();
          return;
        }
        createReadStream = fs.createReadStream, stat = fs.promises.stat;
      }
      this.value = (() => createReadStream(path))(), this.stats = stat(path);
    }
  }
  get type() {
    return mime[getFileExtension(this.path)] || "application/octet-stream";
  }
  get length() {
    if (isBun)
      return this.value.size;
    return this.stats?.then((x2) => x2.size) ?? 0;
  }
}
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
  let skipKeys = options?.skipKeys, override = options?.override ?? true, mergeArray = options?.mergeArray ?? false;
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (mergeArray && Array.isArray(value)) {
      target[key] = Array.isArray(target[key]) ? [...target[key], ...value] : target[key] = value;
      continue;
    }
    if (!isObject(value) || !(key in target) || isClass(value)) {
      if ((override || !(key in target)) && !Object.isFrozen(target))
        try {
          target[key] = value;
        } catch {}
      continue;
    }
    if (!Object.isFrozen(target[key]))
      try {
        target[key] = mergeDeep(target[key], value, { skipKeys, override, mergeArray });
      } catch {}
  }
  return target;
};
var mergeCookie = (a, b) => {
  let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"], mergeArray: false });
  if (v.properties)
    delete v.properties;
  return v;
};
var mergeObjectArray = (a, b) => {
  if (!b)
    return a;
  let array = [], checksums = [];
  if (a) {
    if (!Array.isArray(a))
      a = [a];
    for (let item of a)
      if (array.push(item), item.checksum)
        checksums.push(item.checksum);
  }
  if (b) {
    if (!Array.isArray(b))
      b = [b];
    for (let item of b)
      if (!checksums.includes(item.checksum))
        array.push(item);
  }
  return array;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x2) => (acc[x2] = true, acc), {});
var isRecordNumber = (x2) => typeof x2 === "object" && Object.keys(x2).every((x22) => !isNaN(+x22));
var mergeResponse = (a, b) => {
  if (isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({}, a, b);
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({ 200: a }, b);
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  if (!a && !b)
    return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  if (!b)
    return a ?? {};
  if (!a)
    return b ?? {};
  if (!Object.values(b).find((x2) => x2 !== undefined && x2 !== null))
    return { ...a };
  let hook = { ...a, ...b, body: b.body ?? a.body, headers: b.headers ?? a.headers, params: b.params ?? a.params, query: b.query ?? a.query, cookie: b.cookie ?? a.cookie, response: mergeResponse(a.response, b.response), type: a.type || b.type, detail: mergeDeep(b.detail ?? {}, a.detail ?? {}), parse: mergeObjectArray(a.parse, b.parse), transform: mergeObjectArray(a.transform, b.transform), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), mergeObjectArray(fnToContainer(b.resolve, "resolve"), b.beforeHandle)), afterHandle: mergeObjectArray(a.afterHandle, b.afterHandle), mapResponse: mergeObjectArray(a.mapResponse, b.mapResponse), afterResponse: mergeObjectArray(a.afterResponse, b.afterResponse), trace: mergeObjectArray(a.trace, b.trace), error: mergeObjectArray(a.error, b.error), standaloneSchema: a.standaloneSchema || b.standaloneSchema ? a.standaloneSchema && !b.standaloneSchema ? a.standaloneSchema : b.standaloneSchema && !a.standaloneSchema ? b.standaloneSchema : [...a.standaloneSchema ?? [], ...b.standaloneSchema ?? []] : undefined };
  if (hook.resolve)
    delete hook.resolve;
  return hook;
};
var lifeCycleToArray = (a) => {
  if (a.parse && !Array.isArray(a.parse))
    a.parse = [a.parse];
  if (a.transform && !Array.isArray(a.transform))
    a.transform = [a.transform];
  if (a.afterHandle && !Array.isArray(a.afterHandle))
    a.afterHandle = [a.afterHandle];
  if (a.mapResponse && !Array.isArray(a.mapResponse))
    a.mapResponse = [a.mapResponse];
  if (a.afterResponse && !Array.isArray(a.afterResponse))
    a.afterResponse = [a.afterResponse];
  if (a.trace && !Array.isArray(a.trace))
    a.trace = [a.trace];
  if (a.error && !Array.isArray(a.error))
    a.error = [a.error];
  let beforeHandle = [];
  if (a.resolve)
    beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve"), delete a.resolve;
  if (a.beforeHandle)
    if (beforeHandle.length)
      beforeHandle = beforeHandle.concat(Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]);
    else
      beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle];
  if (beforeHandle.length)
    a.beforeHandle = beforeHandle;
  return a;
};
var isBun2 = typeof Bun < "u";
var hasBunHash = isBun2 && typeof Bun.hash === "function";
var checksum = (s) => {
  let h = 9;
  for (let i2 = 0;i2 < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i2++), 387420489);
  return h = h ^ h >>> 9;
};
var injectChecksum = (checksum2, x2) => {
  if (!x2)
    return;
  if (!Array.isArray(x2)) {
    let fn = x2;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x2];
  for (let fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn, inject, { skipIfHasType = false }) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x2 of fn)
    if (skipIfHasType)
      x2.scope ??= inject;
    else
      x2.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array = [];
  for (let x2 of fn)
    switch (x2.scope) {
      case "global":
      case "scoped":
        array.push({ ...x2 });
        break;
    }
  return array;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Enhance Your Calm": 420, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k2, v]) => [v, k2]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val === "object")
    val = JSON.stringify(val);
  else if (typeof val !== "string")
    val = val + "";
  if (secret === null)
    throw TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var insertStandaloneValidator = (hook, name, value) => {
  if (!hook.standaloneValidator?.length || !Array.isArray(hook.standaloneValidator)) {
    hook.standaloneValidator = [{ [name]: value }];
    return;
  }
  let last = hook.standaloneValidator[hook.standaloneValidator.length - 1];
  if (name in last)
    hook.standaloneValidator.push({ [name]: value });
  else
    last[name] = value;
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number = Number(message);
    if (Number.isNaN(number) || number.toString() !== message)
      return null;
    return number;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  onFinally;
  root = null;
  promises = [];
  constructor(onError = console.error, onFinally = () => {}) {
    this.onError = onError;
    this.onFinally = onFinally;
  }
  get size() {
    return this.promises.length;
  }
  add(promise) {
    if (this.promises.push(promise), this.root ||= this.drain(), this.promises.length === 1)
      this.then(this.onFinally);
    return promise;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error) {
        this.onError(error);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn, subType) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function" || typeof fn === "string")
      return subType ? { fn, subType } : { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x2 of fn)
    if (typeof x2 === "function" || typeof x2 === "string")
      fns.push(subType ? { fn: x2, subType } : { fn: x2 });
    else if ("fn" in x2)
      fns.push(x2);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  if (a.start)
    a.start = fnToContainer(a.start);
  if (a.request)
    a.request = fnToContainer(a.request);
  if (a.parse)
    a.parse = fnToContainer(a.parse);
  if (a.transform)
    a.transform = fnToContainer(a.transform);
  if (a.beforeHandle)
    a.beforeHandle = fnToContainer(a.beforeHandle);
  if (a.afterHandle)
    a.afterHandle = fnToContainer(a.afterHandle);
  if (a.mapResponse)
    a.mapResponse = fnToContainer(a.mapResponse);
  if (a.afterResponse)
    a.afterResponse = fnToContainer(a.afterResponse);
  if (a.trace)
    a.trace = fnToContainer(a.trace);
  if (a.error)
    a.error = fnToContainer(a.error);
  if (a.stop)
    a.stop = fnToContainer(a.stop);
  return a;
};
var lifeCycleToFn = (a) => {
  let lifecycle = Object.create(null);
  if (a.start?.map)
    lifecycle.start = a.start.map((x2) => x2.fn);
  if (a.request?.map)
    lifecycle.request = a.request.map((x2) => x2.fn);
  if (a.parse?.map)
    lifecycle.parse = a.parse.map((x2) => x2.fn);
  if (a.transform?.map)
    lifecycle.transform = a.transform.map((x2) => x2.fn);
  if (a.beforeHandle?.map)
    lifecycle.beforeHandle = a.beforeHandle.map((x2) => x2.fn);
  if (a.afterHandle?.map)
    lifecycle.afterHandle = a.afterHandle.map((x2) => x2.fn);
  if (a.mapResponse?.map)
    lifecycle.mapResponse = a.mapResponse.map((x2) => x2.fn);
  if (a.afterResponse?.map)
    lifecycle.afterResponse = a.afterResponse.map((x2) => x2.fn);
  if (a.error?.map)
    lifecycle.error = a.error.map((x2) => x2.fn);
  if (a.stop?.map)
    lifecycle.stop = a.stop.map((x2) => x2.fn);
  if (a.trace?.map)
    lifecycle.trace = a.trace.map((x2) => x2.fn);
  else
    lifecycle.trace = [];
  return lifecycle;
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, path: inference.path, route: inference.route, url: inference.url });
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  let formData = new FormData;
  if (formData[ELYSIA_FORM_DATA] = {}, items)
    for (let [key, value] of Object.entries(items)) {
      if (Array.isArray(value)) {
        formData[ELYSIA_FORM_DATA][key] = [];
        for (let v of value) {
          if (value instanceof File)
            formData.append(key, value, value.name);
          else if (value instanceof ElysiaFile)
            formData.append(key, value.value, value.value?.name);
          else
            formData.append(key, value);
          formData[ELYSIA_FORM_DATA][key].push(value);
        }
        continue;
      }
      if (value instanceof File)
        formData.append(key, value, value.name);
      else if (value instanceof ElysiaFile)
        formData.append(key, value.value, value.value?.name);
      else
        formData.append(key, value);
      formData[ELYSIA_FORM_DATA][key] = value;
    }
  return formData;
};
var randomId = typeof crypto > "u" ? () => {
  let result = "", characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", charactersLength = characters.length;
  for (let i2 = 0;i2 < 16; i2++)
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  return result;
} : () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array) => {
  if (!array.length)
    return [];
  let hashes = [];
  for (let i2 = 0;i2 < array.length; i2++) {
    let item = array[i2];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array.splice(i2, 1), i2--;
      hashes.push(item.checksum);
    }
  }
  return array;
};
var promoteEvent = (events, as = "scoped") => {
  if (!events)
    return;
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let _2 in obj)
    return true;
  return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  if (dynamic)
    encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
  return encoded;
};
var supportPerMethodInlineHandler = (() => {
  if (typeof Bun > "u")
    return true;
  if (Bun.semver?.satisfies?.(Bun.version, ">=1.2.14"))
    return true;
  return false;
})();
async function getResponseLength(response) {
  if (response.bodyUsed || !response.body)
    return 0;
  let length = 0, reader = response.body.getReader();
  while (true) {
    let { done, value } = await reader.read();
    if (done)
      break;
    length += value.byteLength;
  }
  return length;
}
var emptySchema = { headers: true, cookie: true, query: true, params: true, body: true, response: true };
var env = typeof Bun < "u" ? Bun.env : typeof process < "u" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var emptyHttpStatus = { 101: undefined, 204: undefined, 205: undefined, 304: undefined, 307: undefined, 308: undefined };

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    if (this.code = StatusMap[code] ?? code, code in emptyHttpStatus)
      this.response = undefined;
    else
      this.response = res;
  }
}
var status = (code, response) => new ElysiaCustomStatusResponse(code, response);
class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError2 extends Error {
  code = "PARSE";
  status = 400;
  constructor(cause) {
    super("Bad Request", { cause });
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error) => {
  if (!error)
    return { summary: undefined };
  let { message, path, value, type } = error, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type) {
    case 42:
      return { ...error, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error, summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value}` };
    case 62:
      let union = error.schema.anyOf.map((x2) => `'${x2?.format ?? x2.type}'`).join(", ");
      return { ...error, summary: isRoot ? `Value should be one of ${union}` : `Property '${property}' should be one of: ${union}` };
    default:
      return { summary: message, ...error };
  }
};

class InvalidFileType extends Error {
  property;
  expected;
  message;
  code = "INVALID_FILE_TYPE";
  status = 422;
  constructor(property, expected, message = `"${property}" has invalid file type`) {
    super(message);
    this.property = property;
    this.expected = expected;
    this.message = message;
    Object.setPrototypeOf(this, InvalidFileType.prototype);
  }
  toResponse(headers) {
    if (isProduction)
      return new Response(JSON.stringify({ type: "validation", on: "body" }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
    return new Response(JSON.stringify({ type: "validation", on: "body", summary: "Invalid file type", message: this.message, property: this.property, expected: this.expected }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
  }
}

class ValidationError extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  valueError;
  expected;
  customError;
  constructor(type, validator, value, errors) {
    let message = "", error, expected, customError;
    if (validator?.provider === "standard" || "~standard" in validator || validator.schema && "~standard" in validator.schema) {
      let standard = ("~standard" in validator ? validator : validator.schema)["~standard"];
      if (error = (errors ?? standard.validate(value).issues)?.[0], isProduction)
        message = JSON.stringify({ type: "validation", on: type, found: value });
      else
        message = JSON.stringify({ type: "validation", on: type, property: error.path?.[0] || "root", message: error?.message, summary: error?.problem, expected, found: value, errors }, null, 2);
      customError = error?.message;
    } else {
      if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse)
        value = value.response;
      error = errors?.First() ?? ("Errors" in validator ? validator.Errors(value).First() : exports_value2.Errors(validator, value).First());
      let accessor = error?.path || "root", schema = validator?.schema ?? validator;
      if (!isProduction)
        try {
          expected = exports_value2.Create(schema);
        } catch (error2) {
          expected = { type: "Could not create expected value", message: error2?.message, error: error2 };
        }
      if (customError = error?.schema?.message || error?.schema?.error !== undefined ? typeof error.schema.error === "function" ? error.schema.error(isProduction ? { type: "validation", on: type, found: value } : { type: "validation", on: type, value, property: accessor, message: error?.message, summary: mapValueError(error).summary, found: value, expected, errors: "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError) }, validator) : error.schema.error : undefined, customError !== undefined)
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      else if (isProduction)
        message = JSON.stringify({ type: "validation", on: type, found: value });
      else
        message = JSON.stringify({ type: "validation", on: type, property: accessor, message: error?.message, summary: mapValueError(error).summary, expected, found: value, errors: "Errors" in validator ? [...validator.Errors(value)].map(mapValueError) : [...exports_value2.Errors(validator, value)].map(mapValueError) }, null, 2);
    }
    super(message);
    this.type = type;
    this.validator = validator;
    this.value = value;
    this.valueError = error, this.expected = expected, this.customError = customError, Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    if ("~standard" in this.validator)
      return this.validator;
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
  detail(message) {
    if (!this.customError)
      return this.message;
    let validator = this.validator, value = this.value, expected = this.expected, errors = this.all;
    return isProduction ? { type: "validation", on: this.type, found: value, message } : { type: "validation", on: this.type, property: this.valueError?.path || "root", message, summary: mapValueError(this.valueError).summary, found: value, expected, errors };
  }
}
var tryParse = (v, schema) => {
  try {
    return JSON.parse(v);
  } catch {
    throw new ValidationError("property", schema, v);
  }
};
function createType(kind, func) {
  if (!exports_type2.Has(kind))
    exports_type2.Set(kind, func);
  return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
var compile = (schema) => {
  try {
    let compiler = TypeCompiler.Compile(schema);
    return compiler.Create = () => exports_value2.Create(schema), compiler.Error = (v) => new ValidationError("property", schema, v, compiler.Errors(v)), compiler;
  } catch {
    return { Check: (v) => exports_value2.Check(schema, v), CheckThrow: (v) => {
      if (!exports_value2.Check(schema, v))
        throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
    }, Decode: (v) => exports_value2.Decode(schema, v), Create: () => exports_value2.Create(schema), Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v)) };
  }
};
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var checkFileExtension = (type, extension) => {
  if (type.startsWith(extension))
    return true;
  return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type.startsWith(extension.slice(0, -1));
};
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
  if (!_fileTypeFromBlobWarn)
    console.warn("[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension."), _fileTypeFromBlobWarn = true;
};
var loadFileType = async () => Promise.resolve().then(() => (init_file_type(), exports_file_type)).then((x2) => {
  return _fileTypeFromBlob = x2.fileTypeFromBlob, _fileTypeFromBlob;
}).catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => {
  if (_fileTypeFromBlob)
    return _fileTypeFromBlob(file2);
  return loadFileType().then((mod) => {
    if (mod)
      return mod(file2);
  });
};
var fileType = async (file2, extension, name = file2?.name ?? "") => {
  if (Array.isArray(file2))
    return await Promise.all(file2.map((f) => fileType(f, extension, name))), true;
  if (!file2)
    return false;
  let result = await fileTypeFromBlob2(file2);
  if (!result)
    throw new InvalidFileType(name, extension);
  if (typeof extension === "string") {
    if (!checkFileExtension(result.mime, extension))
      throw new InvalidFileType(name, extension);
  }
  for (let i2 = 0;i2 < extension.length; i2++)
    if (checkFileExtension(result.mime, extension[i2]))
      return true;
  throw new InvalidFileType(name, extension);
};
var validateFile = (options, value) => {
  if (value instanceof ElysiaFile)
    return true;
  if (!(value instanceof Blob))
    return false;
  if (options.minSize && value.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension === "string")
      return checkFileExtension(value.type, options.extension);
    for (let i2 = 0;i2 < options.extension.length; i2++)
      if (checkFileExtension(value.type, options.extension[i2]))
        return true;
    return false;
  }
  return true;
};
var fullFormats = { date, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var parseDateTimeEmptySpace = (str) => {
  if (str.charCodeAt(str.length - 6) === 32)
    return str.slice(0, -6) + "+" + str.slice(-5);
  return str;
};
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
function validateInt32(value) {
  return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
  return Number.isInteger(value);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  exports_format.Set("date", (value) => {
    let temp = parseDateTimeEmptySpace(value).replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  exports_format.Set("date-time", (value) => {
    let temp = value.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date2 = new Date(temp);
      if (!Number.isNaN(date2.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      exports_format.Set(formatName, (value) => formatValue.test(value));
    else if (typeof formatValue === "function")
      exports_format.Set(formatName, formatValue);
  }
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value), true;
    } catch {
      return false;
    }
  });
var t = Object.assign({}, Type);
createType("UnionEnum", (schema, value) => (typeof value === "number" || typeof value === "string" || value === null) && schema.enum.includes(value));
createType("ArrayBuffer", (schema, value) => value instanceof ArrayBuffer);
var internalFiles = createType("Files", (options, value) => {
  if (options.minItems && options.minItems > 1 && !Array.isArray(value))
    return false;
  if (!Array.isArray(value))
    return validateFile(options, value);
  if (options.minItems && value.length < options.minItems)
    return false;
  if (options.maxItems && value.length > options.maxItems)
    return false;
  for (let i2 = 0;i2 < value.length; i2++)
    if (!validateFile(options, value[i2]))
      return false;
  return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler, ...schema }, value) => {
  if (!(value instanceof FormData))
    return false;
  if (compiler) {
    if (!(ELYSIA_FORM_DATA in value))
      throw new ValidationError("property", schema, value);
    if (!compiler.Check(value[ELYSIA_FORM_DATA]))
      throw compiler.Error(value[ELYSIA_FORM_DATA]);
  }
  return true;
});
var ElysiaType = { String: (property) => Type.String(property), Numeric: (property) => {
  let schema = Type.Number(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value) => {
    let number = +value;
    if (isNaN(number))
      return value;
    if (property && !compiler.Check(number))
      throw compiler.Error(number);
    return number;
  }).Encode((value) => value);
}, Integer: (property) => {
  let schema = Type.Integer(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "integer", default: 0 }), Type.Integer(property)], property)).Decode((value) => {
    let number = +value;
    if (!compiler.Check(number))
      throw compiler.Error(number);
    return number;
  }).Encode((value) => value);
}, Date: (property) => {
  let schema = Type.Date(property), compiler = compile(schema), _default = property?.default ? new Date(property.default) : undefined;
  return t.Transform(t.Union([Type.Date(property), t.String({ format: "date-time", default: _default?.toISOString() }), t.String({ format: "date", default: _default?.toISOString() }), t.Number({ default: _default?.getTime() })], property)).Decode((value) => {
    if (typeof value === "number") {
      let date3 = new Date(value);
      if (!compiler.Check(date3))
        throw compiler.Error(date3);
      return date3;
    }
    if (value instanceof Date)
      return value;
    let date2 = new Date(parseDateTimeEmptySpace(value));
    if (!date2 || isNaN(date2.getTime()))
      throw new ValidationError("property", schema, date2);
    if (!compiler.Check(date2))
      throw compiler.Error(date2);
    return date2;
  }).Encode((value) => {
    if (value instanceof Date)
      return value.toISOString();
    if (typeof value === "string") {
      if (isNaN(new Date(parseDateTimeEmptySpace(value)).getTime()))
        throw new ValidationError("property", schema, value);
      return value;
    }
    if (!compiler.Check(value))
      throw compiler.Error(value);
    return value;
  });
}, BooleanString: (property) => {
  let schema = Type.Boolean(property), compiler = compile(schema);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value) => {
    if (typeof value === "string")
      return value === "true";
    if (value !== undefined && !compiler.Check(value))
      throw compiler.Error(value);
    return value;
  }).Encode((value) => value);
}, ObjectString: (properties, options) => {
  let schema = t.Object(properties, options), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: "{}" }), schema], { elysiaMeta: "ObjectString" })).Decode((value) => {
    if (typeof value === "string") {
      if (value.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema, value);
      if (!compiler.Check(value = tryParse(value, schema)))
        throw compiler.Error(value);
      return compiler.Decode(value);
    }
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw compiler.Error(value);
    return original ?? JSON.stringify(value);
  });
}, ArrayString: (children = t.String(), options) => {
  let schema = t.Array(children, options), compiler = compile(schema), decode2 = (value, isProperty = false) => {
    if (value.charCodeAt(0) === 91) {
      if (!compiler.Check(value = tryParse(value, schema)))
        throw compiler.Error(value);
      return compiler.Decode(value);
    }
    if (isProperty)
      return value;
    throw new ValidationError("property", schema, value);
  };
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: options?.default }), schema])).Decode((value) => {
    if (Array.isArray(value)) {
      let values = [];
      for (let i2 = 0;i2 < value.length; i2++) {
        let v = value[i2];
        if (typeof v === "string") {
          let t2 = decode2(v, true);
          if (Array.isArray(t2))
            values = values.concat(t2);
          else
            values.push(t2);
          continue;
        }
        values.push(v);
      }
      return values;
    }
    if (typeof value === "string")
      return decode2(value);
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw new ValidationError("property", schema, value);
    return original ?? JSON.stringify(value);
  });
}, ArrayQuery: (children = t.String(), options) => {
  let schema = t.Array(children, options), compiler = compile(schema), decode2 = (value) => {
    if (value.indexOf(",") !== -1)
      return compiler.Decode(value.split(","));
    return [value];
  };
  return t.Transform(t.Union([t.String({ default: options?.default }), schema], { elysiaMeta: "ArrayQuery" })).Decode((value) => {
    if (Array.isArray(value)) {
      let values = [];
      for (let i2 = 0;i2 < value.length; i2++) {
        let v = value[i2];
        if (typeof v === "string") {
          let t2 = decode2(v);
          if (Array.isArray(t2))
            values = values.concat(t2);
          else
            values.push(t2);
          continue;
        }
        values.push(v);
      }
      return values;
    }
    if (typeof value === "string")
      return decode2(value);
    return value;
  }).Encode((value) => {
    let original;
    if (typeof value === "string")
      value = tryParse(original = value, schema);
    if (!compiler.Check(value))
      throw new ValidationError("property", schema, value);
    return original ?? JSON.stringify(value);
  });
}, File: createType("File", validateFile), Files: (options = {}) => t.Transform(internalFiles(options)).Decode((value) => {
  if (Array.isArray(value))
    return value;
  return [value];
}).Encode((value) => value), Nullable: (schema, options) => t.Union([schema, t.Null()], { ...options, nullable: true }), MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type = values.every((value) => typeof value === "string") ? { type: "string" } : values.every((value) => typeof value === "number") ? { type: "number" } : values.every((value) => value === null) ? { type: "null" } : {};
  if (values.some((x2) => typeof x2 === "object" && x2 !== null))
    throw Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind]: "UnionEnum", ...type, enum: values };
}, NoValidate: (v, enabled = true) => {
  return v.noValidate = enabled, v;
}, Form: (v, options = {}) => {
  let schema = t.Object(v, { default: form({}), ...options }), compiler = compile(schema);
  return t.Union([schema, internalFormData({ compiler })]);
}, ArrayBuffer(options = {}) {
  return { default: [1, 2, 3], ...options, [Kind]: "ArrayBuffer" };
}, Uint8Array: (options) => {
  let schema = Type.Uint8Array(options), compiler = compile(schema);
  return t.Transform(t.Union([t.ArrayBuffer(), Type.Uint8Array(options)])).Decode((value) => {
    if (value instanceof ArrayBuffer) {
      if (!compiler.Check(value = new Uint8Array(value)))
        throw compiler.Error(value);
      return value;
    }
    return value;
  }).Encode((value) => value);
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.ArrayQuery = ElysiaType.ArrayQuery;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
};
t.Files = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
};
t.Nullable = ElysiaType.Nullable;
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
t.ArrayBuffer = ElysiaType.ArrayBuffer;
t.Uint8Array = ElysiaType.Uint8Array;
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value) {
    this.setCookie.value = value;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    return this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config), this;
  }
  set(config) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config === "function" ? config(this.cookie) : config), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set2.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value = import_fast_decode_uri_component.default(v);
    if (value) {
      let starts = value.charCodeAt(0), ends = value.charCodeAt(value.length - 1);
      if (starts === 123 && ends === 125 || starts === 91 && ends === 93)
        try {
          value = JSON.parse(value);
        } catch {}
    }
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value = temp;
      } else {
        let decoded = true;
        for (let i2 = 0;i2 < secrets.length; i2++) {
          let temp = await unsignCookie(value, secrets[i2]);
          if (temp !== false) {
            decoded = true, value = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value };
  }
  return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set2 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value = property.value;
    if (value === undefined || value === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value === "object" ? JSON.stringify(value) : value + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var handleFile = (response, set2) => {
  if (!isBun && response instanceof Promise)
    return response.then((res) => handleFile(res, set2));
  let size = response.size, immutable = set2 && (set2.status === 206 || set2.status === 304 || set2.status === 412 || set2.status === 416), defaultHeader = immutable ? { "transfer-encoding": "chunked" } : { "accept-ranges": "bytes", "content-range": size ? `bytes 0-${size - 1}/${size}` : undefined, "transfer-encoding": "chunked" };
  if (!set2 && !size)
    return new Response(response);
  if (!set2)
    return new Response(response, { headers: defaultHeader });
  if (set2.headers instanceof Headers) {
    for (let key of Object.keys(defaultHeader))
      if (key in set2.headers)
        set2.headers.append(key, defaultHeader[key]);
    if (immutable)
      set2.headers.delete("content-length"), set2.headers.delete("accept-ranges");
    return new Response(response, set2);
  }
  if (isNotEmpty(set2.headers))
    return new Response(response, { status: set2.status, headers: Object.assign(defaultHeader, set2.headers) });
  return new Response(response, { status: set2.status, headers: defaultHeader });
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i2 = 0;i2 < setCookie.length; i2++) {
    let index = setCookie[i2].indexOf("=");
    headers.append("set-cookie", `${setCookie[i2].slice(0, index)}=${setCookie[i2].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set2) => {
  if (set2?.headers) {
    if (response) {
      if (hasHeaderShorthand)
        Object.assign(set2.headers, response.headers.toJSON());
      else
        for (let [key, value] of response.headers.entries())
          if (key in set2.headers)
            set2.headers[key] = value;
    }
    if (set2.status === 200)
      set2.status = response.status;
    if (set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  if (!response)
    return { headers: {}, status: set2?.status ?? 200 };
  if (hasHeaderShorthand) {
    if (set2 = { headers: response.headers.toJSON(), status: set2?.status ?? 200 }, set2.headers["content-encoding"])
      delete set2.headers["content-encoding"];
    return set2;
  }
  set2 = { headers: {}, status: set2?.status ?? 200 };
  for (let [key, value] of response.headers.entries()) {
    if (key === "content-encoding")
      continue;
    if (key in set2.headers)
      set2.headers[key] = value;
  }
  return set2;
};
var createStreamHandler = ({ mapResponse, mapCompactResponse }) => async (generator, set2, request) => {
  let init = generator.next?.();
  if (set2)
    handleSet(set2);
  if (init instanceof Promise)
    init = await init;
  if (init?.value instanceof ReadableStream)
    generator = init.value;
  else if (init && (typeof init?.done > "u" || init?.done)) {
    if (set2)
      return mapResponse(init.value, set2, request);
    return mapCompactResponse(init.value, request);
  }
  let isSSE = init?.value?.sse ?? generator?.sse ?? set2?.headers["content-type"]?.startsWith("text/event-stream"), format = isSSE ? (data) => `data: ${data}

` : (data) => data, contentType = isSSE ? "text/event-stream" : init?.value && typeof init?.value === "object" ? "application/json" : "text/plain";
  if (set2?.headers) {
    if (!set2.headers["transfer-encoding"])
      set2.headers["transfer-encoding"] = "chunked";
    if (!set2.headers["content-type"])
      set2.headers["content-type"] = contentType;
    if (!set2.headers["cache-control"])
      set2.headers["cache-control"] = "no-cache";
  } else
    set2 = { status: 200, headers: { "content-type": contentType, "transfer-encoding": "chunked", "cache-control": "no-cache", connection: "keep-alive" } };
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal?.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {}
    }), !init || init.value instanceof ReadableStream)
      ;
    else if (init.value !== undefined && init.value !== null)
      if (init.value.toSSE)
        controller.enqueue(init.value.toSSE());
      else if (typeof init.value === "object")
        try {
          controller.enqueue(format(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(format(init.value.toString()));
        }
      else
        controller.enqueue(format(init.value.toString()));
    try {
      for await (let chunk of generator) {
        if (end)
          break;
        if (chunk === undefined || chunk === null)
          continue;
        if (chunk.toSSE)
          controller.enqueue(chunk.toSSE());
        else {
          if (typeof chunk === "object")
            try {
              controller.enqueue(format(JSON.stringify(chunk)));
            } catch {
              controller.enqueue(format(chunk.toString()));
            }
          else
            controller.enqueue(format(chunk.toString()));
          if (!isSSE)
            await new Promise((resolve) => setTimeout(() => resolve(), 0));
        }
      }
    } catch (error) {
      console.warn(error);
    }
    try {
      controller.close();
    } catch {}
  } }), set2);
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value } = await reader.read();
      if (done)
        break;
      if (typeof value === "string")
        yield value;
      else
        yield decoder.decode(value);
    }
  } finally {
    reader.releaseLock();
  }
}
var handleSet = (set2) => {
  if (typeof set2.status === "string")
    set2.status = StatusMap[set2.status];
  if (set2.cookie && isNotEmpty(set2.cookie)) {
    let cookie = serializeCookie(set2.cookie);
    if (cookie)
      set2.headers["set-cookie"] = cookie;
  }
  if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
    set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var createResponseHandler = (handler) => {
  let handleStream = createStreamHandler(handler);
  return (response, set2, request) => {
    let isCookieSet = false;
    if (set2.headers instanceof Headers)
      for (let key of set2.headers.keys())
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (let cookie of set2.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set2.headers?.get(key) ?? "");
    else
      for (let key in set2.headers)
        response.headers.append(key, set2.headers[key]);
    let status2 = set2.status ?? 200;
    if (response.status !== status2 && status2 !== 200 && (response.status <= 300 || response.status > 400)) {
      let newResponse = new Response(response.body, { headers: response.headers, status: set2.status });
      if (!newResponse.headers.has("content-length") && newResponse.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(newResponse), responseToSetHeaders(newResponse, set2), request);
      return newResponse;
    }
    if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
      return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
    return response;
  };
};
var handleElysiaFile = (file2, set2 = { headers: {} }) => {
  let path = file2.path, contentType = mime[path.slice(path.lastIndexOf(".") + 1)];
  if (contentType)
    set2.headers["content-type"] = contentType;
  if (file2.stats && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416)
    return file2.stats.then((stat2) => {
      let size = stat2.size;
      if (size !== undefined)
        set2.headers["content-range"] = `bytes 0-${size - 1}/${size}`, set2.headers["content-length"] = size;
      return handleFile(file2.value, set2);
    });
  return handleFile(file2.value, set2);
};
var mapResponse = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x2) => mapResponse(x2, set2, request));
      case "Function":
        return mapResponse(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream(response, set2, request);
  return mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse(response, set2, request);
      case "Promise":
        return response.then((x2) => mapEarlyResponse(x2, set2));
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return set2.headers["content-type"] = "text/plain", new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleElysiaFile(response, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x2) => {
          let r = mapEarlyResponse(x2, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: { "Content-Type": "text/plain" } });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleElysiaFile(response);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x2) => mapCompactResponse(x2, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x2) => mapCompactResponse(x2, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x2) => mapResponse(x2, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error, set2) => new Response(JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse = createResponseHandler({ mapResponse, mapCompactResponse });
var handleStream = createStreamHandler({ mapResponse, mapCompactResponse });
var WebStandardAdapter = { name: "web-standard", isWebStandard: true, handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`, parser: { json(isOptional) {
  if (isOptional)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, async stop(app, closeActiveConnections) {
  if (!app.server)
    throw Error("Elysia isn't running. Call `app.listen` to start the server.");
  if (app.server) {
    if (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i2 = 0;i2 < app.event.stop.length; i2++)
        app.event.stop[i2].fn(app);
  }
}, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.decorator))
    decoratorsLiteral += `,'${key}':decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = !!app.event.trace?.length;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,status,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({},app.setHeaders)" : "Object.create(null)", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, error404(hasEventHook, hasErrorHook, afterHandle = "") {
  let findDynamicRoute = "if(route===null){" + afterHandle + `
return `;
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()";
  return findDynamicRoute += "}", { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
function isCloudflareWorker() {
  try {
    if (typeof caches < "u" && typeof caches.default < "u")
      return true;
    if (typeof WebSocketPair < "u")
      return true;
  } catch {
    return false;
  }
  return false;
}
var CloudflareAdapter = { ...WebStandardAdapter, name: "cloudflare-worker", composeGeneralHandler: { ...WebStandardAdapter.composeGeneralHandler, error404(hasEventHook, hasErrorHook, afterHandle) {
  let { code } = WebStandardAdapter.composeGeneralHandler.error404(hasEventHook, hasErrorHook, afterHandle);
  return { code, declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404={clone:()=>new Response(error404Message,{status:404})}
` };
} }, beforeCompile(app) {
  for (let route of app.routes)
    route.compile();
}, listen(app) {
  return (options, callback) => {
    console.warn("Cloudflare Worker does not support listen method. Please export default Elysia instance instead."), app.compile();
  };
} };
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x2 = code.split(`
`, 2);
  return [x2[0], x2[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    if (parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let parameterMap = Object.create(null);
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      parameterMap[p] = true;
      continue;
    }
    for (let q of p.split(","))
      parameterMap[q.trim()] = true;
  }
  return { hasParenthesis, parameters: parameterMap };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (parameters.query)
    inference.query = true;
  if (parameters.headers)
    inference.headers = true;
  if (parameters.body)
    inference.body = true;
  if (parameters.cookie)
    inference.cookie = true;
  if (parameters.set)
    inference.set = true;
  if (parameters.server)
    inference.server = true;
  if (parameters.route)
    inference.route = true;
  if (parameters.url)
    inference.url = true;
  if (parameters.path)
    inference.path = true;
  if (hasParenthesis)
    return `{ ${Object.keys(parameters).join(", ")} }`;
  return Object.keys(parameters).join(", ");
};
var findEndIndex = (type, content, index) => {
  let regex2 = new RegExp(`${type.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
  if (index !== undefined)
    regex2.lastIndex = index;
  let match = regex2.exec(content);
  return match ? match.index : -1;
};
var findAlias = (type, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type, content);
    if (index === -1)
      index = findEndIndex("=" + type, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type);
      if (lastIndex + 3 + type.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.indexOf("...") !== -1)
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type, alias) => new RegExp(`${alias}\\.(${type})|${alias}\\["${type}"\\]|${alias}\\['${type}'\\]`).test(code);
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters(alias).parameters;
      if (parameters.query)
        inference.query = true;
      if (parameters.headers)
        inference.headers = true;
      if (parameters.body)
        inference.body = true;
      if (parameters.cookie)
        inference.cookie = true;
      if (parameters.set)
        inference.set = true;
      if (parameters.server)
        inference.server = true;
      if (parameters.url)
        inference.url = true;
      if (parameters.route)
        inference.route = true;
      if (parameters.path)
        inference.path = true;
      continue;
    }
    if (!inference.query && (access("query", alias) || code.includes("return " + alias) || code.includes("return " + alias + ".query")))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (!inference.route && access("route", alias))
      inference.route = true;
    if (!inference.url && access("url", alias))
      inference.url = true;
    if (!inference.path && access("path", alias))
      inference.path = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.route && inference.url && inference.path)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`\\w\\((.*?)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.url = true, inference.route = true, inference.path = true, true;
    return false;
  } catch (error) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var pendingGC;
var caches2 = {};
var clearSucroseCache = (delay) => {
  if (delay === null || isCloudflareWorker())
    return;
  if (delay === undefined)
    delay = 295000;
  if (pendingGC)
    clearTimeout(pendingGC);
  pendingGC = setTimeout(() => {
    if (caches2 = {}, pendingGC = undefined, isBun)
      Bun.gc(false);
  }, delay);
};
var mergeInference = (a, b) => {
  return { body: a.body || b.body, cookie: a.cookie || b.cookie, headers: a.headers || b.headers, query: a.query || b.query, set: a.set || b.set, server: a.server || b.server, url: a.url || b.url, route: a.route || b.route, path: a.path || b.path };
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, settings = {}) => {
  let events = [];
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  for (let i2 = 0;i2 < events.length; i2++) {
    let e = events[i2];
    if (!e)
      continue;
    let event = typeof e === "object" ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let content = event.toString(), key = checksum(content), cachedInference = caches2[key];
    if (cachedInference) {
      inference = mergeInference(inference, cachedInference);
      continue;
    }
    clearSucroseCache(settings.gcTime);
    let fnInference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, [parameter, body] = separateFunction(content), rootParameters = findParameterReference(parameter, fnInference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
        code = code.slice(1, -1);
      if (!isContextPassToFunction(mainParameter, code, fnInference))
        inferBodyReference(code, aliases, fnInference);
      if (!fnInference.query && code.includes("return " + mainParameter + ".query"))
        fnInference.query = true;
    }
    if (!caches2[key])
      caches2[key] = fnInference;
    if (inference = mergeInference(inference, fnInference), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.url && inference.route && inference.path)
      break;
  }
  return inference;
};
var mapResponse2 = (response, set2, request) => {
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("", set2);
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Error":
        return errorToResponse2(response, set2);
      case "Promise":
        return response.then((x2) => mapResponse2(x2, set2, request));
      case "Function":
        return mapResponse2(response(), set2, request);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response, set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream2(response, set2, request);
  return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
    switch (handleSet(set2), response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set2);
      case "Response":
        return handleResponse2(response, set2, request);
      case "Promise":
        return response.then((x2) => mapEarlyResponse2(x2, set2));
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapEarlyResponse2(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set2, request);
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return set2.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set2);
      case "ElysiaFile":
        return handleFile(response.value, set2);
      case "File":
        return handleFile(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "ElysiaCustomStatusResponse":
        return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x2) => {
          let r = mapEarlyResponse2(x2, set2);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse2(response, set2);
      case "Function":
        return mapCompactResponse2(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (response instanceof Error)
          return errorToResponse2(response, set2);
        if (response instanceof ElysiaCustomStatusResponse)
          return set2.status = response.code, mapEarlyResponse2(response.response, set2, request);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set2, request);
        if (typeof response?.then === "function")
          return response.then((x2) => mapEarlyResponse2(x2, set2));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set2);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x2) => mapCompactResponse2(x2, request));
    case "Function":
      return mapCompactResponse2(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x2) => mapCompactResponse2(x2, request));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream2(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x2) => mapResponse2(x2, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error, set2) => new Response(JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }), { status: set2?.status !== 200 ? set2?.status ?? 500 : 500, headers: set2?.headers });
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse2 = createResponseHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var handleStream2 = createStreamHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var KEY_HAS_PLUS = 1;
var KEY_NEEDS_DECODE = 2;
var VALUE_HAS_PLUS = 4;
var VALUE_NEEDS_DECODE = 8;
function parseQueryFromURL(input, startIndex = 0, array, object) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (array?.[finalKey])
      if (finalValue.charCodeAt(0) === 91) {
        if (object?.[finalKey])
          finalValue = JSON.parse(finalValue);
        else
          finalValue = finalValue.slice(1, -1).split(",");
        if (currentValue === undefined)
          result[finalKey] = finalValue;
        else if (Array.isArray(currentValue))
          currentValue.push(...finalValue);
        else
          result[finalKey] = finalValue, result[finalKey].unshift(currentValue);
      } else if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    else
      result[finalKey] = finalValue;
  }
}
function parseQueryStandardSchema(input, startIndex = 0) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (finalValue.charCodeAt(0) === 91 && finalValue.charCodeAt(finalValue.length - 1) === 93) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {}
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else if (finalValue.charCodeAt(0) === 123 && finalValue.charCodeAt(finalValue.length - 1) === 125) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {}
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else {
      if (finalValue.includes(","))
        finalValue = finalValue.split(",");
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    }
  }
}
function parseQuery(input) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = -1, equalityIndex = -1;
  for (let i2 = 0;i2 < inputLength; i2++)
    switch (input.charCodeAt(i2)) {
      case 38:
        processKeyValuePair(input, i2), startingIndex = i2, equalityIndex = i2, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i2;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (currentValue === undefined)
      result[finalKey] = finalValue;
    else if (Array.isArray(currentValue))
      currentValue.push(finalValue);
    else
      result[finalKey] = [currentValue, finalValue];
  }
}
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i2 = 0;i2 < (process2.total ?? 0); i2++) {
      let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error2, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise2;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error2, index: i2, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i22 = 0;i22 < callbacks2.length; i22++)
          callbacks2[i22](result2);
        return (error3 = null) => {
          let end3 = performance.now();
          if (error3)
            groupError = error3;
          let detail = { end: end3, error: error3, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i22 = 0;i22 < callbacksEnd2.length; i22++)
            callbacksEnd2[i22](detail);
          resolveEnd2(end3), resolveError2(error3);
        };
      });
    }
    let result = { ...process2, end, error, onEvent(callback) {
      for (let i2 = 0;i2 < processes.length; i2++)
        processes[i2](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i2 = 0;i2 < callbacks.length; i2++)
      callbacks[i2](result);
    return { resolveChild: resolvers, resolve(error2 = null) {
      let end2 = performance.now();
      if (!error2 && groupError)
        error2 = groupError;
      let detail = { end: end2, error: error2, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i2 = 0;i2 < callbacksEnd.length; i2++)
        callbacksEnd[i2](detail);
      resolveEnd(end2), resolveError(error2);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context[ELYSIA_REQUEST_ID], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError, time: Date.now(), store: context.store }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var Kind3 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n|\.)/.test(name) || !isNaN(+name[0]);
var joinProperty = (v1, v2, isOptional = false) => {
  if (typeof v2 === "number")
    return `${v1}[${v2}]`;
  if (isSpecialProperty(v2))
    return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
  return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => isSpecialProperty(v) ? `"${v}"` : v;
var sanitize = (key, sanitize2 = 0, schema) => {
  if (schema.type !== "string" || schema.const || schema.trusted)
    return key;
  let hof = "";
  for (let i2 = sanitize2 - 1;i2 >= 0; i2--)
    hof += `d.h${i2}(`;
  return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
  if (!schema.allOf || Kind3 in schema && (schema[Kind3] !== "Intersect" || schema.type !== "object"))
    return schema;
  let { allOf, ...newSchema } = schema;
  if (newSchema.properties = {}, Kind3 in newSchema)
    newSchema[Kind3] = "Object";
  for (let type of allOf) {
    if (type.type !== "object")
      continue;
    let { properties, required, type: _2, [Kind3]: __, ...rest } = type;
    if (required)
      newSchema.required = newSchema.required ? newSchema.required.concat(required) : required;
    Object.assign(newSchema, rest);
    for (let property in type.properties)
      newSchema.properties[property] = mergeObjectIntersection(type.properties[property]);
  }
  return newSchema;
};
var handleRecord = (schema, property, instruction) => {
  let child = schema.patternProperties["^(.*)$"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];
  if (!child)
    return property;
  let i2 = instruction.array;
  instruction.array++;
  let v = `(()=>{const ar${i2}s=Object.keys(${property}),ar${i2}v={};for(let i=0;i<ar${i2}s.length;i++){const ar${i2}p=${property}[ar${i2}s[i]];ar${i2}v[ar${i2}s[i]]=${mirror(child, `ar${i2}p`, instruction)}`, optionals = instruction.optionalsInArray[i2 + 1];
  if (optionals)
    for (let oi = 0;oi < optionals.length; oi++) {
      let target = `ar${i2}v[ar${i2}s[i]].${optionals[oi]}`;
      v += `;if(${target}===undefined)delete ${target}`;
    }
  return v += `}return ar${i2}v})()`, v;
};
var handleTuple = (schema, property, instruction) => {
  let i2 = instruction.array;
  instruction.array++;
  let isRoot = property === "v" && !instruction.unions.length, v = "";
  if (!isRoot)
    v = "(()=>{";
  v += `const ar${i2}v=[`;
  for (let i22 = 0;i22 < schema.length; i22++) {
    if (i22 !== 0)
      v += ",";
    v += mirror(schema[i22], joinProperty(property, i22, instruction.parentIsOptional), instruction);
  }
  if (v += "];", !isRoot)
    v += `return ar${i2}v})()`;
  return v;
};
function deepClone(source, weak = new WeakMap) {
  if (source === null || typeof source !== "object" || typeof source === "function")
    return source;
  if (weak.has(source))
    return weak.get(source);
  if (Array.isArray(source)) {
    let copy = Array(source.length);
    weak.set(source, copy);
    for (let i2 = 0;i2 < source.length; i2++)
      copy[i2] = deepClone(source[i2], weak);
    return copy;
  }
  if (typeof source === "object") {
    let keys = Object.keys(source).concat(Object.getOwnPropertySymbols(source)), cloned = {};
    for (let key of keys)
      cloned[key] = deepClone(source[key], weak);
    return cloned;
  }
  return source;
}
var handleUnion = (schemas, property, instruction) => {
  if (instruction.TypeCompiler === undefined) {
    if (!instruction.typeCompilerWanred)
      console.warn(Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union")), instruction.typeCompilerWanred = true;
    return property;
  }
  instruction.unionKeys[property] = 1;
  let ui = instruction.unions.length, typeChecks = instruction.unions[ui] = [], v = `(()=>{
`, unwrapRef = (type) => {
    if (!(Kind3 in type) || !type.$ref)
      return type;
    if (type[Kind3] === "This")
      return deepClone(instruction.definitions[type.$ref]);
    else if (type[Kind3] === "Ref")
      if (!instruction.modules)
        console.warn(Error("[exact-mirror] modules is required when using nested cyclic reference"));
      else
        return instruction.modules.Import(type.$ref);
    return type;
  };
  for (let i2 = 0;i2 < schemas.length; i2++) {
    let type = unwrapRef(schemas[i2]);
    if (Array.isArray(type.anyOf))
      for (let i22 = 0;i22 < type.anyOf.length; i22++)
        type.anyOf[i22] = unwrapRef(type.anyOf[i22]);
    else if (type.items)
      if (Array.isArray(type.items))
        for (let i22 = 0;i22 < type.items.length; i22++)
          type.items[i22] = unwrapRef(type.items[i22]);
      else
        type.items = unwrapRef(type.items);
    typeChecks.push(TypeCompiler.Compile(type)), v += `if(d.unions[${ui}][${i2}].Check(${property})){return ${mirror(type, property, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: true })}}
`;
  }
  return v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`, v;
};
var mirror = (schema, property, instruction) => {
  if (!schema)
    return "";
  let isRoot = property === "v" && !instruction.unions.length;
  if (Kind3 in schema && schema[Kind3] === "Import" && schema.$ref in schema.$defs)
    return mirror(schema.$defs[schema.$ref], property, { ...instruction, definitions: Object.assign(instruction.definitions, schema.$defs) });
  if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
    return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
  if (instruction.recursion >= instruction.recursionLimit)
    return property;
  let v = "";
  if (schema.$id && Hint2 in schema)
    instruction.definitions[schema.$id] = schema;
  switch (schema.type) {
    case "object":
      if (schema[Kind3] === "Record") {
        v = handleRecord(schema, property, instruction);
        break;
      }
      if (schema = mergeObjectIntersection(schema), v += "{", schema.additionalProperties)
        v += `...${property},`;
      let keys = Object.keys(schema.properties);
      for (let i22 = 0;i22 < keys.length; i22++) {
        let key = keys[i22], isOptional = !schema.required || schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf), name = joinProperty(property, key, instruction.parentIsOptional);
        if (isOptional) {
          let index = instruction.array;
          if (property.startsWith("ar")) {
            let refName = name.slice(name.indexOf(".") + 1), array = instruction.optionalsInArray;
            if (array[index])
              array[index].push(refName);
            else
              array[index] = [refName];
          } else
            instruction.optionals.push(name);
        }
        let child = schema.properties[key];
        if (i22 !== 0)
          v += ",";
        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: isOptional })}`;
      }
      v += "}";
      break;
    case "array":
      if (schema.items.type !== "object" && schema.items.type !== "array")
        if (Array.isArray(schema.items)) {
          v = handleTuple(schema.items, property, instruction);
          break;
        } else if (isRoot)
          return "return v";
        else if (Kind3 in schema.items && schema.items.$ref && (schema.items[Kind3] === "Ref" || schema.items[Kind3] === "This"))
          v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, { ...instruction, parentIsOptional: true, recursion: instruction.recursion + 1 });
        else {
          v = property;
          break;
        }
      let i2 = instruction.array;
      instruction.array++;
      let reference = property;
      if (isRoot)
        v = `const ar${i2}v=new Array(${property}.length);`;
      else
        reference = `ar${i2}s`, v = `((${reference})=>{const ar${i2}v=new Array(${reference}.length);`;
      v += `for(let i=0;i<${reference}.length;i++){const ar${i2}p=${reference}[i];ar${i2}v[i]=${mirror(schema.items, `ar${i2}p`, instruction)}`;
      let optionals = instruction.optionalsInArray[i2 + 1];
      if (optionals)
        for (let oi = 0;oi < optionals.length; oi++) {
          let target = `ar${i2}v[i].${optionals[oi]}`;
          v += `;if(${target}===undefined)delete ${target}`;
        }
      if (v += "}", !isRoot)
        v += `return ar${i2}v})(${property})`;
      break;
    default:
      if (schema.$ref && schema.$ref in instruction.definitions)
        return mirror(instruction.definitions[schema.$ref], property, instruction);
      if (Array.isArray(schema.anyOf)) {
        v = handleUnion(schema.anyOf, property, instruction);
        break;
      }
      v = sanitize(property, instruction.sanitize?.length, schema);
      break;
  }
  if (!isRoot)
    return v;
  if (schema.type === "array")
    v = `${v}const x=ar0v;`;
  else
    v = `const x=${v}
`;
  for (let i2 = 0;i2 < instruction.optionals.length; i2++) {
    let key = instruction.optionals[i2], prop = key.slice(1);
    if (v += `if(${key}===undefined`, instruction.unionKeys[key])
      v += `||x${prop}===undefined`;
    let shouldQuestion = prop.charCodeAt(0) !== 63 && schema.type !== "array";
    v += `)delete x${shouldQuestion ? prop.charCodeAt(0) === 91 ? "?." : "?" : ""}${prop}
`;
  }
  return `${v}return x`;
};
var createMirror = (schema, { TypeCompiler: TypeCompiler22, modules, definitions, sanitize: sanitize2, recursionLimit = 8, removeUnknownUnionType = false } = {}) => {
  let unions = [];
  if (typeof sanitize2 === "function")
    sanitize2 = [sanitize2];
  let f = mirror(schema, "v", { optionals: [], optionalsInArray: [], array: 0, parentIsOptional: false, unions, unionKeys: {}, TypeCompiler: TypeCompiler22, modules, definitions: definitions ?? modules?.$defs ?? {}, sanitize: sanitize2, recursion: 0, recursionLimit, removeUnknownUnionType });
  if (!unions.length && !sanitize2?.length)
    return Function("v", f);
  let hof;
  if (sanitize2?.length) {
    hof = {};
    for (let i2 = 0;i2 < sanitize2.length; i2++)
      hof[`h${i2}`] = sanitize2[i2];
  }
  return Function("d", `return function mirror(v){${f}}`)({ unions, ...hof });
};
var isOptional = (schema) => {
  if (!schema)
    return false;
  if (schema?.[Kind] === "Import" && schema.References)
    return schema.References().some(isOptional);
  if (schema.schema)
    schema = schema.schema;
  return !!schema && OptionalKind in schema;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasAdditionalProperties(property.anyOf[i2]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasAdditionalProperties(schema.items);
  return false;
};
var hasType = (type, schema) => {
  if (!schema)
    return false;
  if (Kind in schema && schema[Kind] === type)
    return true;
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasType(type, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasType(type, property.anyOf[i2]))
            return true;
      }
      if (Kind in property && property[Kind] === type)
        return true;
    }
    return false;
  }
  return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type;
};
var hasElysiaMeta = (meta, _schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema.elysiaMeta === meta)
    return true;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.anyOf)
    return schema.anyOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.someOf)
    return schema.someOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.allOf)
    return schema.allOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.not)
    return schema.not.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasElysiaMeta(meta, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasElysiaMeta(meta, property.anyOf[i2]))
            return true;
      }
      return schema.elysiaMeta === meta;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasElysiaMeta(meta, schema.items);
  return false;
};
var hasProperty = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i2 = 0;i2 < property.anyOf.length; i2++)
          if (hasProperty(expectedProperty, property.anyOf[i2]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var hasRef = (schema) => {
  if (!schema)
    return false;
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasRef(schema.oneOf[i2]))
        return true;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      if (hasRef(schema.anyOf[i2]))
        return true;
  }
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasRef(schema.oneOf[i2]))
        return true;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      if (hasRef(schema.allOf[i2]))
        return true;
  }
  if (schema.not && hasRef(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasRef(property))
        return true;
      if (property.type === "array" && property.items && hasRef(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasRef(schema.items))
    return true;
  return schema[Kind] === "Ref" && "$ref" in schema;
};
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      if (hasTransform(schema.oneOf[i2]))
        return true;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      if (hasTransform(schema.anyOf[i2]))
        return true;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      if (hasTransform(schema.allOf[i2]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasTransform(property))
        return true;
      if (property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasTransform(schema.items))
    return true;
  return TransformKind in schema;
};
var replaceSchemaType = (schema, options, _config = {}) => {
  let config = _config;
  if (config.root = true, !Array.isArray(options))
    return options.original = schema, _replaceSchemaType(schema, options, config);
  for (let option of options)
    option.original = schema, schema = _replaceSchemaType(schema, option, config);
  return schema;
};
var _replaceSchemaType = (schema, options, config) => {
  if (!schema)
    return schema;
  let root = config.root;
  if (options.onlyFirst && schema.type === options.onlyFirst)
    return options.to(schema) ?? schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i2 = 0;i2 < schema.oneOf.length; i2++)
      schema.oneOf[i2] = _replaceSchemaType(schema.oneOf[i2], options, config);
    return schema;
  }
  if (schema.anyOf) {
    for (let i2 = 0;i2 < schema.anyOf.length; i2++)
      schema.anyOf[i2] = _replaceSchemaType(schema.anyOf[i2], options, config);
    return schema;
  }
  if (schema.allOf) {
    for (let i2 = 0;i2 < schema.allOf.length; i2++)
      schema.allOf[i2] = _replaceSchemaType(schema.allOf[i2], options, config);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, config);
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema, to = options.to(rest);
    if (!to)
      return schema;
    let transform2, composeProperties = (schema2) => {
      let v = _composeProperties(schema2);
      if (v.$id)
        delete v.$id;
      return v;
    }, _composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, { ...config, root: false });
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType(items, options, { ...config, root: false }) };
      let value = { ...rest, ...v };
      if (delete value.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform2 = t.ObjectString(properties2, rest), value.properties = properties2;
      else if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform2 = t.ArrayString(items, rest), value.items = items;
      return value;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
      return rest;
    }
    if (to.anyOf)
      for (let i2 = 0;i2 < to.anyOf.length; i2++)
        to.anyOf[i2] = composeProperties(to.anyOf[i2]);
    else if (to.oneOf)
      for (let i2 = 0;i2 < to.oneOf.length; i2++)
        to.oneOf[i2] = composeProperties(to.oneOf[i2]);
    else if (to.allOf)
      for (let i2 = 0;i2 < to.allOf.length; i2++)
        to.allOf[i2] = composeProperties(to.allOf[i2]);
    else if (to.not)
      to.not = composeProperties(to.not);
    if (transform2)
      to[TransformKind] = transform2[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value] of Object.entries(properties))
      switch (value[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not, type, ...rest } = value, to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i2 = 0;i2 < to.anyOf.length; i2++)
              to.anyOf[i2] = { ...rest, ...to.anyOf[i2] };
          else if (to.oneOf)
            for (let i2 = 0;i2 < to.oneOf.length; i2++)
              to.oneOf[i2] = { ...rest, ...to.oneOf[i2] };
          else if (to.allOf)
            for (let i2 = 0;i2 < to.allOf.length; i2++)
              to.allOf[i2] = { ...rest, ...to.allOf[i2] };
          else if (to.not)
            to.not = { ...rest, ...to.not };
          properties[key] = { ...rest, ..._replaceSchemaType(rest, options, { ...config, root: false }) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
          break;
        default:
          if (Array.isArray(value.items))
            for (let i2 = 0;i2 < value.items.length; i2++)
              value.items[i2] = _replaceSchemaType(value.items[i2], options, { ...config, root: false });
          else if (value.anyOf || value.oneOf || value.allOf || value.not)
            properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
          else if (value.type === "array")
            value.items = _replaceSchemaType(value.items, options, { ...config, root: false });
          break;
      }
  if (schema.type === "array" && schema.items)
    if (Array.isArray(schema.items))
      schema.items = schema.items.map((item) => _replaceSchemaType(item, options, { ...config, root: false }));
    else
      schema.items = _replaceSchemaType(schema.items, options, { ...config, root: false });
  return schema;
};
var createCleaner = (schema) => (value) => {
  if (typeof value === "object")
    try {
      return exports_value2.Clean(schema, value);
    } catch {}
  return value;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, modules, normalize = false, additionalProperties = false, forceAdditionalProperties = false, coerce = false, additionalCoerce = [], validators, sanitize: sanitize2 } = {}) => {
  if (validators = validators?.filter((x2) => x2), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let doesHaveRef = undefined, replaceSchema = (schema2) => {
    if (coerce)
      return replaceSchemaType(schema2, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    return replaceSchemaType(schema2, additionalCoerce);
  }, mapSchema = (s2) => {
    if (s2 && typeof s2 !== "string" && "~standard" in s2)
      return s2;
    if (!s2)
      return;
    let schema2;
    if (typeof s2 !== "string")
      schema2 = s2;
    else if (schema2 = modules && s2 in modules.$defs ? modules.Import(s2) : models[s2], !schema2)
      return;
    if (Kind in schema2) {
      if (schema2[Kind] === "Import") {
        if (!hasRef(schema2.$defs[schema2.$ref])) {
          if (schema2 = schema2.$defs[schema2.$ref], coerce || additionalCoerce)
            schema2 = replaceSchema(schema2);
        }
      } else if (hasRef(schema2)) {
        let id = randomId();
        schema2 = t.Module({ ...modules?.$defs, [id]: schema2 }).Import(id);
      } else if (coerce || additionalCoerce)
        schema2 = replaceSchema(schema2);
    }
    return schema2;
  }, schema = mapSchema(s), _validators = validators;
  if ("~standard" in schema || validators?.length && validators.some((x2) => x2 && typeof x2 !== "string" && ("~standard" in x2))) {
    let typeboxSubValidator = (schema2) => {
      let mirror2;
      if (normalize === true || normalize === "exactMirror")
        try {
          mirror2 = createMirror(schema2, { TypeCompiler, sanitize: sanitize2?.(), modules });
        } catch {
          console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema2), mirror2 = createCleaner(schema2);
        }
      let vali = getSchemaValidator(schema2, { models, modules, dynamic, normalize, additionalProperties: true, forceAdditionalProperties: true, coerce, additionalCoerce });
      return vali.Decode = mirror2, (v) => {
        if (vali.Check(v))
          return { value: vali.Decode(v) };
        else
          return { issues: [...vali.Errors(v)] };
      };
    }, mainCheck = schema["~standard"] ? schema["~standard"].validate : typeboxSubValidator(schema), checkers = [];
    if (validators?.length)
      for (let validator2 of validators) {
        if (!validator2)
          continue;
        if (typeof validator2 === "string")
          continue;
        if (validator2?.["~standard"]) {
          checkers.push(validator2["~standard"]);
          continue;
        }
        if (Kind in validator2) {
          checkers.push(typeboxSubValidator(validator2));
          continue;
        }
      }
    async function Check2(value) {
      let v = mainCheck(value);
      if (v instanceof Promise)
        v = await v;
      if (v.issues)
        return v;
      let values = [];
      if (v && typeof v === "object")
        values.push(v.value);
      for (let i2 = 0;i2 < checkers.length; i2++) {
        if (v = checkers[i2].validate(value), v instanceof Promise)
          v = await v;
        if (v.issues)
          return v;
        if (v && typeof v === "object")
          values.push(v.value);
      }
      if (!values.length)
        return { value: v };
      if (values.length === 1)
        return { value: values[0] };
      if (values.length === 2)
        return { value: mergeDeep(values[0], values[1]) };
      let newValue = mergeDeep(values[0], values[1]);
      for (let i2 = 2;i2 < values.length; i2++)
        newValue = mergeDeep(newValue, values[i2]);
      return { value: newValue };
    }
    let validator = { provider: "standard", schema, references: "", checkFunc: () => {}, code: "", Check: Check2, Errors: (value) => Check2(value)?.then?.((x2) => x2?.issues), Code: () => "", Decode: Check2, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
    return validator.parse = (v) => {
      try {
        return validator.Decode(validator.Clean?.(v) ?? v);
      } catch (error) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
      } catch (error) {
        let errors = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors[0]?.summary, errors };
      }
    }, validator;
  } else if (validators?.length) {
    let hasAdditional = false, validators2 = _validators, { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([schema, ...validators2.map(mapSchema)]);
    if (notObjects) {
      if (schema = t.Intersect([...mergedObjectSchema ? [mergedObjectSchema] : [], ...notObjects.map((x2) => {
        let schema2 = mapSchema(x2);
        if (schema2.type === "object" && "additionalProperties" in schema2) {
          if (!hasAdditional && schema2.additionalProperties === false)
            hasAdditional = true;
          delete schema2.additionalProperties;
        }
        return schema2;
      })]), schema.type === "object" && hasAdditional)
        schema.additionalProperties = false;
    }
  } else if (schema.type === "object" && (("additionalProperties" in schema) === false || forceAdditionalProperties))
    schema.additionalProperties = additionalProperties;
  else
    schema = replaceSchemaType(schema, { onlyFirst: "object", from: t.Object({}), to({ properties, ...options }) {
      if (!properties)
        return;
      if ("additionalProperties" in schema)
        return;
      return t.Object(properties, { ...options, additionalProperties: false });
    } });
  if (dynamic)
    if (Kind in schema) {
      let validator = { provider: "typebox", schema, references: "", checkFunc: () => {}, code: "", Check: (value) => exports_value2.Check(schema, value), Errors: (value) => exports_value2.Errors(schema, value), Code: () => "", Clean: createCleaner(schema), Decode: (value) => exports_value2.Decode(schema, value), Encode: (value) => exports_value2.Encode(schema, value), get hasAdditionalProperties() {
        if ("~hasAdditionalProperties" in this)
          return this["~hasAdditionalProperties"];
        return this["~hasAdditionalProperties"] = hasAdditionalProperties(schema);
      }, get hasDefault() {
        if ("~hasDefault" in this)
          return this["~hasDefault"];
        return this["~hasDefault"] = hasProperty("default", schema);
      }, get isOptional() {
        if ("~isOptional" in this)
          return this["~isOptional"];
        return this["~isOptional"] = isOptional(schema);
      }, get hasTransform() {
        if ("~hasTransform" in this)
          return this["~hasTransform"];
        return this["~hasTransform"] = hasTransform(schema);
      }, "~hasRef": doesHaveRef, get hasRef() {
        if ("~hasRef" in this)
          return this["~hasRef"];
        return this["~hasRef"] = hasTransform(schema);
      } };
      if (schema.config) {
        if (validator.config = schema.config, validator?.schema?.config)
          delete validator.schema.config;
      }
      if (normalize && schema.additionalProperties === false)
        if (normalize === true || normalize === "exactMirror")
          try {
            validator.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
          } catch {
            console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), validator.Clean = createCleaner(schema);
          }
        else
          validator.Clean = createCleaner(schema);
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    } else {
      let validator = { provider: "standard", schema, references: "", checkFunc: () => {}, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value) {
        let response = schema["~standard"].validate(value);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response.issues;
      }, Code: () => "", Decode(value) {
        let response = schema["~standard"].validate(value);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response;
      }, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    }
  let compiled;
  if (Kind in schema) {
    if (compiled = TypeCompiler.Compile(schema, Object.values(models).filter((x2) => (Kind in x2))), compiled.provider = "typebox", schema.config) {
      if (compiled.config = schema.config, compiled?.schema?.config)
        delete compiled.schema.config;
    }
    if (normalize === true || normalize === "exactMirror")
      try {
        compiled.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
      } catch (error) {
        console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.dir(schema, { depth: null }), compiled.Clean = createCleaner(schema);
      }
    else if (normalize === "typebox")
      compiled.Clean = createCleaner(schema);
  } else
    compiled = { provider: "standard", schema, references: "", checkFunc(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response.issues;
    }, Code: () => "", Decode(value) {
      let response = schema["~standard"].validate(value);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, Encode: (value) => value, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
  if (compiled.parse = (v) => {
    try {
      return compiled.Decode(compiled.Clean?.(v) ?? v);
    } catch (error) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(compiled.Clean?.(v) ?? v), error: null };
    } catch (error) {
      let errors = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors[0]?.summary, errors };
    }
  }, Kind in schema)
    Object.assign(compiled, { get hasAdditionalProperties() {
      if ("~hasAdditionalProperties" in this)
        return this["~hasAdditionalProperties"];
      return this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled);
    }, get hasDefault() {
      if ("~hasDefault" in this)
        return this["~hasDefault"];
      return this["~hasDefault"] = hasProperty("default", compiled);
    }, get isOptional() {
      if ("~isOptional" in this)
        return this["~isOptional"];
      return this["~isOptional"] = isOptional(compiled);
    }, get hasTransform() {
      if ("~hasTransform" in this)
        return this["~hasTransform"];
      return this["~hasTransform"] = hasTransform(schema);
    }, get hasRef() {
      if ("~hasRef" in this)
        return this["~hasRef"];
      return this["~hasRef"] = hasRef(schema);
    }, "~hasRef": doesHaveRef });
  return compiled;
};
var isUnion = (schema) => schema[Kind] === "Union" || !schema.schema && !!schema.anyOf;
var mergeObjectSchemas = (schemas) => {
  if (schemas.length === 0)
    return { schema: undefined, notObjects: [] };
  if (schemas.length === 1)
    return schemas[0].type === "object" ? { schema: schemas[0], notObjects: [] } : { schema: undefined, notObjects: schemas };
  let newSchema, notObjects = [], additionalPropertiesIsTrue = false, additionalPropertiesIsFalse = false;
  for (let schema of schemas) {
    if (schema.type !== "object") {
      notObjects.push(schema);
      continue;
    }
    if ("additionalProperties" in schema) {
      if (schema.additionalProperties === true)
        additionalPropertiesIsTrue = true;
      else if (schema.additionalProperties === false)
        additionalPropertiesIsFalse = true;
    }
    if (!newSchema) {
      newSchema = schema;
      continue;
    }
    newSchema = { ...newSchema, ...schema, properties: { ...newSchema.properties, ...schema.properties }, required: [...newSchema?.required ?? [], ...schema.required] };
  }
  if (newSchema) {
    if (newSchema.required)
      newSchema.required = [...new Set(newSchema.required)];
    if (additionalPropertiesIsFalse)
      newSchema.additionalProperties = false;
    else if (additionalPropertiesIsTrue)
      newSchema.additionalProperties = true;
  }
  return { schema: newSchema, notObjects };
};
var getResponseSchemaValidator = (s, { models = {}, modules, dynamic = false, normalize = false, additionalProperties = false, validators = [], sanitize: sanitize2 }) => {
  if (validators = validators.filter((x2) => x2), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let maybeSchemaOrRecord;
  if (typeof s !== "string")
    maybeSchemaOrRecord = s;
  else if (maybeSchemaOrRecord = modules && s in modules.$defs ? modules.Import(s) : models[s], !maybeSchemaOrRecord)
    return;
  if (!maybeSchemaOrRecord)
    return;
  if (Kind in maybeSchemaOrRecord || "~standard" in maybeSchemaOrRecord)
    return { 200: getSchemaValidator(maybeSchemaOrRecord, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[200]), sanitize: sanitize2 }) };
  let record = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status2) => {
    if (isNaN(+status2))
      return;
    let maybeNameOrSchema = maybeSchemaOrRecord[+status2];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        if (!schema)
          return;
        record[+status2] = Kind in schema || "~standard" in schema ? getSchemaValidator(schema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[+status2]), sanitize: sanitize2 }) : schema;
      }
      return;
    }
    record[+status2] = Kind in maybeNameOrSchema || "~standard" in maybeNameOrSchema ? getSchemaValidator(maybeNameOrSchema, { modules, models, additionalProperties, dynamic, normalize, coerce: false, additionalCoerce: [], validators: validators.map((x2) => x2[+status2]), sanitize: sanitize2 }) : maybeNameOrSchema;
  }), record;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _queryCoercions;
var queryCoercions = () => {
  if (!_queryCoercions)
    _queryCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayQuery(t.Any()) }];
  return _queryCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, modules, defaultConfig = {}, config, dynamic, normalize = false, models, validators, sanitize: sanitize2 }) => {
  let cookieValidator = validator?.provider ? validator : getSchemaValidator(validator, { modules, dynamic, models, normalize, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators, sanitize: sanitize2 });
  if (cookieValidator)
    cookieValidator.config = mergeCookie(cookieValidator.config, config);
  else
    cookieValidator = getSchemaValidator(t.Cookie(t.Any()), { modules, dynamic, models, additionalProperties: true, validators, sanitize: sanitize2 }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var unwrapImportSchema = (schema) => schema && schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object" ? schema.$defs[schema.$ref] : schema;
var allocateIf = (value, condition) => condition ? value : "";
var defaultParsers = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var createReport = ({ context = "c", trace = [], addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {};
      }, resolve() {} };
    };
  for (let i2 = 0;i2 < trace.length; i2++)
    addFn(`let report${i2},reportChild${i2},reportErr${i2},reportErrChild${i2};let trace${i2}=${context}[ELYSIA_TRACE]?.[${i2}]??trace[${i2}](${context});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i2 = 0;i2 < trace.length; i2++)
      addFn(`${reporter}${i2} = trace${i2}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return { resolve() {
      for (let i2 = 0;i2 < trace.length; i2++)
        addFn(`${reporter}${i2}.resolve()
`);
    }, resolveChild(name2) {
      for (let i2 = 0;i2 < trace.length; i2++)
        addFn(`${reporter}Child${i2}=${reporter}${i2}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i2 = 0;i2 < trace.length; i2++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i2}?.(${binding}) }else{${reporter}Child${i2}?.()}`);
          else
            addFn(`${reporter}Child${i2}?.()
`);
      };
    } };
  };
};
var composeCleaner = ({ schema, name, type, typeAlias = type, normalize, ignoreTryCatch = false }) => {
  if (!normalize || !schema.Clean)
    return "";
  if (normalize === true || normalize === "exactMirror") {
    if (ignoreTryCatch)
      return `${name}=validator.${typeAlias}.Clean(${name})
`;
    return `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}`;
  }
  if (normalize === "typebox")
    return `${name}=validator.${typeAlias}.Clean(${name})
`;
  return "";
};
var composeValidationFactory = ({ injectResponse = "", normalize = false, validator, encodeSchema = false, isStaticResponse = false, hasSanitize = false }) => ({ validate: (type, value = `c.${type}`, error) => `c.set.status=422;throw new ValidationError('${type}',validator.${type},${value}${error ? "," + error : ""})`, response: (name = "r") => {
  if (isStaticResponse || !validator.response)
    return "";
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}if(${name} instanceof Response === false)switch(c.set.status){`;
  for (let [status2, value] of Object.entries(validator.response)) {
    if (code += `
case ${status2}:
`, value.provider === "standard") {
      code += `let vare${status2}=validator.response[${status2}].Check(${name})
if(vare${status2} instanceof Promise)vare${status2}=await vare${status2}
if(vare${status2}.issues)throw new ValidationError('response',validator.response[${status2}],${name},vare${status2}.issues)
${name}=vare${status2}.value
c.set.status=${status2}
break
`;
      continue;
    }
    let noValidate = value.schema?.noValidate === true;
    if (!noValidate && value.schema?.$ref && value.schema?.$defs) {
      let refKey = value.schema.$ref, defKey = typeof refKey === "string" && refKey.includes("/") ? refKey.split("/").pop() : refKey;
      if (value.schema.$defs[defKey]?.noValidate === true)
        noValidate = true;
    }
    let appliedCleaner = noValidate || hasSanitize, clean2 = ({ ignoreTryCatch = false } = {}) => composeCleaner({ name, schema: value, type: "response", typeAlias: `response[${status2}]`, normalize, ignoreTryCatch });
    if (appliedCleaner)
      code += clean2();
    let applyErrorCleaner = !appliedCleaner && normalize && !noValidate;
    if (encodeSchema && value.hasTransform && !noValidate) {
      if (code += `try{${name}=validator.response[${status2}].Encode(${name})
`, !appliedCleaner)
        code += clean2({ ignoreTryCatch: true });
      code += `c.set.status=${status2}}catch{` + (applyErrorCleaner ? `try{
` + clean2({ ignoreTryCatch: true }) + `${name}=validator.response[${status2}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status2}],${name})}` : `throw new ValidationError('response',validator.response[${status2}],${name})`) + "}";
    } else {
      if (!appliedCleaner)
        code += clean2();
      if (!noValidate)
        code += `if(validator.response[${status2}].Check(${name})===false)throw new ValidationError('response',validator.response[${status2}],${name})
c.set.status=${status2}
`;
    }
    code += `break
`;
  }
  return code + "}";
} });
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.isAsync !== undefined)
    return v.isAsync;
  let fn = isObject2 ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal = fn.toString();
  if (matchResponseClone.test(literal)) {
    if (isObject2)
      v.isAsync = false;
    return false;
  }
  let result = matchFnReturn.test(literal);
  if (isObject2)
    v.isAsync = result;
  return result;
};
var hasReturn = (v) => {
  let isObject2 = typeof v === "object";
  if (isObject2 && v.hasReturn !== undefined)
    return v.hasReturn;
  let fnLiteral = isObject2 ? v.fn.toString() : typeof v === "string" ? v.toString() : v, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    if (isObject2)
      v.hasReturn = true;
    return true;
  }
  let result = fnLiteral.includes("return");
  if (isObject2)
    v.hasReturn = result;
  return result;
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var coerceTransformDecodeError = (fnLiteral, type, value = `c.${type}`) => `try{${fnLiteral}}catch(error){if(error.constructor.name === 'TransformDecodeError'){c.set.status=422
throw error.error ?? new ValidationError('${type}',validator.${type},${value})}}`;
var composeHandler = ({ app, path, method, hooks, validator, handler, allowMeta = false, inference }) => {
  let adapter = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} });
    let isResponse = handler instanceof Response || handler?.constructor?.name === "Response" && typeof handler?.clone === "function";
    if (hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
      if (isResponse)
        return Function("a", `"use strict";
return function(){return a.clone()}`)(handler);
      return Function("a", `"use strict";
return function(){return a}`)(handler);
    }
    if (isResponse) {
      let response = handler;
      handler = () => response.clone();
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasTrace = !!hooks.trace?.length, fnLiteral = "";
  if (inference = sucrose(Object.assign({ handler }, hooks), inference, app.config.sucrose), adapter.declare) {
    let literal = adapter.declare(inference);
    if (literal)
      fnLiteral += literal;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasValidation = !!validator.body || !!validator.headers || !!validator.params || !!validator.query || !!validator.cookie || !!validator.response, hasQuery = inference.query || !!validator.query, requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none", hasBody = method !== "" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody, defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || !!validator.headers || adapter.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieMeta = validator.cookie?.config ? mergeCookie(validator?.cookie?.config, app.config.cookie) : app.config.cookie, _encodeCookie = "", encodeCookie = () => {
    if (_encodeCookie)
      return _encodeCookie;
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
        _encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
      else
        for (let name of cookieMeta.sign)
          _encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')
`;
      _encodeCookie += `}
`;
    }
    return _encodeCookie;
  }, normalize = app.config.normalize, encodeSchema = app.config.encodeSchema, validation = composeValidationFactory({ normalize, validator, encodeSchema, isStaticResponse: handler instanceof Response, hasSanitize: !!app.config.sanitize });
  if (hasHeaders)
    fnLiteral += adapter.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get = (name, defaultValue) => {
      let value = cookieMeta?.[name] ?? defaultValue;
      if (!value)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value === "string")
        return `${name}:'${value}',`;
      if (value instanceof Date)
        return `${name}: new Date(${value.getTime()}),`;
      return `${name}:${value},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get("domain") + get("expires") + get("httpOnly") + get("maxAge") + get("path", "/") + get("priority") + get("sameSite") + get("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let arrayProperties = {}, objectProperties = {}, hasArrayProperty = false, hasObjectProperty = false;
    if (validator.query?.schema) {
      let schema = unwrapImportSchema(validator.query?.schema);
      if (Kind in schema && schema.properties)
        for (let [key, value] of Object.entries(schema.properties)) {
          if (hasElysiaMeta("ArrayQuery", value))
            arrayProperties[key] = 1, hasArrayProperty = true;
          if (hasElysiaMeta("ObjectString", value))
            objectProperties[key] = 1, hasObjectProperty = true;
        }
    }
    fnLiteral += `if(c.qi===-1){c.query=Object.create(null)}else{c.query=parseQueryFromURL(c.url,c.qi+1,${hasArrayProperty ? JSON.stringify(arrayProperties) : undefined},${hasObjectProperty ? JSON.stringify(objectProperties) : undefined})}`;
  }
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response=c.responseValue= " : "", responseKeys = Object.keys(validator.response ?? {}), hasMultipleResponses = responseKeys.length > 1, hasSingle200 = responseKeys.length === 0 || responseKeys.length === 1 && responseKeys[0] === "200", maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync) || validator.body?.provider === "standard" || validator.headers?.provider === "standard" || validator.query?.provider === "standard" || validator.params?.provider === "standard" || validator.cookie?.provider === "standard" || Object.values(validator.response ?? {}).find((x2) => x2.provider === "standard"), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || hasMultipleResponses || !hasSingle200 || isHandleFn && hasDefaultHeaders || maybeStream, _afterResponse, afterResponse = () => {
    if (_afterResponse !== undefined)
      return _afterResponse;
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "", prefix = hooks.afterResponse?.some(isAsync) ? "async " : "";
    afterResponse2 += `
setImmediate(${prefix}()=>{`;
    let reporter = createReport({ trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i2 = 0;i2 < hooks.afterResponse.length; i2++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i2].fn.name), prefix2 = isAsync(hooks.afterResponse[i2]) ? "await " : "";
        afterResponse2 += `
${prefix2}e.afterResponse[${i2}](c)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, _afterResponse = afterResponse2;
  }, mapResponse3 = (r = "r") => {
    let after = afterResponse(), response = `${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`;
    if (!after)
      return `return ${response}`;
    return `const _res=${response}` + after + "return _res";
  }, mapResponseContext = maybeStream || adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
  if (hasTrace || inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse?.length });
  if (hasBody) {
    let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    if (adapter.parser.declare)
      fnLiteral += adapter.parser.declare;
    fnLiteral += `
try{`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (!parser && validator.body && !hooks.parse?.length) {
      let schema = validator.body.schema;
      if (schema && schema.anyOf && schema[Kind] === "Union" && schema.anyOf?.length === 2 && schema.anyOf?.find((x2) => x2[Kind] === "ElysiaForm"))
        parser = "formdata";
    }
    if (parser && defaultParsers.includes(parser)) {
      let reporter = report("parse", { total: hooks.parse?.length }), isOptionalBody = !!validator.body?.isOptional;
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`, fnLiteral += `let contentType
if(c.request.body)`, fnLiteral += hasHeaders ? `contentType=c.headers['content-type']
` : `contentType=c.request.headers.get('content-type')
`;
      let hasDefaultParser = false;
      if (hooks.parse?.length)
        fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
      else {
        hasDefaultParser = true;
        let isOptionalBody = !!validator.body?.isOptional;
        fnLiteral += `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` + adapter.parser.json(isOptionalBody) + `break
case 120:` + adapter.parser.urlencoded(isOptionalBody) + `break
case 111:` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 114:` + adapter.parser.formData(isOptionalBody) + `break
default:if(contentType.charCodeAt(0)===116){` + adapter.parser.text(isOptionalBody) + `}break
}`;
      }
      let reporter = report("parse", { total: hooks.parse?.length });
      if (hooks.parse)
        for (let i2 = 0;i2 < hooks.parse.length; i2++) {
          let name = `bo${i2}`;
          if (i2 !== 0)
            fnLiteral += `
if(!used){`;
          if (typeof hooks.parse[i2].fn === "string") {
            let endUnit = reporter.resolveChild(hooks.parse[i2].fn), isOptionalBody = !!validator.body?.isOptional;
            switch (hooks.parse[i2].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true, fnLiteral += adapter.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true, fnLiteral += adapter.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true, fnLiteral += adapter.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true, fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true, fnLiteral += adapter.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `let ${name}=parser['${hooks.parse[i2].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
            }
            endUnit();
          } else {
            let endUnit = reporter.resolveChild(hooks.parse[i2].fn.name);
            fnLiteral += `let ${name}=e.parse[${i2}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
          }
          if (i2 !== 0)
            fnLiteral += "}";
          if (hasDefaultParser)
            break;
        }
      if (reporter.resolve(), !hasDefaultParser) {
        let isOptionalBody = !!validator.body?.isOptional;
        if (hooks.parse?.length)
          fnLiteral += `
if(!used){
`;
        fnLiteral += `switch(contentType){case 'application/json':
` + adapter.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse){` + mapResponse3(`bo${key}`) + `}if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse?.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
      if (hooks.parse?.length)
        fnLiteral += `
delete c.contentType`;
    }
    fnLiteral += "}catch(error){throw new ParseError(error)}";
  }
  if (parseReporter.resolve(), hooks?.transform || hasTrace) {
    let reporter = report("transform", { total: hooks.transform?.length });
    if (hooks.transform?.length) {
      fnLiteral += `let transformed
`;
      for (let i2 = 0;i2 < hooks.transform.length; i2++) {
        let transform2 = hooks.transform[i2], endUnit = reporter.resolveChild(transform2.fn.name);
        if (fnLiteral += isAsync(transform2) ? `transformed=await e.transform[${i2}](c)
` : `transformed=e.transform[${i2}](c)
`, transform2.subType === "mapDerive")
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
        else
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else Object.assign(c,transformed)
`;
        endUnit();
      }
    }
    reporter.resolve();
  }
  let fileUnions = [];
  if (validator) {
    if (validator.headers) {
      if (validator.headers.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.headers", schema: validator.headers, type: "headers", normalize }), validator.headers.isOptional)
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (validator.headers?.provider === "standard")
        fnLiteral += `let vah=validator.headers.Check(c.headers)
if(vah instanceof Promise)vah=await vah
if(vah.issues){` + validation.validate("headers", undefined, "vah.issues") + `}else{c.headers=vah.value}
`;
      else if (validator.headers?.schema?.noValidate !== true)
        fnLiteral += "if(validator.headers.Check(c.headers) === false){" + validation.validate("headers") + "}";
      if (validator.headers.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.headers=validator.headers.Decode(c.headers)
`, "headers");
      if (validator.headers.isOptional)
        fnLiteral += "}";
    }
    if (validator.params) {
      if (validator.params.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (validator.params.provider === "standard")
        fnLiteral += `let vap=validator.params.Check(c.params)
if(vap instanceof Promise)vap=await vap
if(vap.issues){` + validation.validate("params", undefined, "vap.issues") + `}else{c.params=vap.value}
`;
      else if (validator.params?.schema?.noValidate !== true)
        fnLiteral += "if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}";
      if (validator.params.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.params=validator.params.Decode(c.params)
`, "params");
    }
    if (validator.query) {
      if (Kind in validator.query?.schema && validator.query.hasDefault)
        for (let [key, value] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.query", schema: validator.query, type: "query", normalize }), validator.query.isOptional)
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (validator.query.provider === "standard")
        fnLiteral += `let vaq=validator.query.Check(c.query)
if(vaq instanceof Promise)vaq=await vaq
if(vaq.issues){` + validation.validate("query", undefined, "vaq.issues") + `}else{c.query=vaq.value}
`;
      else if (validator.query?.schema?.noValidate !== true)
        fnLiteral += "if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}";
      if (validator.query.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query"), fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query");
      if (validator.query.isOptional)
        fnLiteral += "}";
    }
    if (hasBody && validator.body) {
      if (validator.body.hasTransform || validator.body.isOptional)
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&(isNotEmpty(c.body)||c.body instanceof ArrayBuffer))
`;
      let hasUnion = isUnion(validator.body.schema), hasNonUnionFileWithDefault = false;
      if (validator.body.hasDefault) {
        let value = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" || unwrapImportSchema(validator.body.schema)[Kind] === "Object" ? {} : undefined), schema = unwrapImportSchema(validator.body.schema);
        if (!hasUnion && value && typeof value === "object" && (hasType("File", schema) || hasType("Files", schema))) {
          hasNonUnionFileWithDefault = true;
          for (let [k2, v] of Object.entries(value))
            if (v === "File" || v === "Files")
              delete value[k2];
          if (!isNotEmpty(value))
            value = undefined;
        }
        let parsed = typeof value === "object" ? JSON.stringify(value) : typeof value === "string" ? `'${value}'` : value;
        if (value !== undefined && value !== null)
          if (Array.isArray(value))
            fnLiteral += `if(!c.body)c.body=${parsed}
`;
          else if (typeof value === "object")
            fnLiteral += `c.body=Object.assign(${parsed},c.body)
`;
          else
            fnLiteral += `c.body=${parsed}
`;
        if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body.provider === "standard")
          fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
        else if (validator.body?.schema?.noValidate !== true)
          if (validator.body.isOptional)
            fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
          else
            fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      } else if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize }), validator.body.provider === "standard")
        fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
      else if (validator.body?.schema?.noValidate !== true)
        if (validator.body.isOptional)
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      if (validator.body.hasTransform)
        fnLiteral += coerceTransformDecodeError(`if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`, "body");
      if (hasUnion && validator.body.schema.anyOf?.length) {
        let iterator = Object.values(validator.body.schema.anyOf);
        for (let i2 = 0;i2 < iterator.length; i2++) {
          let type = iterator[i2];
          if (hasType("File", type) || hasType("Files", type)) {
            let candidate = getSchemaValidator(type, { modules: app.definitions.typebox, dynamic: !app.config.aot, models: app.definitions.type, normalize: app.config.normalize, additionalCoerce: coercePrimitiveRoot(), sanitize: () => app.config.sanitize });
            if (candidate) {
              let isFirst = fileUnions.length === 0, iterator2 = Object.entries(type.properties), validator2 = isFirst ? `
` : " else ";
              validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
              let validateFile2 = "", validatorLength = 0;
              for (let i22 = 0;i22 < iterator2.length; i22++) {
                let [k2, v] = iterator2[i22];
                if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
                  continue;
                if (validatorLength)
                  validateFile2 += ",";
                validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, validatorLength++;
              }
              if (validateFile2) {
                if (validatorLength === 1)
                  validator2 += `await ${validateFile2}
`;
                else if (validatorLength > 1)
                  validator2 += `await Promise.all([${validateFile2}])
`;
                validator2 += "}", fnLiteral += validator2, fileUnions.push(candidate);
              }
            }
          }
        }
      } else if (hasNonUnionFileWithDefault || !hasUnion && (hasType("File", unwrapImportSchema(validator.body.schema)) || hasType("Files", unwrapImportSchema(validator.body.schema)))) {
        let validateFile2 = "", i2 = 0;
        for (let [k2, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties)) {
          if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
            continue;
          if (i2)
            validateFile2 += ",";
          validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, i2++;
        }
        if (i2)
          fnLiteral += `
`;
        if (i2 === 1)
          fnLiteral += `await ${validateFile2}
`;
        else if (i2 > 1)
          fnLiteral += `await Promise.all([${validateFile2}])
`;
      }
    }
    if (validator.cookie) {
      if (validator.cookie.config = mergeCookie(validator.cookie.config, validator.cookie?.config ?? {}), fnLiteral += `let cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, validator.cookie.isOptional)
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (validator.cookie.provider === "standard")
        fnLiteral += `let vac=validator.cookie.Check(cookieValue)
if(vac instanceof Promise)vac=await vac
if(vac.issues){` + validation.validate("cookie", undefined, "vac.issues") + `}else{cookieValue=vac.value}
`, fnLiteral += `for(const k of Object.keys(cookieValue))c.cookie[k].value=cookieValue[k]
`;
      else if (validator.body?.schema?.noValidate !== true) {
        if (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + validation.validate("cookie", "cookieValue") + "}", validator.cookie.hasTransform)
          fnLiteral += coerceTransformDecodeError("for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue))){c.cookie[key].value=value}", "cookie");
      }
      if (validator.cookie.isOptional)
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle || hasTrace) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle?.length }), hasResolve = false;
    if (hooks.beforeHandle?.length)
      for (let i2 = 0;i2 < hooks.beforeHandle.length; i2++) {
        let beforeHandle = hooks.beforeHandle[i2], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
        if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
          if (!hasResolve)
            hasResolve = true, fnLiteral += `
let resolved
`;
          if (fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i2}](c);
` : `resolved=e.beforeHandle[${i2}](c);
`, beforeHandle.subType === "mapResolve")
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
          else
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else Object.assign(c, resolved)
`;
          endUnit();
        } else if (!returning)
          fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i2}](c)
` : `e.beforeHandle[${i2}](c)
`, endUnit();
        else {
          if (fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i2}](c)
` : `be=e.beforeHandle[${i2}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length || hasTrace) {
            report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
            let reporter2 = report("afterHandle", { total: hooks.afterHandle?.length });
            if (hooks.afterHandle?.length)
              for (let i22 = 0;i22 < hooks.afterHandle.length; i22++) {
                let hook = hooks.afterHandle[i22], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
                if (fnLiteral += `c.response=c.responseValue=be
`, !returning2)
                  fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i22}](c, be)
` : `e.afterHandle[${i22}](c, be)
`;
                else
                  fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i22}](c)
` : `af=e.afterHandle[${i22}](c)
`, fnLiteral += `if(af!==undefined) c.response=c.responseValue=be=af
`;
                endUnit2("af");
              }
            reporter2.resolve();
          }
          if (validator.response)
            fnLiteral += validation.response("be");
          let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
          if (hooks.mapResponse?.length) {
            fnLiteral += `c.response=c.responseValue=be
`;
            for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
              let mapResponse4 = hooks.mapResponse[i22], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
              fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i22}](c)
if(mr!==undefined)be=c.response=c.responseValue=mr}`, endUnit2();
            }
          }
          mapResponseReporter.resolve(), fnLiteral += afterResponse(), fnLiteral += encodeCookie(), fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
        }
      }
    reporter.resolve();
  }
  if (hooks.afterHandle?.length || hasTrace) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle?.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=c.responseValue=await ${handle}
` : `let r=c.response=c.responseValue=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle?.length });
    if (hooks.afterHandle?.length)
      for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
        let hook = hooks.afterHandle[i2], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
        if (!returning)
          fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c)
` : `e.afterHandle[${i2}](c)
`, endUnit();
        else if (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i2}](c)
` : `af=e.afterHandle[${i2}](c)
`, endUnit("af"), validator.response)
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += validation.response("af"), fnLiteral += "c.response=c.responseValue=af}";
        else
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=c.responseValue=af}";
      }
    if (reporter.resolve(), hooks.afterHandle?.length)
      fnLiteral += `r=c.response
`;
    if (validator.response)
      fnLiteral += validation.response();
    fnLiteral += encodeCookie();
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
    if (hooks.mapResponse?.length)
      for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
        let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr
`, endUnit();
      }
    mapResponseReporter.resolve(), fnLiteral += mapResponse3();
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse?.length || hasTrace) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response)
        fnLiteral += validation.response();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=c.responseValue=r
`;
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie(), handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else
        fnLiteral += mapResponse3();
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response=c.responseValue= r
`;
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie() + mapResponse3();
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else
        fnLiteral += mapResponse3(handled);
    }
  }
  if (fnLiteral += `
}catch(error){`, !maybeAsync && hooks.error?.length)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasCookie)
    fnLiteral += encodeCookie();
  if (hasTrace && hooks.trace)
    for (let i2 = 0;i2 < hooks.trace.length; i2++)
      fnLiteral += `report${i2}?.resolve(error);reportChild${i2}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error?.length });
  if (hooks.error?.length) {
    if (fnLiteral += `c.error=error
`, hasValidation)
      fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
    else
      fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
    if (fnLiteral += `let er
`, hooks.mapResponse?.length)
      fnLiteral += `let mep
`;
    for (let i2 = 0;i2 < hooks.error.length; i2++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i2].fn.name);
      if (isAsync(hooks.error[i2]))
        fnLiteral += `er=await e.error[${i2}](c)
`;
      else
        fnLiteral += `er=e.error[${i2}](c)
if(er instanceof Promise)er=await er
`;
      if (endUnit(), hooks.mapResponse?.length) {
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
        for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
          let mapResponse4 = hooks.mapResponse[i22], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `c.response=c.responseValue=er
mep=e.mapResponse[${i22}](c)
if(mep instanceof Promise)er=await er
if(mep!==undefined)er=mep
`, endUnit2();
        }
        mapResponseReporter.resolve();
      }
      if (fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace && hooks.trace) {
        for (let i22 = 0;i22 < hooks.trace.length; i22++)
          fnLiteral += `report${i22}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync && hooks.error?.length)
    fnLiteral += "})()";
  fnLiteral += "}";
  let adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", init = "const {handler,handleError,hooks:e, " + allocateIf("validator,", hasValidation) + "mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" + allocateIf("parseQuery,", hasBody) + allocateIf("parseQueryFromURL,", hasQuery) + "},error:{" + allocateIf("ValidationError,", hasValidation) + allocateIf("ParseError", hasBody) + "},fileType,schema,definitions,ERROR_CODE," + allocateIf("parseCookie,", hasCookie) + allocateIf("signCookie,", hasCookie) + allocateIf("decodeURIComponent,", hasQuery) + "ElysiaCustomStatusResponse," + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf("getServer,", inference.server) + allocateIf("fileUnions,", fileUnions.length) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle?.length)
    init += `let be
`;
  if (hooks.afterHandle?.length)
    init += `let af
`;
  if (hooks.mapResponse?.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema=schema
c.defs=definitions
`;
  fnLiteral = init + fnLiteral + "}", init = "";
  try {
    return Function("hooks", `"use strict";
` + fnLiteral)({ handler, hooks: lifeCycleToFn(hooks), validator: hasValidation ? validator : undefined, handleError: app.handleError, mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, isNotEmpty, utils: { parseQuery: hasBody ? parseQuery : undefined, parseQueryFromURL: hasQuery ? validator.query?.provider === "standard" ? parseQueryStandardSchema : parseQueryFromURL : undefined }, error: { ValidationError: hasValidation ? ValidationError : undefined, ParseError: hasBody ? ParseError2 : undefined }, fileType, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE, parseCookie: hasCookie ? parseCookie : undefined, signCookie: hasCookie ? signCookie : undefined, decodeURIComponent: hasQuery ? import_fast_decode_uri_component3.default : undefined, ElysiaCustomStatusResponse, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, getServer: inference.server ? () => app.getServer() : undefined, fileUnions: fileUnions.length ? fileUnions : undefined, TypeBoxError: hasValidation ? TypeBoxError : undefined, parser: app["~parser"], ...adapter.inject });
  } catch (error) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: fnLiteral, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x2) => x2.toString()), resolve: debugHooks?.resolve?.map?.((x2) => x2.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x2) => x2.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x2) => x2.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x2) => x2.toString()), parse: debugHooks?.parse?.map?.((x2) => x2.toString()), error: debugHooks?.error?.map?.((x2) => x2.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x2) => x2.toString()), stop: debugHooks?.stop?.map?.((x2) => x2.toString()) }, validator, definitions: app.definitions.type, error }), console.log("---"), process.exit(1);
  }
};
var createOnRequestHandler = (app, addFn) => {
  let fnLiteral = "", reporter = createReport({ trace: app.event.trace, addFn: addFn ?? ((word) => {
    fnLiteral += word;
  }) })("request", { total: app.event.request?.length });
  if (app.event.request?.length) {
    fnLiteral += "try{";
    for (let i2 = 0;i2 < app.event.request.length; i2++) {
      let hook = app.event.request[i2], withReturn = hasReturn(hook), maybeAsync = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i2].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i2}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i2}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  return reporter.resolve(), fnLiteral;
};
var createHoc = (app, fnName = "map") => {
  let hoc = app.extender.higherOrderFunctions;
  if (!hoc.length)
    return "return " + fnName;
  let adapter = app["~adapter"].composeGeneralHandler, handler = fnName;
  for (let i2 = 0;i2 < hoc.length; i2++)
    handler = `hoc[${i2}](${handler},${adapter.parameters})`;
  return `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
};
var composeGeneralHandler = (app) => {
  let adapter = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  let isWebstandard = app["~adapter"].isWebStandard, hasTrace = app.event.trace?.length, fnLiteral = "", router = app.router, findDynamicRoute = router.http.root.WS ? "const route=router.find(r.method==='GET'&&r.headers.get('upgrade')==='websocket'?'WS':r.method,p)" : "const route=router.find(r.method,p)";
  if (findDynamicRoute += router.http.root.ALL ? `??router.find('ALL',p)
` : `
`, isWebstandard)
    findDynamicRoute += `if(r.method==='HEAD'){const route=router.find('GET',p)
if(route){c.params=route.params
const _res=route.store.handler?route.store.handler(c):route.store.compile()(c)
if(_res)return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})}}`;
  let afterResponse = `c.error=notFound
`;
  if (app.event.afterResponse?.length && !app.event.error) {
    afterResponse = `
c.error=notFound
`;
    let prefix = app.event.afterResponse.some(isAsync) ? "async" : "";
    afterResponse += `
setImmediate(${prefix}()=>{`;
    for (let i2 = 0;i2 < app.event.afterResponse.length; i2++) {
      let fn2 = app.event.afterResponse[i2].fn;
      afterResponse += `
${isAsyncName(fn2) ? "await " : ""}afterResponse[${i2}](c)
`;
    }
    afterResponse += `})
`;
  }
  if (app.inference.query)
    afterResponse += `
if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}`;
  let error404 = adapter.error404(!!app.event.request?.length, !!app.event.error?.length, afterResponse);
  findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`;
  let switchMap = "";
  for (let [path, methods] of Object.entries(router.static)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    let encoded = encodePath(path);
    if (path !== encoded)
      switchMap += `case'${encoded}':`;
    if (switchMap += "switch(r.method){", "GET" in methods || "WS" in methods) {
      if (switchMap += "case 'GET':", "WS" in methods) {
        if (switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`, "GET" in methods === false)
          if ("ALL" in methods)
            switchMap += `return ht[${methods.ALL}].composed(c)
`;
          else
            switchMap += `break map
`;
      }
      if ("GET" in methods)
        switchMap += `return ht[${methods.GET}].composed(c)
`;
    }
    if (isWebstandard && (("GET" in methods) || ("ALL" in methods)) && "HEAD" in methods === false)
      switchMap += `case 'HEAD':const _res=ht[${methods.GET ?? methods.ALL}].composed(c)
return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})
`;
    for (let [method, index] of Object.entries(methods)) {
      if (method === "ALL" || method === "GET" || method === "WS")
        continue;
      switchMap += `case '${method}':return ht[${index}].composed(c)
`;
    }
    if ("ALL" in methods)
      switchMap += `default:return ht[${methods.ALL}].composed(c)
`;
    else
      switchMap += `default:break map
`;
    switchMap += "}";
  }
  let maybeAsync = !!app.event.request?.some(isAsync), adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,getResponseLength,` + allocateIf("parseQueryFromURL,", app.inference.query) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (app.event.afterResponse?.length)
    fnLiteral += `const afterResponse=app.event.afterResponse.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace?.length)
    fnLiteral += "const " + app.event.trace.map((_2, i2) => `tr${i2}=app.event.trace[${i2}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`, app.event.request?.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter.createContext(app), app.event.trace?.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_2, i2) => `tr${i2}(c)`).join(",") + `]
`;
  if (fnLiteral += createOnRequestHandler(app), switchMap)
    fnLiteral += `
map: switch(p){
` + switchMap + "}";
  fnLiteral += findDynamicRoute + `}
` + createHoc(app);
  let handleError = composeErrorHandler(app);
  app.handleError = handleError;
  let fn = Function("data", `"use strict";
` + fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError, randomId, handleError, status, redirect, getResponseLength, parseQueryFromURL: app.inference.query ? parseQueryFromURL : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
  if (isBun)
    Bun.gc(false);
  return fn;
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter = app["~adapter"].composeError, adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "", hasTrace = !!app.event.trace?.length;
  if (fnLiteral += "const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," + allocateIf("onError,", app.event.error) + allocateIf("afterResponse,", app.event.afterResponse) + allocateIf("trace,", app.event.trace) + allocateIf("onMapResponse,", app.event.mapResponse) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=inject
`, fnLiteral += `return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`, fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } }), afterResponse = () => {
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "", prefix = hooks.afterResponse?.some(isAsync) ? "async" : "";
    afterResponse2 += `
setImmediate(${prefix}()=>{`;
    let reporter = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length, name: "context" });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i2 = 0;i2 < hooks.afterResponse.length; i2++) {
        let fn = hooks.afterResponse[i2].fn, endUnit = reporter.resolveChild(fn.name);
        afterResponse2 += `
${isAsyncName(fn) ? "await " : ""}afterResponse[${i2}](context)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, afterResponse2;
  };
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter.declare)
    fnLiteral += adapter.declare;
  let saveResponse = hasTrace || !!hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i2 = 0;i2 < app.event.error.length; i2++) {
      let handler = app.event.error[i2], response = `${isAsync(handler) ? "await " : ""}onError[${i2}](context)
`;
      if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response){` + afterResponse() + `return mapResponse(_r,set${adapter.mapResponseContext})}if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
        if (hooks.mapResponse?.length)
          for (let i22 = 0;i22 < hooks.mapResponse.length; i22++) {
            let mapResponse3 = hooks.mapResponse[i22], endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
            fnLiteral += `context.response=context.responseValue=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i22}](context)
`, endUnit();
          }
        mapResponseReporter2.resolve(), fnLiteral += afterResponse() + `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` + afterResponse() + adapter.validationError + `
}
`, fnLiteral += "if(error instanceof Error){" + afterResponse() + `
if(typeof error.toResponse==='function')return context.response=context.responseValue=error.toResponse()
` + adapter.unknownError + `
}`;
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=context.responseValue=error.message??error
`, hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
      let mapResponse3 = hooks.mapResponse[i2], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
if(mr!==undefined)error=context.response=context.responseValue=mr}`, endUnit();
    }
  }
  mapResponseReporter.resolve(), fnLiteral += afterResponse() + `
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`;
  let mapFn = (x2) => typeof x2 === "function" ? x2 : x2.fn;
  return Function("inject", `"use strict";
` + fnLiteral)({ mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, onError: app.event.error?.map(mapFn), afterResponse: app.event.afterResponse?.map(mapFn), trace: app.event.trace?.map(mapFn), onMapResponse: app.event.mapResponse?.map(mapFn), ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter.inject });
};
var allocateIf2 = (value, condition) => condition ? value : "";
var createContext = (app, route, inference, isInline = false) => {
  let fnLiteral = "", defaultHeaders = app.setHeaders, hasTrace = !!app.event.trace?.length;
  if (hasTrace)
    fnLiteral += `const id=randomId()
`;
  let isDynamic = /[:*]/.test(route.path), getQi = `const u=request.url,s=u.indexOf('/',${app.config.handler?.standardHostname ?? true ? 11 : 7}),qi=u.indexOf('?', s + 1)
`, needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x2) => x2.query) || app.event.request?.length;
  if (needsQuery)
    fnLiteral += getQi;
  let getPath = !inference.path ? "" : !isDynamic ? `path:'${route.path}',` : "get path(){" + (needsQuery ? "" : getQi) + `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
  if (fnLiteral += allocateIf2("const c=", !isInline) + "{request,store," + allocateIf2("qi,", needsQuery) + allocateIf2("params:request.params,", isDynamic) + getPath + allocateIf2("url:request.url,", hasTrace || inference.url || needsQuery) + "redirect,status,set:{headers:" + (isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") + ",status:200}", inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  {
    let decoratorsLiteral = "";
    for (let key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,'${key}':decorator['${key}']`;
    fnLiteral += decoratorsLiteral;
  }
  return fnLiteral += `}
`, fnLiteral;
};
var createBunRouteHandler = (app, route) => {
  let hasTrace = !!app.event.trace?.length, hasHoc = !!app.extender.higherOrderFunctions.length, inference = sucrose(route.hooks, app.inference);
  inference = sucrose({ handler: route.handler }, inference);
  let fnLiteral = "const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," + allocateIf2("randomId=data.randomId,", hasTrace) + allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) + allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) + allocateIf2("trace=data.trace,", hasTrace) + allocateIf2("hoc=data.hoc,", hasHoc) + `status=data.status
`;
  if (app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`;
  let needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x2) => x2.query);
  if (hasTrace || needsQuery || app.event.request?.length)
    fnLiteral += createContext(app, route, inference), fnLiteral += createOnRequestHandler(app), fnLiteral += "return handler(c)}";
  else
    fnLiteral += `return handler(${createContext(app, route, inference, true)})}`;
  return fnLiteral += createHoc(app), Function("data", fnLiteral)({ app, handler: route.compile?.() ?? route.composed, redirect, status, hoc: app.extender.higherOrderFunctions.map((x2) => x2.fn), store: app.store, decorator: app.decorator, route: route.path, randomId: hasTrace ? randomId : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, trace: hasTrace ? app.event.trace?.map((x2) => x2?.fn ?? x2) : undefined, mapEarlyResponse: mapEarlyResponse2 });
};
var createNativeStaticHandler = (handle, hooks, set2) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  if (isHTMLBundle(handle))
    return () => handle;
  let response = mapResponse2(handle, set2 ?? { headers: {} });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
    if (response instanceof Promise)
      return response.then((response2) => {
        if (!response2)
          return;
        if (!response2.headers.has("content-type"))
          response2.headers.append("content-type", "text/plain");
        return response2.clone();
      });
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain");
    return () => response.clone();
  }
};
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  body;
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator, this.sendText = raw.sendText.bind(raw), this.sendBinary = raw.sendBinary.bind(raw), this.close = raw.close.bind(raw), this.terminate = raw.terminate.bind(raw), this.publishText = raw.publishText.bind(raw), this.publishBinary = raw.publishBinary.bind(raw), this.subscribe = raw.subscribe.bind(raw), this.unsubscribe = raw.unsubscribe.bind(raw), this.isSubscribed = raw.isSubscribed.bind(raw), this.cork = raw.cork.bind(raw), this.remoteAddress = raw.remoteAddress, this.binaryType = raw.binaryType, this.data = raw.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
}
var createWSMessageParser = (parse2) => {
  let parsers = typeof parse2 === "function" ? [parse2] : parse2;
  return async function(ws, message) {
    if (typeof message === "string") {
      let start = message?.charCodeAt(0);
      if (start === 34 || start === 47 || start === 91 || start === 123)
        try {
          message = JSON.parse(message);
        } catch {}
      else if (isNumericString(message))
        message = +message;
      else if (message === "true")
        message = true;
      else if (message === "false")
        message = false;
      else if (message === "null")
        message = null;
    }
    if (parsers)
      for (let i2 = 0;i2 < parsers.length; i2++) {
        let temp = parsers[i2](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first = await init;
        if (validateResponse?.Check(first) === false)
          return ws.send(new ValidationError("message", validateResponse, first).message);
        if (send(first.value), !first.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
  let match = optionalParam.exec(path);
  if (!match)
    return [path];
  let routes = [], head = path.slice(0, match.index), param = match[0].slice(0, -1), tail = path.slice(match.index + match[0].length);
  routes.push(head.slice(0, -1)), routes.push(head + param);
  for (let fragment of getPossibleParams(tail)) {
    if (!fragment)
      continue;
    if (!fragment.startsWith("/:"))
      routes.push(head.slice(0, -1) + fragment);
    routes.push(head + param + fragment);
  }
  return routes;
};
var isHTMLBundle = (handle) => {
  return typeof handle === "object" && handle !== null && (handle.toString() === "[object HTMLBundle]" || typeof handle.index === "string");
};
var supportedMethods = { GET: true, HEAD: true, OPTIONS: true, DELETE: true, PATCH: true, POST: true, PUT: true };
var mapRoutes = (app) => {
  if (!app.config.aot || !app.config.systemRouter)
    return;
  let routes = {}, add = (route, handler) => {
    let path = encodeURI(route.path);
    if (routes[path]) {
      if (!routes[path][route.method])
        routes[path][route.method] = handler;
    } else
      routes[path] = { [route.method]: handler };
  }, tree = app.routeTree;
  for (let route of app.router.history) {
    if (typeof route.handler !== "function")
      continue;
    let method = route.method;
    if (method === "GET" && `WS_${route.path}` in tree || method === "WS" || route.path.charCodeAt(route.path.length - 1) === 42 || !(method in supportedMethods))
      continue;
    if (method === "ALL") {
      if (!(`WS_${route.path}` in tree))
        routes[route.path] = route.hooks?.config?.mount ? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions ? createBunRouteHandler(app, route) : route.hooks.mount || route.handler : route.handler;
      continue;
    }
    let compiled, handler = app.config.precompile ? createBunRouteHandler(app, route) : (request) => {
      if (compiled)
        return compiled(request);
      return (compiled = createBunRouteHandler(app, route))(request);
    };
    for (let path of getPossibleParams(route.path))
      add({ method, path }, handler);
  }
  return routes;
};
var mergeRoutes = (r1, r2) => {
  if (!r2)
    return r1;
  for (let key of Object.keys(r2)) {
    if (r1[key] === r2[key])
      continue;
    if (!r1[key]) {
      r1[key] = r2[key];
      continue;
    }
    if (r1[key] && r2[key]) {
      if (typeof r1[key] === "function" || r1[key] instanceof Response) {
        r1[key] = r2[key];
        continue;
      }
      r1[key] = { ...r1[key], ...r2[key] };
    }
  }
  return r1;
};
var BunAdapter = { ...WebStandardAdapter, name: "bun", handler: { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2, mapCompactResponse: mapCompactResponse2, createStaticHandler: createStaticHandler2, createNativeStaticHandler }, composeHandler: { ...WebStandardAdapter.composeHandler, headers: hasHeaderShorthand ? `c.headers=c.request.headers.toJSON()
` : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun > "u")
      throw Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let createStaticRoute = (iterator, { withAsync = false } = {}) => {
      let staticRoutes = {}, ops = [];
      for (let [path, route] of Object.entries(iterator))
        if (path = encodeURI(path), supportPerMethodInlineHandler) {
          if (!route)
            continue;
          for (let [method, value] of Object.entries(route)) {
            if (!value || !(method in supportedMethods))
              continue;
            if (value instanceof Promise) {
              if (withAsync) {
                if (!staticRoutes[path])
                  staticRoutes[path] = {};
                ops.push(value.then((awaited) => {
                  if (awaited instanceof Response)
                    staticRoutes[path][method] = awaited;
                  if (isHTMLBundle(awaited))
                    staticRoutes[path][method] = awaited;
                }));
              }
              continue;
            }
            if (!(value instanceof Response) && !isHTMLBundle(value))
              continue;
            if (!staticRoutes[path])
              staticRoutes[path] = {};
            staticRoutes[path][method] = value;
          }
        } else {
          if (!route)
            continue;
          if (route instanceof Promise) {
            if (withAsync) {
              if (!staticRoutes[path])
                staticRoutes[path] = {};
              ops.push(route.then((awaited) => {
                if (awaited instanceof Response)
                  staticRoutes[path] = awaited;
              }));
            }
            continue;
          }
          if (!(route instanceof Response))
            continue;
          staticRoutes[path] = route;
        }
      if (withAsync)
        return Promise.all(ops).then(() => staticRoutes);
      return staticRoutes;
    }, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, ...options || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {}, ...options.websocket || {} }, fetch: app.fetch } : { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {} }, port: options, fetch: app.fetch };
    if (app.server = Bun.serve(serve), app.event.start)
      for (let i2 = 0;i2 < app.event.start.length; i2++)
        app.event.start[i2].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", () => {
      if (app.server) {
        if (app.server.stop?.(), app.server = null, app.event.stop)
          for (let i2 = 0;i2 < app.event.stop.length; i2++)
            app.event.stop[i2].fn(app);
      }
    }), app.promisedModules.then(async () => {
      app.server?.reload({ ...serve, fetch: app.fetch, routes: mergeRoutes(mergeRoutes(await createStaticRoute(app.router.response, { withAsync: true }), mapRoutes(app)), app.config.serve?.routes) }), Bun?.gc(false);
    });
  };
}, async stop(app, closeActiveConnections) {
  if (app.server) {
    if (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i2 = 0;i2 < app.event.stop.length; i2++)
        app.event.stop[i2].fn(app);
  } else
    console.log("Elysia isn't running. Call `app.listen` to start the server.", Error().stack);
}, ws(app, path, options) {
  let { parse: parse2, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("WS", path, async (context) => {
    let server = context.server ?? app.server, { set: set2, path: path2, qi, headers, query, params } = context;
    if (context.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set2.headers, options.upgrade);
    }
    if (set2.cookie && isNotEmpty(set2.cookie)) {
      let cookie = serializeCookie(set2.cookie);
      if (cookie)
        set2.headers["set-cookie"] = cookie;
    }
    if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
    let handleResponse3 = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse2), _id;
    if (typeof options.beforeHandle === "function") {
      let result = options.beforeHandle(context);
      if (result instanceof Promise)
        await result;
    }
    let errorHandlers = [...options.error ? Array.isArray(options.error) ? options.error : [options.error] : [], ...(app.event.error ?? []).map((x2) => typeof x2 === "function" ? x2 : x2.fn)].filter((x2) => x2), hasCustomErrorHandlers = errorHandlers.length > 0, handleErrors = !hasCustomErrorHandlers ? () => {} : async (ws, error) => {
      for (let handleError of errorHandlers) {
        let response2 = handleError(Object.assign(context, { error }));
        if (response2 instanceof Promise)
          response2 = await response2;
        if (await handleResponse3(ws, response2), response2)
          break;
      }
    };
    if (server?.upgrade(context.request, { headers: isNotEmpty(set2.headers) ? set2.headers : undefined, data: { ...context, get id() {
      if (_id)
        return _id;
      return _id = randomId();
    }, validator: validateResponse, ping(ws, data) {
      options.ping?.(ws, data);
    }, pong(ws, data) {
      options.pong?.(ws, data);
    }, open: async (ws) => {
      try {
        await handleResponse3(ws, options.open?.(new ElysiaWS(ws, context)));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false) {
        let validationError = new ValidationError("message", validateMessage, message);
        if (!hasCustomErrorHandlers)
          return void ws.send(validationError.message);
        return handleErrors(ws, validationError);
      }
      try {
        await handleResponse3(ws, options.message?.(new ElysiaWS(ws, context, message), message));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, drain: async (ws) => {
      try {
        await handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context)));
      } catch (error) {
        handleErrors(ws, error);
      }
    }, close: async (ws, code, reason) => {
      try {
        await handleResponse3(ws, options.close?.(new ElysiaWS(ws, context), code, reason));
      } catch (error) {
        handleErrors(ws, error);
      }
    } } }))
      return;
    return set2.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var env2 = isBun ? Bun.env : typeof process < "u" && process?.env ? process.env : {};
var injectDefaultValues = (typeChecker, obj) => {
  let schema = typeChecker.schema;
  if (!schema)
    return;
  if (schema.$defs?.[schema.$ref])
    schema = schema.$defs[schema.$ref];
  if (!schema?.properties)
    return;
  for (let [key, keySchema] of Object.entries(schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler, defaultHeader = app.setHeaders;
  return async (request) => {
    let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set2 = { cookie: {}, status: 200, headers: defaultHeader ? { ...defaultHeader } : {} }, context = Object.assign({}, app.singleton.decorator, { set: set2, store: app.singleton.store, request, path, qi, error: status, status, redirect });
    try {
      if (app.event.request)
        for (let i2 = 0;i2 < app.event.request.length; i2++) {
          let onRequest = app.event.request[i2].fn, response2 = onRequest(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 = mapEarlyResponse3(response2, set2), response2)
            return context.response = response2;
        }
      let methodKey = request.method === "GET" && request.headers.get("upgrade")?.toLowerCase() === "websocket" ? "WS" : request.method, handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find(methodKey, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), new NotFoundError;
      let { handle, hooks, validator, content, route } = handler.store, body;
      if (request.method !== "GET" && request.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value = form2.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        else {
          let contentType;
          if (request.body)
            contentType = request.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            if (context.contentType = contentType, hooks.parse)
              for (let i2 = 0;i2 < hooks.parse.length; i2++) {
                let hook = hooks.parse[i2].fn;
                if (typeof hook === "string")
                  switch (hook) {
                    case "json":
                    case "application/json":
                      body = await request.json();
                      break;
                    case "text":
                    case "text/plain":
                      body = await request.text();
                      break;
                    case "urlencoded":
                    case "application/x-www-form-urlencoded":
                      body = parseQuery(await request.text());
                      break;
                    case "arrayBuffer":
                    case "application/octet-stream":
                      body = await request.arrayBuffer();
                      break;
                    case "formdata":
                    case "multipart/form-data":
                      body = {};
                      let form2 = await request.formData();
                      for (let key of form2.keys()) {
                        if (body[key])
                          continue;
                        let value = form2.getAll(key);
                        if (value.length === 1)
                          body[key] = value[0];
                        else
                          body[key] = value;
                      }
                      break;
                    default:
                      let parser = app["~parser"][hook];
                      if (parser) {
                        let temp = parser(context, contentType);
                        if (temp instanceof Promise)
                          temp = await temp;
                        if (temp) {
                          body = temp;
                          break;
                        }
                      }
                      break;
                  }
                else {
                  let temp = hook(context, contentType);
                  if (temp instanceof Promise)
                    temp = await temp;
                  if (temp) {
                    body = temp;
                    break;
                  }
                }
              }
            if (delete context.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value = form2.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
          }
        }
      context.route = route, context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1)), context.headers = {};
      for (let [key, value] of request.headers.entries())
        context.headers[key] = value;
      let cookieMeta = { domain: app.config.cookie?.domain ?? validator?.cookie?.config.domain, expires: app.config.cookie?.expires ?? validator?.cookie?.config.expires, httpOnly: app.config.cookie?.httpOnly ?? validator?.cookie?.config.httpOnly, maxAge: app.config.cookie?.maxAge ?? validator?.cookie?.config.maxAge, path: app.config.cookie?.path ?? validator?.cookie?.config.path, priority: app.config.cookie?.priority ?? validator?.cookie?.config.priority, partitioned: app.config.cookie?.partitioned ?? validator?.cookie?.config.partitioned, sameSite: app.config.cookie?.sameSite ?? validator?.cookie?.config.sameSite, secure: app.config.cookie?.secure ?? validator?.cookie?.config.secure, secrets: app.config.cookie?.secrets ?? validator?.cookie?.config.secrets, sign: app.config.cookie?.sign ?? validator?.cookie?.config.sign }, cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context.query);
      if (hooks.transform)
        for (let i2 = 0;i2 < hooks.transform.length; i2++) {
          let hook = hooks.transform[i2], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "derive")
            Object.assign(context, response2);
        }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context.headers);
          for (let [key, value] of request.headers)
            _header[key] = value;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context.headers = validator.headers.Decode(context.headers);
        if (paramsValidator?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        else if (validator.params?.Decode)
          context.params = validator.params.Decode(context.params);
        if (validator.query?.schema) {
          let schema = validator.query.schema;
          if (schema.$defs?.[schema.$ref])
            schema = schema.$defs[schema.$ref];
          let properties = schema.properties;
          for (let property of Object.keys(properties)) {
            let value = properties[property];
            if ((value.type === "array" || value.items?.type === "string") && typeof context.query[property] === "string" && context.query[property])
              context.query[property] = context.query[property].split(",");
          }
        }
        if (queryValidator?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        else if (validator.query?.Decode)
          context.query = validator.query.Decode(context.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        else if (validator.body?.Decode)
          context.body = validator.body.Decode(body);
      }
      if (hooks.beforeHandle)
        for (let i2 = 0;i2 < hooks.beforeHandle.length; i2++) {
          let hook = hooks.beforeHandle[i2], response2 = hook.fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
          if (hook.subType === "resolve") {
            Object.assign(context, response2);
            continue;
          }
          if (response2 !== undefined) {
            if (context.response = response2, hooks.afterHandle)
              for (let i22 = 0;i22 < hooks.afterHandle.length; i22++) {
                let newResponse = hooks.afterHandle[i22].fn(context);
                if (newResponse instanceof Promise)
                  newResponse = await newResponse;
                if (newResponse)
                  response2 = newResponse;
              }
            let result = mapEarlyResponse3(response2, context.set);
            if (result)
              return context.response = result;
          }
        }
      let response = typeof handle === "function" ? handle(context) : handle;
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle?.length) {
        let isCustomStatuResponse = response instanceof ElysiaCustomStatusResponse, status2 = isCustomStatuResponse ? response.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200;
        if (isCustomStatuResponse)
          set2.status = status2, response = response.response;
        let responseValidator = validator?.createResponse?.()?.[status2];
        if (responseValidator?.Check(response) === false)
          if (responseValidator?.Clean) {
            let temp = responseValidator.Clean(response);
            if (responseValidator?.Check(temp) === false)
              throw new ValidationError("response", responseValidator, response);
            response = temp;
          } else
            throw new ValidationError("response", responseValidator, response);
        if (responseValidator?.Encode)
          response = responseValidator.Encode(response);
        if (responseValidator?.Clean)
          response = responseValidator.Clean(response);
      } else {
        context.response = response;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let response2 = hooks.afterHandle[i2].fn(context);
          if (response2 instanceof Promise)
            response2 = await response2;
          let isCustomStatuResponse = response2 instanceof ElysiaCustomStatusResponse, status2 = isCustomStatuResponse ? response2.code : set2.status ? typeof set2.status === "string" ? StatusMap[set2.status] : set2.status : 200;
          if (isCustomStatuResponse)
            set2.status = status2, response2 = response2.response;
          let responseValidator = validator?.createResponse?.()?.[status2];
          if (responseValidator?.Check(response2) === false)
            if (responseValidator?.Clean) {
              let temp = responseValidator.Clean(response2);
              if (responseValidator?.Check(temp) === false)
                throw new ValidationError("response", responseValidator, response2);
              response2 = temp;
            } else
              throw new ValidationError("response", responseValidator, response2);
          if (responseValidator?.Encode)
            context.response = response2 = responseValidator.Encode(response2);
          if (responseValidator?.Clean)
            context.response = response2 = responseValidator.Clean(response2);
          let result = mapEarlyResponse3(response2, context.set);
          if (result !== undefined)
            return context.response = result;
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true) {
          if (secret)
            for (let [key, cookie] of Object.entries(context.set.cookie))
              context.set.cookie[key].value = await signCookie(cookie.value, secret);
        } else {
          let properties = validator?.cookie?.schema?.properties;
          if (secret)
            for (let name of cookieMeta.sign) {
              if (!(name in properties))
                continue;
              if (context.set.cookie[name]?.value)
                context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
            }
        }
      }
      return mapResponse3(context.response = response, context.set);
    } catch (error) {
      let reportedError = error instanceof TransformDecodeError && error.error ? error.error : error;
      return app.handleError(context, reportedError);
    } finally {
      if (app.event.afterResponse)
        setImmediate(async () => {
          for (let afterResponse of app.event.afterResponse)
            await afterResponse.fn(context);
        });
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context, error) => {
    let errorContext = Object.assign(context, { error, code: error.code });
    if (errorContext.set = context.set, app.event.error)
      for (let i2 = 0;i2 < app.event.error.length; i2++) {
        let response = app.event.error[i2].fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== undefined && response !== null)
          return context.response = mapResponse3(response, context.set);
      }
    return new Response(typeof error.cause === "string" ? error.cause : error.message, { headers: context.set.headers, status: error.status ?? 500 });
  };
};

class Elysia {
  config;
  server = null;
  dependencies = {};
  "~Prefix" = "";
  "~Singleton" = null;
  "~Definitions" = null;
  "~Metadata" = null;
  "~Ephemeral" = null;
  "~Volatile" = null;
  "~Routes" = null;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t.Module({}), type: {}, error: {} };
  extender = { macro: {}, higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    if (!this.global && !this.scoped && !this.local)
      return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  standaloneValidator = { global: null, scoped: null, local: null };
  event = {};
  telemetry;
  router = { "~http": undefined, get http() {
    if (!this["~http"])
      this["~http"] = new _({ lazy: true, onParam: import_fast_decode_uri_component4.default });
    return this["~http"];
  }, "~dynamic": undefined, get dynamic() {
    if (!this["~dynamic"])
      this["~dynamic"] = new _({ onParam: import_fast_decode_uri_component4.default });
    return this["~dynamic"];
  }, static: {}, response: {}, history: [] };
  routeTree = {};
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getGlobalDefinitions() {
    return this.definitions;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, path: false, route: false, url: false };
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup(console.error, () => {});
    return this._promisedModules;
  }
  constructor(config = {}) {
    if (config.tags)
      if (!config.detail)
        config.detail = { tags: config.tags };
      else
        config.detail.tags = config.tags;
    if (this.config = { aot: env2.ELYSIA_AOT !== "false", nativeStaticResponse: true, systemRouter: true, encodeSchema: true, normalize: true, ...config, prefix: config.prefix ? config.prefix.charCodeAt(0) === 47 ? config.prefix : `/${config.prefix}` : undefined, cookie: { path: "/", ...config?.cookie }, experimental: config?.experimental ?? {}, seed: config?.seed === undefined ? "" : config?.seed }, this["~adapter"] = config.adapter ?? (typeof Bun < "u" ? BunAdapter : WebStandardAdapter), config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry = { stack: Error().stack };
  }
  "~adapter";
  env(model, _env = env2) {
    if (getSchemaValidator(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true, sanitize: () => this.config.sanitize }).Check(_env) === false) {
      let error = new ValidationError("env", model, _env);
      throw Error(error.all.map((x2) => x2.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, options) {
    let skipPrefix = options?.skipPrefix ?? false, allowMeta = options?.allowMeta ?? false;
    localHook ??= {}, this.applyMacro(localHook);
    let standaloneValidators = [];
    if (localHook.standaloneValidator)
      standaloneValidators = standaloneValidators.concat(localHook.standaloneValidator);
    if (this.standaloneValidator.local)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local);
    if (this.standaloneValidator.scoped)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped);
    if (this.standaloneValidator.global)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global);
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let instanceValidator = this.validator.getCandidate(), cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, createValidator = () => {
      let models = this.definitions.type, dynamic = !this.config.aot, normalize = this.config.normalize, modules = this.definitions.typebox, sanitize2 = () => this.config.sanitize, cookieValidator = () => {
        if (cloned.cookie || standaloneValidators.find((x2) => x2.cookie))
          return getCookieValidator({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, normalize, config: cloned.cookie?.config ?? {}, dynamic, models, validators: standaloneValidators.map((x2) => x2.cookie), sanitize: sanitize2 });
      };
      return shouldPrecompile ? { body: getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x2) => x2.body), sanitize: sanitize2 }), headers: getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.headers), sanitize: sanitize2 }), params: getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.params), sanitize: sanitize2 }), query: getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x2) => x2.query), sanitize: sanitize2 }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x2) => x2.response), sanitize: sanitize2 }) } : { createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator(cloned.body, { modules, dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x2) => x2.body), sanitize: sanitize2 });
      }, createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator(cloned.headers, { modules, dynamic, models, normalize, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.headers), sanitize: sanitize2 });
      }, createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator(cloned.params, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x2) => x2.params), sanitize: sanitize2 });
      }, createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator(cloned.query, { modules, dynamic, models, normalize, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x2) => x2.query), sanitize: sanitize2 });
      }, createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      }, createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize, validators: standaloneValidators.map((x2) => x2.response), sanitize: sanitize2 });
      } };
    };
    if (instanceValidator.body || instanceValidator.cookie || instanceValidator.headers || instanceValidator.params || instanceValidator.query || instanceValidator.response)
      localHook = mergeHook(localHook, instanceValidator);
    if (localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    let hooks = isNotEmpty(this.event) ? mergeHook(this.event, localHookToLifeCycleStore(localHook)) : { ...lifeCycleToArray(localHookToLifeCycleStore(localHook)) };
    if (standaloneValidators.length)
      Object.assign(hooks, { standaloneValidator: standaloneValidators });
    if (this.config.aot === false) {
      let validator = createValidator();
      this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle, route: path });
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.dynamic.add(method, encoded, { validator, hooks, content: localHook?.type, handle, route: path });
      if (this.config.strictPath === false) {
        let loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
        let encoded2 = encodePath(loosePath);
        if (loosePath !== encoded2)
          this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
      }
      this.router.history.push({ method, path, composed: null, handler: handle, compile: undefined, hooks });
      return;
    }
    let adapter = this["~adapter"].handler, nativeStaticHandler = typeof handle !== "function" ? () => {
      let context = { redirect, request: this["~adapter"].isWebStandard ? new Request(`http://e.ly${path}`, { method }) : undefined, server: null, set: { headers: Object.assign({}, this.setHeaders) }, status, store: this.store };
      try {
        this.event.request?.map((x2) => {
          if (typeof x2.fn === "function")
            return x2.fn(context);
          if (typeof x2 === "function")
            return x2(context);
        });
      } catch (error) {
        let res;
        if (context.error = error, this.event.error?.some((x2) => {
          if (typeof x2.fn === "function")
            return res = x2.fn(context);
          if (typeof x2 === "function")
            return res = x2(context);
        }), res !== undefined)
          handle = res;
      }
      let fn = adapter.createNativeStaticHandler?.(handle, hooks, context.set);
      return fn instanceof Promise ? fn.then((fn2) => {
        if (fn2)
          return fn2;
      }) : fn?.();
    } : undefined, useNativeStaticResponse = this.config.nativeStaticResponse === true, addResponsePath = (path2) => {
      if (!useNativeStaticResponse || !nativeStaticHandler)
        return;
      if (supportPerMethodInlineHandler)
        if (this.router.response[path2])
          this.router.response[path2][method] = nativeStaticHandler();
        else
          this.router.response[path2] = { [method]: nativeStaticHandler() };
      else
        this.router.response[path2] = nativeStaticHandler();
    };
    addResponsePath(path);
    let _compiled, compile2 = () => {
      if (_compiled)
        return _compiled;
      return _compiled = composeHandler({ app: this, path, method, hooks, validator: createValidator(), handler: typeof handle !== "function" && typeof adapter.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference: this.inference });
    }, oldIndex;
    if (`${method}_${path}` in this.routeTree)
      for (let i2 = 0;i2 < this.router.history.length; i2++) {
        let route = this.router.history[i2];
        if (route.path === path && route.method === method) {
          oldIndex = i2;
          break;
        }
      }
    else
      this.routeTree[`${method}_${path}`] = this.router.history.length;
    let index = oldIndex ?? this.router.history.length, mainHandler = shouldPrecompile ? compile2() : (ctx) => (this.router.history[index].composed = compile2())(ctx);
    if (oldIndex !== undefined)
      this.router.history[oldIndex] = Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, standaloneValidators.length ? { standaloneValidators } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined);
    else
      this.router.history.push(Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, localHook.webSocket ? { websocket: localHook.websocket } : undefined));
    let handler = { handler: shouldPrecompile ? mainHandler : undefined, compile() {
      return this.handler = compile2();
    } }, staticRouter = this.router.static, isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
    if (method === "WS") {
      if (isStaticPath) {
        if (path in staticRouter)
          staticRouter[path][method] = index;
        else
          staticRouter[path] = { [method]: index };
        return;
      }
      if (this.router.http.add("WS", path, handler), !this.config.strictPath)
        this.router.http.add("WS", getLoosePath(path), handler);
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add("WS", encoded, handler);
      return;
    }
    if (isStaticPath) {
      if (path in staticRouter)
        staticRouter[path][method] = index;
      else
        staticRouter[path] = { [method]: index };
      if (!this.config.strictPath)
        addResponsePath(getLoosePath(path));
    } else {
      if (this.router.http.add(method, path, handler), !this.config.strictPath) {
        let loosePath = getLoosePath(path);
        addResponsePath(loosePath), this.router.http.add(method, loosePath, handler);
      }
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add(method, encoded, handler), addResponsePath(encoded);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error) {
    switch (typeof name) {
      case "string":
        return error.prototype[ERROR_CODE] = name, this.definitions.error[name] = error, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error2] of Object.entries(name))
      error2.prototype[ERROR_CODE] = code, this.definitions.error[code] = error2;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type;
    switch (typeof optionsOrType) {
      case "string":
        type = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type === "resolve" || type === "derive")
        handle.subType = type;
    if (type !== "trace")
      this.inference = sucrose({ [type]: handles.map((x2) => x2.fn) }, this.inference, this.config.sucrose);
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type) {
        case "start":
          this.event.start ??= [], this.event.start.push(fn);
          break;
        case "request":
          this.event.request ??= [], this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse ??= [], this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform ??= [], this.event.transform.push(fn);
          break;
        case "derive":
          this.event.transform ??= [], this.event.transform.push(fnToContainer(fn, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fn);
          break;
        case "resolve":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fnToContainer(fn, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [], this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [], this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [], this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace ??= [], this.event.trace.push(fn);
          break;
        case "error":
          this.event.error ??= [], this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop ??= [], this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  as(type) {
    if (promoteEvent(this.event.parse, type), promoteEvent(this.event.transform, type), promoteEvent(this.event.beforeHandle, type), promoteEvent(this.event.afterHandle, type), promoteEvent(this.event.mapResponse, type), promoteEvent(this.event.afterResponse, type), promoteEvent(this.event.trace, type), promoteEvent(this.event.error, type), type === "scoped") {
      if (this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
    } else if (type === "global") {
      if (this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
      if (this.standaloneValidator.scoped !== null)
        this.standaloneValidator.global ||= [], this.standaloneValidator.global.push(...this.standaloneValidator.scoped), this.standaloneValidator.scoped = null;
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance["~parser"] = this["~parser"], instance.standaloneValidator = { local: [...this.standaloneValidator.local ?? []], scoped: [...this.standaloneValidator.scoped ?? []], global: [...this.standaloneValidator.global ?? []] };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix ?? "") + prefix + path, isSchema) {
        let { body, headers, query, params, cookie, response, ...hook } = schemaOrRun, localHook = hooks, hasStandaloneSchema = body || headers || query || params || cookie || response;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }), undefined);
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        if (this.applyMacro(hook), hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        let type = hook.as ?? "local";
        if (hook.schema === "standalone") {
          if (!this.standaloneValidator[type])
            this.standaloneValidator[type] = [];
          let response = !hook?.response ? undefined : typeof hook.response === "string" || (Kind in hook.response) || ("~standard" in hook.response) ? { 200: hook.response } : hook?.response;
          this.standaloneValidator[type].push({ body: hook.body, headers: hook.headers, params: hook.params, query: hook.query, response, cookie: hook.cookie });
        } else
          this.validator[type] = { body: hook.body ?? this.validator[type]?.body, headers: hook.headers ?? this.validator[type]?.headers, params: hook.params ?? this.validator[type]?.params, query: hook.query ?? this.validator[type]?.query, response: hook.response ?? this.validator[type]?.response, cookie: hook.cookie ?? this.validator[type]?.cookie };
        if (hook.parse)
          this.on({ as: type }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type }, "error", hook.error);
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance.getServer = () => this.getServer();
    let sandbox = run(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      let { body, headers, query, params, cookie, response, ...guardHook } = hook, hasStandaloneSchema = body || headers || query || params || cookie || response;
      this.add(method, path, handler, mergeHook(guardHook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox.event.error ?? []] : [localHook.error, ...sandbox.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }));
    }), this;
  }
  use(plugin) {
    if (!plugin)
      return this;
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "_Elysia")
          return this._use(plugin2.default);
        try {
          return this._use(plugin2.default);
        } catch (error) {
          throw console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'), error;
        }
      }).then((v) => {
        if (v && typeof v.compile === "function")
          v.compile();
        return v;
      })), this;
    return this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (let promise of plugin.promisedModules.promises)
      this.promisedModules.add(promise.then((v) => {
        if (!v)
          return;
        let t2 = this._use(v);
        if (t2 instanceof Promise)
          return t2.then((v2) => {
            if (v2)
              v2.compile();
            else
              v.compile();
          });
        return v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, hooks, undefined);
            if (plugin2 === this)
              return;
            return this.propagatePromiseModules(plugin2), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        })), this;
      return instance;
    }
    this.propagatePromiseModules(plugin);
    let name = plugin.config.name, seed = plugin.config.seed;
    if (plugin.getParent = () => this, plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin.standaloneValidator?.scoped)
      if (this.standaloneValidator.local)
        this.standaloneValidator.local = this.standaloneValidator.local.concat(plugin.standaloneValidator.scoped);
      else
        this.standaloneValidator.local = plugin.standaloneValidator.scoped;
    if (plugin.standaloneValidator?.global)
      if (this.standaloneValidator.global)
        this.standaloneValidator.global = this.standaloneValidator.global.concat(plugin.standaloneValidator.global);
      else
        this.standaloneValidator.global = plugin.standaloneValidator.global;
    if (isNotEmpty(plugin["~parser"]))
      this["~parser"] = { ...plugin["~parser"], ...this["~parser"] };
    if (plugin.setHeaders)
      this.headers(plugin.setHeaders);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro }, this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else {
      if (isNotEmpty(plugin.extender.macro))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
      if (plugin.extender.higherOrderFunctions.length)
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    }
    if (plugin.extender.higherOrderFunctions.length) {
      deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i2 = 0;i2 < this.extender.higherOrderFunctions.length; i2++) {
        let hof = this.extender.higherOrderFunctions[i2];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum))
            this.extender.higherOrderFunctions.splice(i2, 1), i2--;
          hofHashes.push(hof.checksum);
        }
      }
      hofHashes.length = 0;
    }
    if (this.inference = mergeInference(this.inference, plugin.inference), isNotEmpty(plugin.singleton.decorator))
      this.decorate(plugin.singleton.decorator);
    if (isNotEmpty(plugin.singleton.store))
      this.state(plugin.singleton.store);
    if (isNotEmpty(plugin.definitions.type))
      this.model(plugin.definitions.type);
    if (isNotEmpty(plugin.definitions.error))
      this.error(plugin.definitions.error);
    if (isNotEmpty(plugin.extender.macro))
      this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, hooks);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
        return this;
      if (this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry?.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform?.filter((x2) => x2?.subType === "derive").map((x2) => ({ fn: x2.toString(), stack: Error().stack ?? "" })), resolve: plugin.event.transform?.filter((x2) => x2?.subType === "resolve").map((x2) => ({ fn: x2.toString(), stack: Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies }), isNotEmpty(plugin.event))
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
    } else if (isNotEmpty(plugin.event))
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    if (plugin.validator.global)
      this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global });
    if (plugin.validator.scoped)
      this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped });
    return this;
  }
  macro(macroOrName, macro) {
    if (typeof macroOrName === "string" && !macro)
      throw Error("Macro function is required");
    if (typeof macroOrName === "string")
      this.extender.macro[macroOrName] = macro;
    else
      this.extender.macro = { ...this.extender.macro, ...macroOrName };
    return this;
  }
  applyMacro(localHook, appliable = localHook, { iteration = 0, applied = {} } = {}) {
    if (iteration >= 16)
      return;
    let macro = this.extender.macro;
    for (let [key, value] of Object.entries(appliable)) {
      if (key in macro === false)
        continue;
      let macroHook = typeof macro[key] === "function" ? macro[key](value) : macro[key];
      if (!macroHook || typeof macro[key] === "object" && value === false)
        return;
      let seed = checksum(key + JSON.stringify(macroHook.seed ?? value));
      if (seed in applied)
        continue;
      applied[seed] = true;
      for (let [k2, value2] of Object.entries(macroHook)) {
        if (k2 === "seed")
          continue;
        if (k2 in emptySchema) {
          insertStandaloneValidator(localHook, k2, value2), delete localHook[key];
          continue;
        }
        if (k2 === "detail") {
          if (!localHook.detail)
            localHook.detail = {};
          localHook.detail = mergeDeep(localHook.detail, value2, { mergeArray: true }), delete localHook[key];
          continue;
        }
        if (k2 in macro) {
          this.applyMacro(localHook, { [k2]: value2 }, { applied, iteration: iteration + 1 }), delete localHook[key];
          continue;
        }
        if ((k2 === "derive" || k2 === "resolve") && typeof value2 === "function")
          value2 = { fn: value2, subType: k2 };
        switch (typeof localHook[k2]) {
          case "function":
            localHook[k2] = [localHook[k2], value2];
            break;
          case "object":
            if (Array.isArray(localHook[k2]))
              localHook[k2].push(value2);
            else
              localHook[k2] = [localHook[k2], value2];
            break;
          case "undefined":
            localHook[k2] = value2;
            break;
        }
        delete localHook[key];
      }
    }
  }
  mount(path, handleOrConfig, config) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
        throw Error("Invalid handler");
      })(), handler2 = ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
      return this.route("ALL", "/*", handler2, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: run } }), this;
    }
    let handle = handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
      throw Error("Invalid handler");
    })(), length = path.length - (path.endsWith("*") ? 1 : 0), handler = ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), { method: request.method, headers: request.headers, signal: request.signal, credentials: request.credentials, referrerPolicy: request.referrerPolicy, duplex: request.duplex, redirect: request.redirect, mode: request.mode, keepalive: request.keepalive, integrity: request.integrity, body: request.body }));
    return this.route("ALL", path, handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, { parse: "none", ...config, detail: { ...config?.detail, hide: true }, config: { mount: handle } }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (!value || !isNotEmpty(value))
          return this;
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, { override: as === "override" });
          else
            this.singleton.store[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value;
        } else
          this.singleton.store = value(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value;
        return this;
    }
  }
  decorate(options, name, value) {
    if (name === undefined)
      value = options, options = { as: "append" }, name = "";
    else if (value === undefined) {
      if (typeof options === "string")
        value = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, { override: as === "override" });
          else
            this.singleton.decorator[name] = value;
          return this;
        }
        if (value === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value;
        } else
          this.singleton.decorator = value(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value;
        return this;
    }
  }
  derive(optionsOrTransform, transform2) {
    if (!transform2)
      transform2 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform2 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    let onlyTypebox = (a) => {
      let res = {};
      for (let key in a)
        if (!("~standard" in a[key]))
          res[key] = a[key];
      return res;
    };
    switch (typeof name) {
      case "object":
        let parsedTypebox = {}, kvs = Object.entries(name);
        if (!kvs.length)
          return this;
        for (let [key, value] of kvs) {
          if (key in this.definitions.type)
            continue;
          if ("~standard" in value)
            this.definitions.type[key] = value;
          else
            parsedTypebox[key] = this.definitions.type[key] = value, parsedTypebox[key].$id ??= `#/components/schemas/${key}`;
        }
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...parsedTypebox }), this;
      case "function":
        let result = name(this.definitions.type);
        return this.definitions.type = result, this.definitions.typebox = t.Module(onlyTypebox(result)), this;
      case "string":
        if (!model)
          break;
        if (this.definitions.type[name] = model, "~standard" in model)
          return this;
        let newModel = { ...model, id: model.$id ?? `#/components/schemas/${name}` };
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...newModel }), this;
    }
    if (!model)
      return this;
    if (this.definitions.type[name] = model, "~standard" in model)
      return this;
    return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  Ref(key) {
    return t.Ref(key);
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix), remap = (type2) => {
      let store = {};
      switch (type2) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type) ? type : [type];
    for (let type2 of types.some((x2) => x2 === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type2);
    return this;
  }
  prefix(type, word) {
    return this.affix("prefix", type, word);
  }
  suffix(type, word) {
    return this.affix("suffix", type, word);
  }
  compile() {
    if (this["~adapter"].beforeCompile?.(this), this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler(this), this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
  };
  handleError = async (context, error) => {
    return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error);
  };
  listen = (options, callback) => {
    return this["~adapter"].listen(this)(options, callback), this;
  };
  stop = async (closeActiveConnections) => {
    return await this["~adapter"].stop?.(this, closeActiveConnections), this;
  };
  [Symbol.dispose] = () => {
    if (this.server)
      this.stop();
  };
  get modules() {
    return this.promisedModules;
  }
}

// node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom;i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}
class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumObjectColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumObjectColumn");
    this.config.enum = enumInstance;
  }
  build(table) {
    return new PgEnumObjectColumn(table, this.config);
  }
}

class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}

class PgEnumColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  build(table) {
    return new PgEnumColumn(table, this.config);
  }
}

class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
function pgEnum(enumName, input) {
  return Array.isArray(input) ? pgEnumWithSchema(enumName, [...input], undefined) : pgEnumObjectWithSchema(enumName, input, undefined);
}
function pgEnumWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name ?? "", enumInstance), {
    enumName,
    enumValues: values,
    schema,
    [isPgEnumSym]: true
  });
  return enumInstance;
}
function pgEnumObjectWithSchema(enumName, values, schema) {
  const enumInstance = Object.assign((name) => new PgEnumObjectColumnBuilder(name ?? "", enumInstance), {
    enumName,
    enumValues: Object.values(values),
    schema,
    [isPgEnumSym]: true
  });
  return enumInstance;
}

// node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/version.js
var version = "0.44.6";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function isTable(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p] of chunk.entries()) {
          result.push(p);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder2 = noopEncoder) {
    this.value = value;
    this.encoder = encoder2;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder2) {
    return new Param(value, encoder2);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
function isView(view) {
  return typeof view === "object" && view !== null && IsDrizzleView in view;
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getViewSelectedFields(view) {
  return view[ViewBaseConfig].selectedFields;
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}
var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder;

// node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config) {
    super(name, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date2(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}

// node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x2), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x2), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i2 = 0;i2 < 8; i2++) {
    view.setUint8(i2, bytes[offset + i2]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x2 = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x2, y];
  }
  throw new Error("Unsupported geometry type");
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config) {
    super(name, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date: date2,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max2) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max2, column)}`;
}
function notBetween(column, min, max2) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max2, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/postgres/src/index.js
import os from "os";
import fs from "fs";

// node_modules/postgres/src/query.js
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve, reject;
    super((a, b) => {
      resolve = a;
      reject = b;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x2) => (this.active = false, resolve(x2));
    this.reject = (x2) => (this.active = false, reject(x2));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise = new Promise((resolve, reject) => {
            this.cursorFn = (value) => {
              resolve({ value, done: false });
              return new Promise((r) => prev = r);
            };
            this.resolve = () => (this.active = false, resolve({ done: true }));
            this.reject = (x2) => (this.active = false, reject(x2));
          });
          this.execute();
          return promise;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x2;
  return originCache.get(xs);
}

// node_modules/postgres/src/errors.js
class PostgresError extends Error {
  constructor(x2) {
    super(x2.message);
    this.name = this.constructor.name;
    Object.assign(this, x2);
  }
}
var Errors2 = {
  connection,
  postgres,
  generic,
  notSupported
};
function connection(x2, options, socket) {
  const { host, port } = socket || options;
  const error = Object.assign(new Error("write " + x2 + " " + (options.path || host + ":" + port)), {
    code: x2,
    errno: x2,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error, connection);
  return error;
}
function postgres(x2) {
  const error = new PostgresError(x2);
  Error.captureStackTrace(error, postgres);
  return error;
}
function generic(code, message) {
  const error = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error, generic);
  return error;
}
function notSupported(x2) {
  const error = Object.assign(new Error(x2 + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x2
  });
  Error.captureStackTrace(error, notSupported);
  return error;
}

// node_modules/postgres/src/types.js
var types = {
  string: {
    to: 25,
    from: null,
    serialize: (x2) => "" + x2
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x2) => "" + x2,
    parse: (x2) => +x2
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x2) => JSON.stringify(x2),
    parse: (x2) => JSON.parse(x2)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x2) => x2 === true ? "t" : "f",
    parse: (x2) => x2 === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x2) => (x2 instanceof Date ? x2 : new Date(x2)).toISOString(),
    parse: (x2) => new Date(x2)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x2) => "\\x" + Buffer.from(x2).toString("hex"),
    parse: (x2) => Buffer.from(x2.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier2 extends NotTagged {
  constructor(value) {
    super();
    this.value = escapeIdentifier(value);
  }
}

class Parameter extends NotTagged {
  constructor(value, type, array) {
    super();
    this.value = value;
    this.type = type;
    this.array = array;
  }
}

class Builder extends NotTagged {
  constructor(first, rest) {
    super();
    this.first = first;
    this.rest = rest;
  }
  build(before, parameters, types2, options) {
    const keyword = builders.map(([x2, fn]) => ({ fn, i: before.search(x2) })).sort((a, b) => a.i - b.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types2, options);
  }
}
function handleValue(x2, parameters, types2, options) {
  let value = x2 instanceof Parameter ? x2.value : x2;
  if (value === undefined) {
    x2 instanceof Parameter ? x2.value = options.transform.undefined : value = x2 = options.transform.undefined;
    if (value === undefined)
      throw Errors2.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types2.push(x2 instanceof Parameter ? (parameters.push(x2.value), x2.array ? x2.array[x2.type || inferType(x2.value)] || x2.type || firstIsString(x2.value) : x2.type) : (parameters.push(x2), inferType(x2)));
}
var defaultHandlers = typeHandlers(types);
function stringify(q, string, value, parameters, types2, options) {
  for (let i2 = 1;i2 < q.strings.length; i2++) {
    string += stringifyValue(string, value, parameters, types2, options) + q.strings[i2];
    value = q.args[i2];
  }
  return string;
}
function stringifyValue(string, value, parameters, types2, o) {
  return value instanceof Builder ? value.build(string, parameters, types2, o) : value instanceof Query ? fragment(value, parameters, types2, o) : value instanceof Identifier2 ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x2) => acc + " " + fragment(x2, parameters, types2, o), "") : handleValue(value, parameters, types2, o);
}
function fragment(q, parameters, types2, options) {
  q.fragment = true;
  return stringify(q, q.strings[0], q.args[0], parameters, types2, options);
}
function valuesBuilder(first, parameters, types2, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue("values", row[column], parameters, types2, options)).join(",") + ")").join(",");
}
function values(first, rest, parameters, types2, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types2, columns, options);
}
function select(first, rest, parameters, types2, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns = rest.length ? rest.flat() : Object.keys(first);
  return columns.map((x2) => {
    value = first[x2];
    return (value instanceof Query ? fragment(value, parameters, types2, options) : value instanceof Identifier2 ? value.value : handleValue(value, parameters, types2, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x2) : x2);
  }).join(",");
}
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x2 = values(...xs);
    return x2 === "()" ? "(null)" : x2;
  },
  select,
  as: select,
  returning: select,
  "\\(": select,
  update(first, rest, parameters, types2, options) {
    return (rest.length ? rest.flat() : Object.keys(first)).map((x2) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x2) : x2) + "=" + stringifyValue("values", first[x2], parameters, types2, options));
  },
  insert(first, rest, parameters, types2, options) {
    const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types2, columns, options);
  }
}).map(([x2, fn]) => [new RegExp("((?:^|[\\s(])" + x2 + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
function notTagged() {
  throw Errors2.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
function firstIsString(x2) {
  if (Array.isArray(x2))
    return firstIsString(x2[0]);
  return typeof x2 === "string" ? 1009 : 0;
}
var mergeUserTypes = function(types2) {
  const user = typeHandlers(types2 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
function typeHandlers(types2) {
  return Object.keys(types2).reduce((acc, k2) => {
    types2[k2].from && [].concat(types2[k2].from).forEach((x2) => acc.parsers[x2] = types2[k2].parse);
    if (types2[k2].serialize) {
      acc.serializers[types2[k2].to] = types2[k2].serialize;
      types2[k2].from && [].concat(types2[k2].from).forEach((x2) => acc.serializers[x2] = types2[k2].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column } }) {
  return xs.map((x2) => escapeIdentifier(column.to ? column.to(x2) : x2)).join(",");
}
var escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x2) {
  return x2 instanceof Parameter ? x2.type : x2 instanceof Date ? 1184 : x2 instanceof Uint8Array ? 17 : x2 === true || x2 === false ? 16 : typeof x2 === "bigint" ? 20 : Array.isArray(x2) ? inferType2(x2[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
function arrayEscape(x2) {
  return x2.replace(escapeBackslash, "\\\\").replace(escapeQuote, "\\\"");
}
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x2) => arraySerializer2(x2, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x2) => {
    if (x2 === undefined) {
      x2 = options.transform.undefined;
      if (x2 === undefined)
        throw Errors2.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x2 === null ? "null" : '"' + arrayEscape(serializer ? serializer(x2.type ? x2.value : x2) : "" + x2) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x2, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x2, parser, typarray);
};
function arrayParserLoop(s, x2, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x2.length; s.i++) {
    s.char = x2[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x2[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x2[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x2, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i + 1)) : x2.slice(s.last, s.i + 1));
  return xs;
}
var toCamel = (x2) => {
  let str = x2[0];
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
};
var toPascal = (x2) => {
  let str = x2[0].toUpperCase();
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
};
var toKebab = (x2) => x2.replace(/_/g, "-");
var fromCamel = (x2) => x2.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x2) => (x2.slice(0, 1) + x2.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x2) => x2.replace(/-/g, "_");
function createJsonTransform(fn) {
  return function jsonTransform(x2, column) {
    return typeof x2 === "object" && x2 !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x2) ? x2.map((x3) => jsonTransform(x3, column)) : Object.entries(x2).reduce((acc, [k2, v]) => Object.assign(acc, { [fn(k2)]: jsonTransform(v, column) }), {}) : x2;
  };
}
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import { performance as performance2 } from "perf_hooks";

// node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// node_modules/postgres/src/queue.js
var queue_default = Queue;
function Queue(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x2) => {
      const index2 = xs.indexOf(x2);
      return index2 === -1 ? null : (xs.splice(index2, 1), x2);
    },
    push: (x2) => (xs.push(x2), x2),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
}

// node_modules/postgres/src/bytes.js
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x2) => {
  const v = x2.charCodeAt(0);
  acc[x2] = () => {
    buffer[0] = v;
    b.i = 5;
    return b;
  };
  return acc;
}, {});
var b = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x2) {
    b.i += x2;
    return b;
  },
  str(x2) {
    const length = Buffer.byteLength(x2);
    fit(length);
    b.i += buffer.write(x2, b.i, length, "utf8");
    return b;
  },
  i16(x2) {
    fit(2);
    buffer.writeUInt16BE(x2, b.i);
    b.i += 2;
    return b;
  },
  i32(x2, i2) {
    if (i2 || i2 === 0) {
      buffer.writeUInt32BE(x2, i2);
      return b;
    }
    fit(4);
    buffer.writeUInt32BE(x2, b.i);
    b.i += 4;
    return b;
  },
  z(x2) {
    fit(x2);
    buffer.fill(0, b.i, b.i + x2);
    b.i += x2;
    return b;
  },
  raw(x2) {
    buffer = Buffer.concat([buffer.subarray(0, b.i), x2]);
    b.i = buffer.length;
    return b;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b.i - at, at);
    const out = buffer.subarray(0, b.i);
    b.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b;
function fit(x2) {
  if (buffer.length - b.i < x2) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x2);
    prev.copy(buffer);
  }
}
function reset() {
  b.i = 0;
  return b;
}

// node_modules/postgres/src/connection.js
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};
function Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max: max2,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform: transform2,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query2) {
      initial = query2;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x2;
    try {
      x2 = options.socket ? await Promise.resolve(options.socket(options)) : new net.Socket;
    } catch (e) {
      error(e);
      return;
    }
    x2.on("error", error);
    x2.on("close", closed);
    x2.on("drain", drain);
    return x2;
  }
  async function cancel({ pid, secret }, resolve, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve);
    } catch (error2) {
      reject(error2);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors2.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query ? sent.push(q) : (query = q, query.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error2) {
      sent.length === 0 && write(Sync);
      errored(error2);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors2.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse2(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse2(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types2 = [];
    const string = stringify(q, q.strings[0], q.args[0], parameters, types2, options);
    !q.tagged && q.args.forEach((x2) => handleValue(x2, parameters, types2, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types2 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types2, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types2);
  }
  function write(x2, fn) {
    chunk = chunk ? Buffer.concat([chunk, x2]) : Buffer.from(x2);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x2 = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x2;
  }
  function connectTimedOut() {
    errored(Errors2.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x2) => r(x2[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query && onopen(connection2);
  }
  function data(x2) {
    if (incomings) {
      incomings.push(x2);
      remaining -= x2.length;
      if (remaining > 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x2 : Buffer.concat([incoming, x2], incoming.length + x2.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query && (query.cursorFn || query.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance2.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err2) {
      error(err2);
    }
  }
  function error(err2) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err2);
    while (sent.length)
      queryError(sent.shift(), err2);
  }
  function errored(err2) {
    stream && (stream.destroy(err2), stream = null);
    query && queryError(query, err2);
    initial && (queryError(initial, err2), initial = null);
  }
  function queryError(query2, err2) {
    if (query2.reserve)
      return query2.reject(err2);
    if (!err2 || typeof err2 !== "object")
      err2 = new Error(err2);
    "query" in err2 || "parameters" in err2 || Object.defineProperties(err2, {
      stack: { value: err2.stack + query2.origin.replace(/.*\n/, `
`), enumerable: options.debug },
      query: { value: query2.string, enumerable: options.debug },
      parameters: { value: query2.parameters, enumerable: options.debug },
      args: { value: query2.args, enumerable: options.debug },
      types: { value: query2.statement && query2.statement.types, enumerable: options.debug }
    });
    query2.reject(err2);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query || initial || sent.length)
      error(Errors2.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    socket.removeAllListeners();
    socket = null;
    if (initial)
      return reconnect();
    !hadError && (query || sent.length) && error(Errors2.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance2.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors2.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x2 = xs[0]) {
    (x2 === 68 ? DataRow : x2 === 100 ? CopyData : x2 === 65 ? NotificationResponse : x2 === 83 ? ParameterStatus : x2 === 90 ? ReadyForQuery : x2 === 67 ? CommandComplete : x2 === 50 ? BindComplete : x2 === 49 ? ParseComplete : x2 === 116 ? ParameterDescription : x2 === 84 ? RowDescription : x2 === 82 ? Authentication : x2 === 110 ? NoData : x2 === 75 ? BackendKeyData : x2 === 69 ? ErrorResponse : x2 === 115 ? PortalSuspended : x2 === 51 ? CloseComplete : x2 === 71 ? CopyInResponse : x2 === 78 ? NoticeResponse : x2 === 72 ? CopyOutResponse : x2 === 99 ? CopyDone : x2 === 73 ? EmptyQueryResponse : x2 === 86 ? FunctionCallResponse : x2 === 118 ? NegotiateProtocolVersion : x2 === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x2) {
    let index = 7;
    let length2;
    let column;
    let value;
    const row = query.isRaw ? new Array(query.statement.columns.length) : {};
    for (let i2 = 0;i2 < query.statement.columns.length; i2++) {
      column = query.statement.columns[i2];
      length2 = x2.readInt32BE(index);
      index += 4;
      value = length2 === -1 ? null : query.isRaw === true ? x2.subarray(index, index += length2) : column.parser === undefined ? x2.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x2.toString("utf8", index + 1, index += length2)) : column.parser(x2.toString("utf8", index, index += length2));
      query.isRaw ? row[i2] = query.isRaw === true ? value : transform2.value.from ? transform2.value.from(value, column) : value : row[column.name] = transform2.value.from ? transform2.value.from(value, column) : value;
    }
    query.forEachFn ? query.forEachFn(transform2.row.from ? transform2.row.from(row) : row, result) : result[rows++] = transform2.row.from ? transform2.row.from(row) : row;
  }
  function ParameterStatus(x2) {
    const [k2, v] = x2.toString("utf8", 5, x2.length - 1).split(bytes_default.N);
    backendParameters[k2] = v;
    if (options.parameters[k2] !== v) {
      options.parameters[k2] = v;
      onparameter && onparameter(k2, v);
    }
  }
  function ReadyForQuery(x2) {
    query && query.options.simple && query.resolve(results || result);
    query = results = null;
    result = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial.reserve && (initial = null);
        return fetchArrayTypes();
      }
      initial && !initial.reserve && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))
      Connection(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject);
    if (query)
      return;
    connection2.reserved ? !connection2.reserved.release && x2[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x2) {
    rows = 0;
    for (let i2 = x2.length - 1;i2 > 0; i2--) {
      if (x2[i2] === 32 && x2[i2 + 1] < 58 && result.count === null)
        result.count = +x2.toString("utf8", i2 + 1, x2.length - 1);
      if (x2[i2 - 1] >= 65) {
        result.command = x2.toString("utf8", 5, i2);
        result.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result.command === "BEGIN" && max2 !== 1 && !connection2.reserved)
      return errored(Errors2.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query.options.simple)
      return BindComplete();
    if (query.cursorFn) {
      result.count && query.cursorFn(result);
      write(Sync);
    }
    query.resolve(result);
  }
  function ParseComplete() {
    query.parsing = false;
  }
  function BindComplete() {
    !result.statement && (result.statement = query.statement);
    result.columns = query.statement.columns;
  }
  function ParameterDescription(x2) {
    const length2 = x2.readUInt16BE(5);
    for (let i2 = 0;i2 < length2; ++i2)
      !query.statement.types[i2] && (query.statement.types[i2] = x2.readUInt32BE(7 + i2 * 4));
    query.prepare && (statements[query.signature] = query.statement);
    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false);
  }
  function RowDescription(x2) {
    if (result.command) {
      results = results || [result];
      results.push(result = new Result);
      result.count = null;
      query.statement.columns = null;
    }
    const length2 = x2.readUInt16BE(5);
    let index = 7;
    let start;
    query.statement.columns = Array(length2);
    for (let i2 = 0;i2 < length2; ++i2) {
      start = index;
      while (x2[index++] !== 0)
        ;
      const table = x2.readUInt32BE(index);
      const number = x2.readUInt16BE(index + 4);
      const type = x2.readUInt32BE(index + 6);
      query.statement.columns[i2] = {
        name: transform2.column.from ? transform2.column.from(x2.toString("utf8", start, index - 1)) : x2.toString("utf8", start, index - 1),
        parser: parsers2[type],
        table,
        number,
        type
      };
      index += 18;
    }
    result.statement = query.statement;
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  async function Authentication(x2, type = x2.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x2, type);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x2) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x2.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i2 = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i2 - 4, i2).end());
  }
  async function SASLContinue(x2) {
    const res = x2.toString("utf8", 9).split(",").reduce((acc, x3) => (acc[x3[0]] = x3.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + "," + "r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x2) {
    if (x2.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors2.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result.statement = query.statement;
    result.statement.columns = [];
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  function BackendKeyData(x2) {
    backend.pid = x2.readUInt32BE(5);
    backend.secret = x2.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types2 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types2.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x2, xs) {
    return x2 === "read-write" && xs.default_transaction_read_only === "on" || x2 === "read-only" && xs.default_transaction_read_only === "off" || x2 === "primary" && xs.in_hot_standby === "on" || x2 === "standby" && xs.in_hot_standby === "off" || x2 === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query2 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query2.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query2.execute();
  }
  function ErrorResponse(x2) {
    query && (query.cursorFn || query.describeFirst) && write(Sync);
    const error2 = Errors2.postgres(parseError(x2));
    query && query.retried ? errored(query.retried) : query && query.prepared && retryRoutines.has(error2.routine) ? retry(query, error2) : errored(error2);
  }
  function retry(q, error2) {
    delete statements[q.signature];
    q.retried = error2;
    execute(q);
  }
  function NotificationResponse(x2) {
    if (!onnotify)
      return;
    let index = 9;
    while (x2[index++] !== 0)
      ;
    onnotify(x2.toString("utf8", 9, index - 1), x2.toString("utf8", index, x2.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x2 = await Promise.resolve(query.cursorFn(result));
      rows = 0;
      x2 === CLOSE ? write(Close(query.portal)) : (result = new Result, write(Execute("", query.cursorRows)));
    } catch (err2) {
      write(Sync);
      query.reject(err2);
    }
  }
  function CloseComplete() {
    result.count && query.cursorFn(result);
    query.resolve(result);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error2, callback) {
        callback(error2);
        socket.write(bytes_default().f().str(error2 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyData(x2) {
    stream && (stream.push(x2.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x2) {
    onnotice ? onnotice(parseError(x2)) : console.log(parseError(x2));
  }
  function EmptyQueryResponse() {}
  function FunctionCallResponse() {
    errored(Errors2.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors2.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x2) {
    console.error("Postgres.js : Unknown Message:", x2[0]);
  }
  function UnknownAuth(x2, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types2, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x2, i2) => {
      if (x2 === null)
        return bytes_default.i32(4294967295);
      type = types2[i2];
      parameters[i2] = x2 = type in options.serializers ? options.serializers[type](x2) : "" + x2;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x2).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse2(str, parameters, types2, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x2, i2) => bytes_default.i32(types2[i2] || 0));
    return bytes_default.end();
  }
  function Describe(x2, name = "") {
    return bytes_default().D().str(x2).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k2, v]) => k2 + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
}
function parseError(x2) {
  const error = {};
  let start = 5;
  for (let i2 = 5;i2 < x2.length - 1; i2++) {
    if (x2[i2] === 0) {
      error[errorFields[x2[start]]] = x2.toString("utf8", start + 1, i2);
      start = i2 + 1;
    }
  }
  return error;
}
function md5(x2) {
  return crypto2.createHash("md5").update(x2).digest("hex");
}
function hmac(key, x2) {
  return crypto2.createHmac("sha256", key).update(x2).digest();
}
function sha256(x2) {
  return crypto2.createHash("sha256").update(x2).digest();
}
function xor(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i2 = 0;i2 < length; i2++)
    buffer2[i2] = a[i2] ^ b2[i2];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
}

// node_modules/postgres/src/subscribe.js
var noop2 = () => {};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql2 = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init(sql2, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql2;
  sql2.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql2.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2, onerror = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init(sql2, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x2) => {
      connected(x2);
      onsubscribe();
      stream && stream.on("error", onerror);
      return { unsubscribe, state, sql: sql2 };
    });
  }
  function connected(x2) {
    stream = x2.stream;
    state.pid = x2.state.pid;
    state.secret = x2.state.secret;
  }
  async function init(sql3, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql3.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x2] = xs;
    const stream2 = await sql3.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x2.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x2.consistent_point.split("/").map((x3) => Buffer.from(("00000000" + x3).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error);
    stream2.on("close", sql3.close);
    return { stream: stream2, state: xs.state };
    function error(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x3) {
      if (x3[0] === 119) {
        parse2(x3.subarray(25), state2, sql3.options.parsers, handle, options.transform);
      } else if (x3[0] === 107 && x3[17]) {
        state2.lsn = x3.subarray(1, 9);
        pong();
      }
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
    }
    function pong() {
      const x3 = Buffer.alloc(34);
      x3[0] = 114;
      x3.fill(state2.lsn, 1);
      x3.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x3);
    }
  }
  function call(x2, a, b2) {
    subscribers.has(x2) && subscribers.get(x2).forEach(({ fn }) => fn(a, b2, x2));
  }
}
function Time(x2) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x2 / BigInt(1000)));
}
function parse2(x2, state, parsers2, handle, transform2) {
  const char2 = (acc, [k2, v]) => (acc[k2.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x3) => {
      let i2 = 1;
      const r = state[x3.readUInt32BE(i2)] = {
        schema: x3.toString("utf8", i2 += 4, i2 = x3.indexOf(0, i2)) || "pg_catalog",
        table: x3.toString("utf8", i2 + 1, i2 = x3.indexOf(0, i2 + 1)),
        columns: Array(x3.readUInt16BE(i2 += 2)),
        keys: []
      };
      i2 += 2;
      let columnIndex = 0, column;
      while (i2 < x3.length) {
        column = r.columns[columnIndex++] = {
          key: x3[i2++],
          name: transform2.column.from ? transform2.column.from(x3.toString("utf8", i2, i2 = x3.indexOf(0, i2))) : x3.toString("utf8", i2, i2 = x3.indexOf(0, i2)),
          type: x3.readUInt32BE(i2 += 1),
          parser: parsers2[x3.readUInt32BE(i2)],
          atttypmod: x3.readUInt32BE(i2 += 4)
        };
        column.key && r.keys.push(column);
        i2 += 4;
      }
    },
    Y: () => {},
    O: () => {},
    B: (x3) => {
      state.date = Time(x3.readBigInt64BE(9));
      state.lsn = x3.subarray(1, 9);
    },
    I: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      const { row } = tuples(x3, relation.columns, i2 += 7, transform2);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      handle(key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform2).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      const xs = key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform2) : null;
      xs && (i2 = xs.i);
      const { row } = tuples(x3, relation.columns, i2 + 3, transform2);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {},
    C: () => {}
  }).reduce(char2, {})[x2[0]](x2);
}
function tuples(x2, columns, xi, transform2) {
  let type, column, value;
  const row = transform2.raw ? new Array(columns.length) : {};
  for (let i2 = 0;i2 < columns.length; i2++) {
    type = x2[xi++];
    column = columns[i2];
    value = type === 110 ? null : type === 117 ? undefined : column.parser === undefined ? x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x2.toString("utf8", xi + 5, xi += 4 + x2.readUInt32BE(xi))) : column.parser(x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)));
    transform2.raw ? row[i2] = transform2.raw === true ? value : transform2.value.from ? transform2.value.from(value, column) : value : row[column.name] = transform2.value.from ? transform2.value.from(value, column) : value;
  }
  return { i: xi, row: transform2.row.from ? transform2.row.from(row) : row };
}
function parseEvent(x2) {
  const xs = x2.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x2);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
}

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql2, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve, reject) => {
    await sql2.begin(async (sql3) => {
      let finish;
      !oid && ([{ oid }] = await sql3`select lo_creat(-1) as oid`);
      const [{ fd: fd2 }] = await sql3`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql3`select lo_close(${fd2})`.then(finish),
        tell: () => sql3`select lo_tell64(${fd2})`,
        read: (x2) => sql3`select loread(${fd2}, ${x2}) as data`,
        write: (x2) => sql3`select lowrite(${fd2}, ${x2})`,
        truncate: (x2) => sql3`select lo_truncate64(${fd2}, ${x2})`,
        seek: (x2, whence = 0) => sql3`select lo_lseek64(${fd2}, ${x2}, ${whence})`,
        size: () => sql3`
          select
            lo_lseek64(${fd2}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max2 = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max2 ? size2 - max2 : size2;
            max2 -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// node_modules/postgres/src/index.js
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x2) => BigInt(x2),
    serialize: (x2) => x2.toString()
  }
});
var src_default = Postgres;
function Postgres(a, b2) {
  const options = parseOptions(a, b2), subscribe = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql2 = Sql(handler);
  Object.assign(sql2, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql2),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql2;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x2) => new Parameter(x2, type.to);
      return acc;
    }, typed);
    Object.assign(sql3, {
      types: typed,
      typed,
      unsafe,
      notify,
      array,
      json: json2,
      file
    });
    return sql3;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql3(strings, ...args) {
      const query = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier2(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([], args, (query2) => {
        fs.readFile(path, "utf8", (err2, string) => {
          if (err2)
            return query2.reject(err2);
          query2.strings = [string];
          handler2(query2);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql3 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {})));
        });
      },
      onnotify(c, x2) {
        c in listen.channels && listen.channels[c].listeners.forEach((l) => l.fn(x2));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists2 = name in channels;
    if (exists2) {
      channels[name].listeners.push(listener);
      const result2 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result2.state, unlisten };
    }
    channels[name] = { result: sql3`listen ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x2) => x2 !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql3`unlisten ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql2`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue = queue_default();
    const c = open.length ? open.shift() : await new Promise((resolve, reject) => {
      const query = { reserve: resolve, reject };
      queries.push(query);
      closed.length && connect(closed.shift(), query);
    });
    move(c, reserved);
    c.reserved = () => queue.length ? c.execute(queue.shift()) : move(c, reserved);
    c.reserved.release = true;
    const sql3 = Sql(handler2);
    sql3.release = () => {
      c.reserved = null;
      onopen(c);
    };
    return sql3;
    function handler2(q) {
      c.queue === full ? queue.push(q) : c.execute(q) || move(c, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection2, prepare = null;
    try {
      await sql2.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection2, fn),
        new Promise((_2, reject) => connection2.onclose = reject)
      ]);
    } catch (error) {
      throw error;
    }
    async function scope(c, fn2, name) {
      const sql3 = Sql(handler2);
      sql3.savepoint = savepoint;
      sql3.prepare = (x2) => prepare = x2.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result;
      name && await sql3`savepoint ${sql3(name)}`;
      try {
        result = await new Promise((resolve, reject) => {
          const x2 = fn2(sql3);
          Promise.resolve(Array.isArray(x2) ? Promise.all(x2) : x2).then(resolve, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql3`rollback to ${sql3(name)}` : sql3`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql3`prepare transaction '${sql3.unsafe(prepare)}'` : await sql3`commit`;
      }
      return result;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql4) => sql4.apply(sql4, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c.queue === full ? queries2.push(q) : c.execute(q) || move(c, full);
      }
    }
    function onexecute(c) {
      connection2 = c;
      move(c, reserved);
      c.reserved = () => queries2.length ? c.execute(queries2.shift()) : move(c, reserved);
    }
  }
  function move(c, queue) {
    c.queue.remove(c);
    queue.push(c);
    c.queue = queue;
    queue === open ? c.idleTimer.start() : c.idleTimer.cancel();
    return c;
  }
  function json2(x2) {
    return new Parameter(x2, 3802);
  }
  function array(x2, type) {
    if (!Array.isArray(x2))
      return array(Array.from(arguments));
    return new Parameter(x2, type || (x2.length ? inferType(x2) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query) {
    if (ending)
      return query.reject(Errors2.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query);
    if (closed.length)
      return connect(closed.shift(), query);
    busy.length ? go(busy.shift(), query) : queries.push(query);
  }
  function go(c, query) {
    return c.execute(query) ? move(c, busy) : move(c, full);
  }
  function cancel(query) {
    return new Promise((resolve, reject) => {
      query.state ? query.active ? connection_default(options).cancel(query.state, resolve, reject) : query.cancelled = { resolve, reject } : (queries.remove(query), query.cancelled = true, query.reject(Errors2.generic("57014", "canceling statement due to user request")), resolve());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c) => c.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c) => c.end()));
  }
  async function destroy(resolve) {
    await Promise.all(connections.map((c) => c.terminate()));
    while (queries.length)
      queries.shift().reject(Errors2.connection("CONNECTION_DESTROYED", options));
    resolve();
  }
  function connect(c, query) {
    move(c, connecting);
    c.connect(query);
    return c;
  }
  function onend(c) {
    move(c, ended);
  }
  function onopen(c) {
    if (queries.length === 0)
      return move(c, open);
    let max2 = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max2-- > 0) {
      const query = queries.shift();
      if (query.reserve)
        return query.reserve(c);
      ready = c.execute(query);
    }
    ready ? move(c, busy) : move(c, full);
  }
  function onclose(c, e) {
    move(c, closed);
    c.reserved = null;
    c.onclose && (c.onclose(e), c.onclose = null);
    options.onclose && options.onclose(c.id);
    queries.length && connect(c, queries.shift());
  }
}
function parseOptions(a, b2) {
  if (a && a.shared)
    return a;
  const env3 = process.env, o = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query = [...url.searchParams].reduce((a2, [b3, c]) => (a2[b3] = c, a2), {}), host = o.hostname || o.host || multihost || url.hostname || env3.PGHOST || "localhost", port = o.port || url.port || env3.PGPORT || 5432, user = o.user || o.username || url.username || env3.PGUSERNAME || env3.PGUSER || osUsername();
  o.no_prepare && (o.prepare = false);
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
  "timeout" in o && (console.log("The timeout option is deprecated, use idle_timeout instead"), o.idle_timeout = o.timeout);
  query.sslrootcert === "system" && (query.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x2) => x2.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x2) => parseInt(x2.split(":")[1] || port)),
    path: o.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o.database || o.db || (url.pathname || "").slice(1) || env3.PGDATABASE || user,
    user,
    pass: o.pass || o.password || url.password || env3.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k2, d]) => {
      const value = k2 in o ? o[k2] : (k2 in query) ? query[k2] === "disable" || query[k2] === "false" ? false : query[k2] : env3["PG" + k2.toUpperCase()] || d;
      acc[k2] = typeof value === "string" && ints.includes(k2) ? +value : value;
      return acc;
    }, {}),
    connection: {
      application_name: env3.PGAPPNAME || "postgres.js",
      ...o.connection,
      ...Object.entries(query).reduce((acc, [k2, v]) => ((k2 in defaults) || (acc[k2] = v), acc), {})
    },
    types: o.types || {},
    target_session_attrs: tsa(o, url, env3),
    onnotice: o.onnotice,
    onnotify: o.onnotify,
    onclose: o.onclose,
    onparameter: o.onparameter,
    socket: o.socket,
    transform: parseTransform(o.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o.types)
  };
}
function tsa(o, url, env3) {
  const x2 = o.target_session_attrs || url.searchParams.get("target_session_attrs") || env3.PGTARGETSESSIONATTRS;
  if (!x2 || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x2))
    return x2;
  throw new Error("target_session_attrs " + x2 + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x2) {
  return {
    undefined: x2.undefined,
    column: {
      from: typeof x2.column === "function" ? x2.column : x2.column && x2.column.from,
      to: x2.column && x2.column.to
    },
    value: {
      from: typeof x2.value === "function" ? x2.value : x2.value && x2.value.from,
      to: x2.value && x2.value.to
    },
    row: {
      from: typeof x2.row === "function" ? x2.row : x2.row && x2.row.from,
      to: x2.row && x2.row.to
    }
  };
}
function parseUrl(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return os.userInfo().username;
  } catch (_2) {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i2) => {
    const formattedWord = i2 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i2, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i2 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set2) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set2[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i2) => {
      const col = tableColumns[colName];
      const value = set2[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i2 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set: set2, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set2);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index, joinMeta] of joins.entries()) {
      if (index === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0;i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select: select2, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_2, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select2) {
      const select22 = valuesOrSelect;
      if (is(select22, SQL)) {
        valuesSqlList.push(select22);
      } else {
        valuesSqlList.push(select22.getSQL());
      }
    } else {
      const values2 = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values2.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values2.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder2) {
    if (is(encoder2, PgJsonb) || is(encoder2, PgJson)) {
      return "json";
    } else if (is(encoder2, PgNumeric)) {
      return "decimal";
    } else if (is(encoder2, PgTime)) {
      return "time";
    } else if (is(encoder2, PgTimestamp) || is(encoder2, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder2, PgDate) || is(encoder2, PgDateString)) {
      return "date";
    } else if (is(encoder2, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
  $withCache(config) {
    this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select: select2, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values2) {
    values2 = Array.isArray(values2) ? values2 : [values2];
    if (values2.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values2.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select2 = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select2, SQL) && !haveSameKeys(this.table[Columns], select2._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select2, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values2, session, dialect, withList, select2, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values: values2, withList, select: select2, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values2) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values2), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set: set2, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {} };
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self2 = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  with(...queries) {
    const self2 = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select: select2, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config) {}
  async onMutate(_params) {}
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder2 = new TextEncoder;
  const data = encoder2.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b2) => b2.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query, cache, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2, token) {
    const res = await this.execute(sql2, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// node_modules/drizzle-orm/postgres-js/session.js
class PostgresJsPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "PostgresJsPreparedQuery";
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      const { fields, queryString: query, client, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", () => {
          return this.queryWithCache(query, params, async () => {
            return await client.unsafe(query, params);
          });
        });
      }
      const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": query,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(query, params, async () => {
          return await client.unsafe(query, params).values();
        });
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      return tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": this.queryString,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(this.queryString, params, async () => {
          return this.client.unsafe(this.queryString, params);
        });
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class PostgresJsSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "PostgresJsSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new PostgresJsPreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, isResponseInArrayMode, customResultMapper);
  }
  query(query, params) {
    this.logger.logQuery(query, params);
    return this.client.unsafe(query, params).values();
  }
  queryObjects(query, params) {
    return this.client.unsafe(query, params);
  }
  transaction(transaction, config) {
    return this.client.begin(async (client) => {
      const session = new PostgresJsSession(client, this.dialect, this.schema, this.options);
      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
}

class PostgresJsTransaction extends PgTransaction {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema, nestedIndex);
    this.session = session;
  }
  static [entityKind] = "PostgresJsTransaction";
  transaction(transaction) {
    return this.session.client.savepoint((client) => {
      const session = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);
      const tx = new PostgresJsTransaction(this.dialect, session, this.schema);
      return transaction(tx);
    });
  }
}

// node_modules/drizzle-orm/postgres-js/driver.js
class PostgresJsDatabase extends PgDatabase {
  static [entityKind] = "PostgresJsDatabase";
}
function construct(client, config = {}) {
  const transparentParser = (val) => val;
  for (const type of ["1184", "1082", "1083", "1114", "1182", "1185", "1115", "1231"]) {
    client.options.parsers[type] = transparentParser;
    client.options.serializers[type] = transparentParser;
  }
  client.options.serializers["114"] = transparentParser;
  client.options.serializers["3802"] = transparentParser;
  const dialect = new PgDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session = new PostgresJsSession(client, dialect, schema, { logger, cache: config.cache });
  const db = new PostgresJsDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = src_default(params[0]);
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection: connection2, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection2 === "object" && connection2.url !== undefined) {
      const { url, ...config } = connection2;
      const instance2 = src_default(url, config);
      return construct(instance2, drizzleConfig);
    }
    const instance = src_default(connection2);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({
      options: {
        parsers: {},
        serializers: {}
      }
    }, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/db/schema.ts
var exports_schema = {};
__export(exports_schema, {
  users: () => users,
  todos: () => todos,
  todoStatus: () => todoStatus,
  todoPriority: () => todoPriority,
  UserSelectSchema: () => UserSelectSchema,
  UserInsertSchema: () => UserInsertSchema,
  TodoSelectSchema: () => TodoSelectSchema,
  TodoInsertSchema: () => TodoInsertSchema
});

// node_modules/drizzle-zod/node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid3,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union2,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set2,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse5,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map3,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json2,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  date: () => date5,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core3,
  config: () => config,
  coerce: () => exports_coerce,
  clone: () => clone2,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check2,
  catch: () => _catch2,
  boolean: () => boolean3,
  bigint: () => bigint3,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/drizzle-zod/node_modules/zod/v4/core/index.js
var exports_core3 = {};
__export(exports_core3, {
  version: () => version2,
  util: () => exports_util,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse3,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  function: () => _function,
  formatError: () => formatError,
  flattenError: () => flattenError,
  config: () => config,
  clone: () => clone2,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/drizzle-zod/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k2 in _2.prototype) {
      if (!(k2 in inst))
        Object.defineProperty(inst, k2, { value: _2.prototype[k2].bind(inst) });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _2(def) {
    var _a2;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_2, "init", { value: init });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_2, "name", { value: name });
  return _2;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/drizzle-zod/node_modules/zod/v4/core/util.js
var exports_util = {};
__export(exports_util, {
  unwrapMessage: () => unwrapMessage,
  stringifyPrimitive: () => stringifyPrimitive,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject2,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  clone: () => clone2,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert2,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert2(_2) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values2 = Object.entries(entries).filter(([k2, _2]) => numericValues.indexOf(+k2) === -1).map(([_2, v]) => v);
  return values2;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  const set2 = false;
  Object.defineProperty(object, key, {
    get() {
      if (!set2) {
        const value = getter();
        object[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0;i2 < keys.length; i2++) {
      resolvedObj[keys[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0;i2 < length; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
function isObject2(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject2(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject2(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t2}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_2, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_2, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_2, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_2, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_2) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_2, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_2, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k2) => {
    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone2(schema, def);
}
function merge(a, b2) {
  return clone2(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b2._zod.def.catchall,
    checks: []
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function aborted(x2, startIndex = 0) {
  for (let i2 = startIndex;i2 < x2.issues.length; i2++) {
    if (x2.issues[i2]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k2, _2]) => {
    return Number.isNaN(Number.parseInt(k2, 10));
  }).map((el) => el[1]);
}

class Class {
  constructor(..._args) {}
}

// node_modules/drizzle-zod/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a2, _b2;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b2 = curr.items)[el] ?? (_b2[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(path) {
  const segs = [];
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a, b2) => a.path.length - b2.path.length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/drizzle-zod/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse3 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
// node_modules/drizzle-zod/node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid2,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time2,
  string: () => string,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer2,
  html5Email: () => html5Email,
  hostname: () => hostname,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date3,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url,
  base64: () => base64,
  _emoji: () => _emoji
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid2 = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid2(4);
var uuid6 = /* @__PURE__ */ uuid2(6);
var uuid7 = /* @__PURE__ */ uuid2(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date3 = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex2 = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex2;
}
function time2(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex2 = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex2}$`);
};
var bigint2 = /^\d+n?$/;
var integer2 = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean2 = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/drizzle-zod/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer2;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 === def.size)
      return;
    const tooBig = size2 > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b2;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b2 = inst._zod).check ?? (_b2.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/drizzle-zod/node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line2 of dedented) {
      this.content.push(line2);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x2) => `  ${x2}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/drizzle-zod/node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/drizzle-zod/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_2) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_3) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid2(v));
  } else
    def.pattern ?? (def.pattern = uuid2());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date3);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time2(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_2) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_2) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint2;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_2) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0;i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === undefined) {
      if (key in input) {
        final.value[key] = undefined;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === undefined) {
    if (key in input)
      final.value[key] = undefined;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k2 of keys) {
      if (!(def.shape[k2] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k2 = esc(key);
      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k2 = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k2}] === undefined) {
            if (${k2} in input) {
              newResult[${k2}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k2}, ...iss.path] : [${k2}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k2} in input) newResult[${k2}] = undefined;
        } else {
          newResult[${k2}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject3 = isObject2;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject3(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional2 = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional2 ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional2) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t2 = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t2 === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k2, v] of Object.entries(pv)) {
        if (!propValues[k2])
          propValues[k2] = new Set;
        for (const val of v) {
          propValues[k2].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map3 = new Map;
    for (const o of opts) {
      const values2 = o._zod.propValues[def.discriminator];
      if (!values2 || values2.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values2) {
        if (map3.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map3.set(v, o);
      }
    }
    return map3;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b2) {
  if (a === b2) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b2 instanceof Date && +a === +b2) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b2)) {
    if (a.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values2 = def.keyType._zod.values;
      payload.value = {};
      for (const key of values2) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values2.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values2 = getEnumValues(def.entries);
  inst._zod.values = new Set(values2);
  inst._zod.pattern = new RegExp(`^(${values2.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: values2,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x2) => x2 !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  vi: () => vi_default,
  ur: () => ur_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  ko: () => ko_default,
  kh: () => kh_default,
  ja: () => ja_default,
  it: () => it_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/drizzle-zod/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
    set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes")
          return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex")
          return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/de.js
var error6 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error6()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error7 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error7()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error8()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/es.js
var error9 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${issue2.expected}, recibido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${issue2.origin}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
};
function es_default() {
  return {
    localeError: error9()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/fa.js
var error10 = () => {
  const Sizable = {
    string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
    set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType3(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
};
function fa_default() {
  return {
    localeError: error10()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/fi.js
var error11 = () => {
  const Sizable = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
};
function fi_default() {
  return {
    localeError: error11()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/fr.js
var error12 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error12()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/fr-CA.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error13()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/he.js
var error14 = () => {
  const Sizable = {
    string: { unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" },
    set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", verb: "\u05DC\u05DB\u05DC\u05D5\u05DC" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
};
function he_default() {
  return {
    localeError: error14()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/hu.js
var error15 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with")
          return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes")
          return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error15()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/id.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error16()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/it.js
var error17 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error17()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ja.js
var error18 = () => {
  const Sizable = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType3(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex")
          return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
};
function ja_default() {
  return {
    localeError: error18()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/kh.js
var error19 = () => {
  const Sizable = {
    string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
    set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
};
function kh_default() {
  return {
    localeError: error19()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ko.js
var error20 = () => {
  const Sizable = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType3(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing)
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex")
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
};
function ko_default() {
  return {
    localeError: error20()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/mk.js
var error21 = () => {
  const Sizable = {
    string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
    set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
};
function mk_default() {
  return {
    localeError: error21()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ms.js
var error22 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error22()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/nl.js
var error23 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error23()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/no.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error24()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ota.js
var error25 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with")
          return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex")
          return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error25()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ps.js
var error26 = () => {
  const Sizable = {
    string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
    array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
    set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType3(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
};
function ps_default() {
  return {
    localeError: error26()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/pl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error27()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/pt.js
var error28 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error28()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error29 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
};
function ru_default() {
  return {
    localeError: error29()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/sl.js
var error30 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error30()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/sv.js
var error31 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error31()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ta.js
var error32 = () => {
  const Sizable = {
    string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
    set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex")
          return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
};
function ta_default() {
  return {
    localeError: error32()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/th.js
var error33 = () => {
  const Sizable = {
    string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
    set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex")
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
};
function th_default() {
  return {
    localeError: error33()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
};
var error34 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal\u0131" },
    file: { unit: "bayt", verb: "olmal\u0131" },
    array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with")
          return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex")
          return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error34()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ua.js
var error35 = () => {
  const Sizable = {
    string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
    set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
};
function ua_default() {
  return {
    localeError: error35()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/ur.js
var error36 = () => {
  const Sizable = {
    string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
    file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
    array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
    set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType4(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex")
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
};
function ur_default() {
  return {
    localeError: error36()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/vi.js
var error37 = () => {
  const Sizable = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
};
function vi_default() {
  return {
    localeError: error37()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/zh-CN.js
var error38 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error38()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/locales/zh-TW.js
var error39 = () => {
  const Sizable = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  };
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error39()
  };
}
// node_modules/drizzle-zod/node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new Map;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/drizzle-zod/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size2, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size: size2
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types2, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types2,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form2) {
  return _overwrite((input) => input.normalize(form2));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/drizzle-zod/node_modules/zod/v4/core/function.js
class $ZodFunction {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse3(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = func(...parsedArgs);
      return this._def.output ? parse3(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output, undefined, { callee: impl }) : output;
    };
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output
    });
  }
}
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
// node_modules/drizzle-zod/node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex2) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex2.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number")
              json2.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json2.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            json2.anyOf = def.options.map((x2, i2) => this.process(x2, {
              ...params,
              path: [...params.path, "anyOf", i2]
            }));
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b2 = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b2) ? b2.allOf : [b2]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixItems = def.items.map((x2, i2) => this.process(x2, { ...params, path: [...params.path, "prefixItems", i2] }));
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
            } else {
              json2.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json2.items = rest;
              } else {
                json2.additionalItems = rest;
              }
            }
            if (def.rest) {
              json2.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            json2.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values2 = getEnumValues(def.entries);
            if (values2.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values2.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values2;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              json2.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime: mime2 } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime2) {
              if (mime2.length === 1) {
                file.contentMediaType = mime2[0];
                Object.assign(json2, file);
              } else {
                json2.anyOf = mime2.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_2, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/drizzle-zod/node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/drizzle-zod/node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time3,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date4,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date4(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time3(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/drizzle-zod/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/drizzle-zod/node_modules/zod/v4/classic/parse.js
var parse5 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/drizzle-zod/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse5(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union2([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform2(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date4(params));
  inst.time = (params) => inst.check(time3(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid3(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean3(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint3(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date5(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  exports_util.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util.extend(inst, incoming);
  };
  inst.merge = (other) => exports_util.merge(inst, other);
  inst.pick = (mask) => exports_util.pick(inst, mask);
  inst.omit = (mask) => exports_util.omit(inst, mask);
  inst.partial = (...args) => exports_util.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...exports_util.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...exports_util.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union2(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union2([keyType, never()]),
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map3(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set2(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values2, params) => {
    const newEntries = {};
    for (const value of values2) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values2, params) => {
    const newEntries = { ...def.entries };
    for (const value of values2) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values2, params) {
  const entries = Array.isArray(values2) ? Object.fromEntries(values2.map((v) => [v, v])) : values2;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size2, params) => inst.check(_minSize(size2, params));
  inst.max = (size2, params) => inst.check(_maxSize(size2, params));
  inst.mime = (types2, params) => inst.check(_mime(Array.isArray(types2) ? types2 : [types2], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform2(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check2(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check2((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(exports_util.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json2(params) {
  const jsonSchema = lazy(() => {
    return union2([string2(params), number2(), boolean3(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform2(fn), schema);
}
// node_modules/drizzle-zod/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map4) {
  config({
    customError: map4
  });
}
function getErrorMap() {
  return config().customError;
}
// node_modules/drizzle-zod/node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date6,
  boolean: () => boolean4,
  bigint: () => bigint4
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean4(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint4(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date6(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/drizzle-zod/node_modules/zod/v4/classic/external.js
config(en_default());
// node_modules/drizzle-zod/index.mjs
var CONSTANTS = {
  INT8_MIN: -128,
  INT8_MAX: 127,
  INT8_UNSIGNED_MAX: 255,
  INT16_MIN: -32768,
  INT16_MAX: 32767,
  INT16_UNSIGNED_MAX: 65535,
  INT24_MIN: -8388608,
  INT24_MAX: 8388607,
  INT24_UNSIGNED_MAX: 16777215,
  INT32_MIN: -2147483648,
  INT32_MAX: 2147483647,
  INT32_UNSIGNED_MAX: 4294967295,
  INT48_MIN: -140737488355328,
  INT48_MAX: 140737488355327,
  INT48_UNSIGNED_MAX: 281474976710655,
  INT64_MIN: -9223372036854775808n,
  INT64_MAX: 9223372036854775807n,
  INT64_UNSIGNED_MAX: 18446744073709551615n
};
function isColumnType(column, columnTypes) {
  return columnTypes.includes(column.columnType);
}
function isWithEnum(column) {
  return "enumValues" in column && Array.isArray(column.enumValues) && column.enumValues.length > 0;
}
var isPgEnum2 = isWithEnum;
var literalSchema = exports_external.union([exports_external.string(), exports_external.number(), exports_external.boolean(), exports_external.null()]);
var jsonSchema = exports_external.union([
  literalSchema,
  exports_external.record(exports_external.string(), exports_external.any()),
  exports_external.array(exports_external.any())
]);
var bufferSchema = exports_external.custom((v) => v instanceof Buffer);
function columnToSchema(column, factory) {
  const z$1 = factory?.zodInstance ?? exports_external;
  const coerce = factory?.coerce ?? {};
  let schema;
  if (isWithEnum(column)) {
    schema = column.enumValues.length ? z$1.enum(column.enumValues) : z$1.string();
  }
  if (!schema) {
    if (isColumnType(column, ["PgGeometry", "PgPointTuple"])) {
      schema = z$1.tuple([z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgGeometryObject", "PgPointObject"])) {
      schema = z$1.object({ x: z$1.number(), y: z$1.number() });
    } else if (isColumnType(column, ["PgHalfVector", "PgVector"])) {
      schema = z$1.array(z$1.number());
      schema = column.dimensions ? schema.length(column.dimensions) : schema;
    } else if (isColumnType(column, ["PgLine"])) {
      schema = z$1.tuple([z$1.number(), z$1.number(), z$1.number()]);
    } else if (isColumnType(column, ["PgLineABC"])) {
      schema = z$1.object({
        a: z$1.number(),
        b: z$1.number(),
        c: z$1.number()
      });
    } else if (isColumnType(column, ["PgArray"])) {
      schema = z$1.array(columnToSchema(column.baseColumn, factory));
      schema = column.size ? schema.length(column.size) : schema;
    } else if (column.dataType === "array") {
      schema = z$1.array(z$1.any());
    } else if (column.dataType === "number") {
      schema = numberColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "bigint") {
      schema = bigintColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "boolean") {
      schema = coerce === true || coerce.boolean ? z$1.coerce.boolean() : z$1.boolean();
    } else if (column.dataType === "date") {
      schema = coerce === true || coerce.date ? z$1.coerce.date() : z$1.date();
    } else if (column.dataType === "string") {
      schema = stringColumnToSchema(column, z$1, coerce);
    } else if (column.dataType === "json") {
      schema = jsonSchema;
    } else if (column.dataType === "custom") {
      schema = z$1.any();
    } else if (column.dataType === "buffer") {
      schema = bufferSchema;
    }
  }
  if (!schema) {
    schema = z$1.any();
  }
  return schema;
}
function numberColumnToSchema(column, z, coerce) {
  let unsigned = column.getSQLType().includes("unsigned");
  let min;
  let max2;
  let integer3 = false;
  if (isColumnType(column, ["MySqlTinyInt", "SingleStoreTinyInt"])) {
    min = unsigned ? 0 : CONSTANTS.INT8_MIN;
    max2 = unsigned ? CONSTANTS.INT8_UNSIGNED_MAX : CONSTANTS.INT8_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgSmallInt",
    "PgSmallSerial",
    "MySqlSmallInt",
    "SingleStoreSmallInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT16_MIN;
    max2 = unsigned ? CONSTANTS.INT16_UNSIGNED_MAX : CONSTANTS.INT16_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgReal",
    "MySqlFloat",
    "MySqlMediumInt",
    "SingleStoreMediumInt",
    "SingleStoreFloat"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT24_MIN;
    max2 = unsigned ? CONSTANTS.INT24_UNSIGNED_MAX : CONSTANTS.INT24_MAX;
    integer3 = isColumnType(column, ["MySqlMediumInt", "SingleStoreMediumInt"]);
  } else if (isColumnType(column, [
    "PgInteger",
    "PgSerial",
    "MySqlInt",
    "SingleStoreInt"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT32_MIN;
    max2 = unsigned ? CONSTANTS.INT32_UNSIGNED_MAX : CONSTANTS.INT32_MAX;
    integer3 = true;
  } else if (isColumnType(column, [
    "PgDoublePrecision",
    "MySqlReal",
    "MySqlDouble",
    "SingleStoreReal",
    "SingleStoreDouble",
    "SQLiteReal"
  ])) {
    min = unsigned ? 0 : CONSTANTS.INT48_MIN;
    max2 = unsigned ? CONSTANTS.INT48_UNSIGNED_MAX : CONSTANTS.INT48_MAX;
  } else if (isColumnType(column, [
    "PgBigInt53",
    "PgBigSerial53",
    "MySqlBigInt53",
    "MySqlSerial",
    "SingleStoreBigInt53",
    "SingleStoreSerial",
    "SQLiteInteger"
  ])) {
    unsigned = unsigned || isColumnType(column, ["MySqlSerial", "SingleStoreSerial"]);
    min = unsigned ? 0 : Number.MIN_SAFE_INTEGER;
    max2 = Number.MAX_SAFE_INTEGER;
    integer3 = true;
  } else if (isColumnType(column, ["MySqlYear", "SingleStoreYear"])) {
    min = 1901;
    max2 = 2155;
    integer3 = true;
  } else {
    min = Number.MIN_SAFE_INTEGER;
    max2 = Number.MAX_SAFE_INTEGER;
  }
  let schema = coerce === true || coerce?.number ? integer3 ? z.coerce.number() : z.coerce.number().int() : integer3 ? z.int() : z.number();
  schema = schema.gte(min).lte(max2);
  return schema;
}
function bigintColumnToSchema(column, z, coerce) {
  const unsigned = column.getSQLType().includes("unsigned");
  const min = unsigned ? 0n : CONSTANTS.INT64_MIN;
  const max2 = unsigned ? CONSTANTS.INT64_UNSIGNED_MAX : CONSTANTS.INT64_MAX;
  const schema = coerce === true || coerce?.bigint ? z.coerce.bigint() : z.bigint();
  return schema.gte(min).lte(max2);
}
function stringColumnToSchema(column, z, coerce) {
  if (isColumnType(column, ["PgUUID"])) {
    return z.uuid();
  }
  let max2;
  let regex2;
  let fixed = false;
  if (isColumnType(column, ["PgVarchar", "SQLiteText"])) {
    max2 = column.length;
  } else if (isColumnType(column, ["MySqlVarChar", "SingleStoreVarChar"])) {
    max2 = column.length ?? CONSTANTS.INT16_UNSIGNED_MAX;
  } else if (isColumnType(column, ["MySqlText", "SingleStoreText"])) {
    if (column.textType === "longtext") {
      max2 = CONSTANTS.INT32_UNSIGNED_MAX;
    } else if (column.textType === "mediumtext") {
      max2 = CONSTANTS.INT24_UNSIGNED_MAX;
    } else if (column.textType === "text") {
      max2 = CONSTANTS.INT16_UNSIGNED_MAX;
    } else {
      max2 = CONSTANTS.INT8_UNSIGNED_MAX;
    }
  }
  if (isColumnType(column, [
    "PgChar",
    "MySqlChar",
    "SingleStoreChar"
  ])) {
    max2 = column.length;
    fixed = true;
  }
  if (isColumnType(column, ["PgBinaryVector"])) {
    regex2 = /^[01]+$/;
    max2 = column.dimensions;
  }
  let schema = coerce === true || coerce?.string ? z.coerce.string() : z.string();
  schema = regex2 ? schema.regex(regex2) : schema;
  return max2 && fixed ? schema.length(max2) : max2 ? schema.max(max2) : schema;
}
function getColumns(tableLike) {
  return isTable(tableLike) ? getTableColumns(tableLike) : getViewSelectedFields(tableLike);
}
function handleColumns(columns, refinements, conditions, factory) {
  const columnSchemas = {};
  for (const [key, selected] of Object.entries(columns)) {
    if (!is(selected, Column) && !is(selected, SQL) && !is(selected, SQL.Aliased) && typeof selected === "object") {
      const columns2 = isTable(selected) || isView(selected) ? getColumns(selected) : selected;
      columnSchemas[key] = handleColumns(columns2, refinements[key] ?? {}, conditions, factory);
      continue;
    }
    const refinement = refinements[key];
    if (refinement !== undefined && typeof refinement !== "function") {
      columnSchemas[key] = refinement;
      continue;
    }
    const column = is(selected, Column) ? selected : undefined;
    const schema = column ? columnToSchema(column, factory) : exports_external.any();
    const refined = typeof refinement === "function" ? refinement(schema) : schema;
    if (conditions.never(column)) {
      continue;
    } else {
      columnSchemas[key] = refined;
    }
    if (column) {
      if (conditions.nullable(column)) {
        columnSchemas[key] = columnSchemas[key].nullable();
      }
      if (conditions.optional(column)) {
        columnSchemas[key] = columnSchemas[key].optional();
      }
    }
  }
  return exports_external.object(columnSchemas);
}
function handleEnum(enum_, factory) {
  const zod = factory?.zodInstance ?? exports_external;
  return zod.enum(enum_.enumValues);
}
var selectConditions = {
  never: () => false,
  optional: () => false,
  nullable: (column) => !column.notNull
};
var insertConditions = {
  never: (column) => column?.generated?.type === "always" || column?.generatedIdentity?.type === "always",
  optional: (column) => !column.notNull || column.notNull && column.hasDefault,
  nullable: (column) => !column.notNull
};
var createSelectSchema = (entity, refine2) => {
  if (isPgEnum2(entity)) {
    return handleEnum(entity);
  }
  const columns = getColumns(entity);
  return handleColumns(columns, refine2 ?? {}, selectConditions);
};
var createInsertSchema = (entity, refine2) => {
  const columns = getColumns(entity);
  return handleColumns(columns, refine2 ?? {}, insertConditions);
};

// src/db/schema.ts
var todoStatus = pgEnum("todo_status", [
  "pending",
  "in_progress",
  "completed",
  "archived"
]);
var todoPriority = pgEnum("todo_priority", [
  "low",
  "medium",
  "high",
  "urgent"
]);
var users = pgTable("users", {
  id: uuid("id").primaryKey().defaultRandom(),
  username: varchar("username").notNull().unique(),
  email: text("email").notNull().unique(),
  verifiedEmail: boolean("verified_email").notNull().default(false),
  passwordHash: text("password_hash").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var todos = pgTable("todos", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description"),
  isCompleted: boolean("is_completed").notNull().default(false),
  status: todoStatus("status").notNull().default("pending"),
  priority: todoPriority("priority").notNull().default("medium"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var UserInsertSchema = createInsertSchema(users);
var UserSelectSchema = createSelectSchema(users);
var TodoInsertSchema = createInsertSchema(todos);
var TodoSelectSchema = createSelectSchema(todos);

// src/db/clients/index.ts
var client = src_default(process.env.DATABASE_URL, {
  max: 10,
  prepare: true
});
var db = drizzle(client, { schema: exports_schema });

// src/modules/auth/service.ts
var createUser = async (username, email3, passwordHash) => {
  const newUser = await db.insert(users).values({
    username,
    email: email3,
    passwordHash
  });
  return newUser;
};
var findUserByEmail = async (email3) => {
  const user = await db.query.users.findFirst({
    where: (users2, { eq: eq2 }) => eq2(users2.email, email3)
  });
  return user;
};
var verifyEmail = async (email3) => {
  const user = await findUserByEmail(email3);
  if (!user) {
    return { success: false, error: "Email not registered" };
  }
  const [respon] = await db.update(users).set({ verifiedEmail: true }).where(eq(users.email, email3)).returning();
  return { data: respon };
};
var findUserByUsername = async (username) => {
  const user = await db.query.users.findFirst({
    where: (users2, { eq: eq2 }) => eq2(users2.username, username)
  });
  return user;
};
var findUserById = async (id) => {
  const user = await db.query.users.findFirst({
    where: (users2, { eq: eq2 }) => eq2(users2.id, id)
  });
  return user;
};
var hashPassword = async (password) => {
  return Bun.password.hash(password, {
    algorithm: "argon2id",
    memoryCost: 19456,
    timeCost: 2
  });
};
var verifyPassword = async (password, hashedPassword) => {
  const isValid = await Bun.password.verify(password, hashedPassword);
  return isValid;
};

// node_modules/@elysiajs/bearer/dist/index.mjs
var bearer = ({
  extract: {
    body = "access_token",
    query: queryName = "access_token",
    header = "Bearer"
  } = {
    body: "access_token",
    query: "access_token",
    header: "Bearer"
  }
} = {
  extract: {
    body: "access_token",
    query: "access_token",
    header: "Bearer"
  }
}) => new Elysia({
  name: "@elysiajs/bearer",
  seed: {
    body,
    query: queryName,
    header
  }
}).derive({ as: "global" }, function deriveBearer({ query, headers: { authorization } }) {
  return {
    get bearer() {
      if (authorization?.startsWith(header))
        return authorization.slice(header.length + 1);
      const q = query[queryName];
      if (Array.isArray(q))
        return q[0];
      if (q)
        return q;
    }
  };
});
var index_default = bearer;

// node_modules/jose/dist/webapi/lib/buffer_utils.js
var encoder2 = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT322 = 2 ** 32;
function concat(...buffers) {
  const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i2 = 0;
  for (const buffer2 of buffers) {
    buf.set(buffer2, i2);
    i2 += buffer2.length;
  }
  return buf;
}

// node_modules/jose/dist/webapi/lib/base64.js
function encodeBase64(input) {
  if (Uint8Array.prototype.toBase64) {
    return input.toBase64();
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i2 = 0;i2 < input.length; i2 += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, input.subarray(i2, i2 + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
}
function decodeBase64(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0;i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
}

// node_modules/jose/dist/webapi/util/base64url.js
function decode2(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
function encode2(input) {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder2.encode(unencoded);
  }
  if (Uint8Array.prototype.toBase64) {
    return unencoded.toBase64({ alphabet: "base64url", omitPadding: true });
  }
  return encodeBase64(unencoded).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/jose/dist/webapi/util/errors.js
class JOSEError extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message, options) {
    super(message, options);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  claim;
  reason;
  payload;
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}

class JWTExpired extends JOSEError {
  static code = "ERR_JWT_EXPIRED";
  code = "ERR_JWT_EXPIRED";
  claim;
  reason;
  payload;
  constructor(message, payload, claim = "unspecified", reason = "unspecified") {
    super(message, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  static code = "ERR_JOSE_ALG_NOT_ALLOWED";
  code = "ERR_JOSE_ALG_NOT_ALLOWED";
}

class JOSENotSupported extends JOSEError {
  static code = "ERR_JOSE_NOT_SUPPORTED";
  code = "ERR_JOSE_NOT_SUPPORTED";
}
class JWSInvalid extends JOSEError {
  static code = "ERR_JWS_INVALID";
  code = "ERR_JWS_INVALID";
}

class JWTInvalid extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
}
class JWSSignatureVerificationFailed extends JOSEError {
  static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  constructor(message = "signature verification failed", options) {
    super(message, options);
  }
}

// node_modules/jose/dist/webapi/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (usage && !key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg, usage) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg))
        throw unusable(alg);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}

// node_modules/jose/dist/webapi/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  types2 = types2.filter(Boolean);
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types2) => {
  return message("Key must be ", actual, ...types2);
};
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}

// node_modules/jose/dist/webapi/lib/is_key_like.js
function isCryptoKey(key) {
  return key?.[Symbol.toStringTag] === "CryptoKey";
}
function isKeyObject(key) {
  return key?.[Symbol.toStringTag] === "KeyObject";
}
var is_key_like_default = (key) => {
  return isCryptoKey(key) || isKeyObject(key);
};

// node_modules/jose/dist/webapi/lib/is_disjoint.js
var is_disjoint_default = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};

// node_modules/jose/dist/webapi/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
var is_object_default = (input) => {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
};

// node_modules/jose/dist/webapi/lib/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/webapi/lib/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var jwk_to_key_default = async (jwk) => {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
};

// node_modules/jose/dist/webapi/lib/validate_crit.js
var validate_crit_default = (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) => {
  if (joseHeader.crit !== undefined && protectedHeader?.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
};

// node_modules/jose/dist/webapi/lib/validate_algorithms.js
var validate_algorithms_default = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};

// node_modules/jose/dist/webapi/lib/is_jwk.js
function isJWK(key) {
  return is_object_default(key) && typeof key.kty === "string";
}
function isPrivateJWK(key) {
  return key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");
}
function isPublicJWK(key) {
  return key.kty !== "oct" && typeof key.d === "undefined" && typeof key.priv === "undefined";
}
function isSecretJWK(key) {
  return key.kty === "oct" && typeof key.k === "string";
}

// node_modules/jose/dist/webapi/lib/normalize_key.js
var cache;
var handleJWK = async (key, jwk, alg, freeze = false) => {
  cache ||= new WeakMap;
  let cached2 = cache.get(key);
  if (cached2?.[alg]) {
    return cached2[alg];
  }
  const cryptoKey = await jwk_to_key_default({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached2) {
    cache.set(key, { [alg]: cryptoKey });
  } else {
    cached2[alg] = cryptoKey;
  }
  return cryptoKey;
};
var handleKeyObject = (keyObject, alg) => {
  cache ||= new WeakMap;
  let cached2 = cache.get(keyObject);
  if (cached2?.[alg]) {
    return cached2[alg];
  }
  const isPublic = keyObject.type === "public";
  const extractable = isPublic ? true : false;
  let cryptoKey;
  if (keyObject.asymmetricKeyType === "x25519") {
    switch (alg) {
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
  }
  if (keyObject.asymmetricKeyType === "ed25519") {
    if (alg !== "EdDSA" && alg !== "Ed25519") {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
      isPublic ? "verify" : "sign"
    ]);
  }
  switch (keyObject.asymmetricKeyType) {
    case "ml-dsa-44":
    case "ml-dsa-65":
    case "ml-dsa-87": {
      if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
        isPublic ? "verify" : "sign"
      ]);
    }
  }
  if (keyObject.asymmetricKeyType === "rsa") {
    let hash2;
    switch (alg) {
      case "RSA-OAEP":
        hash2 = "SHA-1";
        break;
      case "RS256":
      case "PS256":
      case "RSA-OAEP-256":
        hash2 = "SHA-256";
        break;
      case "RS384":
      case "PS384":
      case "RSA-OAEP-384":
        hash2 = "SHA-384";
        break;
      case "RS512":
      case "PS512":
      case "RSA-OAEP-512":
        hash2 = "SHA-512";
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg.startsWith("RSA-OAEP")) {
      return keyObject.toCryptoKey({
        name: "RSA-OAEP",
        hash: hash2
      }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
    }
    cryptoKey = keyObject.toCryptoKey({
      name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
      hash: hash2
    }, extractable, [isPublic ? "verify" : "sign"]);
  }
  if (keyObject.asymmetricKeyType === "ec") {
    const nist = new Map([
      ["prime256v1", "P-256"],
      ["secp384r1", "P-384"],
      ["secp521r1", "P-521"]
    ]);
    const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
    if (!namedCurve) {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg === "ES256" && namedCurve === "P-256") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES384" && namedCurve === "P-384") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES512" && namedCurve === "P-521") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg.startsWith("ECDH-ES")) {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDH",
        namedCurve
      }, extractable, isPublic ? [] : ["deriveBits"]);
    }
  }
  if (!cryptoKey) {
    throw new TypeError("given KeyObject instance cannot be used for this algorithm");
  }
  if (!cached2) {
    cache.set(keyObject, { [alg]: cryptoKey });
  } else {
    cached2[alg] = cryptoKey;
  }
  return cryptoKey;
};
var normalize_key_default = async (key, alg) => {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg);
      } catch (err2) {
        if (err2 instanceof TypeError) {
          throw err2;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode2(key.k);
    }
    return handleJWK(key, key, alg, true);
  }
  throw new Error("unreachable");
};

// node_modules/jose/dist/webapi/lib/check_key_type.js
var tag = (key) => key?.[Symbol.toStringTag];
var jwkMatchesOp = (alg, key, usage) => {
  if (key.use !== undefined) {
    let expected;
    switch (usage) {
      case "sign":
      case "verify":
        expected = "sig";
        break;
      case "encrypt":
      case "decrypt":
        expected = "enc";
        break;
    }
    if (key.use !== expected) {
      throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
    }
  }
  if (key.alg !== undefined && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg}" when present`);
  }
  if (Array.isArray(key.key_ops)) {
    let expectedKeyOp;
    switch (true) {
      case (usage === "sign" || usage === "verify"):
      case alg === "dir":
      case alg.includes("CBC-HS"):
        expectedKeyOp = usage;
        break;
      case alg.startsWith("PBES2"):
        expectedKeyOp = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
        if (!alg.includes("GCM") && alg.endsWith("KW")) {
          expectedKeyOp = usage === "encrypt" ? "wrapKey" : "unwrapKey";
        } else {
          expectedKeyOp = usage;
        }
        break;
      case (usage === "encrypt" && alg.startsWith("RSA")):
        expectedKeyOp = "wrapKey";
        break;
      case usage === "decrypt":
        expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
        break;
    }
    if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
      throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
    }
  }
  return true;
};
var symmetricTypeCheck = (alg, key, usage) => {
  if (key instanceof Uint8Array)
    return;
  if (isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (isJWK(key)) {
    switch (usage) {
      case "decrypt":
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "encrypt":
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (key.type === "public") {
    switch (usage) {
      case "sign":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
      case "decrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
      default:
        break;
    }
  }
  if (key.type === "private") {
    switch (usage) {
      case "verify":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
      case "encrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
      default:
        break;
    }
  }
};
var check_key_type_default = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(alg) || /^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key, usage);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};

// node_modules/jose/dist/webapi/lib/subtle_dsa.js
var subtle_dsa_default = (alg, algorithm) => {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: parseInt(alg.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
};

// node_modules/jose/dist/webapi/lib/get_sign_verify_key.js
var get_sign_verify_key_default = async (alg, key, usage) => {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg, usage);
  return key;
};

// node_modules/jose/dist/webapi/lib/verify.js
var verify_default = async (alg, key, signature, data) => {
  const cryptoKey = await get_sign_verify_key_default(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtle_dsa_default(alg, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
};

// node_modules/jose/dist/webapi/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  if (!is_object_default(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !is_object_default(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions2 = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions2.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder2.encode(jws.protected ?? ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k2 = await normalize_key_default(key, alg);
  const verified = await verify_default(alg, k2, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: k2 };
  }
  return result;
}

// node_modules/jose/dist/webapi/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/webapi/lib/epoch.js
var epoch_default = (date7) => Math.floor(date7.getTime() / 1000);

// node_modules/jose/dist/webapi/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
};

// node_modules/jose/dist/webapi/lib/jwt_claims_set.js
function validateInput(label, input) {
  if (!Number.isFinite(input)) {
    throw new TypeError(`Invalid ${label} input`);
  }
  return input;
}
var normalizeTyp = (value) => {
  if (value.includes("/")) {
    return value.toLowerCase();
  }
  return `application/${value.toLowerCase()}`;
};
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {}
  if (!is_object_default(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== undefined)
    presenceCheck.push("iat");
  if (audience !== undefined)
    presenceCheck.push("aud");
  if (subject !== undefined)
    presenceCheck.push("sub");
  if (issuer !== undefined)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max2 = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max2) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}

class JWTClaimsBuilder {
  #payload;
  constructor(payload) {
    if (!is_object_default(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this.#payload = structuredClone(payload);
  }
  data() {
    return encoder2.encode(JSON.stringify(this.#payload));
  }
  get iss() {
    return this.#payload.iss;
  }
  set iss(value) {
    this.#payload.iss = value;
  }
  get sub() {
    return this.#payload.sub;
  }
  set sub(value) {
    this.#payload.sub = value;
  }
  get aud() {
    return this.#payload.aud;
  }
  set aud(value) {
    this.#payload.aud = value;
  }
  set jti(value) {
    this.#payload.jti = value;
  }
  set nbf(value) {
    if (typeof value === "number") {
      this.#payload.nbf = validateInput("setNotBefore", value);
    } else if (value instanceof Date) {
      this.#payload.nbf = validateInput("setNotBefore", epoch_default(value));
    } else {
      this.#payload.nbf = epoch_default(new Date) + secs_default(value);
    }
  }
  set exp(value) {
    if (typeof value === "number") {
      this.#payload.exp = validateInput("setExpirationTime", value);
    } else if (value instanceof Date) {
      this.#payload.exp = validateInput("setExpirationTime", epoch_default(value));
    } else {
      this.#payload.exp = epoch_default(new Date) + secs_default(value);
    }
  }
  set iat(value) {
    if (typeof value === "undefined") {
      this.#payload.iat = epoch_default(new Date);
    } else if (value instanceof Date) {
      this.#payload.iat = validateInput("setIssuedAt", epoch_default(value));
    } else if (typeof value === "string") {
      this.#payload.iat = validateInput("setIssuedAt", epoch_default(new Date) + secs_default(value));
    } else {
      this.#payload.iat = validateInput("setIssuedAt", value);
    }
  }
}

// node_modules/jose/dist/webapi/jwt/verify.js
async function jwtVerify(jwt2, key, options) {
  const verified = await compactVerify(jwt2, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// node_modules/jose/dist/webapi/lib/sign.js
var sign_default = async (alg, key, data) => {
  const cryptoKey = await get_sign_verify_key_default(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await crypto.subtle.sign(subtle_dsa_default(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};

// node_modules/jose/dist/webapi/jws/flattened/sign.js
class FlattenedSign {
  #payload;
  #protectedHeader;
  #unprotectedHeader;
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this.#payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this.#protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this.#protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this.#unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this.#unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this.#protectedHeader && !this.#unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this.#protectedHeader, this.#unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this.#protectedHeader,
      ...this.#unprotectedHeader
    };
    const extensions2 = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options?.crit, this.#protectedHeader, joseHeader);
    let b64 = true;
    if (extensions2.has("b64")) {
      b64 = this.#protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this.#payload;
    if (b64) {
      payload = encoder2.encode(encode2(payload));
    }
    let protectedHeader;
    if (this.#protectedHeader) {
      protectedHeader = encoder2.encode(encode2(JSON.stringify(this.#protectedHeader)));
    } else {
      protectedHeader = encoder2.encode("");
    }
    const data = concat(protectedHeader, encoder2.encode("."), payload);
    const k2 = await normalize_key_default(key, alg);
    const signature = await sign_default(alg, k2, data);
    const jws = {
      signature: encode2(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this.#unprotectedHeader) {
      jws.header = this.#unprotectedHeader;
    }
    if (this.#protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/webapi/jws/compact/sign.js
class CompactSign {
  #flattened;
  constructor(payload) {
    this.#flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this.#flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this.#flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/webapi/jwt/sign.js
class SignJWT {
  #protectedHeader;
  #jwt;
  constructor(payload = {}) {
    this.#jwt = new JWTClaimsBuilder(payload);
  }
  setIssuer(issuer) {
    this.#jwt.iss = issuer;
    return this;
  }
  setSubject(subject) {
    this.#jwt.sub = subject;
    return this;
  }
  setAudience(audience) {
    this.#jwt.aud = audience;
    return this;
  }
  setJti(jwtId) {
    this.#jwt.jti = jwtId;
    return this;
  }
  setNotBefore(input) {
    this.#jwt.nbf = input;
    return this;
  }
  setExpirationTime(input) {
    this.#jwt.exp = input;
    return this;
  }
  setIssuedAt(input) {
    this.#jwt.iat = input;
    return this;
  }
  setProtectedHeader(protectedHeader) {
    this.#protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    const sig = new CompactSign(this.#jwt.data());
    sig.setProtectedHeader(this.#protectedHeader);
    if (Array.isArray(this.#protectedHeader?.crit) && this.#protectedHeader.crit.includes("b64") && this.#protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/@elysiajs/jwt/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: true });
};
var value_exports = {};
__export2(value_exports, {
  HasPropertyKey: () => HasPropertyKey3,
  IsArray: () => IsArray5,
  IsAsyncIterator: () => IsAsyncIterator5,
  IsBigInt: () => IsBigInt5,
  IsBoolean: () => IsBoolean5,
  IsDate: () => IsDate5,
  IsFunction: () => IsFunction5,
  IsIterator: () => IsIterator5,
  IsNull: () => IsNull5,
  IsNumber: () => IsNumber5,
  IsObject: () => IsObject5,
  IsRegExp: () => IsRegExp4,
  IsString: () => IsString5,
  IsSymbol: () => IsSymbol5,
  IsUint8Array: () => IsUint8Array5,
  IsUndefined: () => IsUndefined5
});
function HasPropertyKey3(value, key) {
  return key in value;
}
function IsAsyncIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.asyncIterator in value;
}
function IsArray5(value) {
  return Array.isArray(value);
}
function IsBigInt5(value) {
  return typeof value === "bigint";
}
function IsBoolean5(value) {
  return typeof value === "boolean";
}
function IsDate5(value) {
  return value instanceof globalThis.Date;
}
function IsFunction5(value) {
  return typeof value === "function";
}
function IsIterator5(value) {
  return IsObject5(value) && !IsArray5(value) && !IsUint8Array5(value) && Symbol.iterator in value;
}
function IsNull5(value) {
  return value === null;
}
function IsNumber5(value) {
  return typeof value === "number";
}
function IsObject5(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp4(value) {
  return value instanceof globalThis.RegExp;
}
function IsString5(value) {
  return typeof value === "string";
}
function IsSymbol5(value) {
  return typeof value === "symbol";
}
function IsUint8Array5(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined5(value) {
  return value === undefined;
}
function ArrayType6(value) {
  return value.map((value2) => Visit17(value2));
}
function DateType4(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType3(value) {
  return new Uint8Array(value);
}
function RegExpType2(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType6(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit17(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit17(value[key]);
  }
  return result;
}
function Visit17(value) {
  return IsArray5(value) ? ArrayType6(value) : IsDate5(value) ? DateType4(value) : IsUint8Array5(value) ? Uint8ArrayType3(value) : IsRegExp4(value) ? RegExpType2(value) : IsObject5(value) ? ObjectType6(value) : value;
}
function Clone3(value) {
  return Visit17(value);
}
function CloneType2(schema, options) {
  return options === undefined ? Clone3(schema) : Clone3({ ...options, ...schema });
}
function IsObject22(value) {
  return value !== null && typeof value === "object";
}
function IsArray22(value) {
  return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined22(value) {
  return value === undefined;
}
function IsNumber22(value) {
  return typeof value === "number";
}
var TypeSystemPolicy2;
(function(TypeSystemPolicy22) {
  TypeSystemPolicy22.InstanceMode = "default";
  TypeSystemPolicy22.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy22.AllowArrayObject = false;
  TypeSystemPolicy22.AllowNaN = false;
  TypeSystemPolicy22.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy22.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy22.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject3 = IsObject22(value);
    return TypeSystemPolicy22.AllowArrayObject ? isObject3 : isObject3 && !IsArray22(value);
  }
  TypeSystemPolicy22.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy22.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy22.AllowNaN ? IsNumber22(value) : Number.isFinite(value);
  }
  TypeSystemPolicy22.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined22(value);
    return TypeSystemPolicy22.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy22.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy2 || (TypeSystemPolicy2 = {}));
function ImmutableArray2(value) {
  return globalThis.Object.freeze(value).map((value2) => Immutable2(value2));
}
function ImmutableDate2(value) {
  return value;
}
function ImmutableUint8Array2(value) {
  return value;
}
function ImmutableRegExp2(value) {
  return value;
}
function ImmutableObject2(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Immutable2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Immutable2(value[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable2(value) {
  return IsArray5(value) ? ImmutableArray2(value) : IsDate5(value) ? ImmutableDate2(value) : IsUint8Array5(value) ? ImmutableUint8Array2(value) : IsRegExp4(value) ? ImmutableRegExp2(value) : IsObject5(value) ? ImmutableObject2(value) : value;
}
function CreateType2(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy2.InstanceMode) {
    case "freeze":
      return Immutable2(result);
    case "clone":
      return Clone3(result);
    default:
      return result;
  }
}
var TypeBoxError2 = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint3 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
function IsReadonly3(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional3(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny3(value) {
  return IsKindOf3(value, "Any");
}
function IsArgument3(value) {
  return IsKindOf3(value, "Argument");
}
function IsArray32(value) {
  return IsKindOf3(value, "Array");
}
function IsAsyncIterator22(value) {
  return IsKindOf3(value, "AsyncIterator");
}
function IsBigInt22(value) {
  return IsKindOf3(value, "BigInt");
}
function IsBoolean22(value) {
  return IsKindOf3(value, "Boolean");
}
function IsComputed3(value) {
  return IsKindOf3(value, "Computed");
}
function IsConstructor3(value) {
  return IsKindOf3(value, "Constructor");
}
function IsDate22(value) {
  return IsKindOf3(value, "Date");
}
function IsFunction22(value) {
  return IsKindOf3(value, "Function");
}
function IsInteger4(value) {
  return IsKindOf3(value, "Integer");
}
function IsIntersect3(value) {
  return IsKindOf3(value, "Intersect");
}
function IsIterator22(value) {
  return IsKindOf3(value, "Iterator");
}
function IsKindOf3(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralValue3(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsLiteral3(value) {
  return IsKindOf3(value, "Literal");
}
function IsMappedKey3(value) {
  return IsKindOf3(value, "MappedKey");
}
function IsMappedResult3(value) {
  return IsKindOf3(value, "MappedResult");
}
function IsNever3(value) {
  return IsKindOf3(value, "Never");
}
function IsNot3(value) {
  return IsKindOf3(value, "Not");
}
function IsNull22(value) {
  return IsKindOf3(value, "Null");
}
function IsNumber32(value) {
  return IsKindOf3(value, "Number");
}
function IsObject32(value) {
  return IsKindOf3(value, "Object");
}
function IsPromise4(value) {
  return IsKindOf3(value, "Promise");
}
function IsRecord3(value) {
  return IsKindOf3(value, "Record");
}
function IsRef3(value) {
  return IsKindOf3(value, "Ref");
}
function IsRegExp22(value) {
  return IsKindOf3(value, "RegExp");
}
function IsString22(value) {
  return IsKindOf3(value, "String");
}
function IsSymbol22(value) {
  return IsKindOf3(value, "Symbol");
}
function IsTemplateLiteral3(value) {
  return IsKindOf3(value, "TemplateLiteral");
}
function IsThis3(value) {
  return IsKindOf3(value, "This");
}
function IsTransform3(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple3(value) {
  return IsKindOf3(value, "Tuple");
}
function IsUndefined32(value) {
  return IsKindOf3(value, "Undefined");
}
function IsUnion3(value) {
  return IsKindOf3(value, "Union");
}
function IsUint8Array22(value) {
  return IsKindOf3(value, "Uint8Array");
}
function IsUnknown3(value) {
  return IsKindOf3(value, "Unknown");
}
function IsUnsafe3(value) {
  return IsKindOf3(value, "Unsafe");
}
function IsVoid3(value) {
  return IsKindOf3(value, "Void");
}
function IsKind3(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]);
}
function IsSchema3(value) {
  return IsAny3(value) || IsArgument3(value) || IsArray32(value) || IsBoolean22(value) || IsBigInt22(value) || IsAsyncIterator22(value) || IsComputed3(value) || IsConstructor3(value) || IsDate22(value) || IsFunction22(value) || IsInteger4(value) || IsIntersect3(value) || IsIterator22(value) || IsLiteral3(value) || IsMappedKey3(value) || IsMappedResult3(value) || IsNever3(value) || IsNot3(value) || IsNull22(value) || IsNumber32(value) || IsObject32(value) || IsPromise4(value) || IsRecord3(value) || IsRef3(value) || IsRegExp22(value) || IsString22(value) || IsSymbol22(value) || IsTemplateLiteral3(value) || IsThis3(value) || IsTuple3(value) || IsUndefined32(value) || IsUnion3(value) || IsUint8Array22(value) || IsUnknown3(value) || IsUnsafe3(value) || IsVoid3(value) || IsKind3(value);
}
var type_exports = {};
__export2(type_exports, {
  IsAny: () => IsAny22,
  IsArgument: () => IsArgument22,
  IsArray: () => IsArray42,
  IsAsyncIterator: () => IsAsyncIterator32,
  IsBigInt: () => IsBigInt32,
  IsBoolean: () => IsBoolean32,
  IsComputed: () => IsComputed22,
  IsConstructor: () => IsConstructor22,
  IsDate: () => IsDate32,
  IsFunction: () => IsFunction32,
  IsImport: () => IsImport2,
  IsInteger: () => IsInteger22,
  IsIntersect: () => IsIntersect22,
  IsIterator: () => IsIterator32,
  IsKind: () => IsKind22,
  IsKindOf: () => IsKindOf22,
  IsLiteral: () => IsLiteral22,
  IsLiteralBoolean: () => IsLiteralBoolean2,
  IsLiteralNumber: () => IsLiteralNumber2,
  IsLiteralString: () => IsLiteralString2,
  IsLiteralValue: () => IsLiteralValue22,
  IsMappedKey: () => IsMappedKey22,
  IsMappedResult: () => IsMappedResult22,
  IsNever: () => IsNever22,
  IsNot: () => IsNot22,
  IsNull: () => IsNull32,
  IsNumber: () => IsNumber42,
  IsObject: () => IsObject42,
  IsOptional: () => IsOptional22,
  IsPromise: () => IsPromise22,
  IsProperties: () => IsProperties2,
  IsReadonly: () => IsReadonly22,
  IsRecord: () => IsRecord22,
  IsRecursive: () => IsRecursive2,
  IsRef: () => IsRef22,
  IsRegExp: () => IsRegExp32,
  IsSchema: () => IsSchema22,
  IsString: () => IsString32,
  IsSymbol: () => IsSymbol32,
  IsTemplateLiteral: () => IsTemplateLiteral22,
  IsThis: () => IsThis22,
  IsTransform: () => IsTransform22,
  IsTuple: () => IsTuple22,
  IsUint8Array: () => IsUint8Array32,
  IsUndefined: () => IsUndefined42,
  IsUnion: () => IsUnion22,
  IsUnionLiteral: () => IsUnionLiteral2,
  IsUnknown: () => IsUnknown22,
  IsUnsafe: () => IsUnsafe22,
  IsVoid: () => IsVoid22,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError2
});
var TypeGuardUnknownTypeError2 = class extends TypeBoxError2 {
};
var KnownTypes2 = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern2(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree2(value) {
  if (!IsString5(value))
    return false;
  for (let i2 = 0;i2 < value.length; i2++) {
    const code = value.charCodeAt(i2);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties2(value) {
  return IsOptionalBoolean2(value) || IsSchema22(value);
}
function IsOptionalBigInt2(value) {
  return IsUndefined5(value) || IsBigInt5(value);
}
function IsOptionalNumber2(value) {
  return IsUndefined5(value) || IsNumber5(value);
}
function IsOptionalBoolean2(value) {
  return IsUndefined5(value) || IsBoolean5(value);
}
function IsOptionalString2(value) {
  return IsUndefined5(value) || IsString5(value);
}
function IsOptionalPattern2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value) && IsPattern2(value);
}
function IsOptionalFormat2(value) {
  return IsUndefined5(value) || IsString5(value) && IsControlCharacterFree2(value);
}
function IsOptionalSchema2(value) {
  return IsUndefined5(value) || IsSchema22(value);
}
function IsReadonly22(value) {
  return IsObject5(value) && value[ReadonlyKind2] === "Readonly";
}
function IsOptional22(value) {
  return IsObject5(value) && value[OptionalKind2] === "Optional";
}
function IsAny22(value) {
  return IsKindOf22(value, "Any") && IsOptionalString2(value.$id);
}
function IsArgument22(value) {
  return IsKindOf22(value, "Argument") && IsNumber5(value.index);
}
function IsArray42(value) {
  return IsKindOf22(value, "Array") && value.type === "array" && IsOptionalString2(value.$id) && IsSchema22(value.items) && IsOptionalNumber2(value.minItems) && IsOptionalNumber2(value.maxItems) && IsOptionalBoolean2(value.uniqueItems) && IsOptionalSchema2(value.contains) && IsOptionalNumber2(value.minContains) && IsOptionalNumber2(value.maxContains);
}
function IsAsyncIterator32(value) {
  return IsKindOf22(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString2(value.$id) && IsSchema22(value.items);
}
function IsBigInt32(value) {
  return IsKindOf22(value, "BigInt") && value.type === "bigint" && IsOptionalString2(value.$id) && IsOptionalBigInt2(value.exclusiveMaximum) && IsOptionalBigInt2(value.exclusiveMinimum) && IsOptionalBigInt2(value.maximum) && IsOptionalBigInt2(value.minimum) && IsOptionalBigInt2(value.multipleOf);
}
function IsBoolean32(value) {
  return IsKindOf22(value, "Boolean") && value.type === "boolean" && IsOptionalString2(value.$id);
}
function IsComputed22(value) {
  return IsKindOf22(value, "Computed") && IsString5(value.target) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema));
}
function IsConstructor22(value) {
  return IsKindOf22(value, "Constructor") && value.type === "Constructor" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsDate32(value) {
  return IsKindOf22(value, "Date") && value.type === "Date" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximumTimestamp) && IsOptionalNumber2(value.exclusiveMinimumTimestamp) && IsOptionalNumber2(value.maximumTimestamp) && IsOptionalNumber2(value.minimumTimestamp) && IsOptionalNumber2(value.multipleOfTimestamp);
}
function IsFunction32(value) {
  return IsKindOf22(value, "Function") && value.type === "Function" && IsOptionalString2(value.$id) && IsArray5(value.parameters) && value.parameters.every((schema) => IsSchema22(schema)) && IsSchema22(value.returns);
}
function IsImport2(value) {
  return IsKindOf22(value, "Import") && HasPropertyKey3(value, "$defs") && IsObject5(value.$defs) && IsProperties2(value.$defs) && HasPropertyKey3(value, "$ref") && IsString5(value.$ref) && value.$ref in value.$defs;
}
function IsInteger22(value) {
  return IsKindOf22(value, "Integer") && value.type === "integer" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsProperties2(value) {
  return IsObject5(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree2(key) && IsSchema22(schema));
}
function IsIntersect22(value) {
  return IsKindOf22(value, "Intersect") && (IsString5(value.type) && value.type !== "object" ? false : true) && IsArray5(value.allOf) && value.allOf.every((schema) => IsSchema22(schema) && !IsTransform22(schema)) && IsOptionalString2(value.type) && (IsOptionalBoolean2(value.unevaluatedProperties) || IsOptionalSchema2(value.unevaluatedProperties)) && IsOptionalString2(value.$id);
}
function IsIterator32(value) {
  return IsKindOf22(value, "Iterator") && value.type === "Iterator" && IsOptionalString2(value.$id) && IsSchema22(value.items);
}
function IsKindOf22(value, kind) {
  return IsObject5(value) && Kind2 in value && value[Kind2] === kind;
}
function IsLiteralString2(value) {
  return IsLiteral22(value) && IsString5(value.const);
}
function IsLiteralNumber2(value) {
  return IsLiteral22(value) && IsNumber5(value.const);
}
function IsLiteralBoolean2(value) {
  return IsLiteral22(value) && IsBoolean5(value.const);
}
function IsLiteral22(value) {
  return IsKindOf22(value, "Literal") && IsOptionalString2(value.$id) && IsLiteralValue22(value.const);
}
function IsLiteralValue22(value) {
  return IsBoolean5(value) || IsNumber5(value) || IsString5(value);
}
function IsMappedKey22(value) {
  return IsKindOf22(value, "MappedKey") && IsArray5(value.keys) && value.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult22(value) {
  return IsKindOf22(value, "MappedResult") && IsProperties2(value.properties);
}
function IsNever22(value) {
  return IsKindOf22(value, "Never") && IsObject5(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot22(value) {
  return IsKindOf22(value, "Not") && IsSchema22(value.not);
}
function IsNull32(value) {
  return IsKindOf22(value, "Null") && value.type === "null" && IsOptionalString2(value.$id);
}
function IsNumber42(value) {
  return IsKindOf22(value, "Number") && value.type === "number" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.exclusiveMaximum) && IsOptionalNumber2(value.exclusiveMinimum) && IsOptionalNumber2(value.maximum) && IsOptionalNumber2(value.minimum) && IsOptionalNumber2(value.multipleOf);
}
function IsObject42(value) {
  return IsKindOf22(value, "Object") && value.type === "object" && IsOptionalString2(value.$id) && IsProperties2(value.properties) && IsAdditionalProperties2(value.additionalProperties) && IsOptionalNumber2(value.minProperties) && IsOptionalNumber2(value.maxProperties);
}
function IsPromise22(value) {
  return IsKindOf22(value, "Promise") && value.type === "Promise" && IsOptionalString2(value.$id) && IsSchema22(value.item);
}
function IsRecord22(value) {
  return IsKindOf22(value, "Record") && value.type === "object" && IsOptionalString2(value.$id) && IsAdditionalProperties2(value.additionalProperties) && IsObject5(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema.patternProperties) && IsSchema22(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive2(value) {
  return IsObject5(value) && Hint3 in value && value[Hint3] === "Recursive";
}
function IsRef22(value) {
  return IsKindOf22(value, "Ref") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsRegExp32(value) {
  return IsKindOf22(value, "RegExp") && IsOptionalString2(value.$id) && IsString5(value.source) && IsString5(value.flags) && IsOptionalNumber2(value.maxLength) && IsOptionalNumber2(value.minLength);
}
function IsString32(value) {
  return IsKindOf22(value, "String") && value.type === "string" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minLength) && IsOptionalNumber2(value.maxLength) && IsOptionalPattern2(value.pattern) && IsOptionalFormat2(value.format);
}
function IsSymbol32(value) {
  return IsKindOf22(value, "Symbol") && value.type === "symbol" && IsOptionalString2(value.$id);
}
function IsTemplateLiteral22(value) {
  return IsKindOf22(value, "TemplateLiteral") && value.type === "string" && IsString5(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis22(value) {
  return IsKindOf22(value, "This") && IsOptionalString2(value.$id) && IsString5(value.$ref);
}
function IsTransform22(value) {
  return IsObject5(value) && TransformKind2 in value;
}
function IsTuple22(value) {
  return IsKindOf22(value, "Tuple") && value.type === "array" && IsOptionalString2(value.$id) && IsNumber5(value.minItems) && IsNumber5(value.maxItems) && value.minItems === value.maxItems && (IsUndefined5(value.items) && IsUndefined5(value.additionalItems) && value.minItems === 0 || IsArray5(value.items) && value.items.every((schema) => IsSchema22(schema)));
}
function IsUndefined42(value) {
  return IsKindOf22(value, "Undefined") && value.type === "undefined" && IsOptionalString2(value.$id);
}
function IsUnionLiteral2(value) {
  return IsUnion22(value) && value.anyOf.every((schema) => IsLiteralString2(schema) || IsLiteralNumber2(schema));
}
function IsUnion22(value) {
  return IsKindOf22(value, "Union") && IsOptionalString2(value.$id) && IsObject5(value) && IsArray5(value.anyOf) && value.anyOf.every((schema) => IsSchema22(schema));
}
function IsUint8Array32(value) {
  return IsKindOf22(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString2(value.$id) && IsOptionalNumber2(value.minByteLength) && IsOptionalNumber2(value.maxByteLength);
}
function IsUnknown22(value) {
  return IsKindOf22(value, "Unknown") && IsOptionalString2(value.$id);
}
function IsUnsafe22(value) {
  return IsKindOf22(value, "Unsafe");
}
function IsVoid22(value) {
  return IsKindOf22(value, "Void") && value.type === "void" && IsOptionalString2(value.$id);
}
function IsKind22(value) {
  return IsObject5(value) && Kind2 in value && IsString5(value[Kind2]) && !KnownTypes2.includes(value[Kind2]);
}
function IsSchema22(value) {
  return IsObject5(value) && (IsAny22(value) || IsArgument22(value) || IsArray42(value) || IsBoolean32(value) || IsBigInt32(value) || IsAsyncIterator32(value) || IsComputed22(value) || IsConstructor22(value) || IsDate32(value) || IsFunction32(value) || IsInteger22(value) || IsIntersect22(value) || IsIterator32(value) || IsLiteral22(value) || IsMappedKey22(value) || IsMappedResult22(value) || IsNever22(value) || IsNot22(value) || IsNull32(value) || IsNumber42(value) || IsObject42(value) || IsPromise22(value) || IsRecord22(value) || IsRef22(value) || IsRegExp32(value) || IsString32(value) || IsSymbol32(value) || IsTemplateLiteral22(value) || IsThis22(value) || IsTuple22(value) || IsUndefined42(value) || IsUnion22(value) || IsUint8Array32(value) || IsUnknown22(value) || IsUnsafe22(value) || IsVoid22(value) || IsKind22(value));
}
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternNever2 = "(?!.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}$`;
var PatternNumberExact2 = `^${PatternNumber2}$`;
var PatternStringExact2 = `^${PatternString2}$`;
var PatternNeverExact2 = `^${PatternNever2}$`;
function SetIncludes2(T2, S) {
  return T2.includes(S);
}
function SetDistinct2(T2) {
  return [...new Set(T2)];
}
function SetIntersect2(T2, S) {
  return T2.filter((L) => S.includes(L));
}
function SetIntersectManyResolve2(T2, Init) {
  return T2.reduce((Acc, L) => {
    return SetIntersect2(Acc, L);
  }, Init);
}
function SetIntersectMany2(T2) {
  return T2.length === 1 ? T2[0] : T2.length > 1 ? SetIntersectManyResolve2(T2.slice(1), T2[0]) : [];
}
function SetUnionMany2(T2) {
  const Acc = [];
  for (const L of T2)
    Acc.push(...L);
  return Acc;
}
function Any2(options) {
  return CreateType2({ [Kind2]: "Any" }, options);
}
function Array22(items, options) {
  return CreateType2({ [Kind2]: "Array", type: "array", items }, options);
}
function Argument2(index) {
  return CreateType2({ [Kind2]: "Argument", index });
}
function AsyncIterator2(items, options) {
  return CreateType2({ [Kind2]: "AsyncIterator", type: "AsyncIterator", items }, options);
}
function Computed2(target, parameters, options) {
  return CreateType2({ [Kind2]: "Computed", target, parameters }, options);
}
function DiscardKey2(value, key) {
  const { [key]: _2, ...rest } = value;
  return rest;
}
function Discard2(value, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value);
}
function Never2(options) {
  return CreateType2({ [Kind2]: "Never", not: {} }, options);
}
function MappedResult2(properties) {
  return CreateType2({
    [Kind2]: "MappedResult",
    properties
  });
}
function Constructor2(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Constructor", type: "Constructor", parameters, returns }, options);
}
function Function3(parameters, returns, options) {
  return CreateType2({ [Kind2]: "Function", type: "Function", parameters, returns }, options);
}
function UnionCreate2(T2, options) {
  return CreateType2({ [Kind2]: "Union", anyOf: T2 }, options);
}
function IsUnionOptional2(types2) {
  return types2.some((type) => IsOptional3(type));
}
function RemoveOptionalFromRest3(types2) {
  return types2.map((left) => IsOptional3(left) ? RemoveOptionalFromType3(left) : left);
}
function RemoveOptionalFromType3(T2) {
  return Discard2(T2, [OptionalKind2]);
}
function ResolveUnion2(types2, options) {
  const isOptional2 = IsUnionOptional2(types2);
  return isOptional2 ? Optional2(UnionCreate2(RemoveOptionalFromRest3(types2), options)) : UnionCreate2(RemoveOptionalFromRest3(types2), options);
}
function UnionEvaluated2(T2, options) {
  return T2.length === 1 ? CreateType2(T2[0], options) : T2.length === 0 ? Never2(options) : ResolveUnion2(T2, options);
}
function Union3(types2, options) {
  return types2.length === 0 ? Never2(options) : types2.length === 1 ? CreateType2(types2[0], options) : UnionCreate2(types2, options);
}
var TemplateLiteralParserError2 = class extends TypeBoxError2 {
};
function Unescape2(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped2(pattern, index, char2) {
  return pattern[index] === char2 && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, "(");
}
function IsCloseParen2(pattern, index) {
  return IsNonEscaped2(pattern, index, ")");
}
function IsSeparator2(pattern, index) {
  return IsNonEscaped2(pattern, index, "|");
}
function IsGroup2(pattern) {
  if (!(IsOpenParen2(pattern, 0) && IsCloseParen2(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup2(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr2(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd2(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      return true;
  }
  return false;
}
function Or2(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index))
      count += 1;
    if (IsCloseParen2(pattern, index))
      count -= 1;
    if (IsSeparator2(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern) {
  function Group(value, index) {
    if (!IsOpenParen2(value, index))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen2(value, scan))
        count += 1;
      if (IsCloseParen2(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen2(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen2(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse2(pattern) {
  return IsGroup2(pattern) ? TemplateLiteralParse2(InGroup2(pattern)) : IsPrecedenceOr2(pattern) ? Or2(pattern) : IsPrecedenceAnd2(pattern) ? And2(pattern) : { type: "const", const: Unescape2(pattern) };
}
function TemplateLiteralParseExact2(pattern) {
  return TemplateLiteralParse2(pattern.slice(1, pattern.length - 1));
}
var TemplateLiteralFiniteError2 = class extends TypeBoxError2 {
};
function IsNumberExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression2(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}
var TemplateLiteralGenerateError2 = class extends TypeBoxError2 {
};
function* GenerateReduce2(buffer2) {
  if (buffer2.length === 1)
    return yield* buffer2[0];
  for (const left of buffer2[0]) {
    for (const right of GenerateReduce2(buffer2.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}
function Literal2(value, options) {
  return CreateType2({
    [Kind2]: "Literal",
    const: value,
    type: typeof value
  }, options);
}
function Boolean3(options) {
  return CreateType2({ [Kind2]: "Boolean", type: "boolean" }, options);
}
function BigInt3(options) {
  return CreateType2({ [Kind2]: "BigInt", type: "bigint" }, options);
}
function Number22(options) {
  return CreateType2({ [Kind2]: "Number", type: "number" }, options);
}
function String3(options) {
  return CreateType2({ [Kind2]: "String", type: "string" }, options);
}
function* FromUnion21(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number22() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal2(literal2.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal2("$");
    const R = FromSyntax2(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i2 = 2;i2 < syntax.length; i2++) {
    if (syntax[i2] === "}") {
      const L = FromUnion21(syntax.slice(2, i2));
      const R = FromSyntax2(syntax.slice(i2 + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal2(syntax);
}
function* FromSyntax2(syntax) {
  for (let i2 = 0;i2 < syntax.length; i2++) {
    if (syntax[i2] === "$") {
      const L = Literal2(syntax.slice(0, i2));
      const R = FromTerminal2(syntax.slice(i2));
      return yield* [L, ...R];
    }
  }
  yield Literal2(syntax);
}
function TemplateLiteralSyntax2(syntax) {
  return [...FromSyntax2(syntax)];
}
var TemplateLiteralPatternError2 = class extends TypeBoxError2 {
};
function Escape3(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit22(schema, acc) {
  return IsTemplateLiteral3(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion3(schema) ? `(${schema.anyOf.map((schema2) => Visit22(schema2, acc)).join("|")})` : IsNumber32(schema) ? `${acc}${PatternNumber2}` : IsInteger4(schema) ? `${acc}${PatternNumber2}` : IsBigInt22(schema) ? `${acc}${PatternNumber2}` : IsString22(schema) ? `${acc}${PatternString2}` : IsLiteral3(schema) ? `${acc}${Escape3(schema.const.toString())}` : IsBoolean22(schema) ? `${acc}${PatternBoolean2}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema[Kind2]}'`);
  })();
}
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema) => Visit22(schema, "")).join("")}$`;
}
function TemplateLiteralToUnion2(schema) {
  const R = TemplateLiteralGenerate2(schema);
  const L = R.map((S) => Literal2(S));
  return UnionEvaluated2(L);
}
function TemplateLiteral2(unresolved, options) {
  const pattern = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return CreateType2({ [Kind2]: "TemplateLiteral", type: "string", pattern }, options);
}
function FromTemplateLiteral7(templateLiteral2) {
  const keys = TemplateLiteralGenerate2(templateLiteral2);
  return keys.map((key) => key.toString());
}
function FromUnion22(types2) {
  const result = [];
  for (const type of types2)
    result.push(...IndexPropertyKeys2(type));
  return result;
}
function FromLiteral7(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys2(type) {
  return [...new Set(IsTemplateLiteral3(type) ? FromTemplateLiteral7(type) : IsUnion3(type) ? FromUnion22(type.anyOf) : IsLiteral3(type) ? FromLiteral7(type.const) : IsNumber32(type) ? ["[number]"] : IsInteger4(type) ? ["[number]"] : [])];
}
function FromProperties20(type, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index2(type, IndexPropertyKeys2(properties[K2]), options);
  }
  return result;
}
function FromMappedResult13(type, mappedResult, options) {
  return FromProperties20(type, mappedResult.properties, options);
}
function IndexFromMappedResult2(type, mappedResult, options) {
  const properties = FromMappedResult13(type, mappedResult, options);
  return MappedResult2(properties);
}
function FromRest8(types2, key) {
  return types2.map((type) => IndexFromPropertyKey2(type, key));
}
function FromIntersectRest2(types2) {
  return types2.filter((type) => !IsNever3(type));
}
function FromIntersect19(types2, key) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest8(types2, key)));
}
function FromUnionRest2(types2) {
  return types2.some((L) => IsNever3(L)) ? [] : types2;
}
function FromUnion32(types2, key) {
  return UnionEvaluated2(FromUnionRest2(FromRest8(types2, key)));
}
function FromTuple16(types2, key) {
  return key in types2 ? types2[key] : key === "[number]" ? UnionEvaluated2(types2) : Never2();
}
function FromArray18(type, key) {
  return key === "[number]" ? type : Never2();
}
function FromProperty4(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never2();
}
function IndexFromPropertyKey2(type, propertyKey) {
  return IsIntersect3(type) ? FromIntersect19(type.allOf, propertyKey) : IsUnion3(type) ? FromUnion32(type.anyOf, propertyKey) : IsTuple3(type) ? FromTuple16(type.items ?? [], propertyKey) : IsArray32(type) ? FromArray18(type.items, propertyKey) : IsObject32(type) ? FromProperty4(type.properties, propertyKey) : Never2();
}
function IndexFromPropertyKeys2(type, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey2(type, propertyKey));
}
function FromSchema2(type, propertyKeys) {
  return UnionEvaluated2(IndexFromPropertyKeys2(type, propertyKeys));
}
function Index2(type, key, options) {
  if (IsRef3(type) || IsRef3(key)) {
    const error40 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema3(type) || !IsSchema3(key))
      throw new TypeBoxError2(error40);
    return Computed2("Index", [type, key]);
  }
  if (IsMappedResult3(key))
    return IndexFromMappedResult2(type, key, options);
  if (IsMappedKey3(key))
    return IndexFromMappedKey2(type, key, options);
  return CreateType2(IsSchema3(key) ? FromSchema2(type, IndexPropertyKeys2(key)) : FromSchema2(type, key), options);
}
function MappedIndexPropertyKey2(type, key, options) {
  return { [key]: Index2(type, [key], Clone3(options)) };
}
function MappedIndexPropertyKeys2(type, propertyKeys, options) {
  return propertyKeys.reduce((result, left) => {
    return { ...result, ...MappedIndexPropertyKey2(type, left, options) };
  }, {});
}
function MappedIndexProperties2(type, mappedKey, options) {
  return MappedIndexPropertyKeys2(type, mappedKey.keys, options);
}
function IndexFromMappedKey2(type, mappedKey, options) {
  const properties = MappedIndexProperties2(type, mappedKey, options);
  return MappedResult2(properties);
}
function Iterator2(items, options) {
  return CreateType2({ [Kind2]: "Iterator", type: "Iterator", items }, options);
}
function RequiredKeys2(properties) {
  const keys = [];
  for (let key in properties) {
    if (!IsOptional3(properties[key]))
      keys.push(key);
  }
  return keys;
}
function _Object2(properties, options) {
  const required2 = RequiredKeys2(properties);
  const schematic = required2.length > 0 ? { [Kind2]: "Object", type: "object", properties, required: required2 } : { [Kind2]: "Object", type: "object", properties };
  return CreateType2(schematic, options);
}
var Object22 = _Object2;
function Promise22(item, options) {
  return CreateType2({ [Kind2]: "Promise", type: "Promise", item }, options);
}
function RemoveReadonly2(schema) {
  return CreateType2(Discard2(schema, [ReadonlyKind2]));
}
function AddReadonly2(schema) {
  return CreateType2({ ...schema, [ReadonlyKind2]: "Readonly" });
}
function ReadonlyWithFlag2(schema, F) {
  return F === false ? RemoveReadonly2(schema) : AddReadonly2(schema);
}
function Readonly2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? ReadonlyFromMappedResult2(schema, F) : ReadonlyWithFlag2(schema, F);
}
function FromProperties22(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly2(K[K2], F);
  return Acc;
}
function FromMappedResult22(R, F) {
  return FromProperties22(R.properties, F);
}
function ReadonlyFromMappedResult2(R, F) {
  const P = FromMappedResult22(R, F);
  return MappedResult2(P);
}
function Tuple2(types2, options) {
  return CreateType2(types2.length > 0 ? { [Kind2]: "Tuple", type: "array", items: types2, additionalItems: false, minItems: types2.length, maxItems: types2.length } : { [Kind2]: "Tuple", type: "array", minItems: types2.length, maxItems: types2.length }, options);
}
function FromMappedResult32(K, P) {
  return K in P ? FromSchemaType2(K, P[K]) : MappedResult2(P);
}
function MappedKeyToKnownMappedResultProperties2(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties2(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal2(L);
  return Acc;
}
function MappedKeyToMappedResultProperties2(K, P) {
  return SetIncludes2(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
}
function FromMappedKey5(K, P) {
  const R = MappedKeyToMappedResultProperties2(K, P);
  return FromMappedResult32(K, R);
}
function FromRest22(K, T2) {
  return T2.map((L) => FromSchemaType2(K, L));
}
function FromProperties32(K, T2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T2))
    Acc[K2] = FromSchemaType2(K, T2[K2]);
  return Acc;
}
function FromSchemaType2(K, T2) {
  const options = { ...T2 };
  return IsOptional3(T2) ? Optional2(FromSchemaType2(K, Discard2(T2, [OptionalKind2]))) : IsReadonly3(T2) ? Readonly2(FromSchemaType2(K, Discard2(T2, [ReadonlyKind2]))) : IsMappedResult3(T2) ? FromMappedResult32(K, T2.properties) : IsMappedKey3(T2) ? FromMappedKey5(K, T2.keys) : IsConstructor3(T2) ? Constructor2(FromRest22(K, T2.parameters), FromSchemaType2(K, T2.returns), options) : IsFunction22(T2) ? Function3(FromRest22(K, T2.parameters), FromSchemaType2(K, T2.returns), options) : IsAsyncIterator22(T2) ? AsyncIterator2(FromSchemaType2(K, T2.items), options) : IsIterator22(T2) ? Iterator2(FromSchemaType2(K, T2.items), options) : IsIntersect3(T2) ? Intersect3(FromRest22(K, T2.allOf), options) : IsUnion3(T2) ? Union3(FromRest22(K, T2.anyOf), options) : IsTuple3(T2) ? Tuple2(FromRest22(K, T2.items ?? []), options) : IsObject32(T2) ? Object22(FromProperties32(K, T2.properties), options) : IsArray32(T2) ? Array22(FromSchemaType2(K, T2.items), options) : IsPromise4(T2) ? Promise22(FromSchemaType2(K, T2.item), options) : T2;
}
function MappedFunctionReturnType2(K, T2) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType2(L, T2);
  return Acc;
}
function Mapped2(key, map4, options) {
  const K = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const RT = map4({ [Kind2]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType2(K, RT);
  return Object22(R, options);
}
function RemoveOptional2(schema) {
  return CreateType2(Discard2(schema, [OptionalKind2]));
}
function AddOptional2(schema) {
  return CreateType2({ ...schema, [OptionalKind2]: "Optional" });
}
function OptionalWithFlag2(schema, F) {
  return F === false ? RemoveOptional2(schema) : AddOptional2(schema);
}
function Optional2(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema) ? OptionalFromMappedResult2(schema, F) : OptionalWithFlag2(schema, F);
}
function FromProperties42(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional2(P[K2], F);
  return Acc;
}
function FromMappedResult42(R, F) {
  return FromProperties42(R.properties, F);
}
function OptionalFromMappedResult2(R, F) {
  const P = FromMappedResult42(R, F);
  return MappedResult2(P);
}
function IntersectCreate2(T2, options = {}) {
  const allObjects = T2.every((schema) => IsObject32(schema));
  const clonedUnevaluatedProperties = IsSchema3(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType2(options.unevaluatedProperties === false || IsSchema3(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", type: "object", allOf: T2 } : { ...clonedUnevaluatedProperties, [Kind2]: "Intersect", allOf: T2 }, options);
}
function IsIntersectOptional2(types2) {
  return types2.every((left) => IsOptional3(left));
}
function RemoveOptionalFromType22(type) {
  return Discard2(type, [OptionalKind2]);
}
function RemoveOptionalFromRest22(types2) {
  return types2.map((left) => IsOptional3(left) ? RemoveOptionalFromType22(left) : left);
}
function ResolveIntersect2(types2, options) {
  return IsIntersectOptional2(types2) ? Optional2(IntersectCreate2(RemoveOptionalFromRest22(types2), options)) : IntersectCreate2(RemoveOptionalFromRest22(types2), options);
}
function IntersectEvaluated2(types2, options = {}) {
  if (types2.length === 1)
    return CreateType2(types2[0], options);
  if (types2.length === 0)
    return Never2(options);
  if (types2.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(types2, options);
}
function Intersect3(types2, options) {
  if (types2.length === 1)
    return CreateType2(types2[0], options);
  if (types2.length === 0)
    return Never2(options);
  if (types2.some((schema) => IsTransform3(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(types2, options);
}
function Ref2(...args) {
  const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError2("Ref: $ref must be a string");
  return CreateType2({ [Kind2]: "Ref", $ref }, options);
}
function FromComputed6(target, parameters) {
  return Computed2("Awaited", [Computed2(target, parameters)]);
}
function FromRef15($ref) {
  return Computed2("Awaited", [Ref2($ref)]);
}
function FromIntersect22(types2) {
  return Intersect3(FromRest32(types2));
}
function FromUnion42(types2) {
  return Union3(FromRest32(types2));
}
function FromPromise8(type) {
  return Awaited2(type);
}
function FromRest32(types2) {
  return types2.map((type) => Awaited2(type));
}
function Awaited2(type, options) {
  return CreateType2(IsComputed3(type) ? FromComputed6(type.target, type.parameters) : IsIntersect3(type) ? FromIntersect22(type.allOf) : IsUnion3(type) ? FromUnion42(type.anyOf) : IsPromise4(type) ? FromPromise8(type.item) : IsRef3(type) ? FromRef15(type.$ref) : type, options);
}
function FromRest42(types2) {
  const result = [];
  for (const L of types2)
    result.push(KeyOfPropertyKeys2(L));
  return result;
}
function FromIntersect32(types2) {
  const propertyKeysArray = FromRest42(types2);
  const propertyKeys = SetUnionMany2(propertyKeysArray);
  return propertyKeys;
}
function FromUnion52(types2) {
  const propertyKeysArray = FromRest42(types2);
  const propertyKeys = SetIntersectMany2(propertyKeysArray);
  return propertyKeys;
}
function FromTuple22(types2) {
  return types2.map((_2, indexer) => indexer.toString());
}
function FromArray22(_2) {
  return ["[number]"];
}
function FromProperties52(T2) {
  return globalThis.Object.getOwnPropertyNames(T2);
}
function FromPatternProperties2(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys2(type) {
  return IsIntersect3(type) ? FromIntersect32(type.allOf) : IsUnion3(type) ? FromUnion52(type.anyOf) : IsTuple3(type) ? FromTuple22(type.items ?? []) : IsArray32(type) ? FromArray22(type.items) : IsObject32(type) ? FromProperties52(type.properties) : IsRecord3(type) ? FromPatternProperties2(type.patternProperties) : [];
}
var includePatternProperties2 = false;
function FromComputed22(target, parameters) {
  return Computed2("KeyOf", [Computed2(target, parameters)]);
}
function FromRef22($ref) {
  return Computed2("KeyOf", [Ref2($ref)]);
}
function KeyOfFromType2(type, options) {
  const propertyKeys = KeyOfPropertyKeys2(type);
  const propertyKeyTypes2 = KeyOfPropertyKeysToRest2(propertyKeys);
  const result = UnionEvaluated2(propertyKeyTypes2);
  return CreateType2(result, options);
}
function KeyOfPropertyKeysToRest2(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number22() : Literal2(L));
}
function KeyOf2(type, options) {
  return IsComputed3(type) ? FromComputed22(type.target, type.parameters) : IsRef3(type) ? FromRef22(type.$ref) : IsMappedResult3(type) ? KeyOfFromMappedResult2(type, options) : KeyOfFromType2(type, options);
}
function FromProperties62(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf2(properties[K2], Clone3(options));
  return result;
}
function FromMappedResult52(mappedResult, options) {
  return FromProperties62(mappedResult.properties, options);
}
function KeyOfFromMappedResult2(mappedResult, options) {
  const properties = FromMappedResult52(mappedResult, options);
  return MappedResult2(properties);
}
function CompositeKeys2(T2) {
  const Acc = [];
  for (const L of T2)
    Acc.push(...KeyOfPropertyKeys2(L));
  return SetDistinct2(Acc);
}
function FilterNever2(T2) {
  return T2.filter((L) => !IsNever3(L));
}
function CompositeProperty2(T2, K) {
  const Acc = [];
  for (const L of T2)
    Acc.push(...IndexFromPropertyKeys2(L, [K]));
  return FilterNever2(Acc);
}
function CompositeProperties2(T2, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated2(CompositeProperty2(T2, L));
  }
  return Acc;
}
function Composite2(T2, options) {
  const K = CompositeKeys2(T2);
  const P = CompositeProperties2(T2, K);
  const R = Object22(P, options);
  return R;
}
function Date22(options) {
  return CreateType2({ [Kind2]: "Date", type: "Date" }, options);
}
function Null2(options) {
  return CreateType2({ [Kind2]: "Null", type: "null" }, options);
}
function Symbol22(options) {
  return CreateType2({ [Kind2]: "Symbol", type: "symbol" }, options);
}
function Undefined2(options) {
  return CreateType2({ [Kind2]: "Undefined", type: "undefined" }, options);
}
function Uint8Array22(options) {
  return CreateType2({ [Kind2]: "Uint8Array", type: "Uint8Array" }, options);
}
function Unknown2(options) {
  return CreateType2({ [Kind2]: "Unknown" }, options);
}
function FromArray32(T2) {
  return T2.map((L) => FromValue3(L, false));
}
function FromProperties72(value) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value))
    Acc[K] = Readonly2(FromValue3(value[K], false));
  return Acc;
}
function ConditionalReadonly2(T2, root) {
  return root === true ? T2 : Readonly2(T2);
}
function FromValue3(value, root) {
  return IsAsyncIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsIterator5(value) ? ConditionalReadonly2(Any2(), root) : IsArray5(value) ? Readonly2(Tuple2(FromArray32(value))) : IsUint8Array5(value) ? Uint8Array22() : IsDate5(value) ? Date22() : IsObject5(value) ? ConditionalReadonly2(Object22(FromProperties72(value)), root) : IsFunction5(value) ? ConditionalReadonly2(Function3([], Unknown2()), root) : IsUndefined5(value) ? Undefined2() : IsNull5(value) ? Null2() : IsSymbol5(value) ? Symbol22() : IsBigInt5(value) ? BigInt3() : IsNumber5(value) ? Literal2(value) : IsBoolean5(value) ? Literal2(value) : IsString5(value) ? Literal2(value) : Object22({});
}
function Const2(T2, options) {
  return CreateType2(FromValue3(T2, true), options);
}
function ConstructorParameters2(schema, options) {
  return IsConstructor3(schema) ? Tuple2(schema.parameters, options) : Never2(options);
}
function Enum2(item, options) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value) => Literal2(value));
  return Union3(anyOf, { ...options, [Hint3]: "Enum" });
}
var ExtendsResolverError2 = class extends TypeBoxError2 {
};
var ExtendsResult2;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
function IntoBooleanResult2(result) {
  return result === ExtendsResult2.False ? result : ExtendsResult2.True;
}
function Throw2(message2) {
  throw new ExtendsResolverError2(message2);
}
function IsStructuralRight2(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight2(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
}
function FromAnyRight2(left, right) {
  return ExtendsResult2.True;
}
function FromAny5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema) => type_exports.IsAny(schema) || type_exports.IsUnknown(schema)) ? ExtendsResult2.True : type_exports.IsUnion(right) ? ExtendsResult2.Union : type_exports.IsUnknown(right) ? ExtendsResult2.True : type_exports.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
}
function FromArrayRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromArray42(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromAsyncIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromBigInt6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBooleanRight2(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult2.True : type_exports.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBoolean6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromConstructor9(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromDate8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromFunction8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromIntegerRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromInteger6(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
}
function FromIntersectRight2(left, right) {
  return right.allOf.every((schema) => Visit32(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIntersect42(left, right) {
  return left.allOf.some((schema) => Visit32(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIterator8(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromLiteral22(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
}
function FromNeverRight2(left, right) {
  return ExtendsResult2.False;
}
function FromNever6(left, right) {
  return ExtendsResult2.True;
}
function UnwrapTNot2(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
}
function FromNot8(left, right) {
  return type_exports.IsNot(left) ? Visit32(UnwrapTNot2(left), right) : type_exports.IsNot(right) ? Visit32(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
}
function FromNull6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumberRight2(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumber6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function IsObjectPropertyCount2(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectSymbolLike2(schema) {
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "description" in schema.properties && type_exports.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (type_exports.IsString(schema.properties.description.anyOf[0]) && type_exports.IsUndefined(schema.properties.description.anyOf[1]) || type_exports.IsString(schema.properties.description.anyOf[1]) && type_exports.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBooleanLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectBigIntLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectDateLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectUint8ArrayLike2(schema) {
  return IsObjectArrayLike2(schema);
}
function IsObjectFunctionLike2(schema) {
  const length = Number22();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectConstructorLike2(schema) {
  return IsObjectPropertyCount2(schema, 0);
}
function IsObjectArrayLike2(schema) {
  const length = Number22();
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "length" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectPromiseLike2(schema) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema, 0) || IsObjectPropertyCount2(schema, 1) && "then" in schema.properties && IntoBooleanResult2(Visit32(schema.properties["then"], then)) === ExtendsResult2.True;
}
function Property2(left, right) {
  return Visit32(left, right) === ExtendsResult2.False ? ExtendsResult2.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
}
function FromObjectRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike2(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike2(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike2(right) || type_exports.IsString(left) && IsObjectStringLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsNumber(left) && IsObjectNumberLike2(right) || type_exports.IsInteger(left) && IsObjectNumberLike2(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || type_exports.IsDate(left) && IsObjectDateLike2(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike2(right) || type_exports.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey3(left)) ? (() => {
    return right[Hint3] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey3(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
  })() : ExtendsResult2.False;
}
function FromObject19(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : !type_exports.IsObject(right) ? ExtendsResult2.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })();
}
function FromPromise22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !type_exports.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.item, right.item));
}
function RecordKey3(schema) {
  return PatternNumberExact2 in schema.patternProperties ? Number22() : (PatternStringExact2 in schema.patternProperties) ? String3() : Throw2("Unknown record key pattern");
}
function RecordValue3(schema) {
  return PatternNumberExact2 in schema.patternProperties ? schema.patternProperties[PatternNumberExact2] : (PatternStringExact2 in schema.patternProperties) ? schema.patternProperties[PatternStringExact2] : Throw2("Unable to get record value schema");
}
function FromRecordRight2(left, right) {
  const [Key, Value] = [RecordKey3(right), RecordValue3(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult2(Visit32(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })() : ExtendsResult2.False;
}
function FromRecord14(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsRecord(right) ? ExtendsResult2.False : Visit32(RecordValue3(left), RecordValue3(right));
}
function FromRegExp5(left, right) {
  const L = type_exports.IsRegExp(left) ? String3() : left;
  const R = type_exports.IsRegExp(right) ? String3() : right;
  return Visit32(L, R);
}
function FromStringRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult2.True : type_exports.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromString6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromSymbol6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromTemplateLiteral22(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit32(TemplateLiteralToUnion2(left), right) : type_exports.IsTemplateLiteral(right) ? Visit32(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple2(left, right) {
  return type_exports.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit32(schema, right.items) === ExtendsResult2.True);
}
function FromTupleRight2(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult2.True : type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
}
function FromTuple32(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : type_exports.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !type_exports.IsTuple(right) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema, index) => Visit32(schema, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUint8Array5(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUndefined6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsVoid(right) ? FromVoidRight2(left, right) : type_exports.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnionRight2(left, right) {
  return right.anyOf.some((schema) => Visit32(left, schema) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnion62(left, right) {
  return left.anyOf.every((schema) => Visit32(schema, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnknownRight2(left, right) {
  return ExtendsResult2.True;
}
function FromUnknown5(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : type_exports.IsArray(right) ? FromArrayRight2(left, right) : type_exports.IsTuple(right) ? FromTupleRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoidRight2(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult2.True : type_exports.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoid5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function Visit32(left, right) {
  return type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral22(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp5(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot8(left, right) : type_exports.IsAny(left) ? FromAny5(left, right) : type_exports.IsArray(left) ? FromArray42(left, right) : type_exports.IsBigInt(left) ? FromBigInt6(left, right) : type_exports.IsBoolean(left) ? FromBoolean6(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator8(left, right) : type_exports.IsConstructor(left) ? FromConstructor9(left, right) : type_exports.IsDate(left) ? FromDate8(left, right) : type_exports.IsFunction(left) ? FromFunction8(left, right) : type_exports.IsInteger(left) ? FromInteger6(left, right) : type_exports.IsIntersect(left) ? FromIntersect42(left, right) : type_exports.IsIterator(left) ? FromIterator8(left, right) : type_exports.IsLiteral(left) ? FromLiteral22(left, right) : type_exports.IsNever(left) ? FromNever6(left, right) : type_exports.IsNull(left) ? FromNull6(left, right) : type_exports.IsNumber(left) ? FromNumber6(left, right) : type_exports.IsObject(left) ? FromObject19(left, right) : type_exports.IsRecord(left) ? FromRecord14(left, right) : type_exports.IsString(left) ? FromString6(left, right) : type_exports.IsSymbol(left) ? FromSymbol6(left, right) : type_exports.IsTuple(left) ? FromTuple32(left, right) : type_exports.IsPromise(left) ? FromPromise22(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array5(left, right) : type_exports.IsUndefined(left) ? FromUndefined6(left, right) : type_exports.IsUnion(left) ? FromUnion62(left, right) : type_exports.IsUnknown(left) ? FromUnknown5(left, right) : type_exports.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[Kind2]}'`);
}
function ExtendsCheck2(left, right) {
  return Visit32(left, right);
}
function FromProperties82(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends2(P[K2], Right, True, False, Clone3(options));
  return Acc;
}
function FromMappedResult62(Left, Right, True, False, options) {
  return FromProperties82(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P = FromMappedResult62(Left, Right, True, False, options);
  return MappedResult2(P);
}
function ExtendsResolve2(left, right, trueType, falseType) {
  const R = ExtendsCheck2(left, right);
  return R === ExtendsResult2.Union ? Union3([trueType, falseType]) : R === ExtendsResult2.True ? trueType : falseType;
}
function Extends2(L, R, T2, F, options) {
  return IsMappedResult3(L) ? ExtendsFromMappedResult2(L, R, T2, F, options) : IsMappedKey3(L) ? CreateType2(ExtendsFromMappedKey2(L, R, T2, F, options)) : CreateType2(ExtendsResolve2(L, R, T2, F), options);
}
function FromPropertyKey4(K, U, L, R, options) {
  return {
    [K]: Extends2(Literal2(K), U, L, R, Clone3(options))
  };
}
function FromPropertyKeys4(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey22(K, U, L, R, options) {
  return FromPropertyKeys4(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey2(T2, U, L, R, options) {
  const P = FromMappedKey22(T2, U, L, R, options);
  return MappedResult2(P);
}
function ExcludeFromTemplateLiteral2(L, R) {
  return Exclude2(TemplateLiteralToUnion2(L), R);
}
function ExcludeRest2(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck2(inner, R) === ExtendsResult2.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
}
function Exclude2(L, R, options = {}) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExcludeFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExcludeFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExcludeRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? Never2() : L, options);
}
function FromProperties92(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude2(P[K2], U);
  return Acc;
}
function FromMappedResult72(R, T2) {
  return FromProperties92(R.properties, T2);
}
function ExcludeFromMappedResult2(R, T2) {
  const P = FromMappedResult72(R, T2);
  return MappedResult2(P);
}
function ExtractFromTemplateLiteral2(L, R) {
  return Extract2(TemplateLiteralToUnion2(L), R);
}
function ExtractRest2(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck2(inner, R) !== ExtendsResult2.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
}
function Extract2(L, R, options) {
  if (IsTemplateLiteral3(L))
    return CreateType2(ExtractFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CreateType2(ExtractFromMappedResult2(L, R), options);
  return CreateType2(IsUnion3(L) ? ExtractRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? L : Never2(), options);
}
function FromProperties102(P, T2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract2(P[K2], T2);
  return Acc;
}
function FromMappedResult82(R, T2) {
  return FromProperties102(R.properties, T2);
}
function ExtractFromMappedResult2(R, T2) {
  const P = FromMappedResult82(R, T2);
  return MappedResult2(P);
}
function InstanceType2(schema, options) {
  return IsConstructor3(schema) ? CreateType2(schema.returns, options) : Never2(options);
}
function ReadonlyOptional2(schema) {
  return Readonly2(Optional2(schema));
}
function RecordCreateFromPattern2(pattern, T2, options) {
  return CreateType2({ [Kind2]: "Record", type: "object", patternProperties: { [pattern]: T2 } }, options);
}
function RecordCreateFromKeys2(K, T2, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T2;
  return Object22(result, { ...options, [Hint3]: "Record" });
}
function FromTemplateLiteralKey2(K, T2, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T2, options) : RecordCreateFromPattern2(K.pattern, T2, options);
}
function FromUnionKey2(key, type, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(key)), type, options);
}
function FromLiteralKey2(key, type, options) {
  return RecordCreateFromKeys2([key.toString()], type, options);
}
function FromRegExpKey2(key, type, options) {
  return RecordCreateFromPattern2(key.source, type, options);
}
function FromStringKey2(key, type, options) {
  const pattern = IsUndefined5(key.pattern) ? PatternStringExact2 : key.pattern;
  return RecordCreateFromPattern2(pattern, type, options);
}
function FromAnyKey2(_2, type, options) {
  return RecordCreateFromPattern2(PatternStringExact2, type, options);
}
function FromNeverKey2(_key, type, options) {
  return RecordCreateFromPattern2(PatternNeverExact2, type, options);
}
function FromBooleanKey2(_key, type, options) {
  return Object22({ true: type, false: type }, options);
}
function FromIntegerKey2(_key, type, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type, options);
}
function FromNumberKey2(_2, type, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, type, options);
}
function Record2(key, type, options = {}) {
  return IsUnion3(key) ? FromUnionKey2(key.anyOf, type, options) : IsTemplateLiteral3(key) ? FromTemplateLiteralKey2(key, type, options) : IsLiteral3(key) ? FromLiteralKey2(key.const, type, options) : IsBoolean22(key) ? FromBooleanKey2(key, type, options) : IsInteger4(key) ? FromIntegerKey2(key, type, options) : IsNumber32(key) ? FromNumberKey2(key, type, options) : IsRegExp22(key) ? FromRegExpKey2(key, type, options) : IsString22(key) ? FromStringKey2(key, type, options) : IsAny3(key) ? FromAnyKey2(key, type, options) : IsNever3(key) ? FromNeverKey2(key, type, options) : Never2(options);
}
function RecordPattern2(record2) {
  return globalThis.Object.getOwnPropertyNames(record2.patternProperties)[0];
}
function RecordKey22(type) {
  const pattern = RecordPattern2(type);
  return pattern === PatternStringExact2 ? String3() : pattern === PatternNumberExact2 ? Number22() : String3({ pattern });
}
function RecordValue22(type) {
  return type.patternProperties[RecordPattern2(type)];
}
function FromConstructor22(args, type) {
  type.parameters = FromTypes3(args, type.parameters);
  type.returns = FromType3(args, type.returns);
  return type;
}
function FromFunction22(args, type) {
  type.parameters = FromTypes3(args, type.parameters);
  type.returns = FromType3(args, type.returns);
  return type;
}
function FromIntersect52(args, type) {
  type.allOf = FromTypes3(args, type.allOf);
  return type;
}
function FromUnion72(args, type) {
  type.anyOf = FromTypes3(args, type.anyOf);
  return type;
}
function FromTuple42(args, type) {
  if (IsUndefined5(type.items))
    return type;
  type.items = FromTypes3(args, type.items);
  return type;
}
function FromArray52(args, type) {
  type.items = FromType3(args, type.items);
  return type;
}
function FromAsyncIterator22(args, type) {
  type.items = FromType3(args, type.items);
  return type;
}
function FromIterator22(args, type) {
  type.items = FromType3(args, type.items);
  return type;
}
function FromPromise32(args, type) {
  type.item = FromType3(args, type.item);
  return type;
}
function FromObject22(args, type) {
  const mappedProperties = FromProperties112(args, type.properties);
  return { ...type, ...Object22(mappedProperties) };
}
function FromRecord22(args, type) {
  const mappedKey = FromType3(args, RecordKey22(type));
  const mappedValue = FromType3(args, RecordValue22(type));
  const result = Record2(mappedKey, mappedValue);
  return { ...type, ...result };
}
function FromArgument5(args, argument) {
  return argument.index in args ? args[argument.index] : Unknown2();
}
function FromProperty22(args, type) {
  const isReadonly = IsReadonly3(type);
  const isOptional2 = IsOptional3(type);
  const mapped = FromType3(args, type);
  return isReadonly && isOptional2 ? ReadonlyOptional2(mapped) : isReadonly && !isOptional2 ? Readonly2(mapped) : !isReadonly && isOptional2 ? Optional2(mapped) : mapped;
}
function FromProperties112(args, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty22(args, properties[key]) };
  }, {});
}
function FromTypes3(args, types2) {
  return types2.map((type) => FromType3(args, type));
}
function FromType3(args, type) {
  return IsConstructor3(type) ? FromConstructor22(args, type) : IsFunction22(type) ? FromFunction22(args, type) : IsIntersect3(type) ? FromIntersect52(args, type) : IsUnion3(type) ? FromUnion72(args, type) : IsTuple3(type) ? FromTuple42(args, type) : IsArray32(type) ? FromArray52(args, type) : IsAsyncIterator22(type) ? FromAsyncIterator22(args, type) : IsIterator22(type) ? FromIterator22(args, type) : IsPromise4(type) ? FromPromise32(args, type) : IsObject32(type) ? FromObject22(args, type) : IsRecord3(type) ? FromRecord22(args, type) : IsArgument3(type) ? FromArgument5(args, type) : type;
}
function Instantiate2(type, args) {
  return FromType3(args, CloneType2(type));
}
function Integer2(options) {
  return CreateType2({ [Kind2]: "Integer", type: "integer" }, options);
}
function MappedIntrinsicPropertyKey2(K, M, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M, Clone3(options))
  };
}
function MappedIntrinsicPropertyKeys2(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties2(T2, M, options) {
  return MappedIntrinsicPropertyKeys2(T2["keys"], M, options);
}
function IntrinsicFromMappedKey2(T2, M, options) {
  const P = MappedIntrinsicProperties2(T2, M, options);
  return MappedResult2(P);
}
function ApplyUncapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize2(value) {
  const [first, rest] = [value.slice(0, 1), value.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase2(value) {
  return value.toUpperCase();
}
function ApplyLowercase2(value) {
  return value.toLowerCase();
}
function FromTemplateLiteral32(schema, mode, options) {
  const expression = TemplateLiteralParseExact2(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue2(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value) => Literal2(value));
  const mapped = FromRest52(literals, mode);
  const union3 = Union3(mapped);
  return TemplateLiteral2([union3], options);
}
function FromLiteralValue2(value, mode) {
  return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value) : mode === "Capitalize" ? ApplyCapitalize2(value) : mode === "Uppercase" ? ApplyUppercase2(value) : mode === "Lowercase" ? ApplyLowercase2(value) : value : value.toString();
}
function FromRest52(T2, M) {
  return T2.map((L) => Intrinsic2(L, M));
}
function Intrinsic2(schema, mode, options = {}) {
  return IsMappedKey3(schema) ? IntrinsicFromMappedKey2(schema, mode, options) : IsTemplateLiteral3(schema) ? FromTemplateLiteral32(schema, mode, options) : IsUnion3(schema) ? Union3(FromRest52(schema.anyOf, mode), options) : IsLiteral3(schema) ? Literal2(FromLiteralValue2(schema.const, mode), options) : CreateType2(schema, options);
}
function Capitalize2(T2, options = {}) {
  return Intrinsic2(T2, "Capitalize", options);
}
function Lowercase2(T2, options = {}) {
  return Intrinsic2(T2, "Lowercase", options);
}
function Uncapitalize2(T2, options = {}) {
  return Intrinsic2(T2, "Uncapitalize", options);
}
function Uppercase2(T2, options = {}) {
  return Intrinsic2(T2, "Uppercase", options);
}
function FromProperties122(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult92(mappedResult, propertyKeys, options) {
  return FromProperties122(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult92(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}
function FromIntersect62(types2, propertyKeys) {
  return types2.map((type) => OmitResolve2(type, propertyKeys));
}
function FromUnion82(types2, propertyKeys) {
  return types2.map((type) => OmitResolve2(type, propertyKeys));
}
function FromProperty32(properties, key) {
  const { [key]: _2, ...R } = properties;
  return R;
}
function FromProperties132(properties, propertyKeys) {
  return propertyKeys.reduce((T2, K2) => FromProperty32(T2, K2), properties);
}
function FromObject32(properties, propertyKeys) {
  const options = Discard2(properties, [TransformKind2, "$id", "required", "properties"]);
  const omittedProperties = FromProperties132(properties["properties"], propertyKeys);
  return Object22(omittedProperties, options);
}
function UnionFromPropertyKeys3(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function OmitResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect62(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion82(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject32(properties, propertyKeys) : Object22({});
}
function Omit2(type, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys3(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type) ? OmitFromMappedResult2(type, propertyKeys, options) : IsMappedKey3(key) ? OmitFromMappedKey2(type, key, options) : isTypeRef && isKeyRef ? Computed2("Omit", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Omit", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Omit", [type, typeKey], options) : CreateType2({ ...OmitResolve2(type, propertyKeys), ...options });
}
function FromPropertyKey22(type, key, options) {
  return { [key]: Omit2(type, [key], Clone3(options)) };
}
function FromPropertyKeys22(type, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey22(type, LK, options) };
  }, {});
}
function FromMappedKey32(type, mappedKey, options) {
  return FromPropertyKeys22(type, mappedKey.keys, options);
}
function OmitFromMappedKey2(type, mappedKey, options) {
  const properties = FromMappedKey32(type, mappedKey, options);
  return MappedResult2(properties);
}
function FromProperties142(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick2(properties[K2], propertyKeys, Clone3(options));
  return result;
}
function FromMappedResult102(mappedResult, propertyKeys, options) {
  return FromProperties142(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult2(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult102(mappedResult, propertyKeys, options);
  return MappedResult2(properties);
}
function FromIntersect72(types2, propertyKeys) {
  return types2.map((type) => PickResolve2(type, propertyKeys));
}
function FromUnion92(types2, propertyKeys) {
  return types2.map((type) => PickResolve2(type, propertyKeys));
}
function FromProperties152(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject42(T2, K) {
  const options = Discard2(T2, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties152(T2["properties"], K);
  return Object22(properties, options);
}
function UnionFromPropertyKeys22(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue3(key) ? [...result2, Literal2(key)] : result2, []);
  return Union3(result);
}
function PickResolve2(properties, propertyKeys) {
  return IsIntersect3(properties) ? Intersect3(FromIntersect72(properties.allOf, propertyKeys)) : IsUnion3(properties) ? Union3(FromUnion92(properties.anyOf, propertyKeys)) : IsObject32(properties) ? FromObject42(properties, propertyKeys) : Object22({});
}
function Pick2(type, key, options) {
  const typeKey = IsArray5(key) ? UnionFromPropertyKeys22(key) : key;
  const propertyKeys = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const isTypeRef = IsRef3(type);
  const isKeyRef = IsRef3(key);
  return IsMappedResult3(type) ? PickFromMappedResult2(type, propertyKeys, options) : IsMappedKey3(key) ? PickFromMappedKey2(type, key, options) : isTypeRef && isKeyRef ? Computed2("Pick", [type, typeKey], options) : !isTypeRef && isKeyRef ? Computed2("Pick", [type, typeKey], options) : isTypeRef && !isKeyRef ? Computed2("Pick", [type, typeKey], options) : CreateType2({ ...PickResolve2(type, propertyKeys), ...options });
}
function FromPropertyKey32(type, key, options) {
  return {
    [key]: Pick2(type, [key], Clone3(options))
  };
}
function FromPropertyKeys32(type, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey32(type, leftKey, options) };
  }, {});
}
function FromMappedKey42(type, mappedKey, options) {
  return FromPropertyKeys32(type, mappedKey.keys, options);
}
function PickFromMappedKey2(type, mappedKey, options) {
  const properties = FromMappedKey42(type, mappedKey, options);
  return MappedResult2(properties);
}
function FromComputed32(target, parameters) {
  return Computed2("Partial", [Computed2(target, parameters)]);
}
function FromRef32($ref) {
  return Computed2("Partial", [Ref2($ref)]);
}
function FromProperties162(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional2(properties[K]);
  return partialProperties;
}
function FromObject52(type) {
  const options = Discard2(type, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties162(type["properties"]);
  return Object22(properties, options);
}
function FromRest62(types2) {
  return types2.map((type) => PartialResolve2(type));
}
function PartialResolve2(type) {
  return IsComputed3(type) ? FromComputed32(type.target, type.parameters) : IsRef3(type) ? FromRef32(type.$ref) : IsIntersect3(type) ? Intersect3(FromRest62(type.allOf)) : IsUnion3(type) ? Union3(FromRest62(type.anyOf)) : IsObject32(type) ? FromObject52(type) : IsBigInt22(type) ? type : IsBoolean22(type) ? type : IsInteger4(type) ? type : IsLiteral3(type) ? type : IsNull22(type) ? type : IsNumber32(type) ? type : IsString22(type) ? type : IsSymbol22(type) ? type : IsUndefined32(type) ? type : Object22({});
}
function Partial2(type, options) {
  if (IsMappedResult3(type)) {
    return PartialFromMappedResult2(type, options);
  } else {
    return CreateType2({ ...PartialResolve2(type), ...options });
  }
}
function FromProperties172(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial2(K[K2], Clone3(options));
  return Acc;
}
function FromMappedResult112(R, options) {
  return FromProperties172(R.properties, options);
}
function PartialFromMappedResult2(R, options) {
  const P = FromMappedResult112(R, options);
  return MappedResult2(P);
}
function FromComputed42(target, parameters) {
  return Computed2("Required", [Computed2(target, parameters)]);
}
function FromRef42($ref) {
  return Computed2("Required", [Ref2($ref)]);
}
function FromProperties182(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard2(properties[K], [OptionalKind2]);
  return requiredProperties;
}
function FromObject62(type) {
  const options = Discard2(type, [TransformKind2, "$id", "required", "properties"]);
  const properties = FromProperties182(type["properties"]);
  return Object22(properties, options);
}
function FromRest72(types2) {
  return types2.map((type) => RequiredResolve2(type));
}
function RequiredResolve2(type) {
  return IsComputed3(type) ? FromComputed42(type.target, type.parameters) : IsRef3(type) ? FromRef42(type.$ref) : IsIntersect3(type) ? Intersect3(FromRest72(type.allOf)) : IsUnion3(type) ? Union3(FromRest72(type.anyOf)) : IsObject32(type) ? FromObject62(type) : IsBigInt22(type) ? type : IsBoolean22(type) ? type : IsInteger4(type) ? type : IsLiteral3(type) ? type : IsNull22(type) ? type : IsNumber32(type) ? type : IsString22(type) ? type : IsSymbol22(type) ? type : IsUndefined32(type) ? type : Object22({});
}
function Required2(type, options) {
  if (IsMappedResult3(type)) {
    return RequiredFromMappedResult2(type, options);
  } else {
    return CreateType2({ ...RequiredResolve2(type), ...options });
  }
}
function FromProperties192(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required2(P[K2], options);
  return Acc;
}
function FromMappedResult122(R, options) {
  return FromProperties192(R.properties, options);
}
function RequiredFromMappedResult2(R, options) {
  const P = FromMappedResult122(R, options);
  return MappedResult2(P);
}
function DereferenceParameters2(moduleProperties, types2) {
  return types2.map((type) => {
    return IsRef3(type) ? Dereference2(moduleProperties, type.$ref) : FromType22(moduleProperties, type);
  });
}
function Dereference2(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef3(moduleProperties[ref]) ? Dereference2(moduleProperties, moduleProperties[ref].$ref) : FromType22(moduleProperties, moduleProperties[ref]) : Never2();
}
function FromAwaited2(parameters) {
  return Awaited2(parameters[0]);
}
function FromIndex2(parameters) {
  return Index2(parameters[0], parameters[1]);
}
function FromKeyOf2(parameters) {
  return KeyOf2(parameters[0]);
}
function FromPartial2(parameters) {
  return Partial2(parameters[0]);
}
function FromOmit2(parameters) {
  return Omit2(parameters[0], parameters[1]);
}
function FromPick2(parameters) {
  return Pick2(parameters[0], parameters[1]);
}
function FromRequired2(parameters) {
  return Required2(parameters[0]);
}
function FromComputed52(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters2(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited2(dereferenced) : target === "Index" ? FromIndex2(dereferenced) : target === "KeyOf" ? FromKeyOf2(dereferenced) : target === "Partial" ? FromPartial2(dereferenced) : target === "Omit" ? FromOmit2(dereferenced) : target === "Pick" ? FromPick2(dereferenced) : target === "Required" ? FromRequired2(dereferenced) : Never2();
}
function FromArray62(moduleProperties, type) {
  return Array22(FromType22(moduleProperties, type));
}
function FromAsyncIterator32(moduleProperties, type) {
  return AsyncIterator2(FromType22(moduleProperties, type));
}
function FromConstructor32(moduleProperties, parameters, instanceType) {
  return Constructor2(FromTypes22(moduleProperties, parameters), FromType22(moduleProperties, instanceType));
}
function FromFunction32(moduleProperties, parameters, returnType) {
  return Function3(FromTypes22(moduleProperties, parameters), FromType22(moduleProperties, returnType));
}
function FromIntersect82(moduleProperties, types2) {
  return Intersect3(FromTypes22(moduleProperties, types2));
}
function FromIterator32(moduleProperties, type) {
  return Iterator2(FromType22(moduleProperties, type));
}
function FromObject72(moduleProperties, properties) {
  return Object22(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType22(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord32(moduleProperties, type) {
  const [value, pattern] = [FromType22(moduleProperties, RecordValue22(type)), RecordPattern2(type)];
  const result = CloneType2(type);
  result.patternProperties[pattern] = value;
  return result;
}
function FromTransform2(moduleProperties, transform3) {
  return IsRef3(transform3) ? { ...Dereference2(moduleProperties, transform3.$ref), [TransformKind2]: transform3[TransformKind2] } : transform3;
}
function FromTuple52(moduleProperties, types2) {
  return Tuple2(FromTypes22(moduleProperties, types2));
}
function FromUnion102(moduleProperties, types2) {
  return Union3(FromTypes22(moduleProperties, types2));
}
function FromTypes22(moduleProperties, types2) {
  return types2.map((type) => FromType22(moduleProperties, type));
}
function FromType22(moduleProperties, type) {
  return IsOptional3(type) ? CreateType2(FromType22(moduleProperties, Discard2(type, [OptionalKind2])), type) : IsReadonly3(type) ? CreateType2(FromType22(moduleProperties, Discard2(type, [ReadonlyKind2])), type) : IsTransform3(type) ? CreateType2(FromTransform2(moduleProperties, type), type) : IsArray32(type) ? CreateType2(FromArray62(moduleProperties, type.items), type) : IsAsyncIterator22(type) ? CreateType2(FromAsyncIterator32(moduleProperties, type.items), type) : IsComputed3(type) ? CreateType2(FromComputed52(moduleProperties, type.target, type.parameters)) : IsConstructor3(type) ? CreateType2(FromConstructor32(moduleProperties, type.parameters, type.returns), type) : IsFunction22(type) ? CreateType2(FromFunction32(moduleProperties, type.parameters, type.returns), type) : IsIntersect3(type) ? CreateType2(FromIntersect82(moduleProperties, type.allOf), type) : IsIterator22(type) ? CreateType2(FromIterator32(moduleProperties, type.items), type) : IsObject32(type) ? CreateType2(FromObject72(moduleProperties, type.properties), type) : IsRecord3(type) ? CreateType2(FromRecord32(moduleProperties, type)) : IsTuple3(type) ? CreateType2(FromTuple52(moduleProperties, type.items || []), type) : IsUnion3(type) ? CreateType2(FromUnion102(moduleProperties, type.anyOf), type) : type;
}
function ComputeType2(moduleProperties, key) {
  return key in moduleProperties ? FromType22(moduleProperties, moduleProperties[key]) : Never2();
}
function ComputeModuleProperties2(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType2(moduleProperties, key) };
  }, {});
}
var TModule2 = class {
  constructor($defs) {
    const computed = ComputeModuleProperties2($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType2(this.$defs[key], options) };
    return CreateType2({ [Kind2]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
};
function Module2(properties) {
  return new TModule2(properties);
}
function Not3(type, options) {
  return CreateType2({ [Kind2]: "Not", not: type }, options);
}
function Parameters2(schema, options) {
  return IsFunction22(schema) ? Tuple2(schema.parameters, options) : Never2();
}
var Ordinal2 = 0;
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = CloneType2(callback({ [Kind2]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType2({ [Hint3]: "Recursive", ...thisType }, options);
}
function RegExp22(unresolved, options) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType2({ [Kind2]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}
function RestResolve2(T2) {
  return IsIntersect3(T2) ? T2.allOf : IsUnion3(T2) ? T2.anyOf : IsTuple3(T2) ? T2.items ?? [] : [];
}
function Rest2(T2) {
  return RestResolve2(T2);
}
function ReturnType2(schema, options) {
  return IsFunction22(schema) ? CreateType2(schema.returns, options) : Never2(options);
}
var TransformDecodeBuilder2 = class {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode3) {
    return new TransformEncodeBuilder2(this.schema, decode3);
  }
};
var TransformEncodeBuilder2 = class {
  constructor(schema, decode3) {
    this.schema = schema;
    this.decode = decode3;
  }
  EncodeTransform(encode3, schema) {
    const Encode2 = (value) => schema[TransformKind2].Encode(encode3(value));
    const Decode2 = (value) => this.decode(schema[TransformKind2].Decode(value));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema, [TransformKind2]: Codec };
  }
  EncodeSchema(encode3, schema) {
    const Codec = { Decode: this.decode, Encode: encode3 };
    return { ...schema, [TransformKind2]: Codec };
  }
  Encode(encode3) {
    return IsTransform3(this.schema) ? this.EncodeTransform(encode3, this.schema) : this.EncodeSchema(encode3, this.schema);
  }
};
function Transform2(schema) {
  return new TransformDecodeBuilder2(schema);
}
function Unsafe2(options = {}) {
  return CreateType2({ [Kind2]: options[Kind2] ?? "Unsafe" }, options);
}
function Void2(options) {
  return CreateType2({ [Kind2]: "Void", type: "void" }, options);
}
var type_exports2 = {};
__export2(type_exports2, {
  Any: () => Any2,
  Argument: () => Argument2,
  Array: () => Array22,
  AsyncIterator: () => AsyncIterator2,
  Awaited: () => Awaited2,
  BigInt: () => BigInt3,
  Boolean: () => Boolean3,
  Capitalize: () => Capitalize2,
  Composite: () => Composite2,
  Const: () => Const2,
  Constructor: () => Constructor2,
  ConstructorParameters: () => ConstructorParameters2,
  Date: () => Date22,
  Enum: () => Enum2,
  Exclude: () => Exclude2,
  Extends: () => Extends2,
  Extract: () => Extract2,
  Function: () => Function3,
  Index: () => Index2,
  InstanceType: () => InstanceType2,
  Instantiate: () => Instantiate2,
  Integer: () => Integer2,
  Intersect: () => Intersect3,
  Iterator: () => Iterator2,
  KeyOf: () => KeyOf2,
  Literal: () => Literal2,
  Lowercase: () => Lowercase2,
  Mapped: () => Mapped2,
  Module: () => Module2,
  Never: () => Never2,
  Not: () => Not3,
  Null: () => Null2,
  Number: () => Number22,
  Object: () => Object22,
  Omit: () => Omit2,
  Optional: () => Optional2,
  Parameters: () => Parameters2,
  Partial: () => Partial2,
  Pick: () => Pick2,
  Promise: () => Promise22,
  Readonly: () => Readonly2,
  ReadonlyOptional: () => ReadonlyOptional2,
  Record: () => Record2,
  Recursive: () => Recursive2,
  Ref: () => Ref2,
  RegExp: () => RegExp22,
  Required: () => Required2,
  Rest: () => Rest2,
  ReturnType: () => ReturnType2,
  String: () => String3,
  Symbol: () => Symbol22,
  TemplateLiteral: () => TemplateLiteral2,
  Transform: () => Transform2,
  Tuple: () => Tuple2,
  Uint8Array: () => Uint8Array22,
  Uncapitalize: () => Uncapitalize2,
  Undefined: () => Undefined2,
  Union: () => Union3,
  Unknown: () => Unknown2,
  Unsafe: () => Unsafe2,
  Uppercase: () => Uppercase2,
  Void: () => Void2
});
var Type2 = type_exports2;
var jwt2 = ({
  name = "jwt",
  secret,
  schema,
  ...defaultValues
}) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema ? getSchemaValidator(Type2.Intersect([
    schema,
    Type2.Object({
      iss: Type2.Optional(Type2.String()),
      sub: Type2.Optional(Type2.String()),
      aud: Type2.Optional(Type2.Union([Type2.String(), Type2.Array(Type2.String())])),
      jti: Type2.Optional(Type2.String()),
      nbf: Type2.Optional(Type2.Number()),
      exp: Type2.Optional(Type2.Number()),
      iat: Type2.Optional(Type2.Number())
    })
  ]), {
    modules: Type2.Module({})
  }) : undefined;
  return new Elysia({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      schema,
      ...defaultValues
    }
  }).decorate(name, {
    sign(signValue) {
      const { nbf, exp, iat, ...data } = signValue;
      const JWTHeader = {
        alg: defaultValues.alg ?? "HS256",
        b64: defaultValues.b64,
        crit: defaultValues.crit,
        cty: defaultValues.cty,
        jku: defaultValues.jku,
        jwk: defaultValues.jwk,
        kid: defaultValues.kid,
        typ: defaultValues.typ ?? "JWT",
        x5c: defaultValues.x5c,
        x5t: defaultValues.x5t,
        x5u: defaultValues.x5u
      };
      const JWTPayload = {
        aud: data.aud ?? defaultValues.aud,
        iss: data.iss ?? defaultValues.iss,
        jti: data.jti ?? defaultValues.jti,
        sub: data.sub ?? defaultValues.sub,
        ...data
      };
      let jwt22 = new SignJWT({ ...JWTPayload }).setProtectedHeader({
        alg: JWTHeader.alg,
        ...JWTHeader
      });
      const setNbf = "nbf" in signValue ? nbf : defaultValues.nbf;
      if (setNbf !== undefined) {
        jwt22 = jwt22.setNotBefore(setNbf);
      }
      const setExp = "exp" in signValue ? exp : defaultValues.exp;
      if (setExp !== undefined) {
        jwt22 = jwt22.setExpirationTime(setExp);
      }
      const setIat = "iat" in signValue ? iat : defaultValues.iat;
      if (setIat !== false) {
        jwt22 = jwt22.setIssuedAt(/* @__PURE__ */ new Date);
      }
      return jwt22.sign(key);
    },
    async verify(jwt22, options) {
      if (!jwt22)
        return false;
      try {
        const data = (await (options ? jwtVerify(jwt22, key, options) : jwtVerify(jwt22, key))).payload;
        if (validator && !validator.Check(data))
          throw new ValidationError("JWT", validator, data);
        return data;
      } catch (_2) {
        return false;
      }
    }
  });
};
var index_default2 = jwt2;

// src/plugin/jwt.ts
var jwtPlugin = index_default2({
  secret: process.env.JWT_SECRET,
  alg: "HS256",
  exp: "15m"
});

// src/modules/auth/model.ts
var loginBody = t.Object({
  username: t.String(),
  password: t.String()
});
var registerBody = t.Object({
  username: t.String(),
  email: t.String(),
  password: t.String()
});

// src/modules/auth/index.ts
var authController = new Elysia({ prefix: "/auth" }).use(jwtPlugin).use(index_default()).post("/login", async ({ body: { username, password }, jwt: jwt3, status: status2, cookie }) => {
  const user = await findUserByUsername(username);
  if (!user || !user.passwordHash) {
    return { error: "Invalid credentials" };
  }
  const isValid = await verifyPassword(password, user.passwordHash);
  if (username !== user.username || !isValid)
    return { error: "Invalid credentials" };
  const token = await jwt3.sign({
    id: user.id,
    username: user.username,
    email: user.email
  });
  const refreshToken = await jwt3.sign({
    id: user.id,
    username: user.username,
    email: user.email,
    type: "refresh",
    exp: "7d"
  });
  if (cookie.auth) {
    cookie.auth.set({
      value: refreshToken,
      httpOnly: true,
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7,
      path: "/"
    });
  }
  return status2(200), {
    message: "Login successful",
    token,
    data: { id: user.id, username: user.username, email: user.email }
  };
}, {
  body: loginBody
}).post("/register", async ({ body: { username, email: email3, password }, status: status2, jwt: jwt3, cookie }) => {
  const existingUser = await findUserByUsername(username);
  if (existingUser) {
    return status2(400), { error: "Username already taken" };
  }
  const passwordHash = await hashPassword(password);
  const newUser = await createUser(username, email3, passwordHash);
  console.log("New User Created:", newUser);
  return status2(200), {
    message: "User registered successfully",
    data: newUser
  };
}, {
  body: registerBody
}).post("/logout", async ({ jwt: jwt3, cookie, bearer: bearer2, status: status2 }) => {
  const verifyToken = await jwt3.verify(bearer2);
  if (!verifyToken)
    return status2(401), { error: "Unauthorized" };
  if (cookie.auth) {
    cookie.auth.remove();
  }
  return status2(200), { message: "Logged out successfully", data: verifyToken };
}).post("/refresh", async ({ jwt: jwt3, cookie, status: status2 }) => {
  const token = cookie.auth?.value;
  if (!token)
    return status2(401), { error: "Missing refresh token" };
  const payload = await jwt3.verify(String(token));
  if (!payload)
    return status2(401), { error: "Invalid refresh token" };
  const user = await findUserById(String(payload.id));
  if (!user)
    return status2(401), { error: "User not found" };
  const newAccessToken = await jwt3.sign({
    id: user.id,
    username: user.username,
    email: user.email
  });
  const newRefreshToken = await jwt3.sign({
    id: user.id,
    username: user.username,
    email: user.email,
    type: "refresh",
    exp: "7d"
  });
  if (cookie.refresh) {
    cookie.refresh.set({
      value: newRefreshToken,
      httpOnly: true,
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7,
      path: "/"
    });
  }
  return status2(200), { message: "Token refreshed", token: newAccessToken };
});

// node_modules/@elysiajs/cors/dist/index.mjs
var isBun3 = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
  if (isBun3)
    return Object.keys(headers.toJSON()).join(", ");
  let keys = "";
  let i2 = 0;
  headers.forEach((_2, key) => {
    if (i2)
      keys = keys + ", " + key;
    else
      keys = key;
    i2++;
  });
  return keys;
};
var cors = (config2) => {
  let {
    aot = true,
    origin = true,
    methods = true,
    allowedHeaders = true,
    exposeHeaders = true,
    credentials = true,
    maxAge = 5,
    preflight = true
  } = config2 ?? {};
  if (Array.isArray(allowedHeaders))
    allowedHeaders = allowedHeaders.join(", ");
  if (Array.isArray(exposeHeaders))
    exposeHeaders = exposeHeaders.join(", ");
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config2,
    aot
  });
  const anyOrigin = origins?.some((o) => o === "*");
  const originMap = {};
  if (origins) {
    for (const origin2 of origins)
      if (typeof origin2 === "string")
        originMap[origin2] = true;
  }
  const processOrigin = (origin2, request, from) => {
    if (Array.isArray(origin2))
      return origin2.some((o) => processOrigin(o, request, from));
    switch (typeof origin2) {
      case "string":
        if (from in originMap)
          return true;
        const fromProtocol = from.indexOf("://");
        if (fromProtocol !== -1)
          from = from.slice(fromProtocol + 3);
        return origin2 === from;
      case "function":
        return origin2(request) === true;
      case "object":
        if (origin2 instanceof RegExp)
          return origin2.test(from);
    }
    return false;
  };
  const handleOrigin = (set3, request) => {
    if (origin === true) {
      set3.headers.vary = "*";
      set3.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (anyOrigin) {
      set3.headers.vary = "*";
      set3.headers["access-control-allow-origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i2 = 0;i2 < origins.length; i2++) {
        const value = processOrigin(origins[i2], request, from);
        if (value === true) {
          set3.headers.vary = origin ? "Origin" : "*";
          set3.headers["access-control-allow-origin"] = from || "*";
          return;
        }
      }
    }
    set3.headers.vary = "Origin";
    if (headers.length)
      set3.headers["access-control-allow-origin"] = headers.join(", ");
  };
  const handleMethod = (set3, method) => {
    if (!method)
      return;
    if (methods === true)
      return set3.headers["access-control-allow-methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set3.headers["access-control-allow-methods"] = "*";
    if (!Array.isArray(methods))
      return set3.headers["access-control-allow-methods"] = methods;
    set3.headers["access-control-allow-methods"] = methods.join(", ");
  };
  const defaultHeaders = {};
  if (typeof exposeHeaders === "string")
    defaultHeaders["access-control-expose-headers"] = exposeHeaders;
  if (typeof allowedHeaders === "string")
    defaultHeaders["access-control-allow-headers"] = allowedHeaders;
  if (credentials === true)
    defaultHeaders["access-control-allow-credentials"] = "true";
  app.headers(defaultHeaders);
  function handleOption({ set: set3, request, headers }) {
    handleOrigin(set3, request);
    handleMethod(set3, request.headers.get("access-control-request-method"));
    if (allowedHeaders === true || exposeHeaders === true) {
      if (allowedHeaders === true)
        set3.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
      if (exposeHeaders === true)
        set3.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
    }
    if (maxAge)
      set3.headers["access-control-max-age"] = maxAge.toString();
    return new Response(null, {
      status: 204
    });
  }
  if (preflight)
    app.options("/", handleOption).options("/*", handleOption);
  return app.onRequest(function processCors({ set: set3, request }) {
    handleOrigin(set3, request);
    handleMethod(set3, request.method);
    if (allowedHeaders === true || exposeHeaders === true) {
      const headers = processHeaders(request.headers);
      if (allowedHeaders === true)
        set3.headers["access-control-allow-headers"] = headers;
      if (exposeHeaders === true)
        set3.headers["access-control-expose-headers"] = headers;
    }
  });
};
var index_default3 = cors;

// src/plugin/auth-guard.ts
var authGuard = {
  beforeHandle: [
    async ({ jwt: jwt3, bearer: bearer2, status: status2 }) => {
      const token = await jwt3.verify(bearer2);
      if (!token)
        return status2(401, { error: "Unauthorized" });
    }
  ]
};

// src/modules/profiles/index.ts
init_server_bun();
var React9 = __toESM(require_react(), 1);

// src/emails/otp.tsx
var React8 = __toESM(require_react(), 1);

// node_modules/@react-email/button/dist/index.mjs
var React2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var __defProp4 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp3.call(b3, prop))
      __defNormalProp(a, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps = (a, b3) => __defProps(a, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function convertToPx(value) {
  let px = 0;
  if (!value) {
    return px;
  }
  if (typeof value === "number") {
    return value;
  }
  const matches = /^([\d.]+)(px|em|rem|%)$/.exec(value);
  if (matches && matches.length === 3) {
    const numValue = Number.parseFloat(matches[1]);
    const unit = matches[2];
    switch (unit) {
      case "px":
        return numValue;
      case "em":
      case "rem":
        px = numValue * 16;
        return px;
      case "%":
        px = numValue / 100 * 600;
        return px;
      default:
        return numValue;
    }
  }
  return 0;
}
function parsePaddingValue(value) {
  if (typeof value === "number")
    return {
      paddingTop: value,
      paddingBottom: value,
      paddingLeft: value,
      paddingRight: value
    };
  if (typeof value === "string") {
    const values2 = value.toString().trim().split(/\s+/);
    if (values2.length === 1) {
      return {
        paddingTop: values2[0],
        paddingBottom: values2[0],
        paddingLeft: values2[0],
        paddingRight: values2[0]
      };
    }
    if (values2.length === 2) {
      return {
        paddingTop: values2[0],
        paddingRight: values2[1],
        paddingBottom: values2[0],
        paddingLeft: values2[1]
      };
    }
    if (values2.length === 3) {
      return {
        paddingTop: values2[0],
        paddingRight: values2[1],
        paddingBottom: values2[2],
        paddingLeft: values2[1]
      };
    }
    if (values2.length === 4) {
      return {
        paddingTop: values2[0],
        paddingRight: values2[1],
        paddingBottom: values2[2],
        paddingLeft: values2[3]
      };
    }
  }
  return {
    paddingTop: undefined,
    paddingBottom: undefined,
    paddingLeft: undefined,
    paddingRight: undefined
  };
}
function parsePadding(properties) {
  let paddingTop;
  let paddingRight;
  let paddingBottom;
  let paddingLeft;
  for (const [key, value] of Object.entries(properties)) {
    if (key === "padding") {
      ({ paddingTop, paddingBottom, paddingLeft, paddingRight } = parsePaddingValue(value));
    } else if (key === "paddingTop") {
      paddingTop = value;
    } else if (key === "paddingRight") {
      paddingRight = value;
    } else if (key === "paddingBottom") {
      paddingBottom = value;
    } else if (key === "paddingLeft") {
      paddingLeft = value;
    }
  }
  return {
    paddingTop: paddingTop ? convertToPx(paddingTop) : undefined,
    paddingRight: paddingRight ? convertToPx(paddingRight) : undefined,
    paddingBottom: paddingBottom ? convertToPx(paddingBottom) : undefined,
    paddingLeft: paddingLeft ? convertToPx(paddingLeft) : undefined
  };
}
var pxToPt = (px) => typeof px === "number" && !Number.isNaN(Number(px)) ? px * 3 / 4 : undefined;
var maxFontWidth = 5;
function computeFontWidthAndSpaceCount(expectedWidth) {
  if (expectedWidth === 0)
    return [0, 0];
  let smallestSpaceCount = 0;
  const computeRequiredFontWidth = () => {
    if (smallestSpaceCount > 0) {
      return expectedWidth / smallestSpaceCount / 2;
    }
    return Number.POSITIVE_INFINITY;
  };
  while (computeRequiredFontWidth() > maxFontWidth) {
    smallestSpaceCount++;
  }
  return [computeRequiredFontWidth(), smallestSpaceCount];
}
var Button = React2.forwardRef((_a2, ref) => {
  var _b2 = _a2, { children, style, target = "_blank" } = _b2, props = __objRest(_b2, ["children", "style", "target"]);
  const { paddingTop, paddingRight, paddingBottom, paddingLeft } = parsePadding(style != null ? style : {});
  const y = (paddingTop != null ? paddingTop : 0) + (paddingBottom != null ? paddingBottom : 0);
  const textRaise = pxToPt(y);
  const [plFontWidth, plSpaceCount] = computeFontWidthAndSpaceCount(paddingLeft != null ? paddingLeft : 0);
  const [prFontWidth, prSpaceCount] = computeFontWidthAndSpaceCount(paddingRight != null ? paddingRight : 0);
  return /* @__PURE__ */ import_jsx_runtime.jsxs("a", __spreadProps(__spreadValues({}, props), {
    ref,
    style: __spreadProps(__spreadValues({
      lineHeight: "100%",
      textDecoration: "none",
      display: "inline-block",
      maxWidth: "100%",
      msoPaddingAlt: "0px"
    }, style), {
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft
    }),
    target,
    children: [
      /* @__PURE__ */ import_jsx_runtime.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="mso-font-width:${plFontWidth * 100}%;mso-text-raise:${textRaise}" hidden>${"&#8202;".repeat(plSpaceCount)}</i><![endif]-->`
        }
      }),
      /* @__PURE__ */ import_jsx_runtime.jsx("span", {
        style: {
          maxWidth: "100%",
          display: "inline-block",
          lineHeight: "120%",
          msoPaddingAlt: "0px",
          msoTextRaise: pxToPt(paddingBottom)
        },
        children
      }),
      /* @__PURE__ */ import_jsx_runtime.jsx("span", {
        dangerouslySetInnerHTML: {
          __html: `<!--[if mso]><i style="mso-font-width:${prFontWidth * 100}%" hidden>${"&#8202;".repeat(prSpaceCount)}&#8203;</i><![endif]-->`
        }
      })
    ]
  }));
});
Button.displayName = "Button";

// node_modules/@react-email/column/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var __defProp5 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp4.call(b3, prop))
      __defNormalProp2(a, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b3) => __defProps2(a, __getOwnPropDescs2(b3));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Column2 = React3.forwardRef((_a2, ref) => {
  var _b2 = _a2, { children, style } = _b2, props = __objRest2(_b2, ["children", "style"]);
  return /* @__PURE__ */ import_jsx_runtime2.jsx("td", __spreadProps2(__spreadValues2({}, props), { "data-id": "__react-email-column", ref, style, children }));
});
Column2.displayName = "Column";

// node_modules/@react-email/container/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var __defProp6 = Object.defineProperty;
var __defProps3 = Object.defineProperties;
var __getOwnPropDescs3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => (key in obj) ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp5.call(b3, prop))
      __defNormalProp3(a, prop, b3[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b3)) {
      if (__propIsEnum3.call(b3, prop))
        __defNormalProp3(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps3 = (a, b3) => __defProps3(a, __getOwnPropDescs3(b3));
var __objRest3 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Container = React4.forwardRef((_a2, ref) => {
  var _b2 = _a2, { children, style } = _b2, props = __objRest3(_b2, ["children", "style"]);
  return /* @__PURE__ */ import_jsx_runtime3.jsx("table", __spreadProps3(__spreadValues3({
    align: "center",
    width: "100%"
  }, props), {
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    ref,
    role: "presentation",
    style: __spreadValues3({ maxWidth: "37.5em" }, style),
    children: /* @__PURE__ */ import_jsx_runtime3.jsx("tbody", { children: /* @__PURE__ */ import_jsx_runtime3.jsx("tr", { style: { width: "100%" }, children: /* @__PURE__ */ import_jsx_runtime3.jsx("td", { children }) }) })
  }));
});
Container.displayName = "Container";

// node_modules/@react-email/row/dist/index.mjs
var React5 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var __defProp7 = Object.defineProperty;
var __defProps4 = Object.defineProperties;
var __getOwnPropDescs4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp6 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => (key in obj) ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp6.call(b5, prop))
      __defNormalProp4(a, prop, b5[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b5)) {
      if (__propIsEnum4.call(b5, prop))
        __defNormalProp4(a, prop, b5[prop]);
    }
  return a;
};
var __spreadProps4 = (a, b5) => __defProps4(a, __getOwnPropDescs4(b5));
var __objRest4 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Row = React5.forwardRef((_a4, ref) => {
  var _b2 = _a4, { children, style } = _b2, props = __objRest4(_b2, ["children", "style"]);
  return /* @__PURE__ */ import_jsx_runtime5.jsx("table", __spreadProps4(__spreadValues4({
    align: "center",
    width: "100%",
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation"
  }, props), {
    ref,
    style,
    children: /* @__PURE__ */ import_jsx_runtime5.jsx("tbody", { style: { width: "100%" }, children: /* @__PURE__ */ import_jsx_runtime5.jsx("tr", { style: { width: "100%" }, children }) })
  }));
});
Row.displayName = "Row";

// node_modules/@react-email/section/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var __defProp8 = Object.defineProperty;
var __defProps5 = Object.defineProperties;
var __getOwnPropDescs5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols5 = Object.getOwnPropertySymbols;
var __hasOwnProp7 = Object.prototype.hasOwnProperty;
var __propIsEnum5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp5 = (obj, key, value) => (key in obj) ? __defProp8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues5 = (a, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp7.call(b5, prop))
      __defNormalProp5(a, prop, b5[prop]);
  if (__getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(b5)) {
      if (__propIsEnum5.call(b5, prop))
        __defNormalProp5(a, prop, b5[prop]);
    }
  return a;
};
var __spreadProps5 = (a, b5) => __defProps5(a, __getOwnPropDescs5(b5));
var __objRest5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp7.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols5)
    for (var prop of __getOwnPropSymbols5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var Section = React6.forwardRef((_a4, ref) => {
  var _b2 = _a4, { children, style } = _b2, props = __objRest5(_b2, ["children", "style"]);
  return /* @__PURE__ */ import_jsx_runtime6.jsx("table", __spreadProps5(__spreadValues5({
    align: "center",
    width: "100%",
    border: 0,
    cellPadding: "0",
    cellSpacing: "0",
    role: "presentation"
  }, props), {
    ref,
    style,
    children: /* @__PURE__ */ import_jsx_runtime6.jsx("tbody", { children: /* @__PURE__ */ import_jsx_runtime6.jsx("tr", { children: /* @__PURE__ */ import_jsx_runtime6.jsx("td", { children }) }) })
  }));
});
Section.displayName = "Section";

// node_modules/@react-email/tailwind/dist/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var Or5 = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var __dirname = "/Users/dkaji/koding/basic/elysia/app/node_modules/@react-email/tailwind/dist";
var ta2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function He3(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
function cu2(u) {
  if (Object.prototype.hasOwnProperty.call(u, "__esModule"))
    return u;
  var a = u.default;
  if (typeof a == "function") {
    var h2 = function p() {
      return this instanceof p ? Reflect.construct(a, arguments, this.constructor) : a.apply(this, arguments);
    };
    h2.prototype = a.prototype;
  } else
    h2 = {};
  return Object.defineProperty(h2, "__esModule", { value: true }), Object.keys(u).forEach(function(p) {
    var l3 = Object.getOwnPropertyDescriptor(u, p);
    Object.defineProperty(h2, p, l3.get ? l3 : {
      enumerable: true,
      get: function() {
        return u[p];
      }
    });
  }), h2;
}
var pt3 = { exports: {} };
var ra2;
function Ti() {
  if (ra2)
    return pt3.exports;
  ra2 = 1;
  var u = String, a = function() {
    return { isColorSupported: false, reset: u, bold: u, dim: u, italic: u, underline: u, inverse: u, hidden: u, strikethrough: u, black: u, red: u, green: u, yellow: u, blue: u, magenta: u, cyan: u, white: u, gray: u, bgBlack: u, bgRed: u, bgGreen: u, bgYellow: u, bgBlue: u, bgMagenta: u, bgCyan: u, bgWhite: u, blackBright: u, redBright: u, greenBright: u, yellowBright: u, blueBright: u, magentaBright: u, cyanBright: u, whiteBright: u, bgBlackBright: u, bgRedBright: u, bgGreenBright: u, bgYellowBright: u, bgBlueBright: u, bgMagentaBright: u, bgCyanBright: u, bgWhiteBright: u };
  };
  return pt3.exports = a(), pt3.exports.createColors = a, pt3.exports;
}
var du2 = {};
var pu2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: du2
}, Symbol.toStringTag, { value: "Module" }));
var Ne3 = /* @__PURE__ */ cu2(pu2);
var kr3;
var na2;
function Ai2() {
  if (na2)
    return kr3;
  na2 = 1;
  let u = /* @__PURE__ */ Ti(), a = Ne3;

  class h2 extends Error {
    constructor(l3, f, s2, c2, t10, e2) {
      super(l3), this.name = "CssSyntaxError", this.reason = l3, t10 && (this.file = t10), c2 && (this.source = c2), e2 && (this.plugin = e2), typeof f < "u" && typeof s2 < "u" && (typeof f == "number" ? (this.line = f, this.column = s2) : (this.line = f.line, this.column = f.column, this.endLine = s2.line, this.endColumn = s2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, h2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(l3) {
      if (!this.source)
        return "";
      let f = this.source;
      l3 == null && (l3 = u.isColorSupported);
      let s2 = (v3) => v3, c2 = (v3) => v3, t10 = (v3) => v3;
      if (l3) {
        let { bold: v3, gray: m, red: n2 } = u.createColors(true);
        c2 = (d2) => v3(n2(d2)), s2 = (d2) => m(d2), a && (t10 = (d2) => a(d2));
      }
      let e2 = f.split(/\r?\n/), r2 = Math.max(this.line - 3, 0), i2 = Math.min(this.line + 2, e2.length), o2 = String(i2).length;
      return e2.slice(r2, i2).map((v3, m) => {
        let n2 = r2 + 1 + m, d2 = " " + (" " + n2).slice(-o2) + " | ";
        if (n2 === this.line) {
          if (v3.length > 160) {
            let w3 = 20, y2 = Math.max(0, this.column - w3), x2 = Math.max(this.column + w3, this.endColumn + w3), g2 = v3.slice(y2, x2), O3 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, Math.min(this.column - 1, w3 - 1)).replace(/[^\t]/g, " ");
            return c2(">") + s2(d2) + t10(g2) + `
 ` + O3 + c2("^");
          }
          let _4 = s2(d2.replace(/\d/g, " ")) + v3.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return c2(">") + s2(d2) + t10(v3) + `
 ` + _4 + c2("^");
        }
        return " " + s2(d2) + t10(v3);
      }).join(`
`);
    }
    toString() {
      let l3 = this.showSourceCode();
      return l3 && (l3 = `

` + l3 + `
`), this.name + ": " + this.message + l3;
    }
  }
  return kr3 = h2, h2.default = h2, kr3;
}
var Pr3;
var ia2;
function dl() {
  if (ia2)
    return Pr3;
  ia2 = 1;
  const u = {
    after: `
`,
    beforeClose: `
`,
    beforeComment: `
`,
    beforeDecl: `
`,
    beforeOpen: " ",
    beforeRule: `
`,
    colon: ": ",
    commentLeft: " ",
    commentRight: " ",
    emptyBody: "",
    indent: "    ",
    semicolon: false
  };
  function a(p) {
    return p[0].toUpperCase() + p.slice(1);
  }

  class h2 {
    constructor(l3) {
      this.builder = l3;
    }
    atrule(l3, f) {
      let s2 = "@" + l3.name, c2 = l3.params ? this.rawValue(l3, "params") : "";
      if (typeof l3.raws.afterName < "u" ? s2 += l3.raws.afterName : c2 && (s2 += " "), l3.nodes)
        this.block(l3, s2 + c2);
      else {
        let t10 = (l3.raws.between || "") + (f ? ";" : "");
        this.builder(s2 + c2 + t10, l3);
      }
    }
    beforeAfter(l3, f) {
      let s2;
      l3.type === "decl" ? s2 = this.raw(l3, null, "beforeDecl") : l3.type === "comment" ? s2 = this.raw(l3, null, "beforeComment") : f === "before" ? s2 = this.raw(l3, null, "beforeRule") : s2 = this.raw(l3, null, "beforeClose");
      let c2 = l3.parent, t10 = 0;
      for (;c2 && c2.type !== "root"; )
        t10 += 1, c2 = c2.parent;
      if (s2.includes(`
`)) {
        let e2 = this.raw(l3, null, "indent");
        if (e2.length)
          for (let r2 = 0;r2 < t10; r2++)
            s2 += e2;
      }
      return s2;
    }
    block(l3, f) {
      let s2 = this.raw(l3, "between", "beforeOpen");
      this.builder(f + s2 + "{", l3, "start");
      let c2;
      l3.nodes && l3.nodes.length ? (this.body(l3), c2 = this.raw(l3, "after")) : c2 = this.raw(l3, "after", "emptyBody"), c2 && this.builder(c2), this.builder("}", l3, "end");
    }
    body(l3) {
      let f = l3.nodes.length - 1;
      for (;f > 0 && l3.nodes[f].type === "comment"; )
        f -= 1;
      let s2 = this.raw(l3, "semicolon");
      for (let c2 = 0;c2 < l3.nodes.length; c2++) {
        let t10 = l3.nodes[c2], e2 = this.raw(t10, "before");
        e2 && this.builder(e2), this.stringify(t10, f !== c2 || s2);
      }
    }
    comment(l3) {
      let f = this.raw(l3, "left", "commentLeft"), s2 = this.raw(l3, "right", "commentRight");
      this.builder("/*" + f + l3.text + s2 + "*/", l3);
    }
    decl(l3, f) {
      let s2 = this.raw(l3, "between", "colon"), c2 = l3.prop + s2 + this.rawValue(l3, "value");
      l3.important && (c2 += l3.raws.important || " !important"), f && (c2 += ";"), this.builder(c2, l3);
    }
    document(l3) {
      this.body(l3);
    }
    raw(l3, f, s2) {
      let c2;
      if (s2 || (s2 = f), f && (c2 = l3.raws[f], typeof c2 < "u"))
        return c2;
      let t10 = l3.parent;
      if (s2 === "before" && (!t10 || t10.type === "root" && t10.first === l3 || t10 && t10.type === "document"))
        return "";
      if (!t10)
        return u[s2];
      let e2 = l3.root();
      if (e2.rawCache || (e2.rawCache = {}), typeof e2.rawCache[s2] < "u")
        return e2.rawCache[s2];
      if (s2 === "before" || s2 === "after")
        return this.beforeAfter(l3, s2);
      {
        let r2 = "raw" + a(s2);
        this[r2] ? c2 = this[r2](e2, l3) : e2.walk((i2) => {
          if (c2 = i2.raws[f], typeof c2 < "u")
            return false;
        });
      }
      return typeof c2 > "u" && (c2 = u[s2]), e2.rawCache[s2] = c2, c2;
    }
    rawBeforeClose(l3) {
      let f;
      return l3.walk((s2) => {
        if (s2.nodes && s2.nodes.length > 0 && typeof s2.raws.after < "u")
          return f = s2.raws.after, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawBeforeComment(l3, f) {
      let s2;
      return l3.walkComments((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeDecl") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeDecl(l3, f) {
      let s2;
      return l3.walkDecls((c2) => {
        if (typeof c2.raws.before < "u")
          return s2 = c2.raws.before, s2.includes(`
`) && (s2 = s2.replace(/[^\n]+$/, "")), false;
      }), typeof s2 > "u" ? s2 = this.raw(f, null, "beforeRule") : s2 && (s2 = s2.replace(/\S/g, "")), s2;
    }
    rawBeforeOpen(l3) {
      let f;
      return l3.walk((s2) => {
        if (s2.type !== "decl" && (f = s2.raws.between, typeof f < "u"))
          return false;
      }), f;
    }
    rawBeforeRule(l3) {
      let f;
      return l3.walk((s2) => {
        if (s2.nodes && (s2.parent !== l3 || l3.first !== s2) && typeof s2.raws.before < "u")
          return f = s2.raws.before, f.includes(`
`) && (f = f.replace(/[^\n]+$/, "")), false;
      }), f && (f = f.replace(/\S/g, "")), f;
    }
    rawColon(l3) {
      let f;
      return l3.walkDecls((s2) => {
        if (typeof s2.raws.between < "u")
          return f = s2.raws.between.replace(/[^\s:]/g, ""), false;
      }), f;
    }
    rawEmptyBody(l3) {
      let f;
      return l3.walk((s2) => {
        if (s2.nodes && s2.nodes.length === 0 && (f = s2.raws.after, typeof f < "u"))
          return false;
      }), f;
    }
    rawIndent(l3) {
      if (l3.raws.indent)
        return l3.raws.indent;
      let f;
      return l3.walk((s2) => {
        let c2 = s2.parent;
        if (c2 && c2 !== l3 && c2.parent && c2.parent === l3 && typeof s2.raws.before < "u") {
          let t10 = s2.raws.before.split(`
`);
          return f = t10[t10.length - 1], f = f.replace(/\S/g, ""), false;
        }
      }), f;
    }
    rawSemicolon(l3) {
      let f;
      return l3.walk((s2) => {
        if (s2.nodes && s2.nodes.length && s2.last.type === "decl" && (f = s2.raws.semicolon, typeof f < "u"))
          return false;
      }), f;
    }
    rawValue(l3, f) {
      let s2 = l3[f], c2 = l3.raws[f];
      return c2 && c2.value === s2 ? c2.raw : s2;
    }
    root(l3) {
      this.body(l3), l3.raws.after && this.builder(l3.raws.after);
    }
    rule(l3) {
      this.block(l3, this.rawValue(l3, "selector")), l3.raws.ownSemicolon && this.builder(l3.raws.ownSemicolon, l3, "end");
    }
    stringify(l3, f) {
      if (!this[l3.type])
        throw new Error("Unknown AST node type " + l3.type + ". Maybe you need to change PostCSS stringifier.");
      this[l3.type](l3, f);
    }
  }
  return Pr3 = h2, h2.default = h2, Pr3;
}
var Er3;
var aa2;
function or4() {
  if (aa2)
    return Er3;
  aa2 = 1;
  let u = dl();
  function a(h2, p) {
    new u(p).stringify(h2);
  }
  return Er3 = a, a.default = a, Er3;
}
var ht3 = {};
var sa2;
function Ci2() {
  return sa2 || (sa2 = 1, ht3.isClean = Symbol("isClean"), ht3.my = Symbol("my")), ht3;
}
var Tr3;
var oa2;
function lr3() {
  if (oa2)
    return Tr3;
  oa2 = 1;
  let u = Ai2(), a = dl(), h2 = or4(), { isClean: p, my: l3 } = Ci2();
  function f(t10, e2) {
    let r2 = new t10.constructor;
    for (let i2 in t10) {
      if (!Object.prototype.hasOwnProperty.call(t10, i2) || i2 === "proxyCache")
        continue;
      let o2 = t10[i2], v3 = typeof o2;
      i2 === "parent" && v3 === "object" ? e2 && (r2[i2] = e2) : i2 === "source" ? r2[i2] = o2 : Array.isArray(o2) ? r2[i2] = o2.map((m) => f(m, r2)) : (v3 === "object" && o2 !== null && (o2 = f(o2)), r2[i2] = o2);
    }
    return r2;
  }
  function s2(t10, e2) {
    if (e2 && typeof e2.offset < "u")
      return e2.offset;
    let r2 = 1, i2 = 1, o2 = 0;
    for (let v3 = 0;v3 < t10.length; v3++) {
      if (i2 === e2.line && r2 === e2.column) {
        o2 = v3;
        break;
      }
      t10[v3] === `
` ? (r2 = 1, i2 += 1) : r2 += 1;
    }
    return o2;
  }

  class c2 {
    get proxyOf() {
      return this;
    }
    constructor(e2 = {}) {
      this.raws = {}, this[p] = false, this[l3] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let i2 of e2[r2])
            typeof i2.clone == "function" ? this.append(i2.clone()) : this.append(i2);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(/\n\s{4}at /, `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`);
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = f(this);
      for (let i2 in e2)
        r2[i2] = e2[i2];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: i2, start: o2 } = this.rangeBy(r2);
        return this.source.input.error(e2, { column: o2.column, line: o2.line }, { column: i2.column, line: i2.line }, r2);
      }
      return new u(e2);
    }
    getProxyProcessor() {
      return {
        get(e2, r2) {
          return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
        },
        set(e2, r2, i2) {
          return e2[r2] === i2 || (e2[r2] = i2, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || r2 === "text") && e2.markDirty()), true;
        }
      };
    }
    markClean() {
      this[p] = true;
    }
    markDirty() {
      if (this[p]) {
        this[p] = false;
        let e2 = this;
        for (;e2 = e2.parent; )
          e2[p] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2) {
      let r2 = this.source.start;
      if (e2.index)
        r2 = this.positionInside(e2.index);
      else if (e2.word) {
        let i2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = i2.slice(s2(i2, this.source.start), s2(i2, this.source.end)).indexOf(e2.word);
        v3 !== -1 && (r2 = this.positionInside(v3));
      }
      return r2;
    }
    positionInside(e2) {
      let r2 = this.source.start.column, i2 = this.source.start.line, o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, v3 = s2(o2, this.source.start), m = v3 + e2;
      for (let n2 = v3;n2 < m; n2++)
        o2[n2] === `
` ? (r2 = 1, i2 += 1) : r2 += 1;
      return { column: r2, line: i2 };
    }
    prev() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = {
        column: this.source.start.column,
        line: this.source.start.line
      }, i2 = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: r2.column + 1,
        line: r2.line
      };
      if (e2.word) {
        let o2 = "document" in this.source.input ? this.source.input.document : this.source.input.css, m = o2.slice(s2(o2, this.source.start), s2(o2, this.source.end)).indexOf(e2.word);
        m !== -1 && (r2 = this.positionInside(m), i2 = this.positionInside(m + e2.word.length));
      } else
        e2.start ? r2 = {
          column: e2.start.column,
          line: e2.start.line
        } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? i2 = {
          column: e2.end.column,
          line: e2.end.line
        } : typeof e2.endIndex == "number" ? i2 = this.positionInside(e2.endIndex) : e2.index && (i2 = this.positionInside(e2.index + 1));
      return (i2.line < r2.line || i2.line === r2.line && i2.column <= r2.column) && (i2 = { column: r2.column + 1, line: r2.line }), { end: i2, start: r2 };
    }
    raw(e2, r2) {
      return new a().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, i2 = false;
        for (let o2 of e2)
          o2 === this ? i2 = true : i2 ? (this.parent.insertAfter(r2, o2), r2 = o2) : this.parent.insertBefore(r2, o2);
        i2 || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (;e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let i2 = {}, o2 = r2 == null;
      r2 = r2 || /* @__PURE__ */ new Map;
      let v3 = 0;
      for (let m in this) {
        if (!Object.prototype.hasOwnProperty.call(this, m) || m === "parent" || m === "proxyCache")
          continue;
        let n2 = this[m];
        if (Array.isArray(n2))
          i2[m] = n2.map((d2) => typeof d2 == "object" && d2.toJSON ? d2.toJSON(null, r2) : d2);
        else if (typeof n2 == "object" && n2.toJSON)
          i2[m] = n2.toJSON(null, r2);
        else if (m === "source") {
          let d2 = r2.get(n2.input);
          d2 == null && (d2 = v3, r2.set(n2.input, v3), v3++), i2[m] = {
            end: n2.end,
            inputId: d2,
            start: n2.start
          };
        } else
          i2[m] = n2;
      }
      return o2 && (i2.inputs = [...r2.keys()].map((m) => m.toJSON())), i2;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = h2) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (i2) => {
        r2 += i2;
      }), r2;
    }
    warn(e2, r2, i2) {
      let o2 = { node: this };
      for (let v3 in i2)
        o2[v3] = i2[v3];
      return e2.warn(r2, o2);
    }
  }
  return Tr3 = c2, c2.default = c2, Tr3;
}
var Ar3;
var la2;
function ur3() {
  if (la2)
    return Ar3;
  la2 = 1;
  let u = lr3();

  class a extends u {
    constructor(p) {
      super(p), this.type = "comment";
    }
  }
  return Ar3 = a, a.default = a, Ar3;
}
var Cr3;
var ua2;
function fr3() {
  if (ua2)
    return Cr3;
  ua2 = 1;
  let u = lr3();

  class a extends u {
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
    constructor(p) {
      p && typeof p.value < "u" && typeof p.value != "string" && (p = { ...p, value: String(p.value) }), super(p), this.type = "decl";
    }
  }
  return Cr3 = a, a.default = a, Cr3;
}
var Rr3;
var fa2;
function nt3() {
  if (fa2)
    return Rr3;
  fa2 = 1;
  let u = ur3(), a = fr3(), h2 = lr3(), { isClean: p, my: l3 } = Ci2(), f, s2, c2, t10;
  function e2(o2) {
    return o2.map((v3) => (v3.nodes && (v3.nodes = e2(v3.nodes)), delete v3.source, v3));
  }
  function r2(o2) {
    if (o2[p] = false, o2.proxyOf.nodes)
      for (let v3 of o2.proxyOf.nodes)
        r2(v3);
  }

  class i2 extends h2 {
    get first() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
    append(...v3) {
      for (let m of v3) {
        let n2 = this.normalize(m, this.last);
        for (let d2 of n2)
          this.proxyOf.nodes.push(d2);
      }
      return this.markDirty(), this;
    }
    cleanRaws(v3) {
      if (super.cleanRaws(v3), this.nodes)
        for (let m of this.nodes)
          m.cleanRaws(v3);
    }
    each(v3) {
      if (!this.proxyOf.nodes)
        return;
      let m = this.getIterator(), n2, d2;
      for (;this.indexes[m] < this.proxyOf.nodes.length && (n2 = this.indexes[m], d2 = v3(this.proxyOf.nodes[n2], n2), d2 !== false); )
        this.indexes[m] += 1;
      return delete this.indexes[m], d2;
    }
    every(v3) {
      return this.nodes.every(v3);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let v3 = this.lastEach;
      return this.indexes[v3] = 0, v3;
    }
    getProxyProcessor() {
      return {
        get(v3, m) {
          return m === "proxyOf" ? v3 : v3[m] ? m === "each" || typeof m == "string" && m.startsWith("walk") ? (...n2) => v3[m](...n2.map((d2) => typeof d2 == "function" ? (_4, w3) => d2(_4.toProxy(), w3) : d2)) : m === "every" || m === "some" ? (n2) => v3[m]((d2, ..._4) => n2(d2.toProxy(), ..._4)) : m === "root" ? () => v3.root().toProxy() : m === "nodes" ? v3.nodes.map((n2) => n2.toProxy()) : m === "first" || m === "last" ? v3[m].toProxy() : v3[m] : v3[m];
        },
        set(v3, m, n2) {
          return v3[m] === n2 || (v3[m] = n2, (m === "name" || m === "params" || m === "selector") && v3.markDirty()), true;
        }
      };
    }
    index(v3) {
      return typeof v3 == "number" ? v3 : (v3.proxyOf && (v3 = v3.proxyOf), this.proxyOf.nodes.indexOf(v3));
    }
    insertAfter(v3, m) {
      let n2 = this.index(v3), d2 = this.normalize(m, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(v3);
      for (let w3 of d2)
        this.proxyOf.nodes.splice(n2 + 1, 0, w3);
      let _4;
      for (let w3 in this.indexes)
        _4 = this.indexes[w3], n2 < _4 && (this.indexes[w3] = _4 + d2.length);
      return this.markDirty(), this;
    }
    insertBefore(v3, m) {
      let n2 = this.index(v3), d2 = n2 === 0 ? "prepend" : false, _4 = this.normalize(m, this.proxyOf.nodes[n2], d2).reverse();
      n2 = this.index(v3);
      for (let y2 of _4)
        this.proxyOf.nodes.splice(n2, 0, y2);
      let w3;
      for (let y2 in this.indexes)
        w3 = this.indexes[y2], n2 <= w3 && (this.indexes[y2] = w3 + _4.length);
      return this.markDirty(), this;
    }
    normalize(v3, m) {
      if (typeof v3 == "string")
        v3 = e2(s2(v3).nodes);
      else if (typeof v3 > "u")
        v3 = [];
      else if (Array.isArray(v3)) {
        v3 = v3.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type === "root" && this.type !== "document") {
        v3 = v3.nodes.slice(0);
        for (let d2 of v3)
          d2.parent && d2.parent.removeChild(d2, "ignore");
      } else if (v3.type)
        v3 = [v3];
      else if (v3.prop) {
        if (typeof v3.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof v3.value != "string" && (v3.value = String(v3.value)), v3 = [new a(v3)];
      } else if (v3.selector || v3.selectors)
        v3 = [new t10(v3)];
      else if (v3.name)
        v3 = [new f(v3)];
      else if (v3.text)
        v3 = [new u(v3)];
      else
        throw new Error("Unknown node type in node creation");
      return v3.map((d2) => (d2[l3] || i2.rebuild(d2), d2 = d2.proxyOf, d2.parent && d2.parent.removeChild(d2), d2[p] && r2(d2), d2.raws || (d2.raws = {}), typeof d2.raws.before > "u" && m && typeof m.raws.before < "u" && (d2.raws.before = m.raws.before.replace(/\S/g, "")), d2.parent = this.proxyOf, d2));
    }
    prepend(...v3) {
      v3 = v3.reverse();
      for (let m of v3) {
        let n2 = this.normalize(m, this.first, "prepend").reverse();
        for (let d2 of n2)
          this.proxyOf.nodes.unshift(d2);
        for (let d2 in this.indexes)
          this.indexes[d2] = this.indexes[d2] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(v3) {
      return v3.parent = this, this.proxyOf.nodes.push(v3), this;
    }
    removeAll() {
      for (let v3 of this.proxyOf.nodes)
        v3.parent = undefined;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(v3) {
      v3 = this.index(v3), this.proxyOf.nodes[v3].parent = undefined, this.proxyOf.nodes.splice(v3, 1);
      let m;
      for (let n2 in this.indexes)
        m = this.indexes[n2], m >= v3 && (this.indexes[n2] = m - 1);
      return this.markDirty(), this;
    }
    replaceValues(v3, m, n2) {
      return n2 || (n2 = m, m = {}), this.walkDecls((d2) => {
        m.props && !m.props.includes(d2.prop) || m.fast && !d2.value.includes(m.fast) || (d2.value = d2.value.replace(v3, n2));
      }), this.markDirty(), this;
    }
    some(v3) {
      return this.nodes.some(v3);
    }
    walk(v3) {
      return this.each((m, n2) => {
        let d2;
        try {
          d2 = v3(m, n2);
        } catch (_4) {
          throw m.addToError(_4);
        }
        return d2 !== false && m.walk && (d2 = m.walk(v3)), d2;
      });
    }
    walkAtRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "atrule" && v3.test(n2.name))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "atrule" && n2.name === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "atrule")
          return m(n2, d2);
      }));
    }
    walkComments(v3) {
      return this.walk((m, n2) => {
        if (m.type === "comment")
          return v3(m, n2);
      });
    }
    walkDecls(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "decl" && v3.test(n2.prop))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "decl" && n2.prop === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "decl")
          return m(n2, d2);
      }));
    }
    walkRules(v3, m) {
      return m ? v3 instanceof RegExp ? this.walk((n2, d2) => {
        if (n2.type === "rule" && v3.test(n2.selector))
          return m(n2, d2);
      }) : this.walk((n2, d2) => {
        if (n2.type === "rule" && n2.selector === v3)
          return m(n2, d2);
      }) : (m = v3, this.walk((n2, d2) => {
        if (n2.type === "rule")
          return m(n2, d2);
      }));
    }
  }
  return i2.registerParse = (o2) => {
    s2 = o2;
  }, i2.registerRule = (o2) => {
    t10 = o2;
  }, i2.registerAtRule = (o2) => {
    f = o2;
  }, i2.registerRoot = (o2) => {
    c2 = o2;
  }, Rr3 = i2, i2.default = i2, i2.rebuild = (o2) => {
    o2.type === "atrule" ? Object.setPrototypeOf(o2, f.prototype) : o2.type === "rule" ? Object.setPrototypeOf(o2, t10.prototype) : o2.type === "decl" ? Object.setPrototypeOf(o2, a.prototype) : o2.type === "comment" ? Object.setPrototypeOf(o2, u.prototype) : o2.type === "root" && Object.setPrototypeOf(o2, c2.prototype), o2[l3] = true, o2.nodes && o2.nodes.forEach((v3) => {
      i2.rebuild(v3);
    });
  }, Rr3;
}
var Ir3;
var ca2;
function Ri2() {
  if (ca2)
    return Ir3;
  ca2 = 1;
  let u = nt3();

  class a extends u {
    constructor(p) {
      super(p), this.type = "atrule";
    }
    append(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...p);
    }
    prepend(...p) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...p);
    }
  }
  return Ir3 = a, a.default = a, u.registerAtRule(a), Ir3;
}
var Mr2;
var da2;
function Ii2() {
  if (da2)
    return Mr2;
  da2 = 1;
  let u = nt3(), a, h2;

  class p extends u {
    constructor(f) {
      super({ type: "document", ...f }), this.nodes || (this.nodes = []);
    }
    toResult(f = {}) {
      return new a(new h2, this, f).stringify();
    }
  }
  return p.registerLazyResult = (l3) => {
    a = l3;
  }, p.registerProcessor = (l3) => {
    h2 = l3;
  }, Mr2 = p, p.default = p, Mr2;
}
var Dr3;
var pa2;
function hu2() {
  if (pa2)
    return Dr3;
  pa2 = 1;
  let u = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  return Dr3 = { nanoid: (p = 21) => {
    let l3 = "", f = p | 0;
    for (;f--; )
      l3 += u[Math.random() * 64 | 0];
    return l3;
  }, customAlphabet: (p, l3 = 21) => (f = l3) => {
    let s2 = "", c2 = f | 0;
    for (;c2--; )
      s2 += p[Math.random() * p.length | 0];
    return s2;
  } }, Dr3;
}
var qr2;
var ha2;
function pl() {
  if (ha2)
    return qr2;
  ha2 = 1;
  let { existsSync: u, readFileSync: a } = Ne3, { dirname: h2, join: p } = Ne3, { SourceMapConsumer: l3, SourceMapGenerator: f } = Ne3;
  function s2(t10) {
    return Buffer ? Buffer.from(t10, "base64").toString() : window.atob(t10);
  }

  class c2 {
    constructor(e2, r2) {
      if (r2.map === false)
        return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let i2 = r2.map ? r2.map.prev : undefined, o2 = this.loadMap(r2.from, i2);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = h2(this.mapFile)), o2 && (this.text = o2);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new l3(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, i2 = /^data:application\/json;base64,/, o2 = /^data:application\/json;charset=utf-?8,/, v3 = /^data:application\/json,/, m = e2.match(o2) || e2.match(v3);
      if (m)
        return decodeURIComponent(e2.substr(m[0].length));
      let n2 = e2.match(r2) || e2.match(i2);
      if (n2)
        return s2(e2.substr(n2[0].length));
      let d2 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + d2);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/g);
      if (!r2)
        return;
      let i2 = e2.lastIndexOf(r2.pop()), o2 = e2.indexOf("*/", i2);
      i2 > -1 && o2 > -1 && (this.annotation = this.getAnnotationURL(e2.substring(i2, o2)));
    }
    loadFile(e2) {
      if (this.root = h2(e2), u(e2))
        return this.mapFile = e2, a(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false)
        return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let i2 = r2(e2);
          if (i2) {
            let o2 = this.loadFile(i2);
            if (!o2)
              throw new Error("Unable to load previous source map: " + i2.toString());
            return o2;
          }
        } else {
          if (r2 instanceof l3)
            return f.fromSourceMap(r2).toString();
          if (r2 instanceof f)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error("Unsupported previous source map format: " + r2.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let i2 = this.annotation;
          return e2 && (i2 = p(h2(e2), i2)), this.loadFile(i2);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  }
  return qr2 = c2, c2.default = c2, qr2;
}
var Lr3;
var va2;
function cr3() {
  if (va2)
    return Lr3;
  va2 = 1;
  let { nanoid: u } = /* @__PURE__ */ hu2(), { isAbsolute: a, resolve: h2 } = Ne3, { SourceMapConsumer: p, SourceMapGenerator: l3 } = Ne3, { fileURLToPath: f, pathToFileURL: s2 } = Ne3, c2 = Ai2(), t10 = pl(), e2 = Ne3, r2 = Symbol("fromOffsetCache"), i2 = !!(p && l3), o2 = !!(h2 && a);

  class v3 {
    get from() {
      return this.file || this.id;
    }
    constructor(n2, d2 = {}) {
      if (n2 === null || typeof n2 > "u" || typeof n2 == "object" && !n2.toString)
        throw new Error(`PostCSS received ${n2} instead of CSS string`);
      if (this.css = n2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, this.document = this.css, d2.document && (this.document = d2.document.toString()), d2.from && (!o2 || /^\w+:\/\//.test(d2.from) || a(d2.from) ? this.file = d2.from : this.file = h2(d2.from)), o2 && i2) {
        let _4 = new t10(this.css, d2);
        if (_4.text) {
          this.map = _4;
          let w3 = _4.consumer().file;
          !this.file && w3 && (this.file = this.mapResolve(w3));
        }
      }
      this.file || (this.id = "<input css " + u(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(n2, d2, _4, w3 = {}) {
      let y2, x2, g2;
      if (d2 && typeof d2 == "object") {
        let A = d2, E2 = _4;
        if (typeof A.offset == "number") {
          let b5 = this.fromOffset(A.offset);
          d2 = b5.line, _4 = b5.col;
        } else
          d2 = A.line, _4 = A.column;
        if (typeof E2.offset == "number") {
          let b5 = this.fromOffset(E2.offset);
          x2 = b5.line, y2 = b5.col;
        } else
          x2 = E2.line, y2 = E2.column;
      } else if (!_4) {
        let A = this.fromOffset(d2);
        d2 = A.line, _4 = A.col;
      }
      let O3 = this.origin(d2, _4, x2, y2);
      return O3 ? g2 = new c2(n2, O3.endLine === undefined ? O3.line : { column: O3.column, line: O3.line }, O3.endLine === undefined ? O3.column : { column: O3.endColumn, line: O3.endLine }, O3.source, O3.file, w3.plugin) : g2 = new c2(n2, x2 === undefined ? d2 : { column: _4, line: d2 }, x2 === undefined ? _4 : { column: y2, line: x2 }, this.css, this.file, w3.plugin), g2.input = { column: _4, endColumn: y2, endLine: x2, line: d2, source: this.css }, this.file && (s2 && (g2.input.url = s2(this.file).toString()), g2.input.file = this.file), g2;
    }
    fromOffset(n2) {
      let d2, _4;
      if (this[r2])
        _4 = this[r2];
      else {
        let y2 = this.css.split(`
`);
        _4 = new Array(y2.length);
        let x2 = 0;
        for (let g2 = 0, O3 = y2.length;g2 < O3; g2++)
          _4[g2] = x2, x2 += y2[g2].length + 1;
        this[r2] = _4;
      }
      d2 = _4[_4.length - 1];
      let w3 = 0;
      if (n2 >= d2)
        w3 = _4.length - 1;
      else {
        let y2 = _4.length - 2, x2;
        for (;w3 < y2; )
          if (x2 = w3 + (y2 - w3 >> 1), n2 < _4[x2])
            y2 = x2 - 1;
          else if (n2 >= _4[x2 + 1])
            w3 = x2 + 1;
          else {
            w3 = x2;
            break;
          }
      }
      return {
        col: n2 - _4[w3] + 1,
        line: w3 + 1
      };
    }
    mapResolve(n2) {
      return /^\w+:\/\//.test(n2) ? n2 : h2(this.map.consumer().sourceRoot || this.map.root || ".", n2);
    }
    origin(n2, d2, _4, w3) {
      if (!this.map)
        return false;
      let y2 = this.map.consumer(), x2 = y2.originalPositionFor({ column: d2, line: n2 });
      if (!x2.source)
        return false;
      let g2;
      typeof _4 == "number" && (g2 = y2.originalPositionFor({ column: w3, line: _4 }));
      let O3;
      a(x2.source) ? O3 = s2(x2.source) : O3 = new URL(x2.source, this.map.consumer().sourceRoot || s2(this.map.mapFile));
      let A = {
        column: x2.column,
        endColumn: g2 && g2.column,
        endLine: g2 && g2.line,
        line: x2.line,
        url: O3.toString()
      };
      if (O3.protocol === "file:")
        if (f)
          A.file = f(O3);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let E2 = y2.sourceContentFor(x2.source);
      return E2 && (A.source = E2), A;
    }
    toJSON() {
      let n2 = {};
      for (let d2 of ["hasBOM", "css", "file", "id"])
        this[d2] != null && (n2[d2] = this[d2]);
      return this.map && (n2.map = { ...this.map }, n2.map.consumerCache && (n2.map.consumerCache = undefined)), n2;
    }
  }
  return Lr3 = v3, v3.default = v3, e2 && e2.registerInput && e2.registerInput(v3), Lr3;
}
var Nr3;
var ga2;
function lt3() {
  if (ga2)
    return Nr3;
  ga2 = 1;
  let u = nt3(), a, h2;

  class p extends u {
    constructor(f) {
      super(f), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(f, s2, c2) {
      let t10 = super.normalize(f);
      if (s2) {
        if (c2 === "prepend")
          this.nodes.length > 1 ? s2.raws.before = this.nodes[1].raws.before : delete s2.raws.before;
        else if (this.first !== s2)
          for (let e2 of t10)
            e2.raws.before = s2.raws.before;
      }
      return t10;
    }
    removeChild(f, s2) {
      let c2 = this.index(f);
      return !s2 && c2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[c2].raws.before), super.removeChild(f);
    }
    toResult(f = {}) {
      return new a(new h2, this, f).stringify();
    }
  }
  return p.registerLazyResult = (l3) => {
    a = l3;
  }, p.registerProcessor = (l3) => {
    h2 = l3;
  }, Nr3 = p, p.default = p, u.registerRoot(p), Nr3;
}
var Fr3;
var ma2;
function hl() {
  if (ma2)
    return Fr3;
  ma2 = 1;
  let u = {
    comma(a) {
      return u.split(a, [","], true);
    },
    space(a) {
      let h2 = [" ", `
`, "\t"];
      return u.split(a, h2);
    },
    split(a, h2, p) {
      let l3 = [], f = "", s2 = false, c2 = 0, t10 = false, e2 = "", r2 = false;
      for (let i2 of a)
        r2 ? r2 = false : i2 === "\\" ? r2 = true : t10 ? i2 === e2 && (t10 = false) : i2 === '"' || i2 === "'" ? (t10 = true, e2 = i2) : i2 === "(" ? c2 += 1 : i2 === ")" ? c2 > 0 && (c2 -= 1) : c2 === 0 && h2.includes(i2) && (s2 = true), s2 ? (f !== "" && l3.push(f.trim()), f = "", s2 = false) : f += i2;
      return (p || f !== "") && l3.push(f.trim()), l3;
    }
  };
  return Fr3 = u, u.default = u, Fr3;
}
var $r3;
var ya2;
function Mi2() {
  if (ya2)
    return $r3;
  ya2 = 1;
  let u = nt3(), a = hl();

  class h2 extends u {
    get selectors() {
      return a.comma(this.selector);
    }
    set selectors(l3) {
      let f = this.selector ? this.selector.match(/,\s*/) : null, s2 = f ? f[0] : "," + this.raw("between", "beforeOpen");
      this.selector = l3.join(s2);
    }
    constructor(l3) {
      super(l3), this.type = "rule", this.nodes || (this.nodes = []);
    }
  }
  return $r3 = h2, h2.default = h2, u.registerRule(h2), $r3;
}
var Ur3;
var wa2;
function vu2() {
  if (wa2)
    return Ur3;
  wa2 = 1;
  let u = Ri2(), a = ur3(), h2 = fr3(), p = cr3(), l3 = pl(), f = lt3(), s2 = Mi2();
  function c2(t10, e2) {
    if (Array.isArray(t10))
      return t10.map((o2) => c2(o2));
    let { inputs: r2, ...i2 } = t10;
    if (r2) {
      e2 = [];
      for (let o2 of r2) {
        let v3 = { ...o2, __proto__: p.prototype };
        v3.map && (v3.map = {
          ...v3.map,
          __proto__: l3.prototype
        }), e2.push(v3);
      }
    }
    if (i2.nodes && (i2.nodes = t10.nodes.map((o2) => c2(o2, e2))), i2.source) {
      let { inputId: o2, ...v3 } = i2.source;
      i2.source = v3, o2 != null && (i2.source.input = e2[o2]);
    }
    if (i2.type === "root")
      return new f(i2);
    if (i2.type === "decl")
      return new h2(i2);
    if (i2.type === "rule")
      return new s2(i2);
    if (i2.type === "comment")
      return new a(i2);
    if (i2.type === "atrule")
      return new u(i2);
    throw new Error("Unknown node type: " + t10.type);
  }
  return Ur3 = c2, c2.default = c2, Ur3;
}
var zr2;
var ba2;
function vl() {
  if (ba2)
    return zr2;
  ba2 = 1;
  let { dirname: u, relative: a, resolve: h2, sep: p } = Ne3, { SourceMapConsumer: l3, SourceMapGenerator: f } = Ne3, { pathToFileURL: s2 } = Ne3, c2 = cr3(), t10 = !!(l3 && f), e2 = !!(u && h2 && a && p);

  class r2 {
    constructor(o2, v3, m, n2) {
      this.stringify = o2, this.mapOpts = m.map || {}, this.root = v3, this.opts = m, this.css = n2, this.originalCSS = n2, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map, this.memoizedPaths = /* @__PURE__ */ new Map, this.memoizedURLs = /* @__PURE__ */ new Map;
    }
    addAnnotation() {
      let o2;
      this.isInline() ? o2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? o2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? o2 = this.mapOpts.annotation(this.opts.to, this.root) : o2 = this.outputFile() + ".map";
      let v3 = `
`;
      this.css.includes(`\r
`) && (v3 = `\r
`), this.css += v3 + "/*# sourceMappingURL=" + o2 + " */";
    }
    applyPrevMaps() {
      for (let o2 of this.previous()) {
        let v3 = this.toUrl(this.path(o2.file)), m = o2.root || u(o2.file), n2;
        this.mapOpts.sourcesContent === false ? (n2 = new l3(o2.text), n2.sourcesContent && (n2.sourcesContent = null)) : n2 = o2.consumer(), this.map.applySourceMap(n2, v3, this.toUrl(this.path(m)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let o2;
          for (let v3 = this.root.nodes.length - 1;v3 >= 0; v3--)
            o2 = this.root.nodes[v3], o2.type === "comment" && o2.text.startsWith("# sourceMappingURL=") && this.root.removeChild(v3);
        } else
          this.css && (this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), e2 && t10 && this.isMap())
        return this.generateMap();
      {
        let o2 = "";
        return this.stringify(this.root, (v3) => {
          o2 += v3;
        }), [o2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let o2 = this.previous()[0].consumer();
        o2.file = this.outputFile(), this.map = f.fromSourceMap(o2, {
          ignoreInvalidMapping: true
        });
      } else
        this.map = new f({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        }), this.map.addMapping({
          generated: { column: 0, line: 1 },
          original: { column: 0, line: 1 },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
        });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new f({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      });
      let o2 = 1, v3 = 1, m = "<no source>", n2 = {
        generated: { column: 0, line: 0 },
        original: { column: 0, line: 0 },
        source: ""
      }, d2, _4;
      this.stringify(this.root, (w3, y2, x2) => {
        if (this.css += w3, y2 && x2 !== "end" && (n2.generated.line = o2, n2.generated.column = v3 - 1, y2.source && y2.source.start ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.start.line, n2.original.column = y2.source.start.column - 1, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, this.map.addMapping(n2))), _4 = w3.match(/\n/g), _4 ? (o2 += _4.length, d2 = w3.lastIndexOf(`
`), v3 = w3.length - d2) : v3 += w3.length, y2 && x2 !== "start") {
          let g2 = y2.parent || { raws: {} };
          (!(y2.type === "decl" || y2.type === "atrule" && !y2.nodes) || y2 !== g2.last || g2.raws.semicolon) && (y2.source && y2.source.end ? (n2.source = this.sourcePath(y2), n2.original.line = y2.source.end.line, n2.original.column = y2.source.end.column - 1, n2.generated.line = o2, n2.generated.column = v3 - 2, this.map.addMapping(n2)) : (n2.source = m, n2.original.line = 1, n2.original.column = 0, n2.generated.line = o2, n2.generated.column = v3 - 1, this.map.addMapping(n2)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((o2) => o2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let o2 = this.mapOpts.annotation;
      return typeof o2 < "u" && o2 !== true ? false : this.previous().length ? this.previous().some((v3) => v3.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((o2) => o2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(o2) {
      if (this.mapOpts.absolute || o2.charCodeAt(0) === 60 || /^\w+:\/\//.test(o2))
        return o2;
      let v3 = this.memoizedPaths.get(o2);
      if (v3)
        return v3;
      let m = this.opts.to ? u(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (m = u(h2(m, this.mapOpts.annotation)));
      let n2 = a(m, o2);
      return this.memoizedPaths.set(o2, n2), n2;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((o2) => {
            if (o2.source && o2.source.input.map) {
              let v3 = o2.source.input.map;
              this.previousMaps.includes(v3) || this.previousMaps.push(v3);
            }
          });
        else {
          let o2 = new c2(this.originalCSS, this.opts);
          o2.map && this.previousMaps.push(o2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let o2 = {};
      if (this.root)
        this.root.walk((v3) => {
          if (v3.source) {
            let m = v3.source.input.from;
            if (m && !o2[m]) {
              o2[m] = true;
              let n2 = this.usesFileUrls ? this.toFileUrl(m) : this.toUrl(this.path(m));
              this.map.setSourceContent(n2, v3.source.input.css);
            }
          }
        });
      else if (this.css) {
        let v3 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(v3, this.css);
      }
    }
    sourcePath(o2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(o2.source.input.from) : this.toUrl(this.path(o2.source.input.from));
    }
    toBase64(o2) {
      return Buffer ? Buffer.from(o2).toString("base64") : window.btoa(unescape(encodeURIComponent(o2)));
    }
    toFileUrl(o2) {
      let v3 = this.memoizedFileURLs.get(o2);
      if (v3)
        return v3;
      if (s2) {
        let m = s2(o2).toString();
        return this.memoizedFileURLs.set(o2, m), m;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(o2) {
      let v3 = this.memoizedURLs.get(o2);
      if (v3)
        return v3;
      p === "\\" && (o2 = o2.replace(/\\/g, "/"));
      let m = encodeURI(o2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(o2, m), m;
    }
  }
  return zr2 = r2, zr2;
}
var Wr3;
var _a4;
function gu2() {
  if (_a4)
    return Wr3;
  _a4 = 1;
  const u = 39, a = 34, h2 = 92, p = 47, l3 = 10, f = 32, s2 = 12, c2 = 9, t10 = 13, e2 = 91, r2 = 93, i2 = 40, o2 = 41, v3 = 123, m = 125, n2 = 59, d2 = 42, _4 = 58, w3 = 64, y2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, x2 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, g2 = /.[\r\n"'(/\\]/, O3 = /[\da-f]/i;
  return Wr3 = function(E2, b5 = {}) {
    let k4 = E2.css.valueOf(), q2 = b5.ignoreErrors, M2, W3, S3, P3, C, R3, $3, B3, z3, L3, F = k4.length, D = 0, I3 = [], N3 = [];
    function J3() {
      return D;
    }
    function T4(V4) {
      throw E2.error("Unclosed " + V4, D);
    }
    function U2() {
      return N3.length === 0 && D >= F;
    }
    function j3(V4) {
      if (N3.length)
        return N3.pop();
      if (D >= F)
        return;
      let K3 = V4 ? V4.ignoreUnclosed : false;
      switch (M2 = k4.charCodeAt(D), M2) {
        case l3:
        case f:
        case c2:
        case t10:
        case s2: {
          P3 = D;
          do
            P3 += 1, M2 = k4.charCodeAt(P3);
          while (M2 === f || M2 === l3 || M2 === c2 || M2 === t10 || M2 === s2);
          R3 = ["space", k4.slice(D, P3)], D = P3 - 1;
          break;
        }
        case e2:
        case r2:
        case v3:
        case m:
        case _4:
        case n2:
        case o2: {
          let X3 = String.fromCharCode(M2);
          R3 = [X3, X3, D];
          break;
        }
        case i2: {
          if (L3 = I3.length ? I3.pop()[1] : "", z3 = k4.charCodeAt(D + 1), L3 === "url" && z3 !== u && z3 !== a && z3 !== f && z3 !== l3 && z3 !== c2 && z3 !== s2 && z3 !== t10) {
            P3 = D;
            do {
              if ($3 = false, P3 = k4.indexOf(")", P3 + 1), P3 === -1)
                if (q2 || K3) {
                  P3 = D;
                  break;
                } else
                  T4("bracket");
              for (B3 = P3;k4.charCodeAt(B3 - 1) === h2; )
                B3 -= 1, $3 = !$3;
            } while ($3);
            R3 = ["brackets", k4.slice(D, P3 + 1), D, P3], D = P3;
          } else
            P3 = k4.indexOf(")", D + 1), W3 = k4.slice(D, P3 + 1), P3 === -1 || g2.test(W3) ? R3 = ["(", "(", D] : (R3 = ["brackets", W3, D, P3], D = P3);
          break;
        }
        case u:
        case a: {
          C = M2 === u ? "'" : '"', P3 = D;
          do {
            if ($3 = false, P3 = k4.indexOf(C, P3 + 1), P3 === -1)
              if (q2 || K3) {
                P3 = D + 1;
                break;
              } else
                T4("string");
            for (B3 = P3;k4.charCodeAt(B3 - 1) === h2; )
              B3 -= 1, $3 = !$3;
          } while ($3);
          R3 = ["string", k4.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case w3: {
          y2.lastIndex = D + 1, y2.test(k4), y2.lastIndex === 0 ? P3 = k4.length - 1 : P3 = y2.lastIndex - 2, R3 = ["at-word", k4.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        case h2: {
          for (P3 = D, S3 = true;k4.charCodeAt(P3 + 1) === h2; )
            P3 += 1, S3 = !S3;
          if (M2 = k4.charCodeAt(P3 + 1), S3 && M2 !== p && M2 !== f && M2 !== l3 && M2 !== c2 && M2 !== t10 && M2 !== s2 && (P3 += 1, O3.test(k4.charAt(P3)))) {
            for (;O3.test(k4.charAt(P3 + 1)); )
              P3 += 1;
            k4.charCodeAt(P3 + 1) === f && (P3 += 1);
          }
          R3 = ["word", k4.slice(D, P3 + 1), D, P3], D = P3;
          break;
        }
        default: {
          M2 === p && k4.charCodeAt(D + 1) === d2 ? (P3 = k4.indexOf("*/", D + 2) + 1, P3 === 0 && (q2 || K3 ? P3 = k4.length : T4("comment")), R3 = ["comment", k4.slice(D, P3 + 1), D, P3], D = P3) : (x2.lastIndex = D + 1, x2.test(k4), x2.lastIndex === 0 ? P3 = k4.length - 1 : P3 = x2.lastIndex - 2, R3 = ["word", k4.slice(D, P3 + 1), D, P3], I3.push(R3), D = P3);
          break;
        }
      }
      return D++, R3;
    }
    function H3(V4) {
      N3.push(V4);
    }
    return {
      back: H3,
      endOfFile: U2,
      nextToken: j3,
      position: J3
    };
  }, Wr3;
}
var Vr2;
var Sa2;
function mu2() {
  if (Sa2)
    return Vr2;
  Sa2 = 1;
  let u = Ri2(), a = ur3(), h2 = fr3(), p = lt3(), l3 = Mi2(), f = gu2();
  const s2 = {
    empty: true,
    space: true
  };
  function c2(e2) {
    for (let r2 = e2.length - 1;r2 >= 0; r2--) {
      let i2 = e2[r2], o2 = i2[3] || i2[2];
      if (o2)
        return o2;
    }
  }

  class t10 {
    constructor(r2) {
      this.input = r2, this.root = new p, this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: r2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(r2) {
      let i2 = new u;
      i2.name = r2[1].slice(1), i2.name === "" && this.unnamedAtrule(i2, r2), this.init(i2, r2[2]);
      let o2, v3, m, n2 = false, d2 = false, _4 = [], w3 = [];
      for (;!this.tokenizer.endOfFile(); ) {
        if (r2 = this.tokenizer.nextToken(), o2 = r2[0], o2 === "(" || o2 === "[" ? w3.push(o2 === "(" ? ")" : "]") : o2 === "{" && w3.length > 0 ? w3.push("}") : o2 === w3[w3.length - 1] && w3.pop(), w3.length === 0)
          if (o2 === ";") {
            i2.source.end = this.getPosition(r2[2]), i2.source.end.offset++, this.semicolon = true;
            break;
          } else if (o2 === "{") {
            d2 = true;
            break;
          } else if (o2 === "}") {
            if (_4.length > 0) {
              for (m = _4.length - 1, v3 = _4[m];v3 && v3[0] === "space"; )
                v3 = _4[--m];
              v3 && (i2.source.end = this.getPosition(v3[3] || v3[2]), i2.source.end.offset++);
            }
            this.end(r2);
            break;
          } else
            _4.push(r2);
        else
          _4.push(r2);
        if (this.tokenizer.endOfFile()) {
          n2 = true;
          break;
        }
      }
      i2.raws.between = this.spacesAndCommentsFromEnd(_4), _4.length ? (i2.raws.afterName = this.spacesAndCommentsFromStart(_4), this.raw(i2, "params", _4), n2 && (r2 = _4[_4.length - 1], i2.source.end = this.getPosition(r2[3] || r2[2]), i2.source.end.offset++, this.spaces = i2.raws.between, i2.raws.between = "")) : (i2.raws.afterName = "", i2.params = ""), d2 && (i2.nodes = [], this.current = i2);
    }
    checkMissedSemicolon(r2) {
      let i2 = this.colon(r2);
      if (i2 === false)
        return;
      let o2 = 0, v3;
      for (let m = i2 - 1;m >= 0 && (v3 = r2[m], !(v3[0] !== "space" && (o2 += 1, o2 === 2))); m--)
        ;
      throw this.input.error("Missed semicolon", v3[0] === "word" ? v3[3] + 1 : v3[2]);
    }
    colon(r2) {
      let i2 = 0, o2, v3, m;
      for (let [n2, d2] of r2.entries()) {
        if (v3 = d2, m = v3[0], m === "(" && (i2 += 1), m === ")" && (i2 -= 1), i2 === 0 && m === ":")
          if (!o2)
            this.doubleColon(v3);
          else {
            if (o2[0] === "word" && o2[1] === "progid")
              continue;
            return n2;
          }
        o2 = v3;
      }
      return false;
    }
    comment(r2) {
      let i2 = new a;
      this.init(i2, r2[2]), i2.source.end = this.getPosition(r2[3] || r2[2]), i2.source.end.offset++;
      let o2 = r2[1].slice(2, -2);
      if (/^\s*$/.test(o2))
        i2.text = "", i2.raws.left = o2, i2.raws.right = "";
      else {
        let v3 = o2.match(/^(\s*)([^]*\S)(\s*)$/);
        i2.text = v3[2], i2.raws.left = v3[1], i2.raws.right = v3[3];
      }
    }
    createTokenizer() {
      this.tokenizer = f(this.input);
    }
    decl(r2, i2) {
      let o2 = new h2;
      this.init(o2, r2[0][2]);
      let v3 = r2[r2.length - 1];
      for (v3[0] === ";" && (this.semicolon = true, r2.pop()), o2.source.end = this.getPosition(v3[3] || v3[2] || c2(r2)), o2.source.end.offset++;r2[0][0] !== "word"; )
        r2.length === 1 && this.unknownWord(r2), o2.raws.before += r2.shift()[1];
      for (o2.source.start = this.getPosition(r2[0][2]), o2.prop = "";r2.length; ) {
        let w3 = r2[0][0];
        if (w3 === ":" || w3 === "space" || w3 === "comment")
          break;
        o2.prop += r2.shift()[1];
      }
      o2.raws.between = "";
      let m;
      for (;r2.length; )
        if (m = r2.shift(), m[0] === ":") {
          o2.raws.between += m[1];
          break;
        } else
          m[0] === "word" && /\w/.test(m[1]) && this.unknownWord([m]), o2.raws.between += m[1];
      (o2.prop[0] === "_" || o2.prop[0] === "*") && (o2.raws.before += o2.prop[0], o2.prop = o2.prop.slice(1));
      let n2 = [], d2;
      for (;r2.length && (d2 = r2[0][0], !(d2 !== "space" && d2 !== "comment")); )
        n2.push(r2.shift());
      this.precheckMissedSemicolon(r2);
      for (let w3 = r2.length - 1;w3 >= 0; w3--) {
        if (m = r2[w3], m[1].toLowerCase() === "!important") {
          o2.important = true;
          let y2 = this.stringFrom(r2, w3);
          y2 = this.spacesFromEnd(r2) + y2, y2 !== " !important" && (o2.raws.important = y2);
          break;
        } else if (m[1].toLowerCase() === "important") {
          let y2 = r2.slice(0), x2 = "";
          for (let g2 = w3;g2 > 0; g2--) {
            let O3 = y2[g2][0];
            if (x2.trim().startsWith("!") && O3 !== "space")
              break;
            x2 = y2.pop()[1] + x2;
          }
          x2.trim().startsWith("!") && (o2.important = true, o2.raws.important = x2, r2 = y2);
        }
        if (m[0] !== "space" && m[0] !== "comment")
          break;
      }
      r2.some((w3) => w3[0] !== "space" && w3[0] !== "comment") && (o2.raws.between += n2.map((w3) => w3[1]).join(""), n2 = []), this.raw(o2, "value", n2.concat(r2), i2), o2.value.includes(":") && !i2 && this.checkMissedSemicolon(r2);
    }
    doubleColon(r2) {
      throw this.input.error("Double colon", { offset: r2[2] }, { offset: r2[2] + r2[1].length });
    }
    emptyRule(r2) {
      let i2 = new l3;
      this.init(i2, r2[2]), i2.selector = "", i2.raws.between = "", this.current = i2;
    }
    end(r2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(r2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(r2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(r2) {
      if (this.spaces += r2[1], this.current.nodes) {
        let i2 = this.current.nodes[this.current.nodes.length - 1];
        i2 && i2.type === "rule" && !i2.raws.ownSemicolon && (i2.raws.ownSemicolon = this.spaces, this.spaces = "", i2.source.end = this.getPosition(r2[2]), i2.source.end.offset += i2.raws.ownSemicolon.length);
      }
    }
    getPosition(r2) {
      let i2 = this.input.fromOffset(r2);
      return {
        column: i2.col,
        line: i2.line,
        offset: r2
      };
    }
    init(r2, i2) {
      this.current.push(r2), r2.source = {
        input: this.input,
        start: this.getPosition(i2)
      }, r2.raws.before = this.spaces, this.spaces = "", r2.type !== "comment" && (this.semicolon = false);
    }
    other(r2) {
      let i2 = false, o2 = null, v3 = false, m = null, n2 = [], d2 = r2[1].startsWith("--"), _4 = [], w3 = r2;
      for (;w3; ) {
        if (o2 = w3[0], _4.push(w3), o2 === "(" || o2 === "[")
          m || (m = w3), n2.push(o2 === "(" ? ")" : "]");
        else if (d2 && v3 && o2 === "{")
          m || (m = w3), n2.push("}");
        else if (n2.length === 0)
          if (o2 === ";")
            if (v3) {
              this.decl(_4, d2);
              return;
            } else
              break;
          else if (o2 === "{") {
            this.rule(_4);
            return;
          } else if (o2 === "}") {
            this.tokenizer.back(_4.pop()), i2 = true;
            break;
          } else
            o2 === ":" && (v3 = true);
        else
          o2 === n2[n2.length - 1] && (n2.pop(), n2.length === 0 && (m = null));
        w3 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (i2 = true), n2.length > 0 && this.unclosedBracket(m), i2 && v3) {
        if (!d2)
          for (;_4.length && (w3 = _4[_4.length - 1][0], !(w3 !== "space" && w3 !== "comment")); )
            this.tokenizer.back(_4.pop());
        this.decl(_4, d2);
      } else
        this.unknownWord(_4);
    }
    parse() {
      let r2;
      for (;!this.tokenizer.endOfFile(); )
        switch (r2 = this.tokenizer.nextToken(), r2[0]) {
          case "space":
            this.spaces += r2[1];
            break;
          case ";":
            this.freeSemicolon(r2);
            break;
          case "}":
            this.end(r2);
            break;
          case "comment":
            this.comment(r2);
            break;
          case "at-word":
            this.atrule(r2);
            break;
          case "{":
            this.emptyRule(r2);
            break;
          default:
            this.other(r2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {}
    raw(r2, i2, o2, v3) {
      let m, n2, d2 = o2.length, _4 = "", w3 = true, y2, x2;
      for (let g2 = 0;g2 < d2; g2 += 1)
        m = o2[g2], n2 = m[0], n2 === "space" && g2 === d2 - 1 && !v3 ? w3 = false : n2 === "comment" ? (x2 = o2[g2 - 1] ? o2[g2 - 1][0] : "empty", y2 = o2[g2 + 1] ? o2[g2 + 1][0] : "empty", !s2[x2] && !s2[y2] ? _4.slice(-1) === "," ? w3 = false : _4 += m[1] : w3 = false) : _4 += m[1];
      if (!w3) {
        let g2 = o2.reduce((O3, A) => O3 + A[1], "");
        r2.raws[i2] = { raw: g2, value: _4 };
      }
      r2[i2] = _4;
    }
    rule(r2) {
      r2.pop();
      let i2 = new l3;
      this.init(i2, r2[0][2]), i2.raws.between = this.spacesAndCommentsFromEnd(r2), this.raw(i2, "selector", r2), this.current = i2;
    }
    spacesAndCommentsFromEnd(r2) {
      let i2, o2 = "";
      for (;r2.length && (i2 = r2[r2.length - 1][0], !(i2 !== "space" && i2 !== "comment")); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    spacesAndCommentsFromStart(r2) {
      let i2, o2 = "";
      for (;r2.length && (i2 = r2[0][0], !(i2 !== "space" && i2 !== "comment")); )
        o2 += r2.shift()[1];
      return o2;
    }
    spacesFromEnd(r2) {
      let i2, o2 = "";
      for (;r2.length && (i2 = r2[r2.length - 1][0], i2 === "space"); )
        o2 = r2.pop()[1] + o2;
      return o2;
    }
    stringFrom(r2, i2) {
      let o2 = "";
      for (let v3 = i2;v3 < r2.length; v3++)
        o2 += r2[v3][1];
      return r2.splice(i2, r2.length - i2), o2;
    }
    unclosedBlock() {
      let r2 = this.current.source.start;
      throw this.input.error("Unclosed block", r2.line, r2.column);
    }
    unclosedBracket(r2) {
      throw this.input.error("Unclosed bracket", { offset: r2[2] }, { offset: r2[2] + 1 });
    }
    unexpectedClose(r2) {
      throw this.input.error("Unexpected }", { offset: r2[2] }, { offset: r2[2] + 1 });
    }
    unknownWord(r2) {
      throw this.input.error("Unknown word " + r2[0][1], { offset: r2[0][2] }, { offset: r2[0][2] + r2[0][1].length });
    }
    unnamedAtrule(r2, i2) {
      throw this.input.error("At-rule without name", { offset: i2[2] }, { offset: i2[2] + i2[1].length });
    }
  }
  return Vr2 = t10, Vr2;
}
var jr3;
var xa2;
function Di2() {
  if (xa2)
    return jr3;
  xa2 = 1;
  let u = nt3(), a = cr3(), h2 = mu2();
  function p(l3, f) {
    let s2 = new a(l3, f), c2 = new h2(s2);
    try {
      c2.parse();
    } catch (t10) {
      throw t10.name === "CssSyntaxError" && f && f.from && (/\.scss$/i.test(f.from) ? t10.message += `
You tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser` : /\.sass/i.test(f.from) ? t10.message += `
You tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser` : /\.less$/i.test(f.from) && (t10.message += `
You tried to parse Less with the standard CSS parser; try again with the postcss-less parser`)), t10;
    }
    return c2.root;
  }
  return jr3 = p, p.default = p, u.registerParse(p), jr3;
}
var Br3;
var Oa2;
function gl() {
  if (Oa2)
    return Br3;
  Oa2 = 1;

  class u {
    constructor(h2, p = {}) {
      if (this.type = "warning", this.text = h2, p.node && p.node.source) {
        let l3 = p.node.rangeBy(p);
        this.line = l3.start.line, this.column = l3.start.column, this.endLine = l3.end.line, this.endColumn = l3.end.column;
      }
      for (let l3 in p)
        this[l3] = p[l3];
    }
    toString() {
      return this.node ? this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  }
  return Br3 = u, u.default = u, Br3;
}
var Gr3;
var ka2;
function qi2() {
  if (ka2)
    return Gr3;
  ka2 = 1;
  let u = gl();

  class a {
    get content() {
      return this.css;
    }
    constructor(p, l3, f) {
      this.processor = p, this.messages = [], this.root = l3, this.opts = f, this.css = undefined, this.map = undefined;
    }
    toString() {
      return this.css;
    }
    warn(p, l3 = {}) {
      l3.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (l3.plugin = this.lastPlugin.postcssPlugin);
      let f = new u(p, l3);
      return this.messages.push(f), f;
    }
    warnings() {
      return this.messages.filter((p) => p.type === "warning");
    }
  }
  return Gr3 = a, a.default = a, Gr3;
}
var Yr2;
var Pa2;
function ml() {
  if (Pa2)
    return Yr2;
  Pa2 = 1;
  let u = {};
  return Yr2 = function(h2) {
    u[h2] || (u[h2] = true, typeof console < "u" && console.warn && console.warn(h2));
  }, Yr2;
}
var Qr3;
var Ea2;
function yl() {
  if (Ea2)
    return Qr3;
  Ea2 = 1;
  let u = nt3(), a = Ii2(), h2 = vl(), p = Di2(), l3 = qi2(), f = lt3(), s2 = or4(), { isClean: c2, my: t10 } = Ci2(), e2 = ml();
  const r2 = {
    atrule: "AtRule",
    comment: "Comment",
    decl: "Declaration",
    document: "Document",
    root: "Root",
    rule: "Rule"
  }, i2 = {
    AtRule: true,
    AtRuleExit: true,
    Comment: true,
    CommentExit: true,
    Declaration: true,
    DeclarationExit: true,
    Document: true,
    DocumentExit: true,
    Once: true,
    OnceExit: true,
    postcssPlugin: true,
    prepare: true,
    Root: true,
    RootExit: true,
    Rule: true,
    RuleExit: true
  }, o2 = {
    Once: true,
    postcssPlugin: true,
    prepare: true
  }, v3 = 0;
  function m(x2) {
    return typeof x2 == "object" && typeof x2.then == "function";
  }
  function n2(x2) {
    let g2 = false, O3 = r2[x2.type];
    return x2.type === "decl" ? g2 = x2.prop.toLowerCase() : x2.type === "atrule" && (g2 = x2.name.toLowerCase()), g2 && x2.append ? [
      O3,
      O3 + "-" + g2,
      v3,
      O3 + "Exit",
      O3 + "Exit-" + g2
    ] : g2 ? [O3, O3 + "-" + g2, O3 + "Exit", O3 + "Exit-" + g2] : x2.append ? [O3, v3, O3 + "Exit"] : [O3, O3 + "Exit"];
  }
  function d2(x2) {
    let g2;
    return x2.type === "document" ? g2 = ["Document", v3, "DocumentExit"] : x2.type === "root" ? g2 = ["Root", v3, "RootExit"] : g2 = n2(x2), {
      eventIndex: 0,
      events: g2,
      iterator: 0,
      node: x2,
      visitorIndex: 0,
      visitors: []
    };
  }
  function _4(x2) {
    return x2[c2] = false, x2.nodes && x2.nodes.forEach((g2) => _4(g2)), x2;
  }
  let w3 = {};

  class y2 {
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
    constructor(g2, O3, A) {
      this.stringified = false, this.processed = false;
      let E2;
      if (typeof O3 == "object" && O3 !== null && (O3.type === "root" || O3.type === "document"))
        E2 = _4(O3);
      else if (O3 instanceof y2 || O3 instanceof l3)
        E2 = _4(O3.root), O3.map && (typeof A.map > "u" && (A.map = {}), A.map.inline || (A.map.inline = false), A.map.prev = O3.map);
      else {
        let b5 = p;
        A.syntax && (b5 = A.syntax.parse), A.parser && (b5 = A.parser), b5.parse && (b5 = b5.parse);
        try {
          E2 = b5(O3, A);
        } catch (k4) {
          this.processed = true, this.error = k4;
        }
        E2 && !E2[t10] && u.rebuild(E2);
      }
      this.result = new l3(g2, E2, A), this.helpers = { ...w3, postcss: w3, result: this.result }, this.plugins = this.processor.plugins.map((b5) => typeof b5 == "object" && b5.prepare ? { ...b5, ...b5.prepare(this.result) } : b5);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(g2) {
      return this.async().catch(g2);
    }
    finally(g2) {
      return this.async().then(g2, g2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(g2, O3) {
      let A = this.result.lastPlugin;
      try {
        if (O3 && O3.addToError(g2), this.error = g2, g2.name === "CssSyntaxError" && !g2.plugin)
          g2.plugin = A.postcssPlugin, g2.setMessage();
        else if (A.postcssVersion && true) {
          let { postcssPlugin: E2, postcssVersion: b5 } = A, k4 = this.result.processor.version, q2 = b5.split("."), M2 = k4.split(".");
          (q2[0] !== M2[0] || parseInt(q2[1]) > parseInt(M2[1])) && console.error("Unknown error from PostCSS plugin. Your current PostCSS version is " + k4 + ", but " + E2 + " uses " + b5 + ". Perhaps this is the source of the error below.");
        }
      } catch (E2) {
        console && console.error && console.error(E2);
      }
      return g2;
    }
    prepareVisitors() {
      this.listeners = {};
      let g2 = (O3, A, E2) => {
        this.listeners[A] || (this.listeners[A] = []), this.listeners[A].push([O3, E2]);
      };
      for (let O3 of this.plugins)
        if (typeof O3 == "object")
          for (let A in O3) {
            if (!i2[A] && /^[A-Z]/.test(A))
              throw new Error(`Unknown event ${A} in ${O3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!o2[A])
              if (typeof O3[A] == "object")
                for (let E2 in O3[A])
                  E2 === "*" ? g2(O3, A, O3[A][E2]) : g2(O3, A + "-" + E2.toLowerCase(), O3[A][E2]);
              else
                typeof O3[A] == "function" && g2(O3, A, O3[A]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let g2 = 0;g2 < this.plugins.length; g2++) {
        let O3 = this.plugins[g2], A = this.runOnRoot(O3);
        if (m(A))
          try {
            await A;
          } catch (E2) {
            throw this.handleError(E2);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (;!g2[c2]; ) {
          g2[c2] = true;
          let O3 = [d2(g2)];
          for (;O3.length > 0; ) {
            let A = this.visitTick(O3);
            if (m(A))
              try {
                await A;
              } catch (E2) {
                let b5 = O3[O3.length - 1].node;
                throw this.handleError(E2, b5);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [O3, A] of this.listeners.OnceExit) {
            this.result.lastPlugin = O3;
            try {
              if (g2.type === "document") {
                let E2 = g2.nodes.map((b5) => A(b5, this.helpers));
                await Promise.all(E2);
              } else
                await A(g2, this.helpers);
            } catch (E2) {
              throw this.handleError(E2);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(g2) {
      this.result.lastPlugin = g2;
      try {
        if (typeof g2 == "object" && g2.Once) {
          if (this.result.root.type === "document") {
            let O3 = this.result.root.nodes.map((A) => g2.Once(A, this.helpers));
            return m(O3[0]) ? Promise.all(O3) : O3;
          }
          return g2.Once(this.result.root, this.helpers);
        } else if (typeof g2 == "function")
          return g2(this.result.root, this.result);
      } catch (O3) {
        throw this.handleError(O3);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let g2 = this.result.opts, O3 = s2;
      g2.syntax && (O3 = g2.syntax.stringify), g2.stringifier && (O3 = g2.stringifier), O3.stringify && (O3 = O3.stringify);
      let E2 = new h2(O3, this.result.root, this.result.opts).generate();
      return this.result.css = E2[0], this.result.map = E2[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let g2 of this.plugins) {
        let O3 = this.runOnRoot(g2);
        if (m(O3))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let g2 = this.result.root;
        for (;!g2[c2]; )
          g2[c2] = true, this.walkSync(g2);
        if (this.listeners.OnceExit)
          if (g2.type === "document")
            for (let O3 of g2.nodes)
              this.visitSync(this.listeners.OnceExit, O3);
          else
            this.visitSync(this.listeners.OnceExit, g2);
      }
      return this.result;
    }
    then(g2, O3) {
      return "from" in this.opts || e2("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."), this.async().then(g2, O3);
    }
    toString() {
      return this.css;
    }
    visitSync(g2, O3) {
      for (let [A, E2] of g2) {
        this.result.lastPlugin = A;
        let b5;
        try {
          b5 = E2(O3, this.helpers);
        } catch (k4) {
          throw this.handleError(k4, O3.proxyOf);
        }
        if (O3.type !== "root" && O3.type !== "document" && !O3.parent)
          return true;
        if (m(b5))
          throw this.getAsyncError();
      }
    }
    visitTick(g2) {
      let O3 = g2[g2.length - 1], { node: A, visitors: E2 } = O3;
      if (A.type !== "root" && A.type !== "document" && !A.parent) {
        g2.pop();
        return;
      }
      if (E2.length > 0 && O3.visitorIndex < E2.length) {
        let [k4, q2] = E2[O3.visitorIndex];
        O3.visitorIndex += 1, O3.visitorIndex === E2.length && (O3.visitors = [], O3.visitorIndex = 0), this.result.lastPlugin = k4;
        try {
          return q2(A.toProxy(), this.helpers);
        } catch (M2) {
          throw this.handleError(M2, A);
        }
      }
      if (O3.iterator !== 0) {
        let k4 = O3.iterator, q2;
        for (;q2 = A.nodes[A.indexes[k4]]; )
          if (A.indexes[k4] += 1, !q2[c2]) {
            q2[c2] = true, g2.push(d2(q2));
            return;
          }
        O3.iterator = 0, delete A.indexes[k4];
      }
      let b5 = O3.events;
      for (;O3.eventIndex < b5.length; ) {
        let k4 = b5[O3.eventIndex];
        if (O3.eventIndex += 1, k4 === v3) {
          A.nodes && A.nodes.length && (A[c2] = true, O3.iterator = A.getIterator());
          return;
        } else if (this.listeners[k4]) {
          O3.visitors = this.listeners[k4];
          return;
        }
      }
      g2.pop();
    }
    walkSync(g2) {
      g2[c2] = true;
      let O3 = n2(g2);
      for (let A of O3)
        if (A === v3)
          g2.nodes && g2.each((E2) => {
            E2[c2] || this.walkSync(E2);
          });
        else {
          let E2 = this.listeners[A];
          if (E2 && this.visitSync(E2, g2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
  }
  return y2.registerPostcss = (x2) => {
    w3 = x2;
  }, Qr3 = y2, y2.default = y2, f.registerLazyResult(y2), a.registerLazyResult(y2), Qr3;
}
var Hr2;
var Ta2;
function yu2() {
  if (Ta2)
    return Hr2;
  Ta2 = 1;
  let u = vl(), a = Di2();
  const h2 = qi2();
  let p = or4(), l3 = ml();

  class f {
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let c2, t10 = a;
      try {
        c2 = t10(this._css, this._opts);
      } catch (e2) {
        this.error = e2;
      }
      if (this.error)
        throw this.error;
      return this._root = c2, c2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
    constructor(c2, t10, e2) {
      t10 = t10.toString(), this.stringified = false, this._processor = c2, this._css = t10, this._opts = e2, this._map = undefined;
      let r2, i2 = p;
      this.result = new h2(this._processor, r2, this._opts), this.result.css = t10;
      let o2 = this;
      Object.defineProperty(this.result, "root", {
        get() {
          return o2.root;
        }
      });
      let v3 = new u(i2, r2, this._opts, t10);
      if (v3.isMap()) {
        let [m, n2] = v3.generate();
        m && (this.result.css = m), n2 && (this.result.map = n2);
      } else
        v3.clearAnnotation(), this.result.css = v3.css;
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(c2) {
      return this.async().catch(c2);
    }
    finally(c2) {
      return this.async().then(c2, c2);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(c2, t10) {
      return "from" in this._opts || l3("Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."), this.async().then(c2, t10);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
  }
  return Hr2 = f, f.default = f, Hr2;
}
var Jr3;
var Aa2;
function wu2() {
  if (Aa2)
    return Jr3;
  Aa2 = 1;
  let u = Ii2(), a = yl(), h2 = yu2(), p = lt3();

  class l3 {
    constructor(s2 = []) {
      this.version = "8.5.3", this.plugins = this.normalize(s2);
    }
    normalize(s2) {
      let c2 = [];
      for (let t10 of s2)
        if (t10.postcss === true ? t10 = t10() : t10.postcss && (t10 = t10.postcss), typeof t10 == "object" && Array.isArray(t10.plugins))
          c2 = c2.concat(t10.plugins);
        else if (typeof t10 == "object" && t10.postcssPlugin)
          c2.push(t10);
        else if (typeof t10 == "function")
          c2.push(t10);
        else if (typeof t10 == "object" && (t10.parse || t10.stringify)) {
          if (true)
            throw new Error("PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.");
        } else
          throw new Error(t10 + " is not a PostCSS plugin");
      return c2;
    }
    process(s2, c2 = {}) {
      return !this.plugins.length && !c2.parser && !c2.stringifier && !c2.syntax ? new h2(this, s2, c2) : new a(this, s2, c2);
    }
    use(s2) {
      return this.plugins = this.plugins.concat(this.normalize([s2])), this;
    }
  }
  return Jr3 = l3, l3.default = l3, p.registerProcessor(l3), u.registerProcessor(l3), Jr3;
}
var Kr3;
var Ca2;
function Be2() {
  if (Ca2)
    return Kr3;
  Ca2 = 1;
  let u = Ri2(), a = ur3(), h2 = nt3(), p = Ai2(), l3 = fr3(), f = Ii2(), s2 = vu2(), c2 = cr3(), t10 = yl(), e2 = hl(), r2 = lr3(), i2 = Di2(), o2 = wu2(), v3 = qi2(), m = lt3(), n2 = Mi2(), d2 = or4(), _4 = gl();
  function w3(...y2) {
    return y2.length === 1 && Array.isArray(y2[0]) && (y2 = y2[0]), new o2(y2);
  }
  return w3.plugin = function(x2, g2) {
    let O3 = false;
    function A(...b5) {
      console && console.warn && !O3 && (O3 = true, console.warn(x2 + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(x2 + `: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
https://www.w3ctech.com/topic/2226`));
      let k4 = g2(...b5);
      return k4.postcssPlugin = x2, k4.postcssVersion = new o2().version, k4;
    }
    let E2;
    return Object.defineProperty(A, "postcss", {
      get() {
        return E2 || (E2 = A()), E2;
      }
    }), A.process = function(b5, k4, q2) {
      return w3([A(q2)]).process(b5, k4);
    }, A;
  }, w3.stringify = d2, w3.parse = i2, w3.fromJSON = s2, w3.list = e2, w3.comment = (y2) => new a(y2), w3.atRule = (y2) => new u(y2), w3.decl = (y2) => new l3(y2), w3.rule = (y2) => new n2(y2), w3.root = (y2) => new m(y2), w3.document = (y2) => new f(y2), w3.CssSyntaxError = p, w3.Declaration = l3, w3.Container = h2, w3.Processor = o2, w3.Document = f, w3.Comment = a, w3.Warning = _4, w3.AtRule = u, w3.Result = v3, w3.Input = c2, w3.Rule = n2, w3.Root = m, w3.Node = r2, t10.registerPostcss(w3), Kr3 = w3, w3.default = w3, Kr3;
}
var bu2 = Be2();
var Le3 = /* @__PURE__ */ He3(bu2);
Le3.stringify;
Le3.fromJSON;
Le3.plugin;
var _u2 = Le3.parse;
Le3.list;
Le3.document;
Le3.comment;
Le3.atRule;
var Su2 = Le3.rule;
var xu2 = Le3.decl;
Le3.root;
Le3.CssSyntaxError;
Le3.Declaration;
Le3.Container;
Le3.Processor;
Le3.Document;
Le3.Comment;
Le3.Warning;
var wl = Le3.AtRule;
Le3.Result;
Le3.Input;
var Ra2 = Le3.Rule;
var Ou2 = Le3.Root;
Le3.Node;
var ku2 = (u) => u.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}");
var Li2 = (u) => {
  if (u.first === undefined) {
    const a = u.parent;
    a && (u.remove(), Li2(a));
  }
};
var Pu2 = (u) => {
  u.walkRules((a) => {
    u.walkRules(a.selector, (h2) => {
      if (h2 === a)
        return;
      const p = h2.parent;
      h2.remove(), p && Li2(p);
    });
  });
};
var bl = (u) => typeof u.type == "function" || u.type.render !== undefined;
function sr3(u, a) {
  const h2 = import_react2.default.Children.map(u, (p) => {
    if (import_react2.default.isValidElement(p)) {
      const l3 = { ...p.props };
      p.props.children && !bl(p) && (l3.children = sr3(p.props.children, a));
      const f = a(import_react2.default.cloneElement(p, l3, l3.children));
      if (import_react2.default.isValidElement(f) && (typeof f.type == "function" || f.type.render)) {
        const c2 = (typeof f.type == "object" ? f.type.render : f.type)(f.props);
        return sr3(c2, a);
      }
      return f;
    }
    return a(p);
  });
  return h2 && h2.length === 1 ? h2[0] : h2;
}
var Eu2 = {
  0: "zero",
  1: "one",
  2: "two",
  3: "three",
  4: "four",
  5: "five",
  6: "six",
  7: "seven",
  8: "eight",
  9: "nine"
};
var _l = (u) => u.replaceAll("+", "plus").replaceAll("[", "").replaceAll("%", "pc").replaceAll("]", "").replaceAll("(", "").replaceAll(")", "").replaceAll("!", "imprtnt").replaceAll(">", "gt").replaceAll("<", "lt").replaceAll("=", "eq").replace(/^[0-9]/, (a) => Eu2[a]).replace(/[^a-zA-Z0-9\-_]/g, "_");
var vt3 = { exports: {} };
var gt4 = { exports: {} };
var mt3 = { exports: {} };
var yt3 = { exports: {} };
var wt3 = { exports: {} };
var bt3 = { exports: {} };
var Ye3 = {};
var _t3 = { exports: {} };
var Ia2;
function Sl() {
  return Ia2 || (Ia2 = 1, function(u, a) {
    a.__esModule = true, a.default = l3;
    function h2(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t10 = false, e2 = 0;e2 < 6 && s2[e2] !== undefined; e2++) {
        var r2 = s2.charCodeAt(e2), i2 = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t10 = r2 === 32, !i2)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["\uFFFD", c2.length + (t10 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t10 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l3(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t10 = 0;t10 < f.length; t10++) {
        if (f[t10] === "\\") {
          var e2 = h2(f.slice(t10 + 1, t10 + 7));
          if (e2 !== undefined) {
            c2 += e2[0], t10 += e2[1];
            continue;
          }
          if (f[t10 + 1] === "\\") {
            c2 += "\\", t10++;
            continue;
          }
          f.length === t10 + 1 && (c2 += f[t10]);
          continue;
        }
        c2 += f[t10];
      }
      return c2;
    }
    u.exports = a.default;
  }(_t3, _t3.exports)), _t3.exports;
}
var St3 = { exports: {} };
var Ma2;
function Tu2() {
  return Ma2 || (Ma2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = arguments.length, f = new Array(l3 > 1 ? l3 - 1 : 0), s2 = 1;s2 < l3; s2++)
        f[s2 - 1] = arguments[s2];
      for (;f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  }(St3, St3.exports)), St3.exports;
}
var xt3 = { exports: {} };
var Da2;
function Au2() {
  return Da2 || (Da2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = arguments.length, f = new Array(l3 > 1 ? l3 - 1 : 0), s2 = 1;s2 < l3; s2++)
        f[s2 - 1] = arguments[s2];
      for (;f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  }(xt3, xt3.exports)), xt3.exports;
}
var Ot3 = { exports: {} };
var qa2;
function Cu2() {
  return qa2 || (qa2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = "", f = p.indexOf("/*"), s2 = 0;f >= 0; ) {
        l3 = l3 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l3;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l3 = l3 + p.slice(s2), l3;
    }
    u.exports = a.default;
  }(Ot3, Ot3.exports)), Ot3.exports;
}
var La2;
function dr3() {
  if (La2)
    return Ye3;
  La2 = 1, Ye3.__esModule = true, Ye3.unesc = Ye3.stripComments = Ye3.getProp = Ye3.ensureObject = undefined;
  var u = l3(Sl());
  Ye3.unesc = u.default;
  var a = l3(Tu2());
  Ye3.getProp = a.default;
  var h2 = l3(Au2());
  Ye3.ensureObject = h2.default;
  var p = l3(Cu2());
  Ye3.stripComments = p.default;
  function l3(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Ye3;
}
var Na2;
function et4() {
  return Na2 || (Na2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = dr3();
    function p(c2, t10) {
      for (var e2 = 0;e2 < t10.length; e2++) {
        var r2 = t10[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l3(c2, t10, e2) {
      return t10 && p(c2.prototype, t10), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c(t10, e2) {
      if (typeof t10 != "object" || t10 === null)
        return t10;
      var r2 = new t10.constructor;
      for (var i2 in t10)
        if (t10.hasOwnProperty(i2)) {
          var o2 = t10[i2], v3 = typeof o2;
          i2 === "parent" && v3 === "object" ? e2 && (r2[i2] = e2) : o2 instanceof Array ? r2[i2] = o2.map(function(m) {
            return c(m, r2);
          }) : r2[i2] = c(o2, r2);
        }
      return r2;
    }, s2 = /* @__PURE__ */ function() {
      function c2(e2) {
        e2 === undefined && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t10 = c2.prototype;
      return t10.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
      }, t10.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t10.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t10.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t10.clone = function(r2) {
        r2 === undefined && (r2 = {});
        var i2 = f(this);
        for (var o2 in r2)
          i2[o2] = r2[o2];
        return i2;
      }, t10.appendToPropertyAndEscape = function(r2, i2, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i2, m || o2 !== i2 ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t10.setPropertyAndEscape = function(r2, i2, o2) {
        this.raws || (this.raws = {}), this[r2] = i2, this.raws[r2] = o2;
      }, t10.setPropertyWithoutEscape = function(r2, i2) {
        this[r2] = i2, this.raws && delete this.raws[r2];
      }, t10.isAtPosition = function(r2, i2) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i2 || this.source.end.line === r2 && this.source.end.column < i2);
      }, t10.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t10.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t10.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l3(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === undefined && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === undefined && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    }();
    a.default = s2, u.exports = a.default;
  }(bt3, bt3.exports)), bt3.exports;
}
var Re3 = {};
var Fa2;
function Fe3() {
  if (Fa2)
    return Re3;
  Fa2 = 1, Re3.__esModule = true, Re3.UNIVERSAL = Re3.TAG = Re3.STRING = Re3.SELECTOR = Re3.ROOT = Re3.PSEUDO = Re3.NESTING = Re3.ID = Re3.COMMENT = Re3.COMBINATOR = Re3.CLASS = Re3.ATTRIBUTE = undefined;
  var u = "tag";
  Re3.TAG = u;
  var a = "string";
  Re3.STRING = a;
  var h2 = "selector";
  Re3.SELECTOR = h2;
  var p = "root";
  Re3.ROOT = p;
  var l3 = "pseudo";
  Re3.PSEUDO = l3;
  var f = "nesting";
  Re3.NESTING = f;
  var s2 = "id";
  Re3.ID = s2;
  var c2 = "comment";
  Re3.COMMENT = c2;
  var t10 = "combinator";
  Re3.COMBINATOR = t10;
  var e2 = "class";
  Re3.CLASS = e2;
  var r2 = "attribute";
  Re3.ATTRIBUTE = r2;
  var i2 = "universal";
  return Re3.UNIVERSAL = i2, Re3;
}
var $a2;
function Ni2() {
  return $a2 || ($a2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(et4()), p = f(Fe3());
    function l3(n2) {
      if (typeof WeakMap != "function")
        return null;
      var d2 = /* @__PURE__ */ new WeakMap, _4 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(y2) {
        return y2 ? _4 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _4 = l3(d2);
      if (_4 && _4.has(n2))
        return _4.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x2 in n2)
        if (x2 !== "default" && Object.prototype.hasOwnProperty.call(n2, x2)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x2) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x2, g2) : w3[x2] = n2[x2];
        }
      return w3.default = n2, _4 && _4.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _4 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_4)
        return (_4 = _4.call(n2)).next.bind(_4);
      if (Array.isArray(n2) || (_4 = t10(n2)) || d2) {
        _4 && (n2 = _4);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t10(n2, d2) {
      if (n2) {
        if (typeof n2 == "string")
          return e2(n2, d2);
        var _4 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_4 === "Object" && n2.constructor && (_4 = n2.constructor.name), _4 === "Map" || _4 === "Set")
          return Array.from(n2);
        if (_4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_4))
          return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _4 = 0, w3 = new Array(d2);_4 < d2; _4++)
        w3[_4] = n2[_4];
      return w3;
    }
    function r2(n2, d2) {
      for (var _4 = 0;_4 < d2.length; _4++) {
        var w3 = d2[_4];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i2(n2, d2, _4) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = /* @__PURE__ */ function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _4 = d2.prototype;
      return _4.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _4.prepend = function(y2) {
        y2.parent = this, this.nodes.unshift(y2);
        for (var x2 in this.indexes)
          this.indexes[x2]++;
        return this;
      }, _4.at = function(y2) {
        return this.nodes[y2];
      }, _4.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _4.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = undefined, this.nodes.splice(y2, 1);
        var x2;
        for (var g2 in this.indexes)
          x2 = this.indexes[g2], x2 >= y2 && (this.indexes[g2] = x2 - 1);
        return this;
      }, _4.removeAll = function() {
        for (var y2 = c2(this.nodes), x2;!(x2 = y2()).done; ) {
          var g2 = x2.value;
          g2.parent = undefined;
        }
        return this.nodes = [], this;
      }, _4.empty = function() {
        return this.removeAll();
      }, _4.insertAfter = function(y2, x2) {
        var g2;
        x2.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2;E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3 + 1, 0, x2].concat(A)), x2.parent = this;
        var b5;
        for (var k4 in this.indexes)
          b5 = this.indexes[k4], O3 < b5 && (this.indexes[k4] = b5 + arguments.length - 1);
        return this;
      }, _4.insertBefore = function(y2, x2) {
        var g2;
        x2.parent = this;
        for (var O3 = this.index(y2), A = [], E2 = 2;E2 < arguments.length; E2++)
          A.push(arguments[E2]);
        (g2 = this.nodes).splice.apply(g2, [O3, 0, x2].concat(A)), x2.parent = this;
        var b5;
        for (var k4 in this.indexes)
          b5 = this.indexes[k4], b5 >= O3 && (this.indexes[k4] = b5 + arguments.length - 1);
        return this;
      }, _4._findChildAtPosition = function(y2, x2) {
        var g2 = undefined;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x2);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x2))
            return g2 = O3, false;
        }), g2;
      }, _4.atPosition = function(y2, x2) {
        if (this.isAtPosition(y2, x2))
          return this._findChildAtPosition(y2, x2) || this;
      }, _4._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _4.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x2 = this.lastEach;
        if (this.indexes[x2] = 0, !!this.length) {
          for (var g2, O3;this.indexes[x2] < this.length && (g2 = this.indexes[x2], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x2] += 1;
          if (delete this.indexes[x2], O3 === false)
            return false;
        }
      }, _4.walk = function(y2) {
        return this.each(function(x2, g2) {
          var O3 = y2(x2, g2);
          if (O3 !== false && x2.length && (O3 = x2.walk(y2)), O3 === false)
            return false;
        });
      }, _4.walkAttributes = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x2, g2);
        });
      }, _4.walkClasses = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x2, g2);
        });
      }, _4.walkCombinators = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x2, g2);
        });
      }, _4.walkComments = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x2, g2);
        });
      }, _4.walkIds = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x2, g2);
        });
      }, _4.walkNesting = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x2, g2);
        });
      }, _4.walkPseudos = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x2, g2);
        });
      }, _4.walkTags = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x2, g2);
        });
      }, _4.walkUniversals = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x2, g2);
        });
      }, _4.split = function(y2) {
        var x2 = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b5 = y2.call(x2, A);
          return g2.push(A), b5 ? (O3.push(g2), g2 = []) : E2 === x2.length - 1 && O3.push(g2), O3;
        }, []);
      }, _4.map = function(y2) {
        return this.nodes.map(y2);
      }, _4.reduce = function(y2, x2) {
        return this.nodes.reduce(y2, x2);
      }, _4.every = function(y2) {
        return this.nodes.every(y2);
      }, _4.some = function(y2) {
        return this.nodes.some(y2);
      }, _4.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _4.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _4.toString = function() {
        return this.map(String).join("");
      }, i2(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    }(h2.default);
    a.default = m, u.exports = a.default;
  }(wt3, wt3.exports)), wt3.exports;
}
var Ua2;
function xl() {
  return Ua2 || (Ua2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Ni2()), p = Fe3();
    function l3(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i2) {
      for (var o2 = 0;o2 < i2.length; o2++) {
        var v3 = i2[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i2, o2) {
      return i2 && f(r2.prototype, i2), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i2) {
      r2.prototype = Object.create(i2.prototype), r2.prototype.constructor = r2, t10(r2, i2);
    }
    function t10(r2, i2) {
      return t10 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t10(r2, i2);
    }
    var e2 = /* @__PURE__ */ function(r2) {
      c2(i2, r2);
      function i2(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i2.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i2, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i2;
    }(h2.default);
    a.default = e2, u.exports = a.default;
  }(yt3, yt3.exports)), yt3.exports;
}
var kt3 = { exports: {} };
var za2;
function Ol() {
  return za2 || (za2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Ni2()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.SELECTOR, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(kt3, kt3.exports)), kt3.exports;
}
var Pt3 = { exports: {} };
/*! https://mths.be/cssesc v3.0.0 by @mathias */
var Xr3;
var Wa2;
function at3() {
  if (Wa2)
    return Xr3;
  Wa2 = 1;
  var u = {}, a = u.hasOwnProperty, h2 = function(t10, e2) {
    if (!t10)
      return e2;
    var r2 = {};
    for (var i2 in e2)
      r2[i2] = a.call(t10, i2) ? t10[i2] : e2[i2];
    return r2;
  }, p = /[ -,\.\/:-@\[-\^`\{-~]/, l3 = /[ -,\.\/:-@\[\]\^`\{-~]/, f = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, s2 = function c(t10, e2) {
    e2 = h2(e2, c.options), e2.quotes != "single" && e2.quotes != "double" && (e2.quotes = "single");
    for (var r2 = e2.quotes == "double" ? '"' : "'", i2 = e2.isIdentifier, o2 = t10.charAt(0), v3 = "", m = 0, n2 = t10.length;m < n2; ) {
      var d2 = t10.charAt(m++), _4 = d2.charCodeAt(), w3 = undefined;
      if (_4 < 32 || _4 > 126) {
        if (_4 >= 55296 && _4 <= 56319 && m < n2) {
          var y2 = t10.charCodeAt(m++);
          (y2 & 64512) == 56320 ? _4 = ((_4 & 1023) << 10) + (y2 & 1023) + 65536 : m--;
        }
        w3 = "\\" + _4.toString(16).toUpperCase() + " ";
      } else
        e2.escapeEverything ? p.test(d2) ? w3 = "\\" + d2 : w3 = "\\" + _4.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(d2) ? w3 = "\\" + _4.toString(16).toUpperCase() + " " : d2 == "\\" || !i2 && (d2 == '"' && r2 == d2 || d2 == "'" && r2 == d2) || i2 && l3.test(d2) ? w3 = "\\" + d2 : w3 = d2;
      v3 += w3;
    }
    return i2 && (/^-[-\d]/.test(v3) ? v3 = "\\-" + v3.slice(1) : /\d/.test(o2) && (v3 = "\\3" + o2 + " " + v3.slice(1))), v3 = v3.replace(f, function(x2, g2, O3) {
      return g2 && g2.length % 2 ? x2 : (g2 || "") + O3;
    }), !i2 && e2.wrap ? r2 + v3 + r2 : v3;
  };
  return s2.options = {
    escapeEverything: false,
    isIdentifier: false,
    quotes: "single",
    wrap: false
  }, s2.version = "3.0.0", Xr3 = s2, Xr3;
}
var Va2;
function kl() {
  return Va2 || (Va2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(at3()), p = dr3(), l3 = s2(et4()), f = Fe3();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0;m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t10(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i2 = /* @__PURE__ */ function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t10(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _4 = (0, h2.default)(d2, {
              isIdentifier: true
            });
            _4 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _4) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    }(l3.default);
    a.default = i2, u.exports = a.default;
  }(Pt3, Pt3.exports)), Pt3.exports;
}
var Et3 = { exports: {} };
var ja2;
function Pl() {
  return ja2 || (ja2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(et4()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.COMMENT, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Et3, Et3.exports)), Et3.exports;
}
var Tt3 = { exports: {} };
var Ba2;
function El() {
  return Ba2 || (Ba2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(et4()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(i2) {
        var o2;
        return o2 = t10.call(this, i2) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t10.prototype.valueToString.call(this);
      }, e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Tt3, Tt3.exports)), Tt3.exports;
}
var At3 = { exports: {} };
var Ct3 = { exports: {} };
var Ga2;
function Fi2() {
  return Ga2 || (Ga2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = f(at3()), p = dr3(), l3 = f(et4());
    function f(i2) {
      return i2 && i2.__esModule ? i2 : { default: i2 };
    }
    function s2(i2, o2) {
      for (var v3 = 0;v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i2, m.key, m);
      }
    }
    function c2(i2, o2, v3) {
      return o2 && s2(i2.prototype, o2), Object.defineProperty(i2, "prototype", { writable: false }), i2;
    }
    function t10(i2, o2) {
      i2.prototype = Object.create(o2.prototype), i2.prototype.constructor = i2, e2(i2, o2);
    }
    function e2(i2, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i2, o2);
    }
    var r2 = /* @__PURE__ */ function(i2) {
      t10(o2, i2);
      function o2() {
        return i2.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i2.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h2.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    }(l3.default);
    a.default = r2, u.exports = a.default;
  }(Ct3, Ct3.exports)), Ct3.exports;
}
var Ya2;
function Tl() {
  return Ya2 || (Ya2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Fi2()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.TAG, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(At3, At3.exports)), At3.exports;
}
var Rt3 = { exports: {} };
var Qa2;
function Al() {
  return Qa2 || (Qa2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(et4()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.STRING, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Rt3, Rt3.exports)), Rt3.exports;
}
var It3 = { exports: {} };
var Ha2;
function Cl() {
  return Ha2 || (Ha2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Ni2()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(i2) {
        var o2;
        return o2 = t10.call(this, i2) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(It3, It3.exports)), It3.exports;
}
var Zr3 = {};
var en3;
var Ja2;
function Rl() {
  if (Ja2)
    return en3;
  Ja2 = 1, en3 = u;
  function u(h2, p) {
    if (a("noDeprecation"))
      return h2;
    var l3 = false;
    function f() {
      if (!l3) {
        if (a("throwDeprecation"))
          throw new Error(p);
        a("traceDeprecation") ? console.trace(p) : console.warn(p), l3 = true;
      }
      return h2.apply(this, arguments);
    }
    return f;
  }
  function a(h2) {
    try {
      if (!ta2.localStorage)
        return false;
    } catch {
      return false;
    }
    var p = ta2.localStorage[h2];
    return p == null ? false : String(p).toLowerCase() === "true";
  }
  return en3;
}
var Ka2;
function Il() {
  return Ka2 || (Ka2 = 1, function(u) {
    u.__esModule = true, u.default = undefined, u.unescapeValue = d2;
    var a = s2(at3()), h2 = s2(Sl()), p = s2(Fi2()), l3 = Fe3(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0;A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t10(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b5) {
        return E2.__proto__ = b5, E2;
      }, r2(g2, O3);
    }
    var i2 = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i2(function() {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i2(function() {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i2(function() {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b5 = E2.match(o2);
      return b5 && (A = b5[1], E2 = b5[2]), E2 = (0, h2.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _4(g2) {
      if (g2.quoteMark !== undefined || g2.value === undefined)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === undefined && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = /* @__PURE__ */ function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b5;
        return E2 === undefined && (E2 = {}), b5 = g2.call(this, _4(E2)) || this, b5.type = l3.ATTRIBUTE, b5.raws = b5.raws || {}, Object.defineProperty(b5.raws, "unquoted", {
          get: i2(function() {
            return b5.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i2(function() {
            return b5.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b5._constructed = true, b5;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b5) {
        b5 === undefined && (b5 = {});
        var k4 = this._determineQuoteMark(b5), q2 = y2[k4], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b5) {
        return b5.smart ? this.smartQuoteMark(b5) : this.preferredQuoteMark(b5);
      }, A.setValue = function(b5, k4) {
        k4 === undefined && (k4 = {}), this._value = b5, this._quoteMark = this._determineQuoteMark(k4), this._syncRawValue();
      }, A.smartQuoteMark = function(b5) {
        var k4 = this.value, q2 = k4.replace(/[^']/g, "").length, M2 = k4.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k4, {
            isIdentifier: true
          });
          if (W3 === k4)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b5);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b5.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k4, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else
          return M2 === q2 ? this.preferredQuoteMark(b5) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b5) {
        var k4 = b5.preferCurrentQuoteMark ? this.quoteMark : b5.quoteMark;
        return k4 === undefined && (k4 = b5.preferCurrentQuoteMark ? b5.quoteMark : this.quoteMark), k4 === undefined && (k4 = O3.DOUBLE_QUOTE), k4;
      }, A._syncRawValue = function() {
        var b5 = (0, a.default)(this._value, y2[this.quoteMark]);
        b5 === this._value ? this.raws && delete this.raws.value : this.raws.value = b5;
      }, A._handleEscapes = function(b5, k4) {
        if (this._constructed) {
          var q2 = (0, a.default)(k4, {
            isIdentifier: true
          });
          q2 !== k4 ? this.raws[b5] = q2 : delete this.raws[b5];
        }
      }, A._spacesFor = function(b5) {
        var k4 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b5] || {}, M2 = this.raws.spaces && this.raws.spaces[b5] || {};
        return Object.assign(k4, q2, M2);
      }, A._stringFor = function(b5, k4, q2) {
        k4 === undefined && (k4 = b5), q2 === undefined && (q2 = x2);
        var M2 = this._spacesFor(k4);
        return q2(this.stringifyProperty(b5), M2);
      }, A.offsetOf = function(b5) {
        var k4 = 1, q2 = this._spacesFor("attribute");
        if (k4 += q2.before.length, b5 === "namespace" || b5 === "ns")
          return this.namespace ? k4 : -1;
        if (b5 === "attributeNS" || (k4 += this.namespaceString.length, this.namespace && (k4 += 1), b5 === "attribute"))
          return k4;
        k4 += this.stringifyProperty("attribute").length, k4 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k4 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b5 === "operator")
          return W3 ? k4 : -1;
        k4 += W3.length, k4 += M2.after.length;
        var S3 = this._spacesFor("value");
        k4 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b5 === "value")
          return P3 ? k4 : -1;
        k4 += P3.length, k4 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k4 += C.before.length, b5 === "insensitive" && this.insensitive ? k4 : -1;
      }, A.toString = function() {
        var b5 = this, k4 = [this.rawSpaceBefore, "["];
        return k4.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k4.push(this._stringFor("operator")), k4.push(this._stringFor("value")), k4.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b5.quoted && M2.before.length === 0 && !(b5.spaces.value && b5.spaces.value.after) && (M2.before = " "), x2(q2, M2);
        }))), k4.push("]"), k4.push(this.rawSpaceAfter), k4.join("");
      }, t10(O3, [{
        key: "quoted",
        get: function() {
          var b5 = this.quoteMark;
          return b5 === "'" || b5 === '"';
        },
        set: function(b5) {
          m();
        }
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b5) {
          if (!this._constructed) {
            this._quoteMark = b5;
            return;
          }
          this._quoteMark !== b5 && (this._quoteMark = b5, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(b5) {
          if (this._constructed) {
            var k4 = d2(b5), q2 = k4.deprecatedUsage, M2 = k4.unescaped, W3 = k4.quoteMark;
            if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
              return;
            this._value = M2, this._quoteMark = W3, this._syncRawValue();
          } else
            this._value = b5;
        }
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b5) {
          b5 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = undefined)), this._insensitive = b5;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b5) {
          this._handleEscapes("attribute", b5), this._attribute = b5;
        }
      }]), O3;
    }(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x2(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  }(Zr3)), Zr3;
}
var Mt2 = { exports: {} };
var Xa2;
function Ml() {
  return Xa2 || (Xa2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Fi2()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.UNIVERSAL, i2.value = "*", i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Mt2, Mt2.exports)), Mt2.exports;
}
var Dt3 = { exports: {} };
var Za2;
function Dl() {
  return Za2 || (Za2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(et4()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.COMBINATOR, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Dt3, Dt3.exports)), Dt3.exports;
}
var qt3 = { exports: {} };
var es2;
function ql() {
  return es2 || (es2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(et4()), p = Fe3();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.NESTING, i2.value = "&", i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(qt3, qt3.exports)), qt3.exports;
}
var Lt3 = { exports: {} };
var ts2;
function Ru2() {
  return ts2 || (ts2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      return p.sort(function(l3, f) {
        return l3 - f;
      });
    }
    u.exports = a.default;
  }(Lt3, Lt3.exports)), Lt3.exports;
}
var tn3 = {};
var oe2 = {};
var rs2;
function Ll() {
  if (rs2)
    return oe2;
  rs2 = 1, oe2.__esModule = true, oe2.word = oe2.tilde = oe2.tab = oe2.str = oe2.space = oe2.slash = oe2.singleQuote = oe2.semicolon = oe2.plus = oe2.pipe = oe2.openSquare = oe2.openParenthesis = oe2.newline = oe2.greaterThan = oe2.feed = oe2.equals = oe2.doubleQuote = oe2.dollar = oe2.cr = oe2.comment = oe2.comma = oe2.combinator = oe2.colon = oe2.closeSquare = oe2.closeParenthesis = oe2.caret = oe2.bang = oe2.backslash = oe2.at = oe2.asterisk = oe2.ampersand = undefined;
  var u = 38;
  oe2.ampersand = u;
  var a = 42;
  oe2.asterisk = a;
  var h2 = 64;
  oe2.at = h2;
  var p = 44;
  oe2.comma = p;
  var l3 = 58;
  oe2.colon = l3;
  var f = 59;
  oe2.semicolon = f;
  var s2 = 40;
  oe2.openParenthesis = s2;
  var c2 = 41;
  oe2.closeParenthesis = c2;
  var t10 = 91;
  oe2.openSquare = t10;
  var e2 = 93;
  oe2.closeSquare = e2;
  var r2 = 36;
  oe2.dollar = r2;
  var i2 = 126;
  oe2.tilde = i2;
  var o2 = 94;
  oe2.caret = o2;
  var v3 = 43;
  oe2.plus = v3;
  var m = 61;
  oe2.equals = m;
  var n2 = 124;
  oe2.pipe = n2;
  var d2 = 62;
  oe2.greaterThan = d2;
  var _4 = 32;
  oe2.space = _4;
  var w3 = 39;
  oe2.singleQuote = w3;
  var y2 = 34;
  oe2.doubleQuote = y2;
  var x2 = 47;
  oe2.slash = x2;
  var g2 = 33;
  oe2.bang = g2;
  var O3 = 92;
  oe2.backslash = O3;
  var A = 13;
  oe2.cr = A;
  var E2 = 12;
  oe2.feed = E2;
  var b5 = 10;
  oe2.newline = b5;
  var k4 = 9;
  oe2.tab = k4;
  var q2 = w3;
  oe2.str = q2;
  var M2 = -1;
  oe2.comment = M2;
  var W3 = -2;
  oe2.word = W3;
  var S3 = -3;
  return oe2.combinator = S3, oe2;
}
var ns2;
function Iu2() {
  return ns2 || (ns2 = 1, function(u) {
    u.__esModule = true, u.FIELDS = undefined, u.default = m;
    var a = f(Ll()), h2, p;
    function l3(n2) {
      if (typeof WeakMap != "function")
        return null;
      var d2 = /* @__PURE__ */ new WeakMap, _4 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(y2) {
        return y2 ? _4 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _4 = l3(d2);
      if (_4 && _4.has(n2))
        return _4.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x2 in n2)
        if (x2 !== "default" && Object.prototype.hasOwnProperty.call(n2, x2)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x2) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x2, g2) : w3[x2] = n2[x2];
        }
      return w3.default = n2, _4 && _4.set(n2, w3), w3;
    }
    for (var s2 = (h2 = {}, h2[a.tab] = true, h2[a.newline] = true, h2[a.cr] = true, h2[a.feed] = true, h2), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t10 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0;r2 < e2.length; r2++)
      t10[e2.charCodeAt(r2)] = true;
    function i2(n2, d2) {
      var _4 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_4), c2[w3])
          return _4 - 1;
        w3 === a.backslash ? _4 = o2(n2, _4) + 1 : _4++;
      } while (_4 < n2.length);
      return _4 - 1;
    }
    function o2(n2, d2) {
      var _4 = d2, w3 = n2.charCodeAt(_4 + 1);
      if (!s2[w3])
        if (t10[w3]) {
          var y2 = 0;
          do
            _4++, y2++, w3 = n2.charCodeAt(_4 + 1);
          while (t10[w3] && y2 < 6);
          y2 < 6 && w3 === a.space && _4++;
        } else
          _4++;
      return _4;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _4 = n2.css.valueOf(), w3 = _4, y2 = w3.length, x2 = -1, g2 = 1, O3 = 0, A = 0, E2, b5, k4, q2, M2, W3, S3, P3, C, R3, $3, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _4 += D, C = _4.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x2, O3);
      }
      for (;O3 < y2; ) {
        switch (E2 = _4.charCodeAt(O3), E2 === a.newline && (x2 = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _4.charCodeAt(C), E2 === a.newline && (x2 = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k4 = C - x2 - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _4.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k4 = O3 - x2, A = C;
            break;
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k4 = O3 - x2, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _4.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C;_4.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k4 = O3 - x2, A = C + 1;
            break;
          default:
            E2 === a.slash && _4.charCodeAt(O3 + 1) === a.asterisk ? (C = _4.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b5 = _4.slice(O3, C + 1), P3 = b5.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $3 = C - P3[S3].length) : (R3 = g2, $3 = x2), z3 = a.comment, g2 = R3, q2 = R3, k4 = C - $3) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k4 = O3 - x2, A = C + 1) : (C = i2(_4, O3), z3 = a.word, q2 = g2, k4 = C - x2), A = C + 1;
            break;
        }
        d2.push([
          z3,
          g2,
          O3 - x2,
          q2,
          k4,
          O3,
          A
        ]), $3 && (x2 = $3, $3 = null), O3 = A;
      }
      return d2;
    }
  }(tn3)), tn3;
}
var is4;
function Mu2() {
  return is4 || (is4 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = A(xl()), p = A(Ol()), l3 = A(kl()), f = A(Pl()), s2 = A(El()), c2 = A(Tl()), t10 = A(Al()), e2 = A(Cl()), r2 = O3(Il()), i2 = A(Ml()), o2 = A(Dl()), v3 = A(ql()), m = A(Ru2()), n2 = O3(Iu2()), d2 = O3(Ll()), _4 = O3(Fe3()), w3 = dr3(), y2, x2;
    function g2(L3) {
      if (typeof WeakMap != "function")
        return null;
      var F = /* @__PURE__ */ new WeakMap, D = /* @__PURE__ */ new WeakMap;
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T4 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T4 && (T4.get || T4.set) ? Object.defineProperty(I3, J3, T4) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0;D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b5(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k4 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k4, (x2 = {}, x2[d2.comment] = true, x2));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === undefined && (L3.raws[F] = D)), L3;
    }
    function $3(L3, F) {
      for (var D = -1, I3 = [];(D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = /* @__PURE__ */ function() {
      function L3(D, I3) {
        I3 === undefined && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h2.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++;this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T4 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false;U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne4 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T4, "spaces", V4);
                var de3 = T4.spaces[V4].after || "";
                T4.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T4, "raws", "spaces", V4, "after") || null;
                _e3 && (T4.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne4[n2.FIELDS.TYPE] === d2.equals)
                T4.operator = Q3, V4 = "operator";
              else if ((!T4.namespace || V4 === "namespace" && !K3) && ne4) {
                j3 && ((0, w3.ensureObject)(T4, "spaces", "attribute"), T4.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "attribute"), T4.raws.spaces.attribute.before = j3, H3 = ""), T4.namespace = (T4.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T4, "raws", "namespace") || null;
                be3 && (T4.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T4, "raws", "value");
                T4.value += "$", ie3 && (T4.raws.value = ie3 + "$");
                break;
              }
            case d2.caret:
              ne4[n2.FIELDS.TYPE] === d2.equals && (T4.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne4[n2.FIELDS.TYPE] === d2.equals && (T4.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne4[n2.FIELDS.TYPE] === d2.equals ? (T4.operator = Q3, V4 = "operator") : !T4.namespace && !T4.attribute && (T4.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne4 && this.content(ne4) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && !T4.operator && !T4.namespace)
                T4.namespace = Q3, V4 = "namespace";
              else if (!T4.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T4, "spaces", "attribute"), T4.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "attribute"), T4.raws.spaces.attribute.before = H3, H3 = ""), T4.attribute = (T4.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T4, "raws", "attribute") || null;
                ke3 && (T4.raws.attribute += Q3), V4 = "attribute";
              } else if (!T4.value && T4.value !== "" || V4 === "value" && !(K3 || T4.quoteMark)) {
                var Y4 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T4, "raws", "value") || "", te2 = T4.value || "";
                T4.value = te2 + Y4, T4.quoteMark = null, (Y4 !== Q3 || G3) && ((0, w3.ensureObject)(T4, "raws"), T4.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T4.value || T4.value === "") && (T4.quoteMark || K3) ? (T4.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T4, "raws"), T4.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T4, "spaces", "insensitive"), T4.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "insensitive"), T4.raws.spaces.insensitive.before = H3, H3 = "")) : (T4.value || T4.value === "") && (V4 = "value", T4.value += Q3, T4.raws.value && (T4.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T4.attribute || !T4.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T4.value = se3, T4.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T4, "raws"), T4.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T4.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T4.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T4.operator = T4.operator ? T4.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne4 && ne4[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T4, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T4, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T4, "raws", "spaces", V4), T4.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T4[V4] || "", ve3 = (0, w3.getProp)(T4, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T4, "raws"), T4.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T4, "attribute"), R3(T4, "namespace"), this.newNode(new r2.default(T4)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T4 = "", U2 = undefined;
        do
          if (k4[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T4 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T4 && (j3.before = T4, T4 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T4) {
          if (U2)
            U2.spaces.after = T4;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t10.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T4,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === undefined && (N3 = false);
        var T4 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T4 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T4 && (U2 = undefined);
        var j3 = {
          space: T4,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === undefined && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T4 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T4;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T4 = this.current.last;
            if (T4) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== undefined && (T4.rawSpaceAfter += H3), T4.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = undefined;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k4[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne4 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne4, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y4 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y4.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y4.spaces.after = ie3.slice(1)) : Y4.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y4
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _4.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T4 = this.current;
          for (I3.append(J3), this.current = J3;this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T4;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3;this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t10.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken;this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T4, U2) {
            N3 += T4, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t10.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i2.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T4 = this.nextToken, U2 = this.content();T4 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T4[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T4 = this.nextToken;
        }
        var V4 = $3(U2, ".").filter(function(ne4) {
          var de3 = U2[ne4 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $3(U2, "#").filter(function(ne4) {
          return U2[ne4 - 1] !== "\\";
        }), X3 = $3(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne4) {
          return !~X3.indexOf(ne4);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne4, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne4, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y4 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne4, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne4)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y4
            };
            ie3 = new l3.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne4)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y4
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y4
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (;this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T4 = I3.pop();
          I3 = I3.join(", ") + " or " + T4;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === undefined && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === undefined && (I3 = this.position + 1);
        for (var N3 = I3;N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b5(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    }();
    a.default = z3, u.exports = a.default;
  }(mt3, mt3.exports)), mt3.exports;
}
var as2;
function Du2() {
  return as2 || (as2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = p(Mu2());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l3 = /* @__PURE__ */ function() {
      function f(c2, t10) {
        this.func = c2 || function() {}, this.funcRes = null, this.options = t10;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t10 != "string";
      }, s2._isLossy = function(t10) {
        t10 === undefined && (t10 = {});
        var e2 = Object.assign({}, this.options, t10);
        return e2.lossless === false;
      }, s2._root = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = new h2.default(t10, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t10) {
        return {
          lossy: this._isLossy(t10)
        };
      }, s2._run = function(t10, e2) {
        var r2 = this;
        return e2 === undefined && (e2 = {}), new Promise(function(i2, o2) {
          try {
            var v3 = r2._root(t10, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = undefined;
              return r2._shouldUpdateSelector(t10, e2) && (n2 = v3.toString(), t10.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i2, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = this._root(t10, e2), i2 = this.func(r2);
        if (i2 && typeof i2.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = undefined;
        return e2.updateSelector && typeof t10 != "string" && (o2 = r2.toString(), t10.selector = o2), {
          transform: i2,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t10, e2) {
        return this._runSync(t10, e2).root;
      }, s2.transform = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t10, e2) {
        return this._runSync(t10, e2).transform;
      }, s2.process = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t10, e2) {
        var r2 = this._runSync(t10, e2);
        return r2.string || r2.root.toString();
      }, f;
    }();
    a.default = l3, u.exports = a.default;
  }(gt4, gt4.exports)), gt4.exports;
}
var rn3 = {};
var Ie3 = {};
var ss2;
function qu2() {
  if (ss2)
    return Ie3;
  ss2 = 1, Ie3.__esModule = true, Ie3.universal = Ie3.tag = Ie3.string = Ie3.selector = Ie3.root = Ie3.pseudo = Ie3.nesting = Ie3.id = Ie3.comment = Ie3.combinator = Ie3.className = Ie3.attribute = undefined;
  var u = o2(Il()), a = o2(kl()), h2 = o2(Dl()), p = o2(Pl()), l3 = o2(El()), f = o2(ql()), s2 = o2(Cl()), c2 = o2(xl()), t10 = o2(Ol()), e2 = o2(Al()), r2 = o2(Tl()), i2 = o2(Ml());
  function o2(b5) {
    return b5 && b5.__esModule ? b5 : { default: b5 };
  }
  var v3 = function(k4) {
    return new u.default(k4);
  };
  Ie3.attribute = v3;
  var m = function(k4) {
    return new a.default(k4);
  };
  Ie3.className = m;
  var n2 = function(k4) {
    return new h2.default(k4);
  };
  Ie3.combinator = n2;
  var d2 = function(k4) {
    return new p.default(k4);
  };
  Ie3.comment = d2;
  var _4 = function(k4) {
    return new l3.default(k4);
  };
  Ie3.id = _4;
  var w3 = function(k4) {
    return new f.default(k4);
  };
  Ie3.nesting = w3;
  var y2 = function(k4) {
    return new s2.default(k4);
  };
  Ie3.pseudo = y2;
  var x2 = function(k4) {
    return new c2.default(k4);
  };
  Ie3.root = x2;
  var g2 = function(k4) {
    return new t10.default(k4);
  };
  Ie3.selector = g2;
  var O3 = function(k4) {
    return new e2.default(k4);
  };
  Ie3.string = O3;
  var A = function(k4) {
    return new r2.default(k4);
  };
  Ie3.tag = A;
  var E2 = function(k4) {
    return new i2.default(k4);
  };
  return Ie3.universal = E2, Ie3;
}
var Pe3 = {};
var os3;
function Lu2() {
  if (os3)
    return Pe3;
  os3 = 1, Pe3.__esModule = true, Pe3.isComment = Pe3.isCombinator = Pe3.isClassName = Pe3.isAttribute = undefined, Pe3.isContainer = y2, Pe3.isIdentifier = undefined, Pe3.isNamespace = x2, Pe3.isNesting = undefined, Pe3.isNode = p, Pe3.isPseudo = undefined, Pe3.isPseudoClass = w3, Pe3.isPseudoElement = _4, Pe3.isUniversal = Pe3.isTag = Pe3.isString = Pe3.isSelector = Pe3.isRoot = undefined;
  var u = Fe3(), a, h2 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h2[g2.type];
  }
  function l3(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l3.bind(null, u.ATTRIBUTE);
  Pe3.isAttribute = f;
  var s2 = l3.bind(null, u.CLASS);
  Pe3.isClassName = s2;
  var c2 = l3.bind(null, u.COMBINATOR);
  Pe3.isCombinator = c2;
  var t10 = l3.bind(null, u.COMMENT);
  Pe3.isComment = t10;
  var e2 = l3.bind(null, u.ID);
  Pe3.isIdentifier = e2;
  var r2 = l3.bind(null, u.NESTING);
  Pe3.isNesting = r2;
  var i2 = l3.bind(null, u.PSEUDO);
  Pe3.isPseudo = i2;
  var o2 = l3.bind(null, u.ROOT);
  Pe3.isRoot = o2;
  var v3 = l3.bind(null, u.SELECTOR);
  Pe3.isSelector = v3;
  var m = l3.bind(null, u.STRING);
  Pe3.isString = m;
  var n2 = l3.bind(null, u.TAG);
  Pe3.isTag = n2;
  var d2 = l3.bind(null, u.UNIVERSAL);
  Pe3.isUniversal = d2;
  function _4(g2) {
    return i2(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i2(g2) && !_4(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x2(g2) {
    return f(g2) || n2(g2);
  }
  return Pe3;
}
var ls2;
function Nu2() {
  return ls2 || (ls2 = 1, function(u) {
    u.__esModule = true;
    var a = Fe3();
    Object.keys(a).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === a[l3] || (u[l3] = a[l3]);
    });
    var h2 = qu2();
    Object.keys(h2).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === h2[l3] || (u[l3] = h2[l3]);
    });
    var p = Lu2();
    Object.keys(p).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === p[l3] || (u[l3] = p[l3]);
    });
  }(rn3)), rn3;
}
var us2;
function Fu2() {
  return us2 || (us2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(Du2()), p = f(Nu2());
    function l3(e2) {
      if (typeof WeakMap != "function")
        return null;
      var r2 = /* @__PURE__ */ new WeakMap, i2 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(v3) {
        return v3 ? i2 : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i2 = l3(r2);
      if (i2 && i2.has(e2))
        return i2.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i2 && i2.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h2.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t10 = c2;
    a.default = t10, u.exports = a.default;
  }(vt3, vt3.exports)), vt3.exports;
}
var $u2 = Fu2();
var $i2 = /* @__PURE__ */ He3($u2);
var fs3 = (u) => u.replace(/-(\w|$)/g, (a, h2) => h2.toUpperCase());
var Uu2 = (u) => {
  const a = u.toLowerCase();
  return a.startsWith("--") ? a : a.startsWith("-ms-") ? fs3(a.slice(1)) : fs3(a);
};
function zu2(u) {
  return u.replaceAll(/\\[0-9]|\\/g, "");
}
var Wu2 = (u, a) => {
  u.walkRules((h2) => {
    var p;
    ((p = h2.parent) == null ? undefined : p.type) !== "atrule" && $i2((l3) => {
      let f = false;
      l3.walkPseudos(() => {
        f = true;
      }), f || a(h2);
    }).processSync(h2.selector);
  });
};
function Vu2(u, a) {
  let p = [...u.split(" ")];
  const l3 = {};
  return Wu2(a, (f) => {
    const s2 = [];
    $i2((c2) => {
      c2.walkClasses((t10) => {
        s2.push(zu2(t10.value));
      });
    }).processSync(f.selector), p = p.filter((c2) => !s2.includes(c2)), f.walkDecls((c2) => {
      l3[Uu2(c2.prop)] = c2.value + (c2.important ? "!important" : "");
    });
  }), {
    styles: l3,
    residualClassName: p.join(" ")
  };
}
var ju2 = (u) => {
  u.walkDecls((a) => {
    const h2 = /rgb\(\s*(\d+)\s*(\d+)\s*(\d+)(?:\s*\/\s*([\d%.]+))?\s*\)/g;
    a.value = a.value.replaceAll(h2, (p, l3, f, s2, c2) => {
      const t10 = c2 === "1" || typeof c2 > "u" ? "" : `,${c2}`;
      return `rgb(${l3},${f},${s2}${t10})`;
    });
  });
};
var Bu2 = (u) => {
  const a = [], h2 = [], p = $i2();
  return u.walkAtRules((l3) => {
    const f = l3.clone();
    f.walkRules((c2) => {
      const t10 = p.astSync(c2.selector);
      t10.walkClasses((r2) => {
        h2.push(r2.value), cs2(r2);
      });
      const e2 = c2.clone({ selector: t10.toString() });
      e2.walkDecls((r2) => {
        r2.important = true;
      }), c2.replaceWith(e2);
    });
    const s2 = a.find((c2) => c2 instanceof wl && c2.params === f.params);
    s2 ? s2.append(f.nodes) : a.push(f);
  }), u.walkRules((l3) => {
    if (l3.parent && l3.parent.type !== "root")
      return;
    const f = p.astSync(l3.selector);
    let s2 = false;
    if (f.walkPseudos(() => {
      s2 = true;
    }), !!s2 && (f.walkClasses((c2) => {
      h2.push(c2.value), cs2(c2);
    }), s2)) {
      const c2 = l3.clone({ selector: f.toString() });
      c2.walkDecls((t10) => {
        t10.important = true;
      }), a.push(c2);
    }
  }), {
    nonInlinableClasses: h2,
    sanitizedRules: a
  };
};
var cs2 = (u) => {
  u.replaceWith(u.clone({
    value: _l(u.value)
  }));
};
var Gu2 = (u, a) => {
  const h2 = {};
  let p = [], l3 = [];
  if (u.props.className) {
    const s2 = a.generateRootForClasses(u.props.className.split(" "));
    ju2(s2), {
      sanitizedRules: l3,
      nonInlinableClasses: p
    } = Bu2(s2);
    const { styles: c2, residualClassName: t10 } = Vu2(u.props.className, s2);
    if (h2.style = {
      ...c2,
      ...u.props.style
    }, !bl(u))
      if (t10.trim().length > 0) {
        h2.className = t10;
        for (const e2 of p)
          h2.className = h2.className.replace(e2, _l(e2));
      } else
        h2.className = undefined;
  }
  const f = {
    ...u.props,
    ...h2
  };
  return {
    elementWithInlinedStyles: import_react2.default.cloneElement(u, f, f.children),
    nonInlinableClasses: p,
    nonInlineStyleNodes: l3
  };
};
var nn2 = {};
var ds2;
function Yu2() {
  return ds2 || (ds2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    let a = {
      atrule: [
        "name",
        "params"
      ],
      rule: [
        "selector"
      ]
    }, h2 = new Set(Object.keys(a));
    function p() {
      function l3(f) {
        let s2 = null;
        f.each((c2) => {
          if (!h2.has(c2.type)) {
            s2 = null;
            return;
          }
          if (s2 === null) {
            s2 = c2;
            return;
          }
          let t10 = a[c2.type];
          var e2, r2;
          c2.type === "atrule" && c2.name === "font-face" ? s2 = c2 : t10.every((i2) => ((e2 = c2[i2]) !== null && e2 !== undefined ? e2 : "").replace(/\s+/g, " ") === ((r2 = s2[i2]) !== null && r2 !== undefined ? r2 : "").replace(/\s+/g, " ")) ? (c2.nodes && s2.append(c2.nodes), c2.remove()) : s2 = c2;
        }), f.each((c2) => {
          c2.type === "atrule" && l3(c2);
        });
      }
      return (f) => {
        l3(f);
      };
    }
  }(nn2)), nn2;
}
var Qu2 = Yu2();
var Hu2 = /* @__PURE__ */ He3(Qu2);
var an2 = {};
var ps2;
function Ju2() {
  return ps2 || (ps2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a() {
      return (l3) => {
        l3.walkRules((f) => {
          let s2 = /* @__PURE__ */ new Map, c2 = /* @__PURE__ */ new Set([]), t10 = /* @__PURE__ */ new Map;
          f.walkDecls((e2) => {
            if (e2.parent === f) {
              if (s2.has(e2.prop)) {
                if (s2.get(e2.prop).value === e2.value) {
                  c2.add(s2.get(e2.prop)), s2.set(e2.prop, e2);
                  return;
                }
                t10.has(e2.prop) || t10.set(e2.prop, /* @__PURE__ */ new Set), t10.get(e2.prop).add(s2.get(e2.prop)), t10.get(e2.prop).add(e2);
              }
              s2.set(e2.prop, e2);
            }
          });
          for (let e2 of c2)
            e2.remove();
          for (let e2 of t10.values()) {
            let r2 = /* @__PURE__ */ new Map;
            for (let i2 of e2) {
              let o2 = p(i2.value);
              o2 !== null && (r2.has(o2) || r2.set(o2, /* @__PURE__ */ new Set), r2.get(o2).add(i2));
            }
            for (let i2 of r2.values()) {
              let o2 = Array.from(i2).slice(0, -1);
              for (let v3 of o2)
                v3.remove();
            }
          }
        });
      };
    }
    let h2 = Symbol("unitless-number");
    function p(l3) {
      let f = /^-?\d*.?\d+([\w%]+)?$/g.exec(l3);
      if (f) {
        var s2;
        return (s2 = f[1]) !== null && s2 !== undefined ? s2 : h2;
      }
      return null;
    }
  }(an2)), an2;
}
var Ku2 = Ju2();
var Xu2 = /* @__PURE__ */ He3(Ku2);
var sn2 = {};
var on3 = { exports: {} };
var hs2;
function Nl() {
  return hs2 || (hs2 = 1, function(u, a) {
    (function(h2, p) {
      u.exports = function(l3, f, s2, c2, t10) {
        for (f = f.split ? f.split(".") : f, c2 = 0;c2 < f.length; c2++)
          l3 = l3 ? l3[f[c2]] : t10;
        return l3 === t10 ? s2 : l3;
      };
    })();
  }(on3)), on3.exports;
}
var ln3 = { exports: {} };
var vs2;
function Zu2() {
  return vs2 || (vs2 = 1, function(u) {
    (function() {
      function a(l3, f, s2) {
        if (!l3)
          return null;
        a.caseSensitive || (l3 = l3.toLowerCase());
        var c2 = a.threshold === null ? null : a.threshold * l3.length, t10 = a.thresholdAbsolute, e2;
        c2 !== null && t10 !== null ? e2 = Math.min(c2, t10) : c2 !== null ? e2 = c2 : t10 !== null ? e2 = t10 : e2 = null;
        var r2, i2, o2, v3, m, n2 = f.length;
        for (m = 0;m < n2; m++)
          if (i2 = f[m], s2 && (i2 = i2[s2]), !!i2 && (a.caseSensitive ? o2 = i2 : o2 = i2.toLowerCase(), v3 = p(l3, o2, e2), (e2 === null || v3 < e2) && (e2 = v3, s2 && a.returnWinningObject ? r2 = f[m] : r2 = i2, a.returnFirstMatch)))
            return r2;
        return r2 || a.nullResultValue;
      }
      a.threshold = 0.4, a.thresholdAbsolute = 20, a.caseSensitive = false, a.nullResultValue = null, a.returnWinningObject = null, a.returnFirstMatch = false, u.exports ? u.exports = a : window.didYouMean = a;
      var h2 = Math.pow(2, 32) - 1;
      function p(l3, f, s2) {
        s2 = s2 || s2 === 0 ? s2 : h2;
        var c2 = l3.length, t10 = f.length;
        if (c2 === 0)
          return Math.min(s2 + 1, t10);
        if (t10 === 0)
          return Math.min(s2 + 1, c2);
        if (Math.abs(c2 - t10) > s2)
          return s2 + 1;
        var e2 = [], r2, i2, o2, v3, m;
        for (r2 = 0;r2 <= t10; r2++)
          e2[r2] = [r2];
        for (i2 = 0;i2 <= c2; i2++)
          e2[0][i2] = i2;
        for (r2 = 1;r2 <= t10; r2++) {
          for (o2 = h2, v3 = 1, r2 > s2 && (v3 = r2 - s2), m = t10 + 1, m > s2 + r2 && (m = s2 + r2), i2 = 1;i2 <= c2; i2++)
            i2 < v3 || i2 > m ? e2[r2][i2] = s2 + 1 : f.charAt(r2 - 1) === l3.charAt(i2 - 1) ? e2[r2][i2] = e2[r2 - 1][i2 - 1] : e2[r2][i2] = Math.min(e2[r2 - 1][i2 - 1] + 1, Math.min(e2[r2][i2 - 1] + 1, e2[r2 - 1][i2] + 1)), e2[r2][i2] < o2 && (o2 = e2[r2][i2]);
          if (o2 > s2)
            return s2 + 1;
        }
        return e2[t10][c2];
      }
    })();
  }(ln3)), ln3.exports;
}
var un3 = {};
var fn3 = {};
var gs2;
function ut3() {
  return gs2 || (gs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (Object.prototype.toString.call(h2) !== "[object Object]")
        return false;
      const p = Object.getPrototypeOf(h2);
      return p === null || Object.getPrototypeOf(p) === null;
    }
  }(fn3)), fn3;
}
var ms2;
function pr3() {
  return ms2 || (ms2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(Be2()), h2 = /* @__PURE__ */ p(ut3());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3(f) {
      return [
        "fontSize",
        "outline"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2[0]), s2) : f === "fontFamily" ? (s2) => {
        typeof s2 == "function" && (s2 = s2({}));
        let c2 = Array.isArray(s2) && (0, h2.default)(s2[1]) ? s2[0] : s2;
        return Array.isArray(c2) ? c2.join(", ") : c2;
      } : [
        "boxShadow",
        "transitionProperty",
        "transitionDuration",
        "transitionDelay",
        "transitionTimingFunction",
        "backgroundImage",
        "backgroundSize",
        "backgroundColor",
        "cursor",
        "animation"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), Array.isArray(s2) && (s2 = s2.join(", ")), s2) : [
        "gridTemplateColumns",
        "gridTemplateRows",
        "objectPosition"
      ].includes(f) ? (s2) => (typeof s2 == "function" && (s2 = s2({})), typeof s2 == "string" && (s2 = a.default.list.comma(s2).join(" ")), s2) : (s2, c2 = {}) => (typeof s2 == "function" && (s2 = s2(c2)), s2);
    }
  }(un3)), un3;
}
var cn3;
var ys2;
function ef() {
  if (ys2)
    return cn3;
  ys2 = 1;
  var u = 40, a = 41, h2 = 39, p = 34, l3 = 92, f = 47, s2 = 44, c2 = 58, t10 = 42, e2 = 117, r2 = 85, i2 = 43, o2 = /^[a-f0-9?-]+$/i;
  return cn3 = function(v3) {
    for (var m = [], n2 = v3, d2, _4, w3, y2, x2, g2, O3, A, E2 = 0, b5 = n2.charCodeAt(E2), k4 = n2.length, q2 = [
      {
        nodes: m
      }
    ], M2 = 0, W3, S3 = "", P3 = "", C = "";E2 < k4; )
      if (b5 <= 32) {
        d2 = E2;
        do
          d2 += 1, b5 = n2.charCodeAt(d2);
        while (b5 <= 32);
        y2 = n2.slice(E2, d2), w3 = m[m.length - 1], b5 === a && M2 ? C = y2 : w3 && w3.type === "div" ? (w3.after = y2, w3.sourceEndIndex += y2.length) : b5 === s2 || b5 === c2 || b5 === f && n2.charCodeAt(d2 + 1) !== t10 && (!W3 || W3 && W3.type === "function" && false) ? P3 = y2 : m.push({
          type: "space",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      } else if (b5 === h2 || b5 === p) {
        d2 = E2, _4 = b5 === h2 ? "'" : '"', y2 = {
          type: "string",
          sourceIndex: E2,
          quote: _4
        };
        do
          if (x2 = false, d2 = n2.indexOf(_4, d2 + 1), ~d2)
            for (g2 = d2;n2.charCodeAt(g2 - 1) === l3; )
              g2 -= 1, x2 = !x2;
          else
            n2 += _4, d2 = n2.length - 1, y2.unclosed = true;
        while (x2);
        y2.value = n2.slice(E2 + 1, d2), y2.sourceEndIndex = y2.unclosed ? d2 : d2 + 1, m.push(y2), E2 = d2 + 1, b5 = n2.charCodeAt(E2);
      } else if (b5 === f && n2.charCodeAt(E2 + 1) === t10)
        d2 = n2.indexOf("*/", E2), y2 = {
          type: "comment",
          sourceIndex: E2,
          sourceEndIndex: d2 + 2
        }, d2 === -1 && (y2.unclosed = true, d2 = n2.length, y2.sourceEndIndex = d2), y2.value = n2.slice(E2 + 2, d2), m.push(y2), E2 = d2 + 2, b5 = n2.charCodeAt(E2);
      else if ((b5 === f || b5 === t10) && W3 && W3.type === "function")
        y2 = n2[E2], m.push({
          type: "word",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2
        }), E2 += 1, b5 = n2.charCodeAt(E2);
      else if (b5 === f || b5 === s2 || b5 === c2)
        y2 = n2[E2], m.push({
          type: "div",
          sourceIndex: E2 - P3.length,
          sourceEndIndex: E2 + y2.length,
          value: y2,
          before: P3,
          after: ""
        }), P3 = "", E2 += 1, b5 = n2.charCodeAt(E2);
      else if (u === b5) {
        d2 = E2;
        do
          d2 += 1, b5 = n2.charCodeAt(d2);
        while (b5 <= 32);
        if (A = E2, y2 = {
          type: "function",
          sourceIndex: E2 - S3.length,
          value: S3,
          before: n2.slice(A + 1, d2)
        }, E2 = d2, S3 === "url" && b5 !== h2 && b5 !== p) {
          d2 -= 1;
          do
            if (x2 = false, d2 = n2.indexOf(")", d2 + 1), ~d2)
              for (g2 = d2;n2.charCodeAt(g2 - 1) === l3; )
                g2 -= 1, x2 = !x2;
            else
              n2 += ")", d2 = n2.length - 1, y2.unclosed = true;
          while (x2);
          O3 = d2;
          do
            O3 -= 1, b5 = n2.charCodeAt(O3);
          while (b5 <= 32);
          A < O3 ? (E2 !== O3 + 1 ? y2.nodes = [
            {
              type: "word",
              sourceIndex: E2,
              sourceEndIndex: O3 + 1,
              value: n2.slice(E2, O3 + 1)
            }
          ] : y2.nodes = [], y2.unclosed && O3 + 1 !== d2 ? (y2.after = "", y2.nodes.push({
            type: "space",
            sourceIndex: O3 + 1,
            sourceEndIndex: d2,
            value: n2.slice(O3 + 1, d2)
          })) : (y2.after = n2.slice(O3 + 1, d2), y2.sourceEndIndex = d2)) : (y2.after = "", y2.nodes = []), E2 = d2 + 1, y2.sourceEndIndex = y2.unclosed ? d2 : E2, b5 = n2.charCodeAt(E2), m.push(y2);
        } else
          M2 += 1, y2.after = "", y2.sourceEndIndex = E2 + 1, m.push(y2), q2.push(y2), m = y2.nodes = [], W3 = y2;
        S3 = "";
      } else if (a === b5 && M2)
        E2 += 1, b5 = n2.charCodeAt(E2), W3.after = C, W3.sourceEndIndex += C.length, C = "", M2 -= 1, q2[q2.length - 1].sourceEndIndex = E2, q2.pop(), W3 = q2[M2], m = W3.nodes;
      else {
        d2 = E2;
        do
          b5 === l3 && (d2 += 1), d2 += 1, b5 = n2.charCodeAt(d2);
        while (d2 < k4 && !(b5 <= 32 || b5 === h2 || b5 === p || b5 === s2 || b5 === c2 || b5 === f || b5 === u || b5 === t10 && W3 && W3.type === "function" || b5 === f && W3.type === "function" || b5 === a && M2));
        y2 = n2.slice(E2, d2), u === b5 ? S3 = y2 : (e2 === y2.charCodeAt(0) || r2 === y2.charCodeAt(0)) && i2 === y2.charCodeAt(1) && o2.test(y2.slice(2)) ? m.push({
          type: "unicode-range",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }) : m.push({
          type: "word",
          sourceIndex: E2,
          sourceEndIndex: d2,
          value: y2
        }), E2 = d2;
      }
    for (E2 = q2.length - 1;E2; E2 -= 1)
      q2[E2].unclosed = true, q2[E2].sourceEndIndex = n2.length;
    return q2[0].nodes;
  }, cn3;
}
var dn3;
var ws3;
function tf() {
  return ws3 || (ws3 = 1, dn3 = function u(a, h2, p) {
    var l3, f, s2, c2;
    for (l3 = 0, f = a.length;l3 < f; l3 += 1)
      s2 = a[l3], p || (c2 = h2(s2, l3, a)), c2 !== false && s2.type === "function" && Array.isArray(s2.nodes) && u(s2.nodes, h2, p), p && h2(s2, l3, a);
  }), dn3;
}
var pn3;
var bs2;
function rf() {
  if (bs2)
    return pn3;
  bs2 = 1;
  function u(h2, p) {
    var { type: l3, value: f } = h2, s2, c2;
    return p && (c2 = p(h2)) !== undefined ? c2 : l3 === "word" || l3 === "space" ? f : l3 === "string" ? (s2 = h2.quote || "", s2 + f + (h2.unclosed ? "" : s2)) : l3 === "comment" ? "/*" + f + (h2.unclosed ? "" : "*/") : l3 === "div" ? (h2.before || "") + f + (h2.after || "") : Array.isArray(h2.nodes) ? (s2 = a(h2.nodes, p), l3 !== "function" ? s2 : f + "(" + (h2.before || "") + s2 + (h2.after || "") + (h2.unclosed ? "" : ")")) : f;
  }
  function a(h2, p) {
    var l3, f;
    if (Array.isArray(h2)) {
      for (l3 = "", f = h2.length - 1;~f; f -= 1)
        l3 = u(h2[f], p) + l3;
      return l3;
    }
    return u(h2, p);
  }
  return pn3 = a, pn3;
}
var hn3;
var _s2;
function nf() {
  if (_s2)
    return hn3;
  _s2 = 1;
  var u = 45, a = 43, h2 = 46, p = 101, l3 = 69;
  function f(s2) {
    var c2 = s2.charCodeAt(0), t10;
    if (c2 === a || c2 === u) {
      if (t10 = s2.charCodeAt(1), t10 >= 48 && t10 <= 57)
        return true;
      var e2 = s2.charCodeAt(2);
      return t10 === h2 && e2 >= 48 && e2 <= 57;
    }
    return c2 === h2 ? (t10 = s2.charCodeAt(1), t10 >= 48 && t10 <= 57) : c2 >= 48 && c2 <= 57;
  }
  return hn3 = function(s2) {
    var c2 = 0, t10 = s2.length, e2, r2, i2;
    if (t10 === 0 || !f(s2))
      return false;
    for (e2 = s2.charCodeAt(c2), (e2 === a || e2 === u) && c2++;c2 < t10 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
      c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), e2 === h2 && r2 >= 48 && r2 <= 57)
      for (c2 += 2;c2 < t10 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    if (e2 = s2.charCodeAt(c2), r2 = s2.charCodeAt(c2 + 1), i2 = s2.charCodeAt(c2 + 2), (e2 === p || e2 === l3) && (r2 >= 48 && r2 <= 57 || (r2 === a || r2 === u) && i2 >= 48 && i2 <= 57))
      for (c2 += r2 === a || r2 === u ? 3 : 2;c2 < t10 && (e2 = s2.charCodeAt(c2), !(e2 < 48 || e2 > 57)); )
        c2 += 1;
    return {
      number: s2.slice(0, c2),
      unit: s2.slice(c2)
    };
  }, hn3;
}
var vn3;
var Ss2;
function af() {
  if (Ss2)
    return vn3;
  Ss2 = 1;
  var u = ef(), a = tf(), h2 = rf();
  function p(l3) {
    return this instanceof p ? (this.nodes = u(l3), this) : new p(l3);
  }
  return p.prototype.toString = function() {
    return Array.isArray(this.nodes) ? h2(this.nodes) : "";
  }, p.prototype.walk = function(l3, f) {
    return a(this.nodes, l3, f), this;
  }, p.unit = nf(), p.walk = a, p.stringify = h2, vn3 = p, vn3;
}
var gn3 = {};
var xs2;
function Ui2() {
  return xs2 || (xs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(c2, t10) {
      for (var e2 in t10)
        Object.defineProperty(c2, e2, {
          enumerable: true,
          get: t10[e2]
        });
    }
    a(u, {
      normalizeScreens: function() {
        return h2;
      },
      isScreenSortable: function() {
        return p;
      },
      compareScreens: function() {
        return l3;
      },
      toScreen: function() {
        return f;
      }
    });
    function h2(c2, t10 = true) {
      return Array.isArray(c2) ? c2.map((e2) => {
        if (t10 && Array.isArray(e2))
          throw new Error("The tuple syntax is not supported for `screens`.");
        if (typeof e2 == "string")
          return {
            name: e2.toString(),
            not: false,
            values: [
              {
                min: e2,
                max: undefined
              }
            ]
          };
        let [r2, i2] = e2;
        return r2 = r2.toString(), typeof i2 == "string" ? {
          name: r2,
          not: false,
          values: [
            {
              min: i2,
              max: undefined
            }
          ]
        } : Array.isArray(i2) ? {
          name: r2,
          not: false,
          values: i2.map((o2) => s2(o2))
        } : {
          name: r2,
          not: false,
          values: [
            s2(i2)
          ]
        };
      }) : h2(Object.entries(c2 ?? {}), false);
    }
    function p(c2) {
      return c2.values.length !== 1 ? {
        result: false,
        reason: "multiple-values"
      } : c2.values[0].raw !== undefined ? {
        result: false,
        reason: "raw-values"
      } : c2.values[0].min !== undefined && c2.values[0].max !== undefined ? {
        result: false,
        reason: "min-and-max"
      } : {
        result: true,
        reason: null
      };
    }
    function l3(c2, t10, e2) {
      let r2 = f(t10, c2), i2 = f(e2, c2), o2 = p(r2), v3 = p(i2);
      if (o2.reason === "multiple-values" || v3.reason === "multiple-values")
        throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
      if (o2.reason === "raw-values" || v3.reason === "raw-values")
        throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
      if (o2.reason === "min-and-max" || v3.reason === "min-and-max")
        throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
      let { min: m, max: n2 } = r2.values[0], { min: d2, max: _4 } = i2.values[0];
      t10.not && ([m, n2] = [
        n2,
        m
      ]), e2.not && ([d2, _4] = [
        _4,
        d2
      ]), m = m === undefined ? m : parseFloat(m), n2 = n2 === undefined ? n2 : parseFloat(n2), d2 = d2 === undefined ? d2 : parseFloat(d2), _4 = _4 === undefined ? _4 : parseFloat(_4);
      let [w3, y2] = c2 === "min" ? [
        m,
        d2
      ] : [
        _4,
        n2
      ];
      return w3 - y2;
    }
    function f(c2, t10) {
      return typeof c2 == "object" ? c2 : {
        name: "arbitrary-screen",
        values: [
          {
            [t10]: c2
          }
        ]
      };
    }
    function s2({ "min-width": c2, min: t10 = c2, max: e2, raw: r2 } = {}) {
      return {
        min: t10,
        max: e2,
        raw: r2
      };
    }
  }(gn3)), gn3;
}
var mn3 = {};
var Os2;
function zi2() {
  return Os2 || (Os2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return h2 = Array.isArray(h2) ? h2 : [
        h2
      ], h2.map((p) => {
        let l3 = p.values.map((f) => f.raw !== undefined ? f.raw : [
          f.min && `(min-width: ${f.min})`,
          f.max && `(max-width: ${f.max})`
        ].filter(Boolean).join(" and "));
        return p.not ? `not all and ${l3}` : l3;
      }).join(", ");
    }
  }(mn3)), mn3;
}
var yn3 = {};
var ks2;
function Wi2() {
  return ks2 || (ks2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "toPath", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (Array.isArray(h2))
        return h2;
      let p = h2.split("[").length - 1, l3 = h2.split("]").length - 1;
      if (p !== l3)
        throw new Error(`Path is invalid. Has unbalanced brackets: ${h2}`);
      return h2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
    }
  }(yn3)), yn3;
}
var wn3 = {};
var bn3 = {};
var _n3 = {};
var Ps2;
function sf() {
  return Ps2 || (Ps2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = {
      aliceblue: [
        240,
        248,
        255
      ],
      antiquewhite: [
        250,
        235,
        215
      ],
      aqua: [
        0,
        255,
        255
      ],
      aquamarine: [
        127,
        255,
        212
      ],
      azure: [
        240,
        255,
        255
      ],
      beige: [
        245,
        245,
        220
      ],
      bisque: [
        255,
        228,
        196
      ],
      black: [
        0,
        0,
        0
      ],
      blanchedalmond: [
        255,
        235,
        205
      ],
      blue: [
        0,
        0,
        255
      ],
      blueviolet: [
        138,
        43,
        226
      ],
      brown: [
        165,
        42,
        42
      ],
      burlywood: [
        222,
        184,
        135
      ],
      cadetblue: [
        95,
        158,
        160
      ],
      chartreuse: [
        127,
        255,
        0
      ],
      chocolate: [
        210,
        105,
        30
      ],
      coral: [
        255,
        127,
        80
      ],
      cornflowerblue: [
        100,
        149,
        237
      ],
      cornsilk: [
        255,
        248,
        220
      ],
      crimson: [
        220,
        20,
        60
      ],
      cyan: [
        0,
        255,
        255
      ],
      darkblue: [
        0,
        0,
        139
      ],
      darkcyan: [
        0,
        139,
        139
      ],
      darkgoldenrod: [
        184,
        134,
        11
      ],
      darkgray: [
        169,
        169,
        169
      ],
      darkgreen: [
        0,
        100,
        0
      ],
      darkgrey: [
        169,
        169,
        169
      ],
      darkkhaki: [
        189,
        183,
        107
      ],
      darkmagenta: [
        139,
        0,
        139
      ],
      darkolivegreen: [
        85,
        107,
        47
      ],
      darkorange: [
        255,
        140,
        0
      ],
      darkorchid: [
        153,
        50,
        204
      ],
      darkred: [
        139,
        0,
        0
      ],
      darksalmon: [
        233,
        150,
        122
      ],
      darkseagreen: [
        143,
        188,
        143
      ],
      darkslateblue: [
        72,
        61,
        139
      ],
      darkslategray: [
        47,
        79,
        79
      ],
      darkslategrey: [
        47,
        79,
        79
      ],
      darkturquoise: [
        0,
        206,
        209
      ],
      darkviolet: [
        148,
        0,
        211
      ],
      deeppink: [
        255,
        20,
        147
      ],
      deepskyblue: [
        0,
        191,
        255
      ],
      dimgray: [
        105,
        105,
        105
      ],
      dimgrey: [
        105,
        105,
        105
      ],
      dodgerblue: [
        30,
        144,
        255
      ],
      firebrick: [
        178,
        34,
        34
      ],
      floralwhite: [
        255,
        250,
        240
      ],
      forestgreen: [
        34,
        139,
        34
      ],
      fuchsia: [
        255,
        0,
        255
      ],
      gainsboro: [
        220,
        220,
        220
      ],
      ghostwhite: [
        248,
        248,
        255
      ],
      gold: [
        255,
        215,
        0
      ],
      goldenrod: [
        218,
        165,
        32
      ],
      gray: [
        128,
        128,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      greenyellow: [
        173,
        255,
        47
      ],
      grey: [
        128,
        128,
        128
      ],
      honeydew: [
        240,
        255,
        240
      ],
      hotpink: [
        255,
        105,
        180
      ],
      indianred: [
        205,
        92,
        92
      ],
      indigo: [
        75,
        0,
        130
      ],
      ivory: [
        255,
        255,
        240
      ],
      khaki: [
        240,
        230,
        140
      ],
      lavender: [
        230,
        230,
        250
      ],
      lavenderblush: [
        255,
        240,
        245
      ],
      lawngreen: [
        124,
        252,
        0
      ],
      lemonchiffon: [
        255,
        250,
        205
      ],
      lightblue: [
        173,
        216,
        230
      ],
      lightcoral: [
        240,
        128,
        128
      ],
      lightcyan: [
        224,
        255,
        255
      ],
      lightgoldenrodyellow: [
        250,
        250,
        210
      ],
      lightgray: [
        211,
        211,
        211
      ],
      lightgreen: [
        144,
        238,
        144
      ],
      lightgrey: [
        211,
        211,
        211
      ],
      lightpink: [
        255,
        182,
        193
      ],
      lightsalmon: [
        255,
        160,
        122
      ],
      lightseagreen: [
        32,
        178,
        170
      ],
      lightskyblue: [
        135,
        206,
        250
      ],
      lightslategray: [
        119,
        136,
        153
      ],
      lightslategrey: [
        119,
        136,
        153
      ],
      lightsteelblue: [
        176,
        196,
        222
      ],
      lightyellow: [
        255,
        255,
        224
      ],
      lime: [
        0,
        255,
        0
      ],
      limegreen: [
        50,
        205,
        50
      ],
      linen: [
        250,
        240,
        230
      ],
      magenta: [
        255,
        0,
        255
      ],
      maroon: [
        128,
        0,
        0
      ],
      mediumaquamarine: [
        102,
        205,
        170
      ],
      mediumblue: [
        0,
        0,
        205
      ],
      mediumorchid: [
        186,
        85,
        211
      ],
      mediumpurple: [
        147,
        112,
        219
      ],
      mediumseagreen: [
        60,
        179,
        113
      ],
      mediumslateblue: [
        123,
        104,
        238
      ],
      mediumspringgreen: [
        0,
        250,
        154
      ],
      mediumturquoise: [
        72,
        209,
        204
      ],
      mediumvioletred: [
        199,
        21,
        133
      ],
      midnightblue: [
        25,
        25,
        112
      ],
      mintcream: [
        245,
        255,
        250
      ],
      mistyrose: [
        255,
        228,
        225
      ],
      moccasin: [
        255,
        228,
        181
      ],
      navajowhite: [
        255,
        222,
        173
      ],
      navy: [
        0,
        0,
        128
      ],
      oldlace: [
        253,
        245,
        230
      ],
      olive: [
        128,
        128,
        0
      ],
      olivedrab: [
        107,
        142,
        35
      ],
      orange: [
        255,
        165,
        0
      ],
      orangered: [
        255,
        69,
        0
      ],
      orchid: [
        218,
        112,
        214
      ],
      palegoldenrod: [
        238,
        232,
        170
      ],
      palegreen: [
        152,
        251,
        152
      ],
      paleturquoise: [
        175,
        238,
        238
      ],
      palevioletred: [
        219,
        112,
        147
      ],
      papayawhip: [
        255,
        239,
        213
      ],
      peachpuff: [
        255,
        218,
        185
      ],
      peru: [
        205,
        133,
        63
      ],
      pink: [
        255,
        192,
        203
      ],
      plum: [
        221,
        160,
        221
      ],
      powderblue: [
        176,
        224,
        230
      ],
      purple: [
        128,
        0,
        128
      ],
      rebeccapurple: [
        102,
        51,
        153
      ],
      red: [
        255,
        0,
        0
      ],
      rosybrown: [
        188,
        143,
        143
      ],
      royalblue: [
        65,
        105,
        225
      ],
      saddlebrown: [
        139,
        69,
        19
      ],
      salmon: [
        250,
        128,
        114
      ],
      sandybrown: [
        244,
        164,
        96
      ],
      seagreen: [
        46,
        139,
        87
      ],
      seashell: [
        255,
        245,
        238
      ],
      sienna: [
        160,
        82,
        45
      ],
      silver: [
        192,
        192,
        192
      ],
      skyblue: [
        135,
        206,
        235
      ],
      slateblue: [
        106,
        90,
        205
      ],
      slategray: [
        112,
        128,
        144
      ],
      slategrey: [
        112,
        128,
        144
      ],
      snow: [
        255,
        250,
        250
      ],
      springgreen: [
        0,
        255,
        127
      ],
      steelblue: [
        70,
        130,
        180
      ],
      tan: [
        210,
        180,
        140
      ],
      teal: [
        0,
        128,
        128
      ],
      thistle: [
        216,
        191,
        216
      ],
      tomato: [
        255,
        99,
        71
      ],
      turquoise: [
        64,
        224,
        208
      ],
      violet: [
        238,
        130,
        238
      ],
      wheat: [
        245,
        222,
        179
      ],
      white: [
        255,
        255,
        255
      ],
      whitesmoke: [
        245,
        245,
        245
      ],
      yellow: [
        255,
        255,
        0
      ],
      yellowgreen: [
        154,
        205,
        50
      ]
    };
  }(_n3)), _n3;
}
var Es2;
function Fl() {
  return Es2 || (Es2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(m, n2) {
      for (var d2 in n2)
        Object.defineProperty(m, d2, {
          enumerable: true,
          get: n2[d2]
        });
    }
    a(u, {
      parseColor: function() {
        return o2;
      },
      formatColor: function() {
        return v3;
      }
    });
    const h2 = /* @__PURE__ */ p(sf());
    function p(m) {
      return m && m.__esModule ? m : {
        default: m
      };
    }
    let l3 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, f = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, s2 = /(?:\d+|\d*\.\d+)%?/, c2 = /(?:\s*,\s*|\s+)/, t10 = /\s*[,/]\s*/, e2 = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/, r2 = new RegExp(`^(rgba?)\\(\\s*(${s2.source}|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t10.source}(${s2.source}|${e2.source}))?\\s*\\)$`), i2 = new RegExp(`^(hsla?)\\(\\s*((?:${s2.source})(?:deg|rad|grad|turn)?|${e2.source})(?:${c2.source}(${s2.source}|${e2.source}))?(?:${c2.source}(${s2.source}|${e2.source}))?(?:${t10.source}(${s2.source}|${e2.source}))?\\s*\\)$`);
    function o2(m, { loose: n2 = false } = {}) {
      var d2, _4;
      if (typeof m != "string")
        return null;
      if (m = m.trim(), m === "transparent")
        return {
          mode: "rgb",
          color: [
            "0",
            "0",
            "0"
          ],
          alpha: "0"
        };
      if (m in h2.default)
        return {
          mode: "rgb",
          color: h2.default[m].map((O3) => O3.toString())
        };
      let w3 = m.replace(f, (O3, A, E2, b5, k4) => [
        "#",
        A,
        A,
        E2,
        E2,
        b5,
        b5,
        k4 ? k4 + k4 : ""
      ].join("")).match(l3);
      if (w3 !== null)
        return {
          mode: "rgb",
          color: [
            parseInt(w3[1], 16),
            parseInt(w3[2], 16),
            parseInt(w3[3], 16)
          ].map((O3) => O3.toString()),
          alpha: w3[4] ? (parseInt(w3[4], 16) / 255).toString() : undefined
        };
      var y2;
      let x2 = (y2 = m.match(r2)) !== null && y2 !== undefined ? y2 : m.match(i2);
      if (x2 === null)
        return null;
      let g2 = [
        x2[2],
        x2[3],
        x2[4]
      ].filter(Boolean).map((O3) => O3.toString());
      return g2.length === 2 && g2[0].startsWith("var(") ? {
        mode: x2[1],
        color: [
          g2[0]
        ],
        alpha: g2[1]
      } : !n2 && g2.length !== 3 || g2.length < 3 && !g2.some((O3) => /^var\(.*?\)$/.test(O3)) ? null : {
        mode: x2[1],
        color: g2,
        alpha: (d2 = x2[5]) === null || d2 === undefined || (_4 = d2.toString) === null || _4 === undefined ? undefined : _4.call(d2)
      };
    }
    function v3({ mode: m, color: n2, alpha: d2 }) {
      let _4 = d2 !== undefined;
      return m === "rgba" || m === "hsla" ? `${m}(${n2.join(", ")}${_4 ? `, ${d2}` : ""})` : `${m}(${n2.join(" ")}${_4 ? ` / ${d2}` : ""})`;
    }
  }(bn3)), bn3;
}
var Ts2;
function hr3() {
  return Ts2 || (Ts2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(f, s2) {
      for (var c2 in s2)
        Object.defineProperty(f, c2, {
          enumerable: true,
          get: s2[c2]
        });
    }
    a(u, {
      withAlphaValue: function() {
        return p;
      },
      default: function() {
        return l3;
      }
    });
    const h2 = Fl();
    function p(f, s2, c2) {
      if (typeof f == "function")
        return f({
          opacityValue: s2
        });
      let t10 = (0, h2.parseColor)(f, {
        loose: true
      });
      return t10 === null ? c2 : (0, h2.formatColor)({
        ...t10,
        alpha: s2
      });
    }
    function l3({ color: f, property: s2, variable: c2 }) {
      let t10 = [].concat(s2);
      if (typeof f == "function")
        return {
          [c2]: "1",
          ...Object.fromEntries(t10.map((r2) => [
            r2,
            f({
              opacityVariable: c2,
              opacityValue: `var(${c2})`
            })
          ]))
        };
      const e2 = (0, h2.parseColor)(f);
      return e2 === null ? Object.fromEntries(t10.map((r2) => [
        r2,
        f
      ])) : e2.alpha !== undefined ? Object.fromEntries(t10.map((r2) => [
        r2,
        f
      ])) : {
        [c2]: "1",
        ...Object.fromEntries(t10.map((r2) => [
          r2,
          (0, h2.formatColor)({
            ...e2,
            alpha: `var(${c2})`
          })
        ]))
      };
    }
  }(wn3)), wn3;
}
var Sn3 = {};
var xn3 = {};
var As2;
function Vi2() {
  return As2 || (As2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return h2.replace(/\\,/g, "\\2c ");
    }
  }(xn3)), xn3;
}
var On2 = {};
var kn3 = {};
var Pn3 = {};
var Cs2;
function st3() {
  return Cs2 || (Cs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "splitAtTopLevelOnly", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      let l3 = [], f = [], s2 = 0, c2 = false;
      for (let t10 = 0;t10 < h2.length; t10++) {
        let e2 = h2[t10];
        l3.length === 0 && e2 === p[0] && !c2 && (p.length === 1 || h2.slice(t10, t10 + p.length) === p) && (f.push(h2.slice(s2, t10)), s2 = t10 + p.length), c2 = c2 ? false : e2 === "\\", e2 === "(" || e2 === "[" || e2 === "{" ? l3.push(e2) : (e2 === ")" && l3[l3.length - 1] === "(" || e2 === "]" && l3[l3.length - 1] === "[" || e2 === "}" && l3[l3.length - 1] === "{") && l3.pop();
      }
      return f.push(h2.slice(s2)), f;
    }
  }(Pn3)), Pn3;
}
var Rs2;
function $l() {
  return Rs2 || (Rs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t10, e2) {
      for (var r2 in e2)
        Object.defineProperty(t10, r2, {
          enumerable: true,
          get: e2[r2]
        });
    }
    a(u, {
      parseBoxShadowValue: function() {
        return s2;
      },
      formatBoxShadowValue: function() {
        return c2;
      }
    });
    const h2 = st3();
    let p = /* @__PURE__ */ new Set([
      "inset",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]), l3 = /\ +(?![^(]*\))/g, f = /^-?(\d+|\.\d+)(.*?)$/g;
    function s2(t10) {
      return (0, h2.splitAtTopLevelOnly)(t10, ",").map((r2) => {
        let i2 = r2.trim(), o2 = {
          raw: i2
        }, v3 = i2.split(l3), m = /* @__PURE__ */ new Set;
        for (let n2 of v3)
          f.lastIndex = 0, !m.has("KEYWORD") && p.has(n2) ? (o2.keyword = n2, m.add("KEYWORD")) : f.test(n2) ? m.has("X") ? m.has("Y") ? m.has("BLUR") ? m.has("SPREAD") || (o2.spread = n2, m.add("SPREAD")) : (o2.blur = n2, m.add("BLUR")) : (o2.y = n2, m.add("Y")) : (o2.x = n2, m.add("X")) : o2.color ? (o2.unknown || (o2.unknown = []), o2.unknown.push(n2)) : o2.color = n2;
        return o2.valid = o2.x !== undefined && o2.y !== undefined, o2;
      });
    }
    function c2(t10) {
      return t10.map((e2) => e2.valid ? [
        e2.keyword,
        e2.x,
        e2.y,
        e2.blur,
        e2.spread,
        e2.color
      ].filter(Boolean).join(" ") : e2.raw).join(", ");
    }
  }(kn3)), kn3;
}
var Is2;
function vr3() {
  return Is2 || (Is2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(R3, $3) {
      for (var B3 in $3)
        Object.defineProperty(R3, B3, {
          enumerable: true,
          get: $3[B3]
        });
    }
    a(u, {
      normalize: function() {
        return t10;
      },
      normalizeAttributeSelectors: function() {
        return e2;
      },
      url: function() {
        return i2;
      },
      number: function() {
        return o2;
      },
      percentage: function() {
        return v3;
      },
      length: function() {
        return d2;
      },
      lineWidth: function() {
        return w3;
      },
      shadow: function() {
        return y2;
      },
      color: function() {
        return x2;
      },
      image: function() {
        return g2;
      },
      gradient: function() {
        return A;
      },
      position: function() {
        return b5;
      },
      familyName: function() {
        return k4;
      },
      genericName: function() {
        return M2;
      },
      absoluteSize: function() {
        return S3;
      },
      relativeSize: function() {
        return C;
      }
    });
    const h2 = Fl(), p = $l(), l3 = st3();
    let f = [
      "min",
      "max",
      "clamp",
      "calc"
    ];
    function s2(R3) {
      return f.some(($3) => new RegExp(`^${$3}\\(.*\\)`).test(R3));
    }
    const c2 = /* @__PURE__ */ new Set([
      "scroll-timeline-name",
      "timeline-scope",
      "view-timeline-name",
      "font-palette",
      "anchor-name",
      "anchor-scope",
      "position-anchor",
      "position-try-options",
      "scroll-timeline",
      "animation-timeline",
      "view-timeline",
      "position-try"
    ]);
    function t10(R3, $3 = null, B3 = true) {
      let z3 = $3 && c2.has($3.property);
      return R3.startsWith("--") && !z3 ? `var(${R3})` : R3.includes("url(") ? R3.split(/(url\(.*?\))/g).filter(Boolean).map((L3) => /^url\(.*?\)$/.test(L3) ? L3 : t10(L3, $3, false)).join("") : (R3 = R3.replace(/([^\\])_+/g, (L3, F) => F + " ".repeat(L3.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), B3 && (R3 = R3.trim()), R3 = r2(R3), R3);
    }
    function e2(R3) {
      return R3.includes("=") && (R3 = R3.replace(/(=.*)/g, ($3, B3) => {
        if (B3[1] === "'" || B3[1] === '"')
          return B3;
        if (B3.length > 2) {
          let z3 = B3[B3.length - 1];
          if (B3[B3.length - 2] === " " && (z3 === "i" || z3 === "I" || z3 === "s" || z3 === "S"))
            return `="${B3.slice(1, -2)}" ${B3[B3.length - 1]}`;
        }
        return `="${B3.slice(1)}"`;
      })), R3;
    }
    function r2(R3) {
      let $3 = [
        "theme"
      ], B3 = [
        "min-content",
        "max-content",
        "fit-content",
        "safe-area-inset-top",
        "safe-area-inset-right",
        "safe-area-inset-bottom",
        "safe-area-inset-left",
        "titlebar-area-x",
        "titlebar-area-y",
        "titlebar-area-width",
        "titlebar-area-height",
        "keyboard-inset-top",
        "keyboard-inset-right",
        "keyboard-inset-bottom",
        "keyboard-inset-left",
        "keyboard-inset-width",
        "keyboard-inset-height",
        "radial-gradient",
        "linear-gradient",
        "conic-gradient",
        "repeating-radial-gradient",
        "repeating-linear-gradient",
        "repeating-conic-gradient"
      ];
      return R3.replace(/(calc|min|max|clamp)\(.+\)/g, (z3) => {
        let L3 = "";
        function F() {
          let D = L3.trimEnd();
          return D[D.length - 1];
        }
        for (let D = 0;D < z3.length; D++) {
          let I3 = function(T4) {
            return T4.split("").every((U2, j3) => z3[D + j3] === U2);
          }, N3 = function(T4) {
            let U2 = 1 / 0;
            for (let H3 of T4) {
              let V4 = z3.indexOf(H3, D);
              V4 !== -1 && V4 < U2 && (U2 = V4);
            }
            let j3 = z3.slice(D, U2);
            return D += j3.length - 1, j3;
          }, J3 = z3[D];
          if (I3("var"))
            L3 += N3([
              ")",
              ","
            ]);
          else if (B3.some((T4) => I3(T4))) {
            let T4 = B3.find((U2) => I3(U2));
            L3 += T4, D += T4.length - 1;
          } else
            $3.some((T4) => I3(T4)) ? L3 += N3([
              ")"
            ]) : I3("[") ? L3 += N3([
              "]"
            ]) : [
              "+",
              "-",
              "*",
              "/"
            ].includes(J3) && ![
              "(",
              "+",
              "-",
              "*",
              "/",
              ","
            ].includes(F()) ? L3 += ` ${J3} ` : L3 += J3;
        }
        return L3.replace(/\s+/g, " ");
      });
    }
    function i2(R3) {
      return R3.startsWith("url(");
    }
    function o2(R3) {
      return !isNaN(Number(R3)) || s2(R3);
    }
    function v3(R3) {
      return R3.endsWith("%") && o2(R3.slice(0, -1)) || s2(R3);
    }
    let n2 = `(?:${[
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px",
      "em",
      "ex",
      "ch",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vmin",
      "vmax",
      "vb",
      "vi",
      "svw",
      "svh",
      "lvw",
      "lvh",
      "dvw",
      "dvh",
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ].join("|")})`;
    function d2(R3) {
      return R3 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${n2}$`).test(R3) || s2(R3);
    }
    let _4 = /* @__PURE__ */ new Set([
      "thin",
      "medium",
      "thick"
    ]);
    function w3(R3) {
      return _4.has(R3);
    }
    function y2(R3) {
      let $3 = (0, p.parseBoxShadowValue)(t10(R3));
      for (let B3 of $3)
        if (!B3.valid)
          return false;
      return true;
    }
    function x2(R3) {
      let $3 = 0;
      return (0, l3.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t10(z3), z3.startsWith("var(") ? true : (0, h2.parseColor)(z3, {
        loose: true
      }) !== null ? ($3++, true) : false)) ? $3 > 0 : false;
    }
    function g2(R3) {
      let $3 = 0;
      return (0, l3.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t10(z3), z3.startsWith("var(") ? true : i2(z3) || A(z3) || [
        "element(",
        "image(",
        "cross-fade(",
        "image-set("
      ].some((L3) => z3.startsWith(L3)) ? ($3++, true) : false)) ? $3 > 0 : false;
    }
    let O3 = /* @__PURE__ */ new Set([
      "conic-gradient",
      "linear-gradient",
      "radial-gradient",
      "repeating-conic-gradient",
      "repeating-linear-gradient",
      "repeating-radial-gradient"
    ]);
    function A(R3) {
      R3 = t10(R3);
      for (let $3 of O3)
        if (R3.startsWith(`${$3}(`))
          return true;
      return false;
    }
    let E2 = /* @__PURE__ */ new Set([
      "center",
      "top",
      "right",
      "bottom",
      "left"
    ]);
    function b5(R3) {
      let $3 = 0;
      return (0, l3.splitAtTopLevelOnly)(R3, "_").every((z3) => (z3 = t10(z3), z3.startsWith("var(") ? true : E2.has(z3) || d2(z3) || v3(z3) ? ($3++, true) : false)) ? $3 > 0 : false;
    }
    function k4(R3) {
      let $3 = 0;
      return (0, l3.splitAtTopLevelOnly)(R3, ",").every((z3) => (z3 = t10(z3), z3.startsWith("var(") ? true : z3.includes(" ") && !/(['"])([^"']+)\1/g.test(z3) || /^\d/g.test(z3) ? false : ($3++, true))) ? $3 > 0 : false;
    }
    let q2 = /* @__PURE__ */ new Set([
      "serif",
      "sans-serif",
      "monospace",
      "cursive",
      "fantasy",
      "system-ui",
      "ui-serif",
      "ui-sans-serif",
      "ui-monospace",
      "ui-rounded",
      "math",
      "emoji",
      "fangsong"
    ]);
    function M2(R3) {
      return q2.has(R3);
    }
    let W3 = /* @__PURE__ */ new Set([
      "xx-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large"
    ]);
    function S3(R3) {
      return W3.has(R3);
    }
    let P3 = /* @__PURE__ */ new Set([
      "larger",
      "smaller"
    ]);
    function C(R3) {
      return P3.has(R3);
    }
  }(On2)), On2;
}
var En3 = {};
var Ms2;
function ji2() {
  return Ms2 || (Ms2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      if (h2 = `${h2}`, h2 === "0")
        return "0";
      if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(h2))
        return h2.replace(/^[+-]?/, (l3) => l3 === "-" ? "" : "-");
      let p = [
        "var",
        "calc",
        "min",
        "max",
        "clamp"
      ];
      for (const l3 of p)
        if (h2.includes(`${l3}(`))
          return `calc(${h2} * -1)`;
    }
  }(En3)), En3;
}
var Tn3 = {};
var Ds2;
function of() {
  return Ds2 || (Ds2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "backgroundSize", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = vr3(), h2 = st3();
    function p(l3) {
      let f = [
        "cover",
        "contain"
      ];
      return (0, h2.splitAtTopLevelOnly)(l3, ",").every((s2) => {
        let c2 = (0, h2.splitAtTopLevelOnly)(s2, "_").filter(Boolean);
        return c2.length === 1 && f.includes(c2[0]) ? true : c2.length !== 1 && c2.length !== 2 ? false : c2.every((t10) => (0, a.length)(t10) || (0, a.percentage)(t10) || t10 === "auto");
      });
    }
  }(Tn3)), Tn3;
}
var An3 = {};
var Cn3 = {};
var qs2;
function tt3() {
  return qs2 || (qs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t10, e2) {
      for (var r2 in e2)
        Object.defineProperty(t10, r2, {
          enumerable: true,
          get: e2[r2]
        });
    }
    a(u, {
      dim: function() {
        return s2;
      },
      default: function() {
        return c2;
      }
    });
    const h2 = /* @__PURE__ */ p(/* @__PURE__ */ Ti());
    function p(t10) {
      return t10 && t10.__esModule ? t10 : {
        default: t10
      };
    }
    let l3 = /* @__PURE__ */ new Set;
    function f(t10, e2, r2) {
      typeof process < "u" && process.env.JEST_WORKER_ID || r2 && l3.has(r2) || (r2 && l3.add(r2), console.warn(""), e2.forEach((i2) => console.warn(t10, "-", i2)));
    }
    function s2(t10) {
      return h2.default.dim(t10);
    }
    const c2 = {
      info(t10, e2) {
        f(h2.default.bold(h2.default.cyan("info")), ...Array.isArray(t10) ? [
          t10
        ] : [
          e2,
          t10
        ]);
      },
      warn(t10, e2) {
        f(h2.default.bold(h2.default.yellow("warn")), ...Array.isArray(t10) ? [
          t10
        ] : [
          e2,
          t10
        ]);
      },
      risk(t10, e2) {
        f(h2.default.bold(h2.default.magenta("risk")), ...Array.isArray(t10) ? [
          t10
        ] : [
          e2,
          t10
        ]);
      }
    };
  }(Cn3)), Cn3;
}
var Ls2;
function it3() {
  return Ls2 || (Ls2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(i2, o2) {
      for (var v3 in o2)
        Object.defineProperty(i2, v3, {
          enumerable: true,
          get: o2[v3]
        });
    }
    a(u, {
      flagEnabled: function() {
        return c2;
      },
      issueFlagNotices: function() {
        return e2;
      },
      default: function() {
        return r2;
      }
    });
    const h2 = /* @__PURE__ */ l3(/* @__PURE__ */ Ti()), p = /* @__PURE__ */ l3(tt3());
    function l3(i2) {
      return i2 && i2.__esModule ? i2 : {
        default: i2
      };
    }
    let f = {
      optimizeUniversalDefaults: false,
      generalizedModifiers: true,
      disableColorOpacityUtilitiesByDefault: false,
      relativeContentPathsByDefault: false
    }, s2 = {
      future: [
        "hoverOnlyWhenSupported",
        "respectDefaultRingColorOpacity",
        "disableColorOpacityUtilitiesByDefault",
        "relativeContentPathsByDefault"
      ],
      experimental: [
        "optimizeUniversalDefaults",
        "generalizedModifiers"
      ]
    };
    function c2(i2, o2) {
      if (s2.future.includes(o2)) {
        var v3, m, n2;
        return i2.future === "all" || ((n2 = (m = i2 == null || (v3 = i2.future) === null || v3 === undefined ? undefined : v3[o2]) !== null && m !== undefined ? m : f[o2]) !== null && n2 !== undefined ? n2 : false);
      }
      if (s2.experimental.includes(o2)) {
        var d2, _4, w3;
        return i2.experimental === "all" || ((w3 = (_4 = i2 == null || (d2 = i2.experimental) === null || d2 === undefined ? undefined : d2[o2]) !== null && _4 !== undefined ? _4 : f[o2]) !== null && w3 !== undefined ? w3 : false);
      }
      return false;
    }
    function t10(i2) {
      if (i2.experimental === "all")
        return s2.experimental;
      var o2;
      return Object.keys((o2 = i2 == null ? undefined : i2.experimental) !== null && o2 !== undefined ? o2 : {}).filter((v3) => s2.experimental.includes(v3) && i2.experimental[v3]);
    }
    function e2(i2) {
      if (process.env.JEST_WORKER_ID === undefined && t10(i2).length > 0) {
        let o2 = t10(i2).map((v3) => h2.default.yellow(v3)).join(", ");
        p.default.warn("experimental-flags-enabled", [
          `You have enabled experimental features: ${o2}`,
          "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."
        ]);
      }
    }
    const r2 = s2;
  }(An3)), An3;
}
var Ns2;
function gr3() {
  return Ns2 || (Ns2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(b5, k4) {
      for (var q2 in k4)
        Object.defineProperty(b5, q2, {
          enumerable: true,
          get: k4[q2]
        });
    }
    a(u, {
      updateAllClasses: function() {
        return e2;
      },
      asValue: function() {
        return o2;
      },
      parseColorFormat: function() {
        return n2;
      },
      asColor: function() {
        return _4;
      },
      asLookupValue: function() {
        return w3;
      },
      typeMap: function() {
        return x2;
      },
      coerceValue: function() {
        return A;
      },
      getMatchingTypes: function() {
        return E2;
      }
    });
    const h2 = /* @__PURE__ */ t10(Vi2()), p = hr3(), l3 = vr3(), f = /* @__PURE__ */ t10(ji2()), s2 = of(), c2 = it3();
    function t10(b5) {
      return b5 && b5.__esModule ? b5 : {
        default: b5
      };
    }
    function e2(b5, k4) {
      b5.walkClasses((q2) => {
        q2.value = k4(q2.value), q2.raws && q2.raws.value && (q2.raws.value = (0, h2.default)(q2.raws.value));
      });
    }
    function r2(b5, k4) {
      if (!v3(b5))
        return;
      let q2 = b5.slice(1, -1);
      if (k4(q2))
        return (0, l3.normalize)(q2);
    }
    function i2(b5, k4 = {}, q2) {
      let M2 = k4[b5];
      if (M2 !== undefined)
        return (0, f.default)(M2);
      if (v3(b5)) {
        let W3 = r2(b5, q2);
        return W3 === undefined ? undefined : (0, f.default)(W3);
      }
    }
    function o2(b5, k4 = {}, { validate: q2 = () => true } = {}) {
      var M2;
      let W3 = (M2 = k4.values) === null || M2 === undefined ? undefined : M2[b5];
      return W3 !== undefined ? W3 : k4.supportsNegativeValues && b5.startsWith("-") ? i2(b5.slice(1), k4.values, q2) : r2(b5, q2);
    }
    function v3(b5) {
      return b5.startsWith("[") && b5.endsWith("]");
    }
    function m(b5) {
      let k4 = b5.lastIndexOf("/"), q2 = b5.lastIndexOf("[", k4), M2 = b5.indexOf("]", k4);
      return b5[k4 - 1] === "]" || b5[k4 + 1] === "[" || q2 !== -1 && M2 !== -1 && q2 < k4 && k4 < M2 && (k4 = b5.lastIndexOf("/", q2)), k4 === -1 || k4 === b5.length - 1 ? [
        b5,
        undefined
      ] : v3(b5) && !b5.includes("]/[") ? [
        b5,
        undefined
      ] : [
        b5.slice(0, k4),
        b5.slice(k4 + 1)
      ];
    }
    function n2(b5) {
      if (typeof b5 == "string" && b5.includes("<alpha-value>")) {
        let k4 = b5;
        return ({ opacityValue: q2 = 1 }) => k4.replace(/<alpha-value>/g, q2);
      }
      return b5;
    }
    function d2(b5) {
      return (0, l3.normalize)(b5.slice(1, -1));
    }
    function _4(b5, k4 = {}, { tailwindConfig: q2 = {} } = {}) {
      var M2;
      if (((M2 = k4.values) === null || M2 === undefined ? undefined : M2[b5]) !== undefined) {
        var W3;
        return n2((W3 = k4.values) === null || W3 === undefined ? undefined : W3[b5]);
      }
      let [S3, P3] = m(b5);
      if (P3 !== undefined) {
        var C, R3, $3, B3;
        let z3 = (B3 = (C = k4.values) === null || C === undefined ? undefined : C[S3]) !== null && B3 !== undefined ? B3 : v3(S3) ? S3.slice(1, -1) : undefined;
        return z3 === undefined ? undefined : (z3 = n2(z3), v3(P3) ? (0, p.withAlphaValue)(z3, d2(P3)) : ((R3 = q2.theme) === null || R3 === undefined || ($3 = R3.opacity) === null || $3 === undefined ? undefined : $3[P3]) === undefined ? undefined : (0, p.withAlphaValue)(z3, q2.theme.opacity[P3]));
      }
      return o2(b5, k4, {
        validate: l3.color
      });
    }
    function w3(b5, k4 = {}) {
      var q2;
      return (q2 = k4.values) === null || q2 === undefined ? undefined : q2[b5];
    }
    function y2(b5) {
      return (k4, q2) => o2(k4, q2, {
        validate: b5
      });
    }
    let x2 = {
      any: o2,
      color: _4,
      url: y2(l3.url),
      image: y2(l3.image),
      length: y2(l3.length),
      percentage: y2(l3.percentage),
      position: y2(l3.position),
      lookup: w3,
      "generic-name": y2(l3.genericName),
      "family-name": y2(l3.familyName),
      number: y2(l3.number),
      "line-width": y2(l3.lineWidth),
      "absolute-size": y2(l3.absoluteSize),
      "relative-size": y2(l3.relativeSize),
      shadow: y2(l3.shadow),
      size: y2(s2.backgroundSize)
    }, g2 = Object.keys(x2);
    function O3(b5, k4) {
      let q2 = b5.indexOf(k4);
      return q2 === -1 ? [
        undefined,
        b5
      ] : [
        b5.slice(0, q2),
        b5.slice(q2 + 1)
      ];
    }
    function A(b5, k4, q2, M2) {
      if (q2.values && k4 in q2.values)
        for (let { type: S3 } of b5 ?? []) {
          let P3 = x2[S3](k4, q2, {
            tailwindConfig: M2
          });
          if (P3 !== undefined)
            return [
              P3,
              S3,
              null
            ];
        }
      if (v3(k4)) {
        let S3 = k4.slice(1, -1), [P3, C] = O3(S3, ":");
        if (!/^[\w-_]+$/g.test(P3))
          C = S3;
        else if (P3 !== undefined && !g2.includes(P3))
          return [];
        if (C.length > 0 && g2.includes(P3))
          return [
            o2(`[${C}]`, q2),
            P3,
            null
          ];
      }
      let W3 = E2(b5, k4, q2, M2);
      for (let S3 of W3)
        return S3;
      return [];
    }
    function* E2(b5, k4, q2, M2) {
      let W3 = (0, c2.flagEnabled)(M2, "generalizedModifiers"), [S3, P3] = m(k4);
      if (W3 && q2.modifiers != null && (q2.modifiers === "any" || typeof q2.modifiers == "object" && (P3 && v3(P3) || (P3 in q2.modifiers))) || (S3 = k4, P3 = undefined), P3 !== undefined && S3 === "" && (S3 = "DEFAULT"), P3 !== undefined && typeof q2.modifiers == "object") {
        var R3, $3;
        let B3 = ($3 = (R3 = q2.modifiers) === null || R3 === undefined ? undefined : R3[P3]) !== null && $3 !== undefined ? $3 : null;
        B3 !== null ? P3 = B3 : v3(P3) && (P3 = d2(P3));
      }
      for (let { type: B3 } of b5 ?? []) {
        let z3 = x2[B3](S3, q2, {
          tailwindConfig: M2
        });
        z3 !== undefined && (yield [
          z3,
          B3,
          P3 ?? null
        ]);
      }
    }
  }(Sn3)), Sn3;
}
var Fs2;
function lf() {
  return Fs2 || (Fs2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return E2;
      }
    });
    const a = /* @__PURE__ */ i2(Nl()), h2 = /* @__PURE__ */ i2(Zu2()), p = /* @__PURE__ */ i2(pr3()), l3 = /* @__PURE__ */ i2(af()), f = Ui2(), s2 = /* @__PURE__ */ i2(zi2()), c2 = Wi2(), t10 = hr3(), e2 = gr3(), r2 = /* @__PURE__ */ i2(tt3());
    function i2(b5) {
      return b5 && b5.__esModule ? b5 : {
        default: b5
      };
    }
    function o2(b5) {
      return typeof b5 == "object" && b5 !== null;
    }
    function v3(b5, k4) {
      let q2 = (0, c2.toPath)(k4);
      do
        if (q2.pop(), (0, a.default)(b5, q2) !== undefined)
          break;
      while (q2.length);
      return q2.length ? q2 : undefined;
    }
    function m(b5) {
      return typeof b5 == "string" ? b5 : b5.reduce((k4, q2, M2) => q2.includes(".") ? `${k4}[${q2}]` : M2 === 0 ? q2 : `${k4}.${q2}`, "");
    }
    function n2(b5) {
      return b5.map((k4) => `'${k4}'`).join(", ");
    }
    function d2(b5) {
      return n2(Object.keys(b5));
    }
    function _4(b5, k4, q2, M2 = {}) {
      const W3 = Array.isArray(k4) ? m(k4) : k4.replace(/^['"]+|['"]+$/g, ""), S3 = Array.isArray(k4) ? k4 : (0, c2.toPath)(W3), P3 = (0, a.default)(b5.theme, S3, q2);
      if (P3 === undefined) {
        let R3 = `'${W3}' does not exist in your theme config.`;
        const $3 = S3.slice(0, -1), B3 = (0, a.default)(b5.theme, $3);
        if (o2(B3)) {
          const z3 = Object.keys(B3).filter((F) => _4(b5, [
            ...$3,
            F
          ]).isValid), L3 = (0, h2.default)(S3[S3.length - 1], z3);
          L3 ? R3 += ` Did you mean '${m([
            ...$3,
            L3
          ])}'?` : z3.length > 0 && (R3 += ` '${m($3)}' has the following valid keys: ${n2(z3)}`);
        } else {
          const z3 = v3(b5.theme, W3);
          if (z3) {
            const L3 = (0, a.default)(b5.theme, z3);
            o2(L3) ? R3 += ` '${m(z3)}' has the following keys: ${d2(L3)}` : R3 += ` '${m(z3)}' is not an object.`;
          } else
            R3 += ` Your theme has the following top-level keys: ${d2(b5.theme)}`;
        }
        return {
          isValid: false,
          error: R3
        };
      }
      if (!(typeof P3 == "string" || typeof P3 == "number" || typeof P3 == "function" || P3 instanceof String || P3 instanceof Number || Array.isArray(P3))) {
        let R3 = `'${W3}' was found but does not resolve to a string.`;
        if (o2(P3)) {
          let $3 = Object.keys(P3).filter((B3) => _4(b5, [
            ...S3,
            B3
          ]).isValid);
          $3.length && (R3 += ` Did you mean something like '${m([
            ...S3,
            $3[0]
          ])}'?`);
        }
        return {
          isValid: false,
          error: R3
        };
      }
      const [C] = S3;
      return {
        isValid: true,
        value: (0, p.default)(C)(P3, M2)
      };
    }
    function w3(b5, k4, q2) {
      k4 = k4.map((W3) => y2(b5, W3, q2));
      let M2 = [
        ""
      ];
      for (let W3 of k4)
        W3.type === "div" && W3.value === "," ? M2.push("") : M2[M2.length - 1] += l3.default.stringify(W3);
      return M2;
    }
    function y2(b5, k4, q2) {
      if (k4.type === "function" && q2[k4.value] !== undefined) {
        let M2 = w3(b5, k4.nodes, q2);
        k4.type = "word", k4.value = q2[k4.value](b5, ...M2);
      }
      return k4;
    }
    function x2(b5, k4, q2) {
      return Object.keys(q2).some((W3) => k4.includes(`${W3}(`)) ? (0, l3.default)(k4).walk((W3) => {
        y2(b5, W3, q2);
      }).toString() : k4;
    }
    let g2 = {
      atrule: "params",
      decl: "value"
    };
    function* O3(b5) {
      b5 = b5.replace(/^['"]+|['"]+$/g, "");
      let k4 = b5.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), q2;
      yield [
        b5,
        undefined
      ], k4 && (b5 = k4[1], q2 = k4[2], yield [
        b5,
        q2
      ]);
    }
    function A(b5, k4, q2) {
      const M2 = Array.from(O3(k4)).map(([S3, P3]) => Object.assign(_4(b5, S3, q2, {
        opacityValue: P3
      }), {
        resolvedPath: S3,
        alpha: P3
      }));
      var W3;
      return (W3 = M2.find((S3) => S3.isValid)) !== null && W3 !== undefined ? W3 : M2[0];
    }
    function E2(b5) {
      let k4 = b5.tailwindConfig, q2 = {
        theme: (M2, W3, ...S3) => {
          let { isValid: P3, value: C, error: R3, alpha: $3 } = A(k4, W3, S3.length ? S3 : undefined);
          if (!P3) {
            var B3;
            let F = M2.parent, D = (B3 = F == null ? undefined : F.raws.tailwind) === null || B3 === undefined ? undefined : B3.candidate;
            if (F && D !== undefined) {
              b5.markInvalidUtilityNode(F), F.remove(), r2.default.warn("invalid-theme-key-in-class", [
                `The utility \`${D}\` contains an invalid theme value and was not generated.`
              ]);
              return;
            }
            throw M2.error(R3);
          }
          let z3 = (0, e2.parseColorFormat)(C);
          return ($3 !== undefined || z3 !== undefined && typeof z3 == "function") && ($3 === undefined && ($3 = 1), C = (0, t10.withAlphaValue)(z3, $3, z3)), C;
        },
        screen: (M2, W3) => {
          W3 = W3.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
          let P3 = (0, f.normalizeScreens)(k4.theme.screens).find(({ name: C }) => C === W3);
          if (!P3)
            throw M2.error(`The '${W3}' screen does not exist in your theme.`);
          return (0, s2.default)(P3);
        }
      };
      return (M2) => {
        M2.walk((W3) => {
          let S3 = g2[W3.type];
          S3 !== undefined && (W3[S3] = x2(W3, W3[S3], q2));
        });
      };
    }
  }(sn2)), sn2;
}
var uf = lf();
var ff = /* @__PURE__ */ He3(uf);
var Rn3 = {};
var Nt3 = { exports: {} };
var Ft2 = { exports: {} };
var $t3 = { exports: {} };
var Ut3 = { exports: {} };
var zt3 = { exports: {} };
var Wt3 = { exports: {} };
var Qe3 = {};
var Vt3 = { exports: {} };
var $s;
function Bi2() {
  return $s || ($s = 1, function(u, a) {
    a.__esModule = true, a.default = l3;
    function h2(f) {
      for (var s2 = f.toLowerCase(), c2 = "", t10 = false, e2 = 0;e2 < 6 && s2[e2] !== undefined; e2++) {
        var r2 = s2.charCodeAt(e2), i2 = r2 >= 97 && r2 <= 102 || r2 >= 48 && r2 <= 57;
        if (t10 = r2 === 32, !i2)
          break;
        c2 += s2[e2];
      }
      if (c2.length !== 0) {
        var o2 = parseInt(c2, 16), v3 = o2 >= 55296 && o2 <= 57343;
        return v3 || o2 === 0 || o2 > 1114111 ? ["\uFFFD", c2.length + (t10 ? 1 : 0)] : [String.fromCodePoint(o2), c2.length + (t10 ? 1 : 0)];
      }
    }
    var p = /\\/;
    function l3(f) {
      var s2 = p.test(f);
      if (!s2)
        return f;
      for (var c2 = "", t10 = 0;t10 < f.length; t10++) {
        if (f[t10] === "\\") {
          var e2 = h2(f.slice(t10 + 1, t10 + 7));
          if (e2 !== undefined) {
            c2 += e2[0], t10 += e2[1];
            continue;
          }
          if (f[t10 + 1] === "\\") {
            c2 += "\\", t10++;
            continue;
          }
          f.length === t10 + 1 && (c2 += f[t10]);
          continue;
        }
        c2 += f[t10];
      }
      return c2;
    }
    u.exports = a.default;
  }(Vt3, Vt3.exports)), Vt3.exports;
}
var jt3 = { exports: {} };
var Us2;
function cf() {
  return Us2 || (Us2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = arguments.length, f = new Array(l3 > 1 ? l3 - 1 : 0), s2 = 1;s2 < l3; s2++)
        f[s2 - 1] = arguments[s2];
      for (;f.length > 0; ) {
        var c2 = f.shift();
        if (!p[c2])
          return;
        p = p[c2];
      }
      return p;
    }
    u.exports = a.default;
  }(jt3, jt3.exports)), jt3.exports;
}
var Bt3 = { exports: {} };
var zs2;
function df() {
  return zs2 || (zs2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = arguments.length, f = new Array(l3 > 1 ? l3 - 1 : 0), s2 = 1;s2 < l3; s2++)
        f[s2 - 1] = arguments[s2];
      for (;f.length > 0; ) {
        var c2 = f.shift();
        p[c2] || (p[c2] = {}), p = p[c2];
      }
    }
    u.exports = a.default;
  }(Bt3, Bt3.exports)), Bt3.exports;
}
var Gt3 = { exports: {} };
var Ws2;
function pf() {
  return Ws2 || (Ws2 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      for (var l3 = "", f = p.indexOf("/*"), s2 = 0;f >= 0; ) {
        l3 = l3 + p.slice(s2, f);
        var c2 = p.indexOf("*/", f + 2);
        if (c2 < 0)
          return l3;
        s2 = c2 + 2, f = p.indexOf("/*", s2);
      }
      return l3 = l3 + p.slice(s2), l3;
    }
    u.exports = a.default;
  }(Gt3, Gt3.exports)), Gt3.exports;
}
var Vs2;
function mr3() {
  if (Vs2)
    return Qe3;
  Vs2 = 1, Qe3.__esModule = true, Qe3.unesc = Qe3.stripComments = Qe3.getProp = Qe3.ensureObject = undefined;
  var u = l3(Bi2());
  Qe3.unesc = u.default;
  var a = l3(cf());
  Qe3.getProp = a.default;
  var h2 = l3(df());
  Qe3.ensureObject = h2.default;
  var p = l3(pf());
  Qe3.stripComments = p.default;
  function l3(f) {
    return f && f.__esModule ? f : { default: f };
  }
  return Qe3;
}
var js2;
function rt3() {
  return js2 || (js2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = mr3();
    function p(c2, t10) {
      for (var e2 = 0;e2 < t10.length; e2++) {
        var r2 = t10[e2];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(c2, r2.key, r2);
      }
    }
    function l3(c2, t10, e2) {
      return t10 && p(c2.prototype, t10), Object.defineProperty(c2, "prototype", { writable: false }), c2;
    }
    var f = function c(t10, e2) {
      if (typeof t10 != "object" || t10 === null)
        return t10;
      var r2 = new t10.constructor;
      for (var i2 in t10)
        if (t10.hasOwnProperty(i2)) {
          var o2 = t10[i2], v3 = typeof o2;
          i2 === "parent" && v3 === "object" ? e2 && (r2[i2] = e2) : o2 instanceof Array ? r2[i2] = o2.map(function(m) {
            return c(m, r2);
          }) : r2[i2] = c(o2, r2);
        }
      return r2;
    }, s2 = /* @__PURE__ */ function() {
      function c2(e2) {
        e2 === undefined && (e2 = {}), Object.assign(this, e2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
      }
      var t10 = c2.prototype;
      return t10.remove = function() {
        return this.parent && this.parent.removeChild(this), this.parent = undefined, this;
      }, t10.replaceWith = function() {
        if (this.parent) {
          for (var r2 in arguments)
            this.parent.insertBefore(this, arguments[r2]);
          this.remove();
        }
        return this;
      }, t10.next = function() {
        return this.parent.at(this.parent.index(this) + 1);
      }, t10.prev = function() {
        return this.parent.at(this.parent.index(this) - 1);
      }, t10.clone = function(r2) {
        r2 === undefined && (r2 = {});
        var i2 = f(this);
        for (var o2 in r2)
          i2[o2] = r2[o2];
        return i2;
      }, t10.appendToPropertyAndEscape = function(r2, i2, o2) {
        this.raws || (this.raws = {});
        var v3 = this[r2], m = this.raws[r2];
        this[r2] = v3 + i2, m || o2 !== i2 ? this.raws[r2] = (m || v3) + o2 : delete this.raws[r2];
      }, t10.setPropertyAndEscape = function(r2, i2, o2) {
        this.raws || (this.raws = {}), this[r2] = i2, this.raws[r2] = o2;
      }, t10.setPropertyWithoutEscape = function(r2, i2) {
        this[r2] = i2, this.raws && delete this.raws[r2];
      }, t10.isAtPosition = function(r2, i2) {
        if (this.source && this.source.start && this.source.end)
          return !(this.source.start.line > r2 || this.source.end.line < r2 || this.source.start.line === r2 && this.source.start.column > i2 || this.source.end.line === r2 && this.source.end.column < i2);
      }, t10.stringifyProperty = function(r2) {
        return this.raws && this.raws[r2] || this[r2];
      }, t10.valueToString = function() {
        return String(this.stringifyProperty("value"));
      }, t10.toString = function() {
        return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
      }, l3(c2, [{
        key: "rawSpaceBefore",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.before;
          return r2 === undefined && (r2 = this.spaces && this.spaces.before), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = r2;
        }
      }, {
        key: "rawSpaceAfter",
        get: function() {
          var r2 = this.raws && this.raws.spaces && this.raws.spaces.after;
          return r2 === undefined && (r2 = this.spaces.after), r2 || "";
        },
        set: function(r2) {
          (0, h2.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = r2;
        }
      }]), c2;
    }();
    a.default = s2, u.exports = a.default;
  }(Wt3, Wt3.exports)), Wt3.exports;
}
var Me3 = {};
var Bs2;
function $e2() {
  if (Bs2)
    return Me3;
  Bs2 = 1, Me3.__esModule = true, Me3.UNIVERSAL = Me3.TAG = Me3.STRING = Me3.SELECTOR = Me3.ROOT = Me3.PSEUDO = Me3.NESTING = Me3.ID = Me3.COMMENT = Me3.COMBINATOR = Me3.CLASS = Me3.ATTRIBUTE = undefined;
  var u = "tag";
  Me3.TAG = u;
  var a = "string";
  Me3.STRING = a;
  var h2 = "selector";
  Me3.SELECTOR = h2;
  var p = "root";
  Me3.ROOT = p;
  var l3 = "pseudo";
  Me3.PSEUDO = l3;
  var f = "nesting";
  Me3.NESTING = f;
  var s2 = "id";
  Me3.ID = s2;
  var c2 = "comment";
  Me3.COMMENT = c2;
  var t10 = "combinator";
  Me3.COMBINATOR = t10;
  var e2 = "class";
  Me3.CLASS = e2;
  var r2 = "attribute";
  Me3.ATTRIBUTE = r2;
  var i2 = "universal";
  return Me3.UNIVERSAL = i2, Me3;
}
var Gs2;
function Gi2() {
  return Gs2 || (Gs2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(rt3()), p = f($e2());
    function l3(n2) {
      if (typeof WeakMap != "function")
        return null;
      var d2 = /* @__PURE__ */ new WeakMap, _4 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(y2) {
        return y2 ? _4 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _4 = l3(d2);
      if (_4 && _4.has(n2))
        return _4.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x2 in n2)
        if (x2 !== "default" && Object.prototype.hasOwnProperty.call(n2, x2)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x2) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x2, g2) : w3[x2] = n2[x2];
        }
      return w3.default = n2, _4 && _4.set(n2, w3), w3;
    }
    function s2(n2) {
      return n2 && n2.__esModule ? n2 : { default: n2 };
    }
    function c2(n2, d2) {
      var _4 = typeof Symbol < "u" && n2[Symbol.iterator] || n2["@@iterator"];
      if (_4)
        return (_4 = _4.call(n2)).next.bind(_4);
      if (Array.isArray(n2) || (_4 = t10(n2)) || d2) {
        _4 && (n2 = _4);
        var w3 = 0;
        return function() {
          return w3 >= n2.length ? { done: true } : { done: false, value: n2[w3++] };
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    function t10(n2, d2) {
      if (n2) {
        if (typeof n2 == "string")
          return e2(n2, d2);
        var _4 = Object.prototype.toString.call(n2).slice(8, -1);
        if (_4 === "Object" && n2.constructor && (_4 = n2.constructor.name), _4 === "Map" || _4 === "Set")
          return Array.from(n2);
        if (_4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_4))
          return e2(n2, d2);
      }
    }
    function e2(n2, d2) {
      (d2 == null || d2 > n2.length) && (d2 = n2.length);
      for (var _4 = 0, w3 = new Array(d2);_4 < d2; _4++)
        w3[_4] = n2[_4];
      return w3;
    }
    function r2(n2, d2) {
      for (var _4 = 0;_4 < d2.length; _4++) {
        var w3 = d2[_4];
        w3.enumerable = w3.enumerable || false, w3.configurable = true, "value" in w3 && (w3.writable = true), Object.defineProperty(n2, w3.key, w3);
      }
    }
    function i2(n2, d2, _4) {
      return d2 && r2(n2.prototype, d2), Object.defineProperty(n2, "prototype", { writable: false }), n2;
    }
    function o2(n2, d2) {
      n2.prototype = Object.create(d2.prototype), n2.prototype.constructor = n2, v3(n2, d2);
    }
    function v3(n2, d2) {
      return v3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w3, y2) {
        return w3.__proto__ = y2, w3;
      }, v3(n2, d2);
    }
    var m = /* @__PURE__ */ function(n2) {
      o2(d2, n2);
      function d2(w3) {
        var y2;
        return y2 = n2.call(this, w3) || this, y2.nodes || (y2.nodes = []), y2;
      }
      var _4 = d2.prototype;
      return _4.append = function(y2) {
        return y2.parent = this, this.nodes.push(y2), this;
      }, _4.prepend = function(y2) {
        return y2.parent = this, this.nodes.unshift(y2), this;
      }, _4.at = function(y2) {
        return this.nodes[y2];
      }, _4.index = function(y2) {
        return typeof y2 == "number" ? y2 : this.nodes.indexOf(y2);
      }, _4.removeChild = function(y2) {
        y2 = this.index(y2), this.at(y2).parent = undefined, this.nodes.splice(y2, 1);
        var x2;
        for (var g2 in this.indexes)
          x2 = this.indexes[g2], x2 >= y2 && (this.indexes[g2] = x2 - 1);
        return this;
      }, _4.removeAll = function() {
        for (var y2 = c2(this.nodes), x2;!(x2 = y2()).done; ) {
          var g2 = x2.value;
          g2.parent = undefined;
        }
        return this.nodes = [], this;
      }, _4.empty = function() {
        return this.removeAll();
      }, _4.insertAfter = function(y2, x2) {
        x2.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2 + 1, 0, x2), x2.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], g2 <= O3 && (this.indexes[A] = O3 + 1);
        return this;
      }, _4.insertBefore = function(y2, x2) {
        x2.parent = this;
        var g2 = this.index(y2);
        this.nodes.splice(g2, 0, x2), x2.parent = this;
        var O3;
        for (var A in this.indexes)
          O3 = this.indexes[A], O3 <= g2 && (this.indexes[A] = O3 + 1);
        return this;
      }, _4._findChildAtPosition = function(y2, x2) {
        var g2 = undefined;
        return this.each(function(O3) {
          if (O3.atPosition) {
            var A = O3.atPosition(y2, x2);
            if (A)
              return g2 = A, false;
          } else if (O3.isAtPosition(y2, x2))
            return g2 = O3, false;
        }), g2;
      }, _4.atPosition = function(y2, x2) {
        if (this.isAtPosition(y2, x2))
          return this._findChildAtPosition(y2, x2) || this;
      }, _4._inferEndPosition = function() {
        this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
      }, _4.each = function(y2) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var x2 = this.lastEach;
        if (this.indexes[x2] = 0, !!this.length) {
          for (var g2, O3;this.indexes[x2] < this.length && (g2 = this.indexes[x2], O3 = y2(this.at(g2), g2), O3 !== false); )
            this.indexes[x2] += 1;
          if (delete this.indexes[x2], O3 === false)
            return false;
        }
      }, _4.walk = function(y2) {
        return this.each(function(x2, g2) {
          var O3 = y2(x2, g2);
          if (O3 !== false && x2.length && (O3 = x2.walk(y2)), O3 === false)
            return false;
        });
      }, _4.walkAttributes = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.ATTRIBUTE)
            return y2.call(x2, g2);
        });
      }, _4.walkClasses = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.CLASS)
            return y2.call(x2, g2);
        });
      }, _4.walkCombinators = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMBINATOR)
            return y2.call(x2, g2);
        });
      }, _4.walkComments = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.COMMENT)
            return y2.call(x2, g2);
        });
      }, _4.walkIds = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.ID)
            return y2.call(x2, g2);
        });
      }, _4.walkNesting = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.NESTING)
            return y2.call(x2, g2);
        });
      }, _4.walkPseudos = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.PSEUDO)
            return y2.call(x2, g2);
        });
      }, _4.walkTags = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.TAG)
            return y2.call(x2, g2);
        });
      }, _4.walkUniversals = function(y2) {
        var x2 = this;
        return this.walk(function(g2) {
          if (g2.type === p.UNIVERSAL)
            return y2.call(x2, g2);
        });
      }, _4.split = function(y2) {
        var x2 = this, g2 = [];
        return this.reduce(function(O3, A, E2) {
          var b5 = y2.call(x2, A);
          return g2.push(A), b5 ? (O3.push(g2), g2 = []) : E2 === x2.length - 1 && O3.push(g2), O3;
        }, []);
      }, _4.map = function(y2) {
        return this.nodes.map(y2);
      }, _4.reduce = function(y2, x2) {
        return this.nodes.reduce(y2, x2);
      }, _4.every = function(y2) {
        return this.nodes.every(y2);
      }, _4.some = function(y2) {
        return this.nodes.some(y2);
      }, _4.filter = function(y2) {
        return this.nodes.filter(y2);
      }, _4.sort = function(y2) {
        return this.nodes.sort(y2);
      }, _4.toString = function() {
        return this.map(String).join("");
      }, i2(d2, [{
        key: "first",
        get: function() {
          return this.at(0);
        }
      }, {
        key: "last",
        get: function() {
          return this.at(this.length - 1);
        }
      }, {
        key: "length",
        get: function() {
          return this.nodes.length;
        }
      }]), d2;
    }(h2.default);
    a.default = m, u.exports = a.default;
  }(zt3, zt3.exports)), zt3.exports;
}
var Ys2;
function Ul() {
  return Ys2 || (Ys2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Gi2()), p = $e2();
    function l3(r2) {
      return r2 && r2.__esModule ? r2 : { default: r2 };
    }
    function f(r2, i2) {
      for (var o2 = 0;o2 < i2.length; o2++) {
        var v3 = i2[o2];
        v3.enumerable = v3.enumerable || false, v3.configurable = true, "value" in v3 && (v3.writable = true), Object.defineProperty(r2, v3.key, v3);
      }
    }
    function s2(r2, i2, o2) {
      return i2 && f(r2.prototype, i2), Object.defineProperty(r2, "prototype", { writable: false }), r2;
    }
    function c2(r2, i2) {
      r2.prototype = Object.create(i2.prototype), r2.prototype.constructor = r2, t10(r2, i2);
    }
    function t10(r2, i2) {
      return t10 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(v3, m) {
        return v3.__proto__ = m, v3;
      }, t10(r2, i2);
    }
    var e2 = /* @__PURE__ */ function(r2) {
      c2(i2, r2);
      function i2(v3) {
        var m;
        return m = r2.call(this, v3) || this, m.type = p.ROOT, m;
      }
      var o2 = i2.prototype;
      return o2.toString = function() {
        var m = this.reduce(function(n2, d2) {
          return n2.push(String(d2)), n2;
        }, []).join(",");
        return this.trailingComma ? m + "," : m;
      }, o2.error = function(m, n2) {
        return this._error ? this._error(m, n2) : new Error(m);
      }, s2(i2, [{
        key: "errorGenerator",
        set: function(m) {
          this._error = m;
        }
      }]), i2;
    }(h2.default);
    a.default = e2, u.exports = a.default;
  }(Ut3, Ut3.exports)), Ut3.exports;
}
var Yt3 = { exports: {} };
var Qs;
function zl() {
  return Qs || (Qs = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Gi2()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.SELECTOR, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Yt3, Yt3.exports)), Yt3.exports;
}
var Qt3 = { exports: {} };
var Hs2;
function Wl() {
  return Hs2 || (Hs2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(at3()), p = mr3(), l3 = s2(rt3()), f = $e2();
    function s2(o2) {
      return o2 && o2.__esModule ? o2 : { default: o2 };
    }
    function c2(o2, v3) {
      for (var m = 0;m < v3.length; m++) {
        var n2 = v3[m];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(o2, n2.key, n2);
      }
    }
    function t10(o2, v3, m) {
      return v3 && c2(o2.prototype, v3), Object.defineProperty(o2, "prototype", { writable: false }), o2;
    }
    function e2(o2, v3) {
      o2.prototype = Object.create(v3.prototype), o2.prototype.constructor = o2, r2(o2, v3);
    }
    function r2(o2, v3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, d2) {
        return n2.__proto__ = d2, n2;
      }, r2(o2, v3);
    }
    var i2 = /* @__PURE__ */ function(o2) {
      e2(v3, o2);
      function v3(n2) {
        var d2;
        return d2 = o2.call(this, n2) || this, d2.type = f.CLASS, d2._constructed = true, d2;
      }
      var m = v3.prototype;
      return m.valueToString = function() {
        return "." + o2.prototype.valueToString.call(this);
      }, t10(v3, [{
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(d2) {
          if (this._constructed) {
            var _4 = (0, h2.default)(d2, {
              isIdentifier: true
            });
            _4 !== d2 ? ((0, p.ensureObject)(this, "raws"), this.raws.value = _4) : this.raws && delete this.raws.value;
          }
          this._value = d2;
        }
      }]), v3;
    }(l3.default);
    a.default = i2, u.exports = a.default;
  }(Qt3, Qt3.exports)), Qt3.exports;
}
var Ht3 = { exports: {} };
var Js;
function Vl() {
  return Js || (Js = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(rt3()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.COMMENT, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Ht3, Ht3.exports)), Ht3.exports;
}
var Jt2 = { exports: {} };
var Ks2;
function jl() {
  return Ks2 || (Ks2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(rt3()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(i2) {
        var o2;
        return o2 = t10.call(this, i2) || this, o2.type = p.ID, o2;
      }
      var r2 = e2.prototype;
      return r2.valueToString = function() {
        return "#" + t10.prototype.valueToString.call(this);
      }, e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Jt2, Jt2.exports)), Jt2.exports;
}
var Kt3 = { exports: {} };
var Xt3 = { exports: {} };
var Xs2;
function Yi2() {
  return Xs2 || (Xs2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = f(at3()), p = mr3(), l3 = f(rt3());
    function f(i2) {
      return i2 && i2.__esModule ? i2 : { default: i2 };
    }
    function s2(i2, o2) {
      for (var v3 = 0;v3 < o2.length; v3++) {
        var m = o2[v3];
        m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(i2, m.key, m);
      }
    }
    function c2(i2, o2, v3) {
      return o2 && s2(i2.prototype, o2), Object.defineProperty(i2, "prototype", { writable: false }), i2;
    }
    function t10(i2, o2) {
      i2.prototype = Object.create(o2.prototype), i2.prototype.constructor = i2, e2(i2, o2);
    }
    function e2(i2, o2) {
      return e2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(m, n2) {
        return m.__proto__ = n2, m;
      }, e2(i2, o2);
    }
    var r2 = /* @__PURE__ */ function(i2) {
      t10(o2, i2);
      function o2() {
        return i2.apply(this, arguments) || this;
      }
      var v3 = o2.prototype;
      return v3.qualifiedName = function(n2) {
        return this.namespace ? this.namespaceString + "|" + n2 : n2;
      }, v3.valueToString = function() {
        return this.qualifiedName(i2.prototype.valueToString.call(this));
      }, c2(o2, [{
        key: "namespace",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          if (n2 === true || n2 === "*" || n2 === "&") {
            this._namespace = n2, this.raws && delete this.raws.namespace;
            return;
          }
          var d2 = (0, h2.default)(n2, {
            isIdentifier: true
          });
          this._namespace = n2, d2 !== n2 ? ((0, p.ensureObject)(this, "raws"), this.raws.namespace = d2) : this.raws && delete this.raws.namespace;
        }
      }, {
        key: "ns",
        get: function() {
          return this._namespace;
        },
        set: function(n2) {
          this.namespace = n2;
        }
      }, {
        key: "namespaceString",
        get: function() {
          if (this.namespace) {
            var n2 = this.stringifyProperty("namespace");
            return n2 === true ? "" : n2;
          } else
            return "";
        }
      }]), o2;
    }(l3.default);
    a.default = r2, u.exports = a.default;
  }(Xt3, Xt3.exports)), Xt3.exports;
}
var Zs;
function Bl() {
  return Zs || (Zs = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Yi2()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.TAG, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Kt3, Kt3.exports)), Kt3.exports;
}
var Zt2 = { exports: {} };
var eo3;
function Gl() {
  return eo3 || (eo3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(rt3()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.STRING, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(Zt2, Zt2.exports)), Zt2.exports;
}
var er2 = { exports: {} };
var to3;
function Yl() {
  return to3 || (to3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Gi2()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(i2) {
        var o2;
        return o2 = t10.call(this, i2) || this, o2.type = p.PSEUDO, o2;
      }
      var r2 = e2.prototype;
      return r2.toString = function() {
        var o2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
        return [this.rawSpaceBefore, this.stringifyProperty("value"), o2, this.rawSpaceAfter].join("");
      }, e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(er2, er2.exports)), er2.exports;
}
var In3 = {};
var ro3;
function Ql() {
  return ro3 || (ro3 = 1, function(u) {
    u.__esModule = true, u.default = undefined, u.unescapeValue = d2;
    var a = s2(at3()), h2 = s2(Bi2()), p = s2(Yi2()), l3 = $e2(), f;
    function s2(g2) {
      return g2 && g2.__esModule ? g2 : { default: g2 };
    }
    function c2(g2, O3) {
      for (var A = 0;A < O3.length; A++) {
        var E2 = O3[A];
        E2.enumerable = E2.enumerable || false, E2.configurable = true, "value" in E2 && (E2.writable = true), Object.defineProperty(g2, E2.key, E2);
      }
    }
    function t10(g2, O3, A) {
      return O3 && c2(g2.prototype, O3), Object.defineProperty(g2, "prototype", { writable: false }), g2;
    }
    function e2(g2, O3) {
      g2.prototype = Object.create(O3.prototype), g2.prototype.constructor = g2, r2(g2, O3);
    }
    function r2(g2, O3) {
      return r2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(E2, b5) {
        return E2.__proto__ = b5, E2;
      }, r2(g2, O3);
    }
    var i2 = Rl(), o2 = /^('|")([^]*)\1$/, v3 = i2(function() {}, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), m = i2(function() {}, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), n2 = i2(function() {}, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
    function d2(g2) {
      var O3 = false, A = null, E2 = g2, b5 = E2.match(o2);
      return b5 && (A = b5[1], E2 = b5[2]), E2 = (0, h2.default)(E2), E2 !== g2 && (O3 = true), {
        deprecatedUsage: O3,
        unescaped: E2,
        quoteMark: A
      };
    }
    function _4(g2) {
      if (g2.quoteMark !== undefined || g2.value === undefined)
        return g2;
      n2();
      var O3 = d2(g2.value), A = O3.quoteMark, E2 = O3.unescaped;
      return g2.raws || (g2.raws = {}), g2.raws.value === undefined && (g2.raws.value = g2.value), g2.value = E2, g2.quoteMark = A, g2;
    }
    var w3 = /* @__PURE__ */ function(g2) {
      e2(O3, g2);
      function O3(E2) {
        var b5;
        return E2 === undefined && (E2 = {}), b5 = g2.call(this, _4(E2)) || this, b5.type = l3.ATTRIBUTE, b5.raws = b5.raws || {}, Object.defineProperty(b5.raws, "unquoted", {
          get: i2(function() {
            return b5.value;
          }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
          set: i2(function() {
            return b5.value;
          }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
        }), b5._constructed = true, b5;
      }
      var A = O3.prototype;
      return A.getQuotedValue = function(b5) {
        b5 === undefined && (b5 = {});
        var k4 = this._determineQuoteMark(b5), q2 = y2[k4], M2 = (0, a.default)(this._value, q2);
        return M2;
      }, A._determineQuoteMark = function(b5) {
        return b5.smart ? this.smartQuoteMark(b5) : this.preferredQuoteMark(b5);
      }, A.setValue = function(b5, k4) {
        k4 === undefined && (k4 = {}), this._value = b5, this._quoteMark = this._determineQuoteMark(k4), this._syncRawValue();
      }, A.smartQuoteMark = function(b5) {
        var k4 = this.value, q2 = k4.replace(/[^']/g, "").length, M2 = k4.replace(/[^"]/g, "").length;
        if (q2 + M2 === 0) {
          var W3 = (0, a.default)(k4, {
            isIdentifier: true
          });
          if (W3 === k4)
            return O3.NO_QUOTE;
          var S3 = this.preferredQuoteMark(b5);
          if (S3 === O3.NO_QUOTE) {
            var P3 = this.quoteMark || b5.quoteMark || O3.DOUBLE_QUOTE, C = y2[P3], R3 = (0, a.default)(k4, C);
            if (R3.length < W3.length)
              return P3;
          }
          return S3;
        } else
          return M2 === q2 ? this.preferredQuoteMark(b5) : M2 < q2 ? O3.DOUBLE_QUOTE : O3.SINGLE_QUOTE;
      }, A.preferredQuoteMark = function(b5) {
        var k4 = b5.preferCurrentQuoteMark ? this.quoteMark : b5.quoteMark;
        return k4 === undefined && (k4 = b5.preferCurrentQuoteMark ? b5.quoteMark : this.quoteMark), k4 === undefined && (k4 = O3.DOUBLE_QUOTE), k4;
      }, A._syncRawValue = function() {
        var b5 = (0, a.default)(this._value, y2[this.quoteMark]);
        b5 === this._value ? this.raws && delete this.raws.value : this.raws.value = b5;
      }, A._handleEscapes = function(b5, k4) {
        if (this._constructed) {
          var q2 = (0, a.default)(k4, {
            isIdentifier: true
          });
          q2 !== k4 ? this.raws[b5] = q2 : delete this.raws[b5];
        }
      }, A._spacesFor = function(b5) {
        var k4 = {
          before: "",
          after: ""
        }, q2 = this.spaces[b5] || {}, M2 = this.raws.spaces && this.raws.spaces[b5] || {};
        return Object.assign(k4, q2, M2);
      }, A._stringFor = function(b5, k4, q2) {
        k4 === undefined && (k4 = b5), q2 === undefined && (q2 = x2);
        var M2 = this._spacesFor(k4);
        return q2(this.stringifyProperty(b5), M2);
      }, A.offsetOf = function(b5) {
        var k4 = 1, q2 = this._spacesFor("attribute");
        if (k4 += q2.before.length, b5 === "namespace" || b5 === "ns")
          return this.namespace ? k4 : -1;
        if (b5 === "attributeNS" || (k4 += this.namespaceString.length, this.namespace && (k4 += 1), b5 === "attribute"))
          return k4;
        k4 += this.stringifyProperty("attribute").length, k4 += q2.after.length;
        var M2 = this._spacesFor("operator");
        k4 += M2.before.length;
        var W3 = this.stringifyProperty("operator");
        if (b5 === "operator")
          return W3 ? k4 : -1;
        k4 += W3.length, k4 += M2.after.length;
        var S3 = this._spacesFor("value");
        k4 += S3.before.length;
        var P3 = this.stringifyProperty("value");
        if (b5 === "value")
          return P3 ? k4 : -1;
        k4 += P3.length, k4 += S3.after.length;
        var C = this._spacesFor("insensitive");
        return k4 += C.before.length, b5 === "insensitive" && this.insensitive ? k4 : -1;
      }, A.toString = function() {
        var b5 = this, k4 = [this.rawSpaceBefore, "["];
        return k4.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (k4.push(this._stringFor("operator")), k4.push(this._stringFor("value")), k4.push(this._stringFor("insensitiveFlag", "insensitive", function(q2, M2) {
          return q2.length > 0 && !b5.quoted && M2.before.length === 0 && !(b5.spaces.value && b5.spaces.value.after) && (M2.before = " "), x2(q2, M2);
        }))), k4.push("]"), k4.push(this.rawSpaceAfter), k4.join("");
      }, t10(O3, [{
        key: "quoted",
        get: function() {
          var b5 = this.quoteMark;
          return b5 === "'" || b5 === '"';
        },
        set: function(b5) {
          m();
        }
      }, {
        key: "quoteMark",
        get: function() {
          return this._quoteMark;
        },
        set: function(b5) {
          if (!this._constructed) {
            this._quoteMark = b5;
            return;
          }
          this._quoteMark !== b5 && (this._quoteMark = b5, this._syncRawValue());
        }
      }, {
        key: "qualifiedAttribute",
        get: function() {
          return this.qualifiedName(this.raws.attribute || this.attribute);
        }
      }, {
        key: "insensitiveFlag",
        get: function() {
          return this.insensitive ? "i" : "";
        }
      }, {
        key: "value",
        get: function() {
          return this._value;
        },
        set: function(b5) {
          if (this._constructed) {
            var k4 = d2(b5), q2 = k4.deprecatedUsage, M2 = k4.unescaped, W3 = k4.quoteMark;
            if (q2 && v3(), M2 === this._value && W3 === this._quoteMark)
              return;
            this._value = M2, this._quoteMark = W3, this._syncRawValue();
          } else
            this._value = b5;
        }
      }, {
        key: "insensitive",
        get: function() {
          return this._insensitive;
        },
        set: function(b5) {
          b5 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = undefined)), this._insensitive = b5;
        }
      }, {
        key: "attribute",
        get: function() {
          return this._attribute;
        },
        set: function(b5) {
          this._handleEscapes("attribute", b5), this._attribute = b5;
        }
      }]), O3;
    }(p.default);
    u.default = w3, w3.NO_QUOTE = null, w3.SINGLE_QUOTE = "'", w3.DOUBLE_QUOTE = '"';
    var y2 = (f = {
      "'": {
        quotes: "single",
        wrap: true
      },
      '"': {
        quotes: "double",
        wrap: true
      }
    }, f[null] = {
      isIdentifier: true
    }, f);
    function x2(g2, O3) {
      return "" + O3.before + g2 + O3.after;
    }
  }(In3)), In3;
}
var tr2 = { exports: {} };
var no3;
function Hl() {
  return no3 || (no3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(Yi2()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.UNIVERSAL, i2.value = "*", i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(tr2, tr2.exports)), tr2.exports;
}
var rr3 = { exports: {} };
var io3;
function Jl() {
  return io3 || (io3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(rt3()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.COMBINATOR, i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(rr3, rr3.exports)), rr3.exports;
}
var nr3 = { exports: {} };
var ao3;
function Kl() {
  return ao3 || (ao3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = l3(rt3()), p = $e2();
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : { default: t10 };
    }
    function f(t10, e2) {
      t10.prototype = Object.create(e2.prototype), t10.prototype.constructor = t10, s2(t10, e2);
    }
    function s2(t10, e2) {
      return s2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i2, o2) {
        return i2.__proto__ = o2, i2;
      }, s2(t10, e2);
    }
    var c2 = /* @__PURE__ */ function(t10) {
      f(e2, t10);
      function e2(r2) {
        var i2;
        return i2 = t10.call(this, r2) || this, i2.type = p.NESTING, i2.value = "&", i2;
      }
      return e2;
    }(h2.default);
    a.default = c2, u.exports = a.default;
  }(nr3, nr3.exports)), nr3.exports;
}
var ir3 = { exports: {} };
var so3;
function hf() {
  return so3 || (so3 = 1, function(u, a) {
    a.__esModule = true, a.default = h2;
    function h2(p) {
      return p.sort(function(l3, f) {
        return l3 - f;
      });
    }
    u.exports = a.default;
  }(ir3, ir3.exports)), ir3.exports;
}
var Mn3 = {};
var le3 = {};
var oo3;
function Xl() {
  if (oo3)
    return le3;
  oo3 = 1, le3.__esModule = true, le3.word = le3.tilde = le3.tab = le3.str = le3.space = le3.slash = le3.singleQuote = le3.semicolon = le3.plus = le3.pipe = le3.openSquare = le3.openParenthesis = le3.newline = le3.greaterThan = le3.feed = le3.equals = le3.doubleQuote = le3.dollar = le3.cr = le3.comment = le3.comma = le3.combinator = le3.colon = le3.closeSquare = le3.closeParenthesis = le3.caret = le3.bang = le3.backslash = le3.at = le3.asterisk = le3.ampersand = undefined;
  var u = 38;
  le3.ampersand = u;
  var a = 42;
  le3.asterisk = a;
  var h2 = 64;
  le3.at = h2;
  var p = 44;
  le3.comma = p;
  var l3 = 58;
  le3.colon = l3;
  var f = 59;
  le3.semicolon = f;
  var s2 = 40;
  le3.openParenthesis = s2;
  var c2 = 41;
  le3.closeParenthesis = c2;
  var t10 = 91;
  le3.openSquare = t10;
  var e2 = 93;
  le3.closeSquare = e2;
  var r2 = 36;
  le3.dollar = r2;
  var i2 = 126;
  le3.tilde = i2;
  var o2 = 94;
  le3.caret = o2;
  var v3 = 43;
  le3.plus = v3;
  var m = 61;
  le3.equals = m;
  var n2 = 124;
  le3.pipe = n2;
  var d2 = 62;
  le3.greaterThan = d2;
  var _4 = 32;
  le3.space = _4;
  var w3 = 39;
  le3.singleQuote = w3;
  var y2 = 34;
  le3.doubleQuote = y2;
  var x2 = 47;
  le3.slash = x2;
  var g2 = 33;
  le3.bang = g2;
  var O3 = 92;
  le3.backslash = O3;
  var A = 13;
  le3.cr = A;
  var E2 = 12;
  le3.feed = E2;
  var b5 = 10;
  le3.newline = b5;
  var k4 = 9;
  le3.tab = k4;
  var q2 = w3;
  le3.str = q2;
  var M2 = -1;
  le3.comment = M2;
  var W3 = -2;
  le3.word = W3;
  var S3 = -3;
  return le3.combinator = S3, le3;
}
var lo3;
function vf() {
  return lo3 || (lo3 = 1, function(u) {
    u.__esModule = true, u.FIELDS = undefined, u.default = m;
    var a = f(Xl()), h2, p;
    function l3(n2) {
      if (typeof WeakMap != "function")
        return null;
      var d2 = /* @__PURE__ */ new WeakMap, _4 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(y2) {
        return y2 ? _4 : d2;
      })(n2);
    }
    function f(n2, d2) {
      if (n2 && n2.__esModule)
        return n2;
      if (n2 === null || typeof n2 != "object" && typeof n2 != "function")
        return { default: n2 };
      var _4 = l3(d2);
      if (_4 && _4.has(n2))
        return _4.get(n2);
      var w3 = {}, y2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var x2 in n2)
        if (x2 !== "default" && Object.prototype.hasOwnProperty.call(n2, x2)) {
          var g2 = y2 ? Object.getOwnPropertyDescriptor(n2, x2) : null;
          g2 && (g2.get || g2.set) ? Object.defineProperty(w3, x2, g2) : w3[x2] = n2[x2];
        }
      return w3.default = n2, _4 && _4.set(n2, w3), w3;
    }
    for (var s2 = (h2 = {}, h2[a.tab] = true, h2[a.newline] = true, h2[a.cr] = true, h2[a.feed] = true, h2), c2 = (p = {}, p[a.space] = true, p[a.tab] = true, p[a.newline] = true, p[a.cr] = true, p[a.feed] = true, p[a.ampersand] = true, p[a.asterisk] = true, p[a.bang] = true, p[a.comma] = true, p[a.colon] = true, p[a.semicolon] = true, p[a.openParenthesis] = true, p[a.closeParenthesis] = true, p[a.openSquare] = true, p[a.closeSquare] = true, p[a.singleQuote] = true, p[a.doubleQuote] = true, p[a.plus] = true, p[a.pipe] = true, p[a.tilde] = true, p[a.greaterThan] = true, p[a.equals] = true, p[a.dollar] = true, p[a.caret] = true, p[a.slash] = true, p), t10 = {}, e2 = "0123456789abcdefABCDEF", r2 = 0;r2 < e2.length; r2++)
      t10[e2.charCodeAt(r2)] = true;
    function i2(n2, d2) {
      var _4 = d2, w3;
      do {
        if (w3 = n2.charCodeAt(_4), c2[w3])
          return _4 - 1;
        w3 === a.backslash ? _4 = o2(n2, _4) + 1 : _4++;
      } while (_4 < n2.length);
      return _4 - 1;
    }
    function o2(n2, d2) {
      var _4 = d2, w3 = n2.charCodeAt(_4 + 1);
      if (!s2[w3])
        if (t10[w3]) {
          var y2 = 0;
          do
            _4++, y2++, w3 = n2.charCodeAt(_4 + 1);
          while (t10[w3] && y2 < 6);
          y2 < 6 && w3 === a.space && _4++;
        } else
          _4++;
      return _4;
    }
    var v3 = {
      TYPE: 0,
      START_LINE: 1,
      START_COL: 2,
      END_LINE: 3,
      END_COL: 4,
      START_POS: 5,
      END_POS: 6
    };
    u.FIELDS = v3;
    function m(n2) {
      var d2 = [], _4 = n2.css.valueOf(), w3 = _4, y2 = w3.length, x2 = -1, g2 = 1, O3 = 0, A = 0, E2, b5, k4, q2, M2, W3, S3, P3, C, R3, $3, B3, z3;
      function L3(F, D) {
        if (n2.safe)
          _4 += D, C = _4.length - 1;
        else
          throw n2.error("Unclosed " + F, g2, O3 - x2, O3);
      }
      for (;O3 < y2; ) {
        switch (E2 = _4.charCodeAt(O3), E2 === a.newline && (x2 = O3, g2 += 1), E2) {
          case a.space:
          case a.tab:
          case a.newline:
          case a.cr:
          case a.feed:
            C = O3;
            do
              C += 1, E2 = _4.charCodeAt(C), E2 === a.newline && (x2 = C, g2 += 1);
            while (E2 === a.space || E2 === a.newline || E2 === a.tab || E2 === a.cr || E2 === a.feed);
            z3 = a.space, q2 = g2, k4 = C - x2 - 1, A = C;
            break;
          case a.plus:
          case a.greaterThan:
          case a.tilde:
          case a.pipe:
            C = O3;
            do
              C += 1, E2 = _4.charCodeAt(C);
            while (E2 === a.plus || E2 === a.greaterThan || E2 === a.tilde || E2 === a.pipe);
            z3 = a.combinator, q2 = g2, k4 = O3 - x2, A = C;
            break;
          case a.asterisk:
          case a.ampersand:
          case a.bang:
          case a.comma:
          case a.equals:
          case a.dollar:
          case a.caret:
          case a.openSquare:
          case a.closeSquare:
          case a.colon:
          case a.semicolon:
          case a.openParenthesis:
          case a.closeParenthesis:
            C = O3, z3 = E2, q2 = g2, k4 = O3 - x2, A = C + 1;
            break;
          case a.singleQuote:
          case a.doubleQuote:
            B3 = E2 === a.singleQuote ? "'" : '"', C = O3;
            do
              for (M2 = false, C = _4.indexOf(B3, C + 1), C === -1 && L3("quote", B3), W3 = C;_4.charCodeAt(W3 - 1) === a.backslash; )
                W3 -= 1, M2 = !M2;
            while (M2);
            z3 = a.str, q2 = g2, k4 = O3 - x2, A = C + 1;
            break;
          default:
            E2 === a.slash && _4.charCodeAt(O3 + 1) === a.asterisk ? (C = _4.indexOf("*/", O3 + 2) + 1, C === 0 && L3("comment", "*/"), b5 = _4.slice(O3, C + 1), P3 = b5.split(`
`), S3 = P3.length - 1, S3 > 0 ? (R3 = g2 + S3, $3 = C - P3[S3].length) : (R3 = g2, $3 = x2), z3 = a.comment, g2 = R3, q2 = R3, k4 = C - $3) : E2 === a.slash ? (C = O3, z3 = E2, q2 = g2, k4 = O3 - x2, A = C + 1) : (C = i2(_4, O3), z3 = a.word, q2 = g2, k4 = C - x2), A = C + 1;
            break;
        }
        d2.push([
          z3,
          g2,
          O3 - x2,
          q2,
          k4,
          O3,
          A
        ]), $3 && (x2 = $3, $3 = null), O3 = A;
      }
      return d2;
    }
  }(Mn3)), Mn3;
}
var uo3;
function gf() {
  return uo3 || (uo3 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = A(Ul()), p = A(zl()), l3 = A(Wl()), f = A(Vl()), s2 = A(jl()), c2 = A(Bl()), t10 = A(Gl()), e2 = A(Yl()), r2 = O3(Ql()), i2 = A(Hl()), o2 = A(Jl()), v3 = A(Kl()), m = A(hf()), n2 = O3(vf()), d2 = O3(Xl()), _4 = O3($e2()), w3 = mr3(), y2, x2;
    function g2(L3) {
      if (typeof WeakMap != "function")
        return null;
      var F = /* @__PURE__ */ new WeakMap, D = /* @__PURE__ */ new WeakMap;
      return (g2 = function(N3) {
        return N3 ? D : F;
      })(L3);
    }
    function O3(L3, F) {
      if (L3 && L3.__esModule)
        return L3;
      if (L3 === null || typeof L3 != "object" && typeof L3 != "function")
        return { default: L3 };
      var D = g2(F);
      if (D && D.has(L3))
        return D.get(L3);
      var I3 = {}, N3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var J3 in L3)
        if (J3 !== "default" && Object.prototype.hasOwnProperty.call(L3, J3)) {
          var T4 = N3 ? Object.getOwnPropertyDescriptor(L3, J3) : null;
          T4 && (T4.get || T4.set) ? Object.defineProperty(I3, J3, T4) : I3[J3] = L3[J3];
        }
      return I3.default = L3, D && D.set(L3, I3), I3;
    }
    function A(L3) {
      return L3 && L3.__esModule ? L3 : { default: L3 };
    }
    function E2(L3, F) {
      for (var D = 0;D < F.length; D++) {
        var I3 = F[D];
        I3.enumerable = I3.enumerable || false, I3.configurable = true, "value" in I3 && (I3.writable = true), Object.defineProperty(L3, I3.key, I3);
      }
    }
    function b5(L3, F, D) {
      return F && E2(L3.prototype, F), Object.defineProperty(L3, "prototype", { writable: false }), L3;
    }
    var k4 = (y2 = {}, y2[d2.space] = true, y2[d2.cr] = true, y2[d2.feed] = true, y2[d2.newline] = true, y2[d2.tab] = true, y2), q2 = Object.assign({}, k4, (x2 = {}, x2[d2.comment] = true, x2));
    function M2(L3) {
      return {
        line: L3[n2.FIELDS.START_LINE],
        column: L3[n2.FIELDS.START_COL]
      };
    }
    function W3(L3) {
      return {
        line: L3[n2.FIELDS.END_LINE],
        column: L3[n2.FIELDS.END_COL]
      };
    }
    function S3(L3, F, D, I3) {
      return {
        start: {
          line: L3,
          column: F
        },
        end: {
          line: D,
          column: I3
        }
      };
    }
    function P3(L3) {
      return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], L3[n2.FIELDS.END_LINE], L3[n2.FIELDS.END_COL]);
    }
    function C(L3, F) {
      if (L3)
        return S3(L3[n2.FIELDS.START_LINE], L3[n2.FIELDS.START_COL], F[n2.FIELDS.END_LINE], F[n2.FIELDS.END_COL]);
    }
    function R3(L3, F) {
      var D = L3[F];
      if (typeof D == "string")
        return D.indexOf("\\") !== -1 && ((0, w3.ensureObject)(L3, "raws"), L3[F] = (0, w3.unesc)(D), L3.raws[F] === undefined && (L3.raws[F] = D)), L3;
    }
    function $3(L3, F) {
      for (var D = -1, I3 = [];(D = L3.indexOf(F, D + 1)) !== -1; )
        I3.push(D);
      return I3;
    }
    function B3() {
      var L3 = Array.prototype.concat.apply([], arguments);
      return L3.filter(function(F, D) {
        return D === L3.indexOf(F);
      });
    }
    var z3 = /* @__PURE__ */ function() {
      function L3(D, I3) {
        I3 === undefined && (I3 = {}), this.rule = D, this.options = Object.assign({
          lossy: false,
          safe: false
        }, I3), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, n2.default)({
          css: this.css,
          error: this._errorGenerator(),
          safe: this.options.safe
        });
        var N3 = C(this.tokens[0], this.tokens[this.tokens.length - 1]);
        this.root = new h2.default({
          source: N3
        }), this.root.errorGenerator = this._errorGenerator();
        var J3 = new p.default({
          source: {
            start: {
              line: 1,
              column: 1
            }
          },
          sourceIndex: 0
        });
        this.root.append(J3), this.current = J3, this.loop();
      }
      var F = L3.prototype;
      return F._errorGenerator = function() {
        var I3 = this;
        return function(N3, J3) {
          return typeof I3.rule == "string" ? new Error(N3) : I3.rule.error(N3, J3);
        };
      }, F.attribute = function() {
        var I3 = [], N3 = this.currToken;
        for (this.position++;this.position < this.tokens.length && this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare; )
          I3.push(this.currToken), this.position++;
        if (this.currToken[n2.FIELDS.TYPE] !== d2.closeSquare)
          return this.expected("closing square bracket", this.currToken[n2.FIELDS.START_POS]);
        var J3 = I3.length, T4 = {
          source: S3(N3[1], N3[2], this.currToken[3], this.currToken[4]),
          sourceIndex: N3[n2.FIELDS.START_POS]
        };
        if (J3 === 1 && !~[d2.word].indexOf(I3[0][n2.FIELDS.TYPE]))
          return this.expected("attribute", I3[0][n2.FIELDS.START_POS]);
        for (var U2 = 0, j3 = "", H3 = "", V4 = null, K3 = false;U2 < J3; ) {
          var X3 = I3[U2], Q3 = this.content(X3), ne4 = I3[U2 + 1];
          switch (X3[n2.FIELDS.TYPE]) {
            case d2.space:
              if (K3 = true, this.options.lossy)
                break;
              if (V4) {
                (0, w3.ensureObject)(T4, "spaces", V4);
                var de3 = T4.spaces[V4].after || "";
                T4.spaces[V4].after = de3 + Q3;
                var _e3 = (0, w3.getProp)(T4, "raws", "spaces", V4, "after") || null;
                _e3 && (T4.raws.spaces[V4].after = _e3 + Q3);
              } else
                j3 = j3 + Q3, H3 = H3 + Q3;
              break;
            case d2.asterisk:
              if (ne4[n2.FIELDS.TYPE] === d2.equals)
                T4.operator = Q3, V4 = "operator";
              else if ((!T4.namespace || V4 === "namespace" && !K3) && ne4) {
                j3 && ((0, w3.ensureObject)(T4, "spaces", "attribute"), T4.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "attribute"), T4.raws.spaces.attribute.before = j3, H3 = ""), T4.namespace = (T4.namespace || "") + Q3;
                var be3 = (0, w3.getProp)(T4, "raws", "namespace") || null;
                be3 && (T4.raws.namespace += Q3), V4 = "namespace";
              }
              K3 = false;
              break;
            case d2.dollar:
              if (V4 === "value") {
                var ie3 = (0, w3.getProp)(T4, "raws", "value");
                T4.value += "$", ie3 && (T4.raws.value = ie3 + "$");
                break;
              }
            case d2.caret:
              ne4[n2.FIELDS.TYPE] === d2.equals && (T4.operator = Q3, V4 = "operator"), K3 = false;
              break;
            case d2.combinator:
              if (Q3 === "~" && ne4[n2.FIELDS.TYPE] === d2.equals && (T4.operator = Q3, V4 = "operator"), Q3 !== "|") {
                K3 = false;
                break;
              }
              ne4[n2.FIELDS.TYPE] === d2.equals ? (T4.operator = Q3, V4 = "operator") : !T4.namespace && !T4.attribute && (T4.namespace = true), K3 = false;
              break;
            case d2.word:
              if (ne4 && this.content(ne4) === "|" && I3[U2 + 2] && I3[U2 + 2][n2.FIELDS.TYPE] !== d2.equals && !T4.operator && !T4.namespace)
                T4.namespace = Q3, V4 = "namespace";
              else if (!T4.attribute || V4 === "attribute" && !K3) {
                j3 && ((0, w3.ensureObject)(T4, "spaces", "attribute"), T4.spaces.attribute.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "attribute"), T4.raws.spaces.attribute.before = H3, H3 = ""), T4.attribute = (T4.attribute || "") + Q3;
                var ke3 = (0, w3.getProp)(T4, "raws", "attribute") || null;
                ke3 && (T4.raws.attribute += Q3), V4 = "attribute";
              } else if (!T4.value && T4.value !== "" || V4 === "value" && !(K3 || T4.quoteMark)) {
                var Y4 = (0, w3.unesc)(Q3), G3 = (0, w3.getProp)(T4, "raws", "value") || "", te2 = T4.value || "";
                T4.value = te2 + Y4, T4.quoteMark = null, (Y4 !== Q3 || G3) && ((0, w3.ensureObject)(T4, "raws"), T4.raws.value = (G3 || te2) + Q3), V4 = "value";
              } else {
                var Z3 = Q3 === "i" || Q3 === "I";
                (T4.value || T4.value === "") && (T4.quoteMark || K3) ? (T4.insensitive = Z3, (!Z3 || Q3 === "I") && ((0, w3.ensureObject)(T4, "raws"), T4.raws.insensitiveFlag = Q3), V4 = "insensitive", j3 && ((0, w3.ensureObject)(T4, "spaces", "insensitive"), T4.spaces.insensitive.before = j3, j3 = ""), H3 && ((0, w3.ensureObject)(T4, "raws", "spaces", "insensitive"), T4.raws.spaces.insensitive.before = H3, H3 = "")) : (T4.value || T4.value === "") && (V4 = "value", T4.value += Q3, T4.raws.value && (T4.raws.value += Q3));
              }
              K3 = false;
              break;
            case d2.str:
              if (!T4.attribute || !T4.operator)
                return this.error("Expected an attribute followed by an operator preceding the string.", {
                  index: X3[n2.FIELDS.START_POS]
                });
              var ee3 = (0, r2.unescapeValue)(Q3), se3 = ee3.unescaped, ue = ee3.quoteMark;
              T4.value = se3, T4.quoteMark = ue, V4 = "value", (0, w3.ensureObject)(T4, "raws"), T4.raws.value = Q3, K3 = false;
              break;
            case d2.equals:
              if (!T4.attribute)
                return this.expected("attribute", X3[n2.FIELDS.START_POS], Q3);
              if (T4.value)
                return this.error('Unexpected "=" found; an operator was already defined.', {
                  index: X3[n2.FIELDS.START_POS]
                });
              T4.operator = T4.operator ? T4.operator + Q3 : Q3, V4 = "operator", K3 = false;
              break;
            case d2.comment:
              if (V4)
                if (K3 || ne4 && ne4[n2.FIELDS.TYPE] === d2.space || V4 === "insensitive") {
                  var xe3 = (0, w3.getProp)(T4, "spaces", V4, "after") || "", ce3 = (0, w3.getProp)(T4, "raws", "spaces", V4, "after") || xe3;
                  (0, w3.ensureObject)(T4, "raws", "spaces", V4), T4.raws.spaces[V4].after = ce3 + Q3;
                } else {
                  var Te3 = T4[V4] || "", ve3 = (0, w3.getProp)(T4, "raws", V4) || Te3;
                  (0, w3.ensureObject)(T4, "raws"), T4.raws[V4] = ve3 + Q3;
                }
              else
                H3 = H3 + Q3;
              break;
            default:
              return this.error('Unexpected "' + Q3 + '" found.', {
                index: X3[n2.FIELDS.START_POS]
              });
          }
          U2++;
        }
        R3(T4, "attribute"), R3(T4, "namespace"), this.newNode(new r2.default(T4)), this.position++;
      }, F.parseWhitespaceEquivalentTokens = function(I3) {
        I3 < 0 && (I3 = this.tokens.length);
        var N3 = this.position, J3 = [], T4 = "", U2 = undefined;
        do
          if (k4[this.currToken[n2.FIELDS.TYPE]])
            this.options.lossy || (T4 += this.content());
          else if (this.currToken[n2.FIELDS.TYPE] === d2.comment) {
            var j3 = {};
            T4 && (j3.before = T4, T4 = ""), U2 = new f.default({
              value: this.content(),
              source: P3(this.currToken),
              sourceIndex: this.currToken[n2.FIELDS.START_POS],
              spaces: j3
            }), J3.push(U2);
          }
        while (++this.position < I3);
        if (T4) {
          if (U2)
            U2.spaces.after = T4;
          else if (!this.options.lossy) {
            var H3 = this.tokens[N3], V4 = this.tokens[this.position - 1];
            J3.push(new t10.default({
              value: "",
              source: S3(H3[n2.FIELDS.START_LINE], H3[n2.FIELDS.START_COL], V4[n2.FIELDS.END_LINE], V4[n2.FIELDS.END_COL]),
              sourceIndex: H3[n2.FIELDS.START_POS],
              spaces: {
                before: T4,
                after: ""
              }
            }));
          }
        }
        return J3;
      }, F.convertWhitespaceNodesToSpace = function(I3, N3) {
        var J3 = this;
        N3 === undefined && (N3 = false);
        var T4 = "", U2 = "";
        I3.forEach(function(H3) {
          var V4 = J3.lossySpace(H3.spaces.before, N3), K3 = J3.lossySpace(H3.rawSpaceBefore, N3);
          T4 += V4 + J3.lossySpace(H3.spaces.after, N3 && V4.length === 0), U2 += V4 + H3.value + J3.lossySpace(H3.rawSpaceAfter, N3 && K3.length === 0);
        }), U2 === T4 && (U2 = undefined);
        var j3 = {
          space: T4,
          rawSpace: U2
        };
        return j3;
      }, F.isNamedCombinator = function(I3) {
        return I3 === undefined && (I3 = this.position), this.tokens[I3 + 0] && this.tokens[I3 + 0][n2.FIELDS.TYPE] === d2.slash && this.tokens[I3 + 1] && this.tokens[I3 + 1][n2.FIELDS.TYPE] === d2.word && this.tokens[I3 + 2] && this.tokens[I3 + 2][n2.FIELDS.TYPE] === d2.slash;
      }, F.namedCombinator = function() {
        if (this.isNamedCombinator()) {
          var I3 = this.content(this.tokens[this.position + 1]), N3 = (0, w3.unesc)(I3).toLowerCase(), J3 = {};
          N3 !== I3 && (J3.value = "/" + I3 + "/");
          var T4 = new o2.default({
            value: "/" + N3 + "/",
            source: S3(this.currToken[n2.FIELDS.START_LINE], this.currToken[n2.FIELDS.START_COL], this.tokens[this.position + 2][n2.FIELDS.END_LINE], this.tokens[this.position + 2][n2.FIELDS.END_COL]),
            sourceIndex: this.currToken[n2.FIELDS.START_POS],
            raws: J3
          });
          return this.position = this.position + 3, T4;
        } else
          this.unexpected();
      }, F.combinator = function() {
        var I3 = this;
        if (this.content() === "|")
          return this.namespace();
        var N3 = this.locateNextMeaningfulToken(this.position);
        if (N3 < 0 || this.tokens[N3][n2.FIELDS.TYPE] === d2.comma || this.tokens[N3][n2.FIELDS.TYPE] === d2.closeParenthesis) {
          var J3 = this.parseWhitespaceEquivalentTokens(N3);
          if (J3.length > 0) {
            var T4 = this.current.last;
            if (T4) {
              var U2 = this.convertWhitespaceNodesToSpace(J3), j3 = U2.space, H3 = U2.rawSpace;
              H3 !== undefined && (T4.rawSpaceAfter += H3), T4.spaces.after += j3;
            } else
              J3.forEach(function(G3) {
                return I3.newNode(G3);
              });
          }
          return;
        }
        var V4 = this.currToken, K3 = undefined;
        N3 > this.position && (K3 = this.parseWhitespaceEquivalentTokens(N3));
        var X3;
        if (this.isNamedCombinator() ? X3 = this.namedCombinator() : this.currToken[n2.FIELDS.TYPE] === d2.combinator ? (X3 = new o2.default({
          value: this.content(),
          source: P3(this.currToken),
          sourceIndex: this.currToken[n2.FIELDS.START_POS]
        }), this.position++) : k4[this.currToken[n2.FIELDS.TYPE]] || K3 || this.unexpected(), X3) {
          if (K3) {
            var Q3 = this.convertWhitespaceNodesToSpace(K3), ne4 = Q3.space, de3 = Q3.rawSpace;
            X3.spaces.before = ne4, X3.rawSpaceBefore = de3;
          }
        } else {
          var _e3 = this.convertWhitespaceNodesToSpace(K3, true), be3 = _e3.space, ie3 = _e3.rawSpace;
          ie3 || (ie3 = be3);
          var ke3 = {}, Y4 = {
            spaces: {}
          };
          be3.endsWith(" ") && ie3.endsWith(" ") ? (ke3.before = be3.slice(0, be3.length - 1), Y4.spaces.before = ie3.slice(0, ie3.length - 1)) : be3.startsWith(" ") && ie3.startsWith(" ") ? (ke3.after = be3.slice(1), Y4.spaces.after = ie3.slice(1)) : Y4.value = ie3, X3 = new o2.default({
            value: " ",
            source: C(V4, this.tokens[this.position - 1]),
            sourceIndex: V4[n2.FIELDS.START_POS],
            spaces: ke3,
            raws: Y4
          });
        }
        return this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.space && (X3.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(X3);
      }, F.comma = function() {
        if (this.position === this.tokens.length - 1) {
          this.root.trailingComma = true, this.position++;
          return;
        }
        this.current._inferEndPosition();
        var I3 = new p.default({
          source: {
            start: M2(this.tokens[this.position + 1])
          },
          sourceIndex: this.tokens[this.position + 1][n2.FIELDS.START_POS]
        });
        this.current.parent.append(I3), this.current = I3, this.position++;
      }, F.comment = function() {
        var I3 = this.currToken;
        this.newNode(new f.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.error = function(I3, N3) {
        throw this.root.error(I3, N3);
      }, F.missingBackslash = function() {
        return this.error("Expected a backslash preceding the semicolon.", {
          index: this.currToken[n2.FIELDS.START_POS]
        });
      }, F.missingParenthesis = function() {
        return this.expected("opening parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.missingSquareBracket = function() {
        return this.expected("opening square bracket", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpected = function() {
        return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[n2.FIELDS.START_POS]);
      }, F.unexpectedPipe = function() {
        return this.error("Unexpected '|'.", this.currToken[n2.FIELDS.START_POS]);
      }, F.namespace = function() {
        var I3 = this.prevToken && this.content(this.prevToken) || true;
        if (this.nextToken[n2.FIELDS.TYPE] === d2.word)
          return this.position++, this.word(I3);
        if (this.nextToken[n2.FIELDS.TYPE] === d2.asterisk)
          return this.position++, this.universal(I3);
        this.unexpectedPipe();
      }, F.nesting = function() {
        if (this.nextToken) {
          var I3 = this.content(this.nextToken);
          if (I3 === "|") {
            this.position++;
            return;
          }
        }
        var N3 = this.currToken;
        this.newNode(new v3.default({
          value: this.content(),
          source: P3(N3),
          sourceIndex: N3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.parentheses = function() {
        var I3 = this.current.last, N3 = 1;
        if (this.position++, I3 && I3.type === _4.PSEUDO) {
          var J3 = new p.default({
            source: {
              start: M2(this.tokens[this.position])
            },
            sourceIndex: this.tokens[this.position][n2.FIELDS.START_POS]
          }), T4 = this.current;
          for (I3.append(J3), this.current = J3;this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, N3 ? this.parse() : (this.current.source.end = W3(this.currToken), this.current.parent.source.end = W3(this.currToken), this.position++);
          this.current = T4;
        } else {
          for (var U2 = this.currToken, j3 = "(", H3;this.position < this.tokens.length && N3; )
            this.currToken[n2.FIELDS.TYPE] === d2.openParenthesis && N3++, this.currToken[n2.FIELDS.TYPE] === d2.closeParenthesis && N3--, H3 = this.currToken, j3 += this.parseParenthesisToken(this.currToken), this.position++;
          I3 ? I3.appendToPropertyAndEscape("value", j3, j3) : this.newNode(new t10.default({
            value: j3,
            source: S3(U2[n2.FIELDS.START_LINE], U2[n2.FIELDS.START_COL], H3[n2.FIELDS.END_LINE], H3[n2.FIELDS.END_COL]),
            sourceIndex: U2[n2.FIELDS.START_POS]
          }));
        }
        if (N3)
          return this.expected("closing parenthesis", this.currToken[n2.FIELDS.START_POS]);
      }, F.pseudo = function() {
        for (var I3 = this, N3 = "", J3 = this.currToken;this.currToken && this.currToken[n2.FIELDS.TYPE] === d2.colon; )
          N3 += this.content(), this.position++;
        if (!this.currToken)
          return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
        if (this.currToken[n2.FIELDS.TYPE] === d2.word)
          this.splitWord(false, function(T4, U2) {
            N3 += T4, I3.newNode(new e2.default({
              value: N3,
              source: C(J3, I3.currToken),
              sourceIndex: J3[n2.FIELDS.START_POS]
            })), U2 > 1 && I3.nextToken && I3.nextToken[n2.FIELDS.TYPE] === d2.openParenthesis && I3.error("Misplaced parenthesis.", {
              index: I3.nextToken[n2.FIELDS.START_POS]
            });
          });
        else
          return this.expected(["pseudo-class", "pseudo-element"], this.currToken[n2.FIELDS.START_POS]);
      }, F.space = function() {
        var I3 = this.content();
        this.position === 0 || this.prevToken[n2.FIELDS.TYPE] === d2.comma || this.prevToken[n2.FIELDS.TYPE] === d2.openParenthesis || this.current.nodes.every(function(N3) {
          return N3.type === "comment";
        }) ? (this.spaces = this.optionalSpace(I3), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[n2.FIELDS.TYPE] === d2.comma || this.nextToken[n2.FIELDS.TYPE] === d2.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(I3), this.position++) : this.combinator();
      }, F.string = function() {
        var I3 = this.currToken;
        this.newNode(new t10.default({
          value: this.content(),
          source: P3(I3),
          sourceIndex: I3[n2.FIELDS.START_POS]
        })), this.position++;
      }, F.universal = function(I3) {
        var N3 = this.nextToken;
        if (N3 && this.content(N3) === "|")
          return this.position++, this.namespace();
        var J3 = this.currToken;
        this.newNode(new i2.default({
          value: this.content(),
          source: P3(J3),
          sourceIndex: J3[n2.FIELDS.START_POS]
        }), I3), this.position++;
      }, F.splitWord = function(I3, N3) {
        for (var J3 = this, T4 = this.nextToken, U2 = this.content();T4 && ~[d2.dollar, d2.caret, d2.equals, d2.word].indexOf(T4[n2.FIELDS.TYPE]); ) {
          this.position++;
          var j3 = this.content();
          if (U2 += j3, j3.lastIndexOf("\\") === j3.length - 1) {
            var H3 = this.nextToken;
            H3 && H3[n2.FIELDS.TYPE] === d2.space && (U2 += this.requiredSpace(this.content(H3)), this.position++);
          }
          T4 = this.nextToken;
        }
        var V4 = $3(U2, ".").filter(function(ne4) {
          var de3 = U2[ne4 - 1] === "\\", _e3 = /^\d+\.\d+%$/.test(U2);
          return !de3 && !_e3;
        }), K3 = $3(U2, "#").filter(function(ne4) {
          return U2[ne4 - 1] !== "\\";
        }), X3 = $3(U2, "#{");
        X3.length && (K3 = K3.filter(function(ne4) {
          return !~X3.indexOf(ne4);
        }));
        var Q3 = (0, m.default)(B3([0].concat(V4, K3)));
        Q3.forEach(function(ne4, de3) {
          var _e3 = Q3[de3 + 1] || U2.length, be3 = U2.slice(ne4, _e3);
          if (de3 === 0 && N3)
            return N3.call(J3, be3, Q3.length);
          var ie3, ke3 = J3.currToken, Y4 = ke3[n2.FIELDS.START_POS] + Q3[de3], G3 = S3(ke3[1], ke3[2] + ne4, ke3[3], ke3[2] + (_e3 - 1));
          if (~V4.indexOf(ne4)) {
            var te2 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y4
            };
            ie3 = new l3.default(R3(te2, "value"));
          } else if (~K3.indexOf(ne4)) {
            var Z3 = {
              value: be3.slice(1),
              source: G3,
              sourceIndex: Y4
            };
            ie3 = new s2.default(R3(Z3, "value"));
          } else {
            var ee3 = {
              value: be3,
              source: G3,
              sourceIndex: Y4
            };
            R3(ee3, "value"), ie3 = new c2.default(ee3);
          }
          J3.newNode(ie3, I3), I3 = null;
        }), this.position++;
      }, F.word = function(I3) {
        var N3 = this.nextToken;
        return N3 && this.content(N3) === "|" ? (this.position++, this.namespace()) : this.splitWord(I3);
      }, F.loop = function() {
        for (;this.position < this.tokens.length; )
          this.parse(true);
        return this.current._inferEndPosition(), this.root;
      }, F.parse = function(I3) {
        switch (this.currToken[n2.FIELDS.TYPE]) {
          case d2.space:
            this.space();
            break;
          case d2.comment:
            this.comment();
            break;
          case d2.openParenthesis:
            this.parentheses();
            break;
          case d2.closeParenthesis:
            I3 && this.missingParenthesis();
            break;
          case d2.openSquare:
            this.attribute();
            break;
          case d2.dollar:
          case d2.caret:
          case d2.equals:
          case d2.word:
            this.word();
            break;
          case d2.colon:
            this.pseudo();
            break;
          case d2.comma:
            this.comma();
            break;
          case d2.asterisk:
            this.universal();
            break;
          case d2.ampersand:
            this.nesting();
            break;
          case d2.slash:
          case d2.combinator:
            this.combinator();
            break;
          case d2.str:
            this.string();
            break;
          case d2.closeSquare:
            this.missingSquareBracket();
          case d2.semicolon:
            this.missingBackslash();
          default:
            this.unexpected();
        }
      }, F.expected = function(I3, N3, J3) {
        if (Array.isArray(I3)) {
          var T4 = I3.pop();
          I3 = I3.join(", ") + " or " + T4;
        }
        var U2 = /^[aeiou]/.test(I3[0]) ? "an" : "a";
        return J3 ? this.error("Expected " + U2 + " " + I3 + ', found "' + J3 + '" instead.', {
          index: N3
        }) : this.error("Expected " + U2 + " " + I3 + ".", {
          index: N3
        });
      }, F.requiredSpace = function(I3) {
        return this.options.lossy ? " " : I3;
      }, F.optionalSpace = function(I3) {
        return this.options.lossy ? "" : I3;
      }, F.lossySpace = function(I3, N3) {
        return this.options.lossy ? N3 ? " " : "" : I3;
      }, F.parseParenthesisToken = function(I3) {
        var N3 = this.content(I3);
        return I3[n2.FIELDS.TYPE] === d2.space ? this.requiredSpace(N3) : N3;
      }, F.newNode = function(I3, N3) {
        return N3 && (/^ +$/.test(N3) && (this.options.lossy || (this.spaces = (this.spaces || "") + N3), N3 = true), I3.namespace = N3, R3(I3, "namespace")), this.spaces && (I3.spaces.before = this.spaces, this.spaces = ""), this.current.append(I3);
      }, F.content = function(I3) {
        return I3 === undefined && (I3 = this.currToken), this.css.slice(I3[n2.FIELDS.START_POS], I3[n2.FIELDS.END_POS]);
      }, F.locateNextMeaningfulToken = function(I3) {
        I3 === undefined && (I3 = this.position + 1);
        for (var N3 = I3;N3 < this.tokens.length; )
          if (q2[this.tokens[N3][n2.FIELDS.TYPE]]) {
            N3++;
            continue;
          } else
            return N3;
        return -1;
      }, b5(L3, [{
        key: "currToken",
        get: function() {
          return this.tokens[this.position];
        }
      }, {
        key: "nextToken",
        get: function() {
          return this.tokens[this.position + 1];
        }
      }, {
        key: "prevToken",
        get: function() {
          return this.tokens[this.position - 1];
        }
      }]), L3;
    }();
    a.default = z3, u.exports = a.default;
  }($t3, $t3.exports)), $t3.exports;
}
var fo2;
function mf() {
  return fo2 || (fo2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = p(gf());
    function p(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var l3 = /* @__PURE__ */ function() {
      function f(c2, t10) {
        this.func = c2 || function() {}, this.funcRes = null, this.options = t10;
      }
      var s2 = f.prototype;
      return s2._shouldUpdateSelector = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = Object.assign({}, this.options, e2);
        return r2.updateSelector === false ? false : typeof t10 != "string";
      }, s2._isLossy = function(t10) {
        t10 === undefined && (t10 = {});
        var e2 = Object.assign({}, this.options, t10);
        return e2.lossless === false;
      }, s2._root = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = new h2.default(t10, this._parseOptions(e2));
        return r2.root;
      }, s2._parseOptions = function(t10) {
        return {
          lossy: this._isLossy(t10)
        };
      }, s2._run = function(t10, e2) {
        var r2 = this;
        return e2 === undefined && (e2 = {}), new Promise(function(i2, o2) {
          try {
            var v3 = r2._root(t10, e2);
            Promise.resolve(r2.func(v3)).then(function(m) {
              var n2 = undefined;
              return r2._shouldUpdateSelector(t10, e2) && (n2 = v3.toString(), t10.selector = n2), {
                transform: m,
                root: v3,
                string: n2
              };
            }).then(i2, o2);
          } catch (m) {
            o2(m);
            return;
          }
        });
      }, s2._runSync = function(t10, e2) {
        e2 === undefined && (e2 = {});
        var r2 = this._root(t10, e2), i2 = this.func(r2);
        if (i2 && typeof i2.then == "function")
          throw new Error("Selector processor returned a promise to a synchronous call.");
        var o2 = undefined;
        return e2.updateSelector && typeof t10 != "string" && (o2 = r2.toString(), t10.selector = o2), {
          transform: i2,
          root: r2,
          string: o2
        };
      }, s2.ast = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.root;
        });
      }, s2.astSync = function(t10, e2) {
        return this._runSync(t10, e2).root;
      }, s2.transform = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.transform;
        });
      }, s2.transformSync = function(t10, e2) {
        return this._runSync(t10, e2).transform;
      }, s2.process = function(t10, e2) {
        return this._run(t10, e2).then(function(r2) {
          return r2.string || r2.root.toString();
        });
      }, s2.processSync = function(t10, e2) {
        var r2 = this._runSync(t10, e2);
        return r2.string || r2.root.toString();
      }, f;
    }();
    a.default = l3, u.exports = a.default;
  }(Ft2, Ft2.exports)), Ft2.exports;
}
var Dn3 = {};
var De3 = {};
var co3;
function yf() {
  if (co3)
    return De3;
  co3 = 1, De3.__esModule = true, De3.universal = De3.tag = De3.string = De3.selector = De3.root = De3.pseudo = De3.nesting = De3.id = De3.comment = De3.combinator = De3.className = De3.attribute = undefined;
  var u = o2(Ql()), a = o2(Wl()), h2 = o2(Jl()), p = o2(Vl()), l3 = o2(jl()), f = o2(Kl()), s2 = o2(Yl()), c2 = o2(Ul()), t10 = o2(zl()), e2 = o2(Gl()), r2 = o2(Bl()), i2 = o2(Hl());
  function o2(b5) {
    return b5 && b5.__esModule ? b5 : { default: b5 };
  }
  var v3 = function(k4) {
    return new u.default(k4);
  };
  De3.attribute = v3;
  var m = function(k4) {
    return new a.default(k4);
  };
  De3.className = m;
  var n2 = function(k4) {
    return new h2.default(k4);
  };
  De3.combinator = n2;
  var d2 = function(k4) {
    return new p.default(k4);
  };
  De3.comment = d2;
  var _4 = function(k4) {
    return new l3.default(k4);
  };
  De3.id = _4;
  var w3 = function(k4) {
    return new f.default(k4);
  };
  De3.nesting = w3;
  var y2 = function(k4) {
    return new s2.default(k4);
  };
  De3.pseudo = y2;
  var x2 = function(k4) {
    return new c2.default(k4);
  };
  De3.root = x2;
  var g2 = function(k4) {
    return new t10.default(k4);
  };
  De3.selector = g2;
  var O3 = function(k4) {
    return new e2.default(k4);
  };
  De3.string = O3;
  var A = function(k4) {
    return new r2.default(k4);
  };
  De3.tag = A;
  var E2 = function(k4) {
    return new i2.default(k4);
  };
  return De3.universal = E2, De3;
}
var Ee3 = {};
var po3;
function wf() {
  if (po3)
    return Ee3;
  po3 = 1, Ee3.__esModule = true, Ee3.isComment = Ee3.isCombinator = Ee3.isClassName = Ee3.isAttribute = undefined, Ee3.isContainer = y2, Ee3.isIdentifier = undefined, Ee3.isNamespace = x2, Ee3.isNesting = undefined, Ee3.isNode = p, Ee3.isPseudo = undefined, Ee3.isPseudoClass = w3, Ee3.isPseudoElement = _4, Ee3.isUniversal = Ee3.isTag = Ee3.isString = Ee3.isSelector = Ee3.isRoot = undefined;
  var u = $e2(), a, h2 = (a = {}, a[u.ATTRIBUTE] = true, a[u.CLASS] = true, a[u.COMBINATOR] = true, a[u.COMMENT] = true, a[u.ID] = true, a[u.NESTING] = true, a[u.PSEUDO] = true, a[u.ROOT] = true, a[u.SELECTOR] = true, a[u.STRING] = true, a[u.TAG] = true, a[u.UNIVERSAL] = true, a);
  function p(g2) {
    return typeof g2 == "object" && h2[g2.type];
  }
  function l3(g2, O3) {
    return p(O3) && O3.type === g2;
  }
  var f = l3.bind(null, u.ATTRIBUTE);
  Ee3.isAttribute = f;
  var s2 = l3.bind(null, u.CLASS);
  Ee3.isClassName = s2;
  var c2 = l3.bind(null, u.COMBINATOR);
  Ee3.isCombinator = c2;
  var t10 = l3.bind(null, u.COMMENT);
  Ee3.isComment = t10;
  var e2 = l3.bind(null, u.ID);
  Ee3.isIdentifier = e2;
  var r2 = l3.bind(null, u.NESTING);
  Ee3.isNesting = r2;
  var i2 = l3.bind(null, u.PSEUDO);
  Ee3.isPseudo = i2;
  var o2 = l3.bind(null, u.ROOT);
  Ee3.isRoot = o2;
  var v3 = l3.bind(null, u.SELECTOR);
  Ee3.isSelector = v3;
  var m = l3.bind(null, u.STRING);
  Ee3.isString = m;
  var n2 = l3.bind(null, u.TAG);
  Ee3.isTag = n2;
  var d2 = l3.bind(null, u.UNIVERSAL);
  Ee3.isUniversal = d2;
  function _4(g2) {
    return i2(g2) && g2.value && (g2.value.startsWith("::") || g2.value.toLowerCase() === ":before" || g2.value.toLowerCase() === ":after" || g2.value.toLowerCase() === ":first-letter" || g2.value.toLowerCase() === ":first-line");
  }
  function w3(g2) {
    return i2(g2) && !_4(g2);
  }
  function y2(g2) {
    return !!(p(g2) && g2.walk);
  }
  function x2(g2) {
    return f(g2) || n2(g2);
  }
  return Ee3;
}
var ho2;
function bf() {
  return ho2 || (ho2 = 1, function(u) {
    u.__esModule = true;
    var a = $e2();
    Object.keys(a).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === a[l3] || (u[l3] = a[l3]);
    });
    var h2 = yf();
    Object.keys(h2).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === h2[l3] || (u[l3] = h2[l3]);
    });
    var p = wf();
    Object.keys(p).forEach(function(l3) {
      l3 === "default" || l3 === "__esModule" || l3 in u && u[l3] === p[l3] || (u[l3] = p[l3]);
    });
  }(Dn3)), Dn3;
}
var vo2;
function Ke3() {
  return vo2 || (vo2 = 1, function(u, a) {
    a.__esModule = true, a.default = undefined;
    var h2 = s2(mf()), p = f(bf());
    function l3(e2) {
      if (typeof WeakMap != "function")
        return null;
      var r2 = /* @__PURE__ */ new WeakMap, i2 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(v3) {
        return v3 ? i2 : r2;
      })(e2);
    }
    function f(e2, r2) {
      if (e2 && e2.__esModule)
        return e2;
      if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
        return { default: e2 };
      var i2 = l3(r2);
      if (i2 && i2.has(e2))
        return i2.get(e2);
      var o2 = {}, v3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var m in e2)
        if (m !== "default" && Object.prototype.hasOwnProperty.call(e2, m)) {
          var n2 = v3 ? Object.getOwnPropertyDescriptor(e2, m) : null;
          n2 && (n2.get || n2.set) ? Object.defineProperty(o2, m, n2) : o2[m] = e2[m];
        }
      return o2.default = e2, i2 && i2.set(e2, o2), o2;
    }
    function s2(e2) {
      return e2 && e2.__esModule ? e2 : { default: e2 };
    }
    var c2 = function(r2) {
      return new h2.default(r2);
    };
    Object.assign(c2, p), delete c2.__esModule;
    var t10 = c2;
    a.default = t10, u.exports = a.default;
  }(Nt3, Nt3.exports)), Nt3.exports;
}
var qn3 = {};
var Ln3 = {};
var ar3 = { exports: {} };
var go2;
function _f() {
  if (go2)
    return ar3.exports;
  go2 = 1;
  const { AtRule: u, Rule: a } = Be2();
  let h2 = Ke3();
  function p(_4, w3) {
    let y2;
    try {
      h2((x2) => {
        y2 = x2;
      }).processSync(_4);
    } catch (x2) {
      throw _4.includes(":") ? w3 ? w3.error("Missed semicolon") : x2 : w3 ? w3.error(x2.message) : x2;
    }
    return y2.at(0);
  }
  function l3(_4, w3) {
    let y2 = false;
    return _4.each((x2) => {
      if (x2.type === "nesting") {
        let g2 = w3.clone({});
        x2.value !== "&" ? x2.replaceWith(p(x2.value.replace("&", g2.toString()))) : x2.replaceWith(g2), y2 = true;
      } else
        "nodes" in x2 && x2.nodes && l3(x2, w3) && (y2 = true);
    }), y2;
  }
  function f(_4, w3) {
    let y2 = [];
    return _4.selectors.forEach((x2) => {
      let g2 = p(x2, _4);
      w3.selectors.forEach((O3) => {
        if (!O3)
          return;
        let A = p(O3, w3);
        l3(A, g2) || (A.prepend(h2.combinator({ value: " " })), A.prepend(g2.clone({}))), y2.push(A.toString());
      });
    }), y2;
  }
  function s2(_4, w3) {
    let y2 = _4.prev();
    for (w3.after(_4);y2 && y2.type === "comment"; ) {
      let x2 = y2.prev();
      w3.after(y2), y2 = x2;
    }
    return _4;
  }
  function c2(_4) {
    return function w(y2, x2, g2, O3 = g2) {
      let A = [];
      if (x2.each((E2) => {
        E2.type === "rule" && g2 ? O3 && (E2.selectors = f(y2, E2)) : E2.type === "atrule" && E2.nodes ? _4[E2.name] ? w(y2, E2, O3) : x2[v3] !== false && A.push(E2) : A.push(E2);
      }), g2 && A.length) {
        let E2 = y2.clone({ nodes: [] });
        for (let b5 of A)
          E2.append(b5);
        x2.prepend(E2);
      }
    };
  }
  function t10(_4, w3, y2) {
    let x2 = new a({
      nodes: [],
      selector: _4
    });
    return x2.append(w3), y2.after(x2), x2;
  }
  function e2(_4, w3) {
    let y2 = {};
    for (let x2 of _4)
      y2[x2] = true;
    if (w3)
      for (let x2 of w3)
        y2[x2.replace(/^@/, "")] = true;
    return y2;
  }
  function r2(_4) {
    _4 = _4.trim();
    let w3 = _4.match(/^\((.*)\)$/);
    if (!w3)
      return { selector: _4, type: "basic" };
    let y2 = w3[1].match(/^(with(?:out)?):(.+)$/);
    if (y2) {
      let x2 = y2[1] === "with", g2 = Object.fromEntries(y2[2].trim().split(/\s+/).map((A) => [A, true]));
      if (x2 && g2.all)
        return { type: "noop" };
      let O3 = (A) => !!g2[A];
      return g2.all ? O3 = () => true : x2 && (O3 = (A) => A === "all" ? false : !g2[A]), {
        escapes: O3,
        type: "withrules"
      };
    }
    return { type: "unknown" };
  }
  function i2(_4) {
    let w3 = [], y2 = _4.parent;
    for (;y2 && y2 instanceof u; )
      w3.push(y2), y2 = y2.parent;
    return w3;
  }
  function o2(_4) {
    let w3 = _4[m];
    if (!w3)
      _4.after(_4.nodes);
    else {
      let y2 = _4.nodes, x2, g2 = -1, O3, A, E2, b5 = i2(_4);
      if (b5.forEach((k4, q2) => {
        if (w3(k4.name))
          x2 = k4, g2 = q2, A = E2;
        else {
          let M2 = E2;
          E2 = k4.clone({ nodes: [] }), M2 && E2.append(M2), O3 = O3 || E2;
        }
      }), x2 ? A ? (O3.append(y2), x2.after(A)) : x2.after(y2) : _4.after(y2), _4.next() && x2) {
        let k4;
        b5.slice(0, g2 + 1).forEach((q2, M2, W3) => {
          let S3 = k4;
          k4 = q2.clone({ nodes: [] }), S3 && k4.append(S3);
          let P3 = [], R3 = (W3[M2 - 1] || _4).next();
          for (;R3; )
            P3.push(R3), R3 = R3.next();
          k4.append(P3);
        }), k4 && (A || y2[y2.length - 1]).after(k4);
      }
    }
    _4.remove();
  }
  const v3 = Symbol("rootRuleMergeSel"), m = Symbol("rootRuleEscapes");
  function n2(_4) {
    let { params: w3 } = _4, { escapes: y2, selector: x2, type: g2 } = r2(w3);
    if (g2 === "unknown")
      throw _4.error(`Unknown @${_4.name} parameter ${JSON.stringify(w3)}`);
    if (g2 === "basic" && x2) {
      let O3 = new a({ nodes: _4.nodes, selector: x2 });
      _4.removeAll(), _4.append(O3);
    }
    _4[m] = y2, _4[v3] = y2 ? !y2("all") : g2 === "noop";
  }
  const d2 = Symbol("hasRootRule");
  return ar3.exports = (_4 = {}) => {
    let w3 = e2(["media", "supports", "layer", "container", "starting-style"], _4.bubble), y2 = c2(w3), x2 = e2([
      "document",
      "font-face",
      "keyframes",
      "-webkit-keyframes",
      "-moz-keyframes"
    ], _4.unwrap), g2 = (_4.rootRuleName || "at-root").replace(/^@/, ""), O3 = _4.preserveEmpty;
    return {
      Once(A) {
        A.walkAtRules(g2, (E2) => {
          n2(E2), A[d2] = true;
        });
      },
      postcssPlugin: "postcss-nested",
      RootExit(A) {
        A[d2] && (A.walkAtRules(g2, o2), A[d2] = false);
      },
      Rule(A) {
        let E2 = false, b5 = A, k4 = false, q2 = [];
        A.each((M2) => {
          M2.type === "rule" ? (q2.length && (b5 = t10(A.selector, q2, b5), q2 = []), k4 = true, E2 = true, M2.selectors = f(A, M2), b5 = s2(M2, b5)) : M2.type === "atrule" ? (q2.length && (b5 = t10(A.selector, q2, b5), q2 = []), M2.name === g2 ? (E2 = true, y2(A, M2, true, M2[v3]), b5 = s2(M2, b5)) : w3[M2.name] ? (k4 = true, E2 = true, y2(A, M2, true), b5 = s2(M2, b5)) : x2[M2.name] ? (k4 = true, E2 = true, y2(A, M2, false), b5 = s2(M2, b5)) : k4 && q2.push(M2)) : M2.type === "decl" && k4 && q2.push(M2);
        }), q2.length && (b5 = t10(A.selector, q2, b5)), E2 && O3 !== true && (A.raws.semicolon = true, A.nodes.length === 0 && A.remove());
      }
    };
  }, ar3.exports.postcss = true, ar3.exports;
}
var Nn3;
var mo2;
function Sf() {
  if (mo2)
    return Nn3;
  mo2 = 1;
  var u = /-(\w|$)/g, a = function(l3, f) {
    return f.toUpperCase();
  }, h2 = function(l3) {
    return l3 = l3.toLowerCase(), l3 === "float" ? "cssFloat" : l3.charCodeAt(0) === 45 && l3.charCodeAt(1) === 109 && l3.charCodeAt(2) === 115 && l3.charCodeAt(3) === 45 ? l3.substr(1).replace(u, a) : l3.replace(u, a);
  };
  return Nn3 = h2, Nn3;
}
var Fn3;
var yo2;
function Zl() {
  if (yo2)
    return Fn3;
  yo2 = 1;
  let u = Sf(), a = {
    boxFlex: true,
    boxFlexGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  function h2(l3) {
    return typeof l3.nodes > "u" ? true : p(l3);
  }
  function p(l3) {
    let f, s2 = {};
    return l3.each((c2) => {
      if (c2.type === "atrule")
        f = "@" + c2.name, c2.params && (f += " " + c2.params), typeof s2[f] > "u" ? s2[f] = h2(c2) : Array.isArray(s2[f]) ? s2[f].push(h2(c2)) : s2[f] = [s2[f], h2(c2)];
      else if (c2.type === "rule") {
        let t10 = p(c2);
        if (s2[c2.selector])
          for (let e2 in t10)
            s2[c2.selector][e2] = t10[e2];
        else
          s2[c2.selector] = t10;
      } else if (c2.type === "decl") {
        c2.prop[0] === "-" && c2.prop[1] === "-" || c2.parent && c2.parent.selector === ":export" ? f = c2.prop : f = u(c2.prop);
        let t10 = c2.value;
        !isNaN(c2.value) && a[f] && (t10 = parseFloat(c2.value)), c2.important && (t10 += " !important"), typeof s2[f] > "u" ? s2[f] = t10 : Array.isArray(s2[f]) ? s2[f].push(t10) : s2[f] = [s2[f], t10];
      }
    }), s2;
  }
  return Fn3 = p, Fn3;
}
var $n3;
var wo2;
function Qi2() {
  if (wo2)
    return $n3;
  wo2 = 1;
  let u = Be2(), a = /\s*!important\s*$/i, h2 = {
    "box-flex": true,
    "box-flex-group": true,
    "column-count": true,
    flex: true,
    "flex-grow": true,
    "flex-positive": true,
    "flex-shrink": true,
    "flex-negative": true,
    "font-weight": true,
    "line-clamp": true,
    "line-height": true,
    opacity: true,
    order: true,
    orphans: true,
    "tab-size": true,
    widows: true,
    "z-index": true,
    zoom: true,
    "fill-opacity": true,
    "stroke-dashoffset": true,
    "stroke-opacity": true,
    "stroke-width": true
  };
  function p(c2) {
    return c2.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function l3(c2, t10, e2) {
    e2 === false || e2 === null || (t10.startsWith("--") || (t10 = p(t10)), typeof e2 == "number" && (e2 === 0 || h2[t10] ? e2 = e2.toString() : e2 += "px"), t10 === "css-float" && (t10 = "float"), a.test(e2) ? (e2 = e2.replace(a, ""), c2.push(u.decl({ prop: t10, value: e2, important: true }))) : c2.push(u.decl({ prop: t10, value: e2 })));
  }
  function f(c2, t10, e2) {
    let r2 = u.atRule({ name: t10[1], params: t10[3] || "" });
    typeof e2 == "object" && (r2.nodes = [], s2(e2, r2)), c2.push(r2);
  }
  function s2(c2, t10) {
    let e2, r2, i2;
    for (e2 in c2)
      if (r2 = c2[e2], !(r2 === null || typeof r2 > "u"))
        if (e2[0] === "@") {
          let o2 = e2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(r2))
            for (let v3 of r2)
              f(t10, o2, v3);
          else
            f(t10, o2, r2);
        } else if (Array.isArray(r2))
          for (let o2 of r2)
            l3(t10, e2, o2);
        else
          typeof r2 == "object" ? (i2 = u.rule({ selector: e2 }), s2(r2, i2), t10.push(i2)) : l3(t10, e2, r2);
  }
  return $n3 = function(c2) {
    let t10 = u.root();
    return s2(c2, t10), t10;
  }, $n3;
}
var Un3;
var bo2;
function eu3() {
  if (bo2)
    return Un3;
  bo2 = 1;
  let u = Zl();
  return Un3 = function(h2) {
    return console && console.warn && h2.warnings().forEach((p) => {
      let l3 = p.plugin || "PostCSS";
      console.warn(l3 + ": " + p.text);
    }), u(h2.root);
  }, Un3;
}
var zn3;
var _o2;
function xf() {
  if (_o2)
    return zn3;
  _o2 = 1;
  let u = Be2(), a = eu3(), h2 = Qi2();
  return zn3 = function(l3) {
    let f = u(l3);
    return async (s2) => {
      let c2 = await f.process(s2, {
        parser: h2,
        from: undefined
      });
      return a(c2);
    };
  }, zn3;
}
var Wn3;
var So2;
function Of() {
  if (So2)
    return Wn3;
  So2 = 1;
  let u = Be2(), a = eu3(), h2 = Qi2();
  return Wn3 = function(p) {
    let l3 = u(p);
    return (f) => {
      let s2 = l3.process(f, { parser: h2, from: undefined });
      return a(s2);
    };
  }, Wn3;
}
var Vn3;
var xo2;
function kf() {
  if (xo2)
    return Vn3;
  xo2 = 1;
  let u = Zl(), a = Qi2(), h2 = xf(), p = Of();
  return Vn3 = {
    objectify: u,
    parse: a,
    async: h2,
    sync: p
  }, Vn3;
}
var Oo3;
function tu3() {
  return Oo3 || (Oo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = /* @__PURE__ */ l3(Be2()), h2 = /* @__PURE__ */ l3(_f()), p = /* @__PURE__ */ l3(kf());
    function l3(s2) {
      return s2 && s2.__esModule ? s2 : {
        default: s2
      };
    }
    function f(s2) {
      return Array.isArray(s2) ? s2.flatMap((c2) => (0, a.default)([
        (0, h2.default)({
          bubble: [
            "screen"
          ]
        })
      ]).process(c2, {
        parser: p.default
      }).root.nodes) : f([
        s2
      ]);
    }
  }(Ln3)), Ln3;
}
var jn3 = {};
var ko2;
function Hi2() {
  return ko2 || (ko2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = /* @__PURE__ */ h2(Ke3());
    function h2(l3) {
      return l3 && l3.__esModule ? l3 : {
        default: l3
      };
    }
    function p(l3, f, s2 = false) {
      if (l3 === "")
        return f;
      let c2 = typeof f == "string" ? (0, a.default)().astSync(f) : f;
      return c2.walkClasses((t10) => {
        let e2 = t10.value, r2 = s2 && e2.startsWith("-");
        t10.value = r2 ? `-${l3}${e2.slice(1)}` : `${l3}${e2}`;
      }), typeof f == "string" ? c2.toString() : c2;
    }
  }(jn3)), jn3;
}
var Bn3 = {};
var Po2;
function yr3() {
  return Po2 || (Po2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(r2, i2) {
      for (var o2 in i2)
        Object.defineProperty(r2, o2, {
          enumerable: true,
          get: i2[o2]
        });
    }
    a(u, {
      env: function() {
        return h2;
      },
      contextMap: function() {
        return p;
      },
      configContextMap: function() {
        return l3;
      },
      contextSourcesMap: function() {
        return f;
      },
      sourceHashMap: function() {
        return s2;
      },
      NOT_ON_DEMAND: function() {
        return c2;
      },
      NONE: function() {
        return t10;
      },
      resolveDebug: function() {
        return e2;
      }
    });
    const h2 = typeof process < "u" ? {
      NODE_ENV: "development",
      DEBUG: e2(process.env.DEBUG)
    } : {
      NODE_ENV: "production",
      DEBUG: false
    }, p = /* @__PURE__ */ new Map, l3 = /* @__PURE__ */ new Map, f = /* @__PURE__ */ new Map, s2 = /* @__PURE__ */ new Map, c2 = new String("*"), t10 = Symbol("__NONE__");
    function e2(r2) {
      if (r2 === undefined)
        return false;
      if (r2 === "true" || r2 === "1")
        return true;
      if (r2 === "false" || r2 === "0")
        return false;
      if (r2 === "*")
        return true;
      let i2 = r2.split(",").map((o2) => o2.split(":")[0]);
      return i2.includes("-tailwindcss") ? false : !!i2.includes("tailwindcss");
    }
  }(Bn3)), Bn3;
}
var Gn3 = {};
var Yn3 = {};
var Eo2;
function ft3() {
  return Eo2 || (Eo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(Ke3()), h2 = /* @__PURE__ */ p(Vi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3(f) {
      var s2;
      let c2 = a.default.className();
      c2.value = f;
      var t10;
      return (0, h2.default)((t10 = c2 == null || (s2 = c2.raws) === null || s2 === undefined ? undefined : s2.value) !== null && t10 !== undefined ? t10 : c2.value);
    }
  }(Yn3)), Yn3;
}
var Qn3 = {};
var To2;
function Ji2() {
  return To2 || (To2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "movePseudos", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    let a = {
      "::after": [
        "terminal",
        "jumpable"
      ],
      "::backdrop": [
        "terminal",
        "jumpable"
      ],
      "::before": [
        "terminal",
        "jumpable"
      ],
      "::cue": [
        "terminal"
      ],
      "::cue-region": [
        "terminal"
      ],
      "::first-letter": [
        "terminal",
        "jumpable"
      ],
      "::first-line": [
        "terminal",
        "jumpable"
      ],
      "::grammar-error": [
        "terminal"
      ],
      "::marker": [
        "terminal",
        "jumpable"
      ],
      "::part": [
        "terminal",
        "actionable"
      ],
      "::placeholder": [
        "terminal",
        "jumpable"
      ],
      "::selection": [
        "terminal",
        "jumpable"
      ],
      "::slotted": [
        "terminal"
      ],
      "::spelling-error": [
        "terminal"
      ],
      "::target-text": [
        "terminal"
      ],
      "::file-selector-button": [
        "terminal",
        "actionable"
      ],
      "::deep": [
        "actionable"
      ],
      "::v-deep": [
        "actionable"
      ],
      "::ng-deep": [
        "actionable"
      ],
      ":after": [
        "terminal",
        "jumpable"
      ],
      ":before": [
        "terminal",
        "jumpable"
      ],
      ":first-letter": [
        "terminal",
        "jumpable"
      ],
      ":first-line": [
        "terminal",
        "jumpable"
      ],
      ":where": [],
      ":is": [],
      ":has": [],
      __default__: [
        "terminal",
        "actionable"
      ]
    };
    function h2(t10) {
      let [e2] = p(t10);
      return e2.forEach(([r2, i2]) => r2.removeChild(i2)), t10.nodes.push(...e2.map(([, r2]) => r2)), t10;
    }
    function p(t10) {
      let e2 = [], r2 = null;
      for (let o2 of t10.nodes)
        if (o2.type === "combinator")
          e2 = e2.filter(([, v3]) => c2(v3).includes("jumpable")), r2 = null;
        else if (o2.type === "pseudo") {
          f(o2) ? (r2 = o2, e2.push([
            t10,
            o2,
            null
          ])) : r2 && s2(o2, r2) ? e2.push([
            t10,
            o2,
            r2
          ]) : r2 = null;
          var i2;
          for (let v3 of (i2 = o2.nodes) !== null && i2 !== undefined ? i2 : []) {
            let [m, n2] = p(v3);
            r2 = n2 || r2, e2.push(...m);
          }
        }
      return [
        e2,
        r2
      ];
    }
    function l3(t10) {
      return t10.value.startsWith("::") || a[t10.value] !== undefined;
    }
    function f(t10) {
      return l3(t10) && c2(t10).includes("terminal");
    }
    function s2(t10, e2) {
      return t10.type !== "pseudo" || l3(t10) ? false : c2(e2).includes("actionable");
    }
    function c2(t10) {
      var e2;
      return (e2 = a[t10.value]) !== null && e2 !== undefined ? e2 : a.__default__;
    }
  }(Qn3)), Qn3;
}
var Ao2;
function ru3() {
  return Ao2 || (Ao2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(d2, _4) {
      for (var w3 in _4)
        Object.defineProperty(d2, w3, {
          enumerable: true,
          get: _4[w3]
        });
    }
    a(u, {
      formatVariantSelector: function() {
        return r2;
      },
      eliminateIrrelevantSelectors: function() {
        return v3;
      },
      finalizeSelector: function() {
        return m;
      },
      handleMergePseudo: function() {
        return n2;
      }
    });
    const h2 = /* @__PURE__ */ t10(Ke3()), p = /* @__PURE__ */ t10(Bi2()), l3 = /* @__PURE__ */ t10(ft3()), f = /* @__PURE__ */ t10(Hi2()), s2 = Ji2(), c2 = st3();
    function t10(d2) {
      return d2 && d2.__esModule ? d2 : {
        default: d2
      };
    }
    let e2 = ":merge";
    function r2(d2, { context: _4, candidate: w3 }) {
      var y2;
      let x2 = (y2 = _4 == null ? undefined : _4.tailwindConfig.prefix) !== null && y2 !== undefined ? y2 : "", g2 = d2.map((A) => {
        let E2 = (0, h2.default)().astSync(A.format);
        return {
          ...A,
          ast: A.respectPrefix ? (0, f.default)(x2, E2) : E2
        };
      }), O3 = h2.default.root({
        nodes: [
          h2.default.selector({
            nodes: [
              h2.default.className({
                value: (0, l3.default)(w3)
              })
            ]
          })
        ]
      });
      for (let { ast: A } of g2)
        [O3, A] = n2(O3, A), A.walkNesting((E2) => E2.replaceWith(...O3.nodes[0].nodes)), O3 = A;
      return O3;
    }
    function i2(d2) {
      let _4 = [];
      for (;d2.prev() && d2.prev().type !== "combinator"; )
        d2 = d2.prev();
      for (;d2 && d2.type !== "combinator"; )
        _4.push(d2), d2 = d2.next();
      return _4;
    }
    function o2(d2) {
      return d2.sort((_4, w3) => _4.type === "tag" && w3.type === "class" ? -1 : _4.type === "class" && w3.type === "tag" ? 1 : _4.type === "class" && w3.type === "pseudo" && w3.value.startsWith("::") ? -1 : _4.type === "pseudo" && _4.value.startsWith("::") && w3.type === "class" ? 1 : d2.index(_4) - d2.index(w3)), d2;
    }
    function v3(d2, _4) {
      let w3 = false;
      d2.walk((y2) => {
        if (y2.type === "class" && y2.value === _4)
          return w3 = true, false;
      }), w3 || d2.remove();
    }
    function m(d2, _4, { context: w3, candidate: y2, base: x2 }) {
      var g2, O3;
      let A = (O3 = w3 == null || (g2 = w3.tailwindConfig) === null || g2 === undefined ? undefined : g2.separator) !== null && O3 !== undefined ? O3 : ":";
      x2 = x2 ?? (0, c2.splitAtTopLevelOnly)(y2, A).pop();
      let E2 = (0, h2.default)().astSync(d2);
      if (E2.walkClasses((M2) => {
        M2.raws && M2.value.includes(x2) && (M2.raws.value = (0, l3.default)((0, p.default)(M2.raws.value)));
      }), E2.each((M2) => v3(M2, x2)), E2.length === 0)
        return null;
      let b5 = Array.isArray(_4) ? r2(_4, {
        context: w3,
        candidate: y2
      }) : _4;
      if (b5 === null)
        return E2.toString();
      let k4 = h2.default.comment({
        value: "/*__simple__*/"
      }), q2 = h2.default.comment({
        value: "/*__simple__*/"
      });
      return E2.walkClasses((M2) => {
        if (M2.value !== x2)
          return;
        let W3 = M2.parent, S3 = b5.nodes[0].nodes;
        if (W3.nodes.length === 1) {
          M2.replaceWith(...S3);
          return;
        }
        let P3 = i2(M2);
        W3.insertBefore(P3[0], k4), W3.insertAfter(P3[P3.length - 1], q2);
        for (let R3 of S3)
          W3.insertBefore(P3[0], R3.clone());
        M2.remove(), P3 = i2(k4);
        let C = W3.index(k4);
        W3.nodes.splice(C, P3.length, ...o2(h2.default.selector({
          nodes: P3
        })).nodes), k4.remove(), q2.remove();
      }), E2.walkPseudos((M2) => {
        M2.value === e2 && M2.replaceWith(M2.nodes);
      }), E2.each((M2) => (0, s2.movePseudos)(M2)), E2.toString();
    }
    function n2(d2, _4) {
      let w3 = [];
      return d2.walkPseudos((y2) => {
        y2.value === e2 && w3.push({
          pseudo: y2,
          value: y2.nodes[0].toString()
        });
      }), _4.walkPseudos((y2) => {
        if (y2.value !== e2)
          return;
        let x2 = y2.nodes[0].toString(), g2 = w3.find((b5) => b5.value === x2);
        if (!g2)
          return;
        let O3 = [], A = y2.next();
        for (;A && A.type !== "combinator"; )
          O3.push(A), A = A.next();
        let E2 = A;
        g2.pseudo.parent.insertAfter(g2.pseudo, h2.default.selector({
          nodes: O3.map((b5) => b5.clone())
        })), y2.remove(), O3.forEach((b5) => b5.remove()), E2 && E2.type === "combinator" && E2.remove();
      }), [
        d2,
        _4
      ];
    }
  }(Gn3)), Gn3;
}
var Hn3 = {};
var Co;
function nu3() {
  return Co || (Co = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(t10, e2) {
      for (var r2 in e2)
        Object.defineProperty(t10, r2, {
          enumerable: true,
          get: e2[r2]
        });
    }
    a(u, {
      asClass: function() {
        return f;
      },
      default: function() {
        return s2;
      },
      formatClass: function() {
        return c2;
      }
    });
    const h2 = /* @__PURE__ */ l3(ft3()), p = /* @__PURE__ */ l3(Vi2());
    function l3(t10) {
      return t10 && t10.__esModule ? t10 : {
        default: t10
      };
    }
    function f(t10) {
      return (0, p.default)(`.${(0, h2.default)(t10)}`);
    }
    function s2(t10, e2) {
      return f(c2(t10, e2));
    }
    function c2(t10, e2) {
      return e2 === "DEFAULT" ? t10 : e2 === "-" || e2 === "-DEFAULT" ? `-${t10}` : e2.startsWith("-") ? `-${t10}${e2}` : e2.startsWith("/") ? `${t10}${e2}` : `${t10}-${e2}`;
    }
  }(Hn3)), Hn3;
}
var Jn3 = {};
var Kn3 = {};
var Xn3 = {};
var Ro3;
function Pf() {
  return Ro3 || (Ro3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return p;
      }
    });
    const a = /* @__PURE__ */ h2(pr3());
    function h2(l3) {
      return l3 && l3.__esModule ? l3 : {
        default: l3
      };
    }
    function p(l3, f = [
      [
        l3,
        [
          l3
        ]
      ]
    ], { filterDefault: s2 = false, ...c2 } = {}) {
      let t10 = (0, a.default)(l3);
      return function({ matchUtilities: e2, theme: r2 }) {
        for (let o2 of f) {
          let v3 = Array.isArray(o2[0]) ? o2 : [
            o2
          ];
          var i2;
          e2(v3.reduce((m, [n2, d2]) => Object.assign(m, {
            [n2]: (_4) => d2.reduce((w3, y2) => Array.isArray(y2) ? Object.assign(w3, {
              [y2[0]]: y2[1]
            }) : Object.assign(w3, {
              [y2]: t10(_4)
            }), {})
          }), {}), {
            ...c2,
            values: s2 ? Object.fromEntries(Object.entries((i2 = r2(l3)) !== null && i2 !== undefined ? i2 : {}).filter(([m]) => m !== "DEFAULT")) : r2(l3)
          });
        }
      };
    }
  }(Xn3)), Xn3;
}
var Zn3 = {};
var Io3;
function Ef() {
  return Io3 || (Io3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return i2;
      }
    });
    const a = /* @__PURE__ */ new Set([
      "normal",
      "reverse",
      "alternate",
      "alternate-reverse"
    ]), h2 = /* @__PURE__ */ new Set([
      "running",
      "paused"
    ]), p = /* @__PURE__ */ new Set([
      "none",
      "forwards",
      "backwards",
      "both"
    ]), l3 = /* @__PURE__ */ new Set([
      "infinite"
    ]), f = /* @__PURE__ */ new Set([
      "linear",
      "ease",
      "ease-in",
      "ease-out",
      "ease-in-out",
      "step-start",
      "step-end"
    ]), s2 = [
      "cubic-bezier",
      "steps"
    ], c2 = /\,(?![^(]*\))/g, t10 = /\ +(?![^(]*\))/g, e2 = /^(-?[\d.]+m?s)$/, r2 = /^(\d+)$/;
    function i2(o2) {
      return o2.split(c2).map((m) => {
        let n2 = m.trim(), d2 = {
          value: n2
        }, _4 = n2.split(t10), w3 = /* @__PURE__ */ new Set;
        for (let y2 of _4)
          !w3.has("DIRECTIONS") && a.has(y2) ? (d2.direction = y2, w3.add("DIRECTIONS")) : !w3.has("PLAY_STATES") && h2.has(y2) ? (d2.playState = y2, w3.add("PLAY_STATES")) : !w3.has("FILL_MODES") && p.has(y2) ? (d2.fillMode = y2, w3.add("FILL_MODES")) : !w3.has("ITERATION_COUNTS") && (l3.has(y2) || r2.test(y2)) ? (d2.iterationCount = y2, w3.add("ITERATION_COUNTS")) : !w3.has("TIMING_FUNCTION") && f.has(y2) || !w3.has("TIMING_FUNCTION") && s2.some((x2) => y2.startsWith(`${x2}(`)) ? (d2.timingFunction = y2, w3.add("TIMING_FUNCTION")) : !w3.has("DURATION") && e2.test(y2) ? (d2.duration = y2, w3.add("DURATION")) : !w3.has("DELAY") && e2.test(y2) ? (d2.delay = y2, w3.add("DELAY")) : w3.has("NAME") ? (d2.unknown || (d2.unknown = []), d2.unknown.push(y2)) : (d2.name = y2, w3.add("NAME"));
        return d2;
      });
    }
  }(Zn3)), Zn3;
}
var ei2 = {};
var Mo3;
function Tf() {
  return Mo3 || (Mo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    const a = (p) => Object.assign({}, ...Object.entries(p ?? {}).flatMap(([l3, f]) => typeof f == "object" ? Object.entries(a(f)).map(([s2, c2]) => ({
      [l3 + (s2 === "DEFAULT" ? "" : `-${s2}`)]: c2
    })) : [
      {
        [`${l3}`]: f
      }
    ])), h2 = a;
  }(ei2)), ei2;
}
var ti3 = {};
var Do2;
function iu3() {
  return Do2 || (Do2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return typeof h2 == "function" ? h2({}) : h2;
    }
  }(ti3)), ti3;
}
var Af = "3.4.10";
var Cf = {
  version: Af
};
var ri3 = {};
var qo3;
function Rf() {
  return qo3 || (qo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "removeAlphaVariables", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      h2.walkDecls((l3) => {
        if (p.includes(l3.prop)) {
          l3.remove();
          return;
        }
        for (let f of p)
          l3.value.includes(`/ var(${f})`) && (l3.value = l3.value.replace(`/ var(${f})`, ""));
      });
    }
  }(ri3)), ri3;
}
var Lo;
function If() {
  return Lo || (Lo = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(S3, P3) {
      for (var C in P3)
        Object.defineProperty(S3, C, {
          enumerable: true,
          get: P3[C]
        });
    }
    a(u, {
      variantPlugins: function() {
        return b5;
      },
      corePlugins: function() {
        return W3;
      }
    });
    const h2 = /* @__PURE__ */ O3(Ne3), p = /* @__PURE__ */ E2(Ne3), l3 = /* @__PURE__ */ O3(Be2()), f = /* @__PURE__ */ O3(Pf()), s2 = /* @__PURE__ */ O3(zi2()), c2 = /* @__PURE__ */ O3(ft3()), t10 = /* @__PURE__ */ O3(Ef()), e2 = /* @__PURE__ */ O3(Tf()), r2 = /* @__PURE__ */ E2(hr3()), i2 = /* @__PURE__ */ O3(iu3()), o2 = /* @__PURE__ */ O3(ut3()), v3 = /* @__PURE__ */ O3(pr3()), m = Cf, n2 = /* @__PURE__ */ O3(tt3()), d2 = Ui2(), _4 = $l(), w3 = Rf(), y2 = it3(), x2 = vr3(), g2 = Ki2();
    function O3(S3) {
      return S3 && S3.__esModule ? S3 : {
        default: S3
      };
    }
    function A(S3) {
      if (typeof WeakMap != "function")
        return null;
      var P3 = /* @__PURE__ */ new WeakMap, C = /* @__PURE__ */ new WeakMap;
      return (A = function(R3) {
        return R3 ? C : P3;
      })(S3);
    }
    function E2(S3, P3) {
      if (S3 && S3.__esModule)
        return S3;
      if (S3 === null || typeof S3 != "object" && typeof S3 != "function")
        return {
          default: S3
        };
      var C = A(P3);
      if (C && C.has(S3))
        return C.get(S3);
      var R3 = {}, $3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var B3 in S3)
        if (B3 !== "default" && Object.prototype.hasOwnProperty.call(S3, B3)) {
          var z3 = $3 ? Object.getOwnPropertyDescriptor(S3, B3) : null;
          z3 && (z3.get || z3.set) ? Object.defineProperty(R3, B3, z3) : R3[B3] = S3[B3];
        }
      return R3.default = S3, C && C.set(S3, R3), R3;
    }
    let b5 = {
      childVariant: ({ addVariant: S3 }) => {
        S3("*", "& > *");
      },
      pseudoElementVariants: ({ addVariant: S3 }) => {
        S3("first-letter", "&::first-letter"), S3("first-line", "&::first-line"), S3("marker", [
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "& *::marker"),
          ({ container: P3 }) => ((0, w3.removeAlphaVariables)(P3, [
            "--tw-text-opacity"
          ]), "&::marker")
        ]), S3("selection", [
          "& *::selection",
          "&::selection"
        ]), S3("file", "&::file-selector-button"), S3("placeholder", "&::placeholder"), S3("backdrop", "&::backdrop"), S3("before", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l3.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::before")), S3("after", ({ container: P3 }) => (P3.walkRules((C) => {
          let R3 = false;
          C.walkDecls("content", () => {
            R3 = true;
          }), R3 || C.prepend(l3.default.decl({
            prop: "content",
            value: "var(--tw-content)"
          }));
        }), "&::after"));
      },
      pseudoClassVariants: ({ addVariant: S3, matchVariant: P3, config: C, prefix: R3 }) => {
        let $3 = [
          [
            "first",
            "&:first-child"
          ],
          [
            "last",
            "&:last-child"
          ],
          [
            "only",
            "&:only-child"
          ],
          [
            "odd",
            "&:nth-child(odd)"
          ],
          [
            "even",
            "&:nth-child(even)"
          ],
          "first-of-type",
          "last-of-type",
          "only-of-type",
          [
            "visited",
            ({ container: z3 }) => ((0, w3.removeAlphaVariables)(z3, [
              "--tw-text-opacity",
              "--tw-border-opacity",
              "--tw-bg-opacity"
            ]), "&:visited")
          ],
          "target",
          [
            "open",
            "&[open]"
          ],
          "default",
          "checked",
          "indeterminate",
          "placeholder-shown",
          "autofill",
          "optional",
          "required",
          "valid",
          "invalid",
          "in-range",
          "out-of-range",
          "read-only",
          "empty",
          "focus-within",
          [
            "hover",
            (0, y2.flagEnabled)(C(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"
          ],
          "focus",
          "focus-visible",
          "active",
          "enabled",
          "disabled"
        ].map((z3) => Array.isArray(z3) ? z3 : [
          z3,
          `&:${z3}`
        ]);
        for (let [z3, L3] of $3)
          S3(z3, (F) => typeof L3 == "function" ? L3(F) : L3);
        let B3 = {
          group: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".group")}\\/${(0, c2.default)(L3)})`,
            " &"
          ] : [
            `:merge(${R3(".group")})`,
            " &"
          ],
          peer: (z3, { modifier: L3 }) => L3 ? [
            `:merge(${R3(".peer")}\\/${(0, c2.default)(L3)})`,
            " ~ &"
          ] : [
            `:merge(${R3(".peer")})`,
            " ~ &"
          ]
        };
        for (let [z3, L3] of Object.entries(B3))
          P3(z3, (F = "", D) => {
            let I3 = (0, x2.normalize)(typeof F == "function" ? F(D) : F);
            I3.includes("&") || (I3 = "&" + I3);
            let [N3, J3] = L3("", D), T4 = null, U2 = null, j3 = 0;
            for (let H3 = 0;H3 < I3.length; ++H3) {
              let V4 = I3[H3];
              V4 === "&" ? T4 = H3 : V4 === "'" || V4 === '"' ? j3 += 1 : T4 !== null && V4 === " " && !j3 && (U2 = H3);
            }
            return T4 !== null && U2 === null && (U2 = I3.length), I3.slice(0, T4) + N3 + I3.slice(T4 + 1, U2) + J3 + I3.slice(U2);
          }, {
            values: Object.fromEntries($3),
            [g2.INTERNAL_FEATURES]: {
              respectPrefix: false
            }
          });
      },
      directionVariants: ({ addVariant: S3 }) => {
        S3("ltr", '&:where([dir="ltr"], [dir="ltr"] *)'), S3("rtl", '&:where([dir="rtl"], [dir="rtl"] *)');
      },
      reducedMotionVariants: ({ addVariant: S3 }) => {
        S3("motion-safe", "@media (prefers-reduced-motion: no-preference)"), S3("motion-reduce", "@media (prefers-reduced-motion: reduce)");
      },
      darkVariants: ({ config: S3, addVariant: P3 }) => {
        let [C, R3 = ".dark"] = [].concat(S3("darkMode", "media"));
        if (C === false && (C = "media", n2.default.warn("darkmode-false", [
          "The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.",
          "Change `darkMode` to `media` or remove it entirely.",
          "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"
        ])), C === "variant") {
          let $3;
          if (Array.isArray(R3) || typeof R3 == "function" ? $3 = R3 : typeof R3 == "string" && ($3 = [
            R3
          ]), Array.isArray($3))
            for (let B3 of $3)
              B3 === ".dark" ? (C = false, n2.default.warn("darkmode-variant-without-selector", [
                "When using `variant` for `darkMode`, you must provide a selector.",
                'Example: `darkMode: ["variant", ".your-selector &"]`'
              ])) : B3.includes("&") || (C = false, n2.default.warn("darkmode-variant-without-ampersand", [
                "When using `variant` for `darkMode`, your selector must contain `&`.",
                'Example `darkMode: ["variant", ".your-selector &"]`'
              ]));
          R3 = $3;
        }
        C === "selector" ? P3("dark", `&:where(${R3}, ${R3} *)`) : C === "media" ? P3("dark", "@media (prefers-color-scheme: dark)") : C === "variant" ? P3("dark", R3) : C === "class" && P3("dark", `&:is(${R3} *)`);
      },
      printVariant: ({ addVariant: S3 }) => {
        S3("print", "@media print");
      },
      screenVariants: ({ theme: S3, addVariant: P3, matchVariant: C }) => {
        var R3;
        let $3 = (R3 = S3("screens")) !== null && R3 !== undefined ? R3 : {}, B3 = Object.values($3).every((K3) => typeof K3 == "string"), z3 = (0, d2.normalizeScreens)(S3("screens")), L3 = /* @__PURE__ */ new Set([]);
        function F(K3) {
          var X3, Q3;
          return (Q3 = (X3 = K3.match(/(\D+)$/)) === null || X3 === undefined ? undefined : X3[1]) !== null && Q3 !== undefined ? Q3 : "(none)";
        }
        function D(K3) {
          K3 !== undefined && L3.add(F(K3));
        }
        function I3(K3) {
          return D(K3), L3.size === 1;
        }
        for (const K3 of z3)
          for (const X3 of K3.values)
            D(X3.min), D(X3.max);
        let N3 = L3.size <= 1;
        function J3(K3) {
          return Object.fromEntries(z3.filter((X3) => (0, d2.isScreenSortable)(X3).result).map((X3) => {
            let { min: Q3, max: ne4 } = X3.values[0];
            if (ne4 !== undefined)
              return X3;
            if (Q3 !== undefined)
              return {
                ...X3,
                not: !X3.not
              };
          }).map((X3) => [
            X3.name,
            X3
          ]));
        }
        function T4(K3) {
          return (X3, Q3) => (0, d2.compareScreens)(K3, X3.value, Q3.value);
        }
        let U2 = T4("max"), j3 = T4("min");
        function H3(K3) {
          return (X3) => {
            if (B3)
              if (N3) {
                if (typeof X3 == "string" && !I3(X3))
                  return n2.default.warn("minmax-have-mixed-units", [
                    "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                  ]), [];
              } else
                return n2.default.warn("mixed-screen-units", [
                  "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."
                ]), [];
            else
              return n2.default.warn("complex-screen-config", [
                "The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."
              ]), [];
            return [
              `@media ${(0, s2.default)((0, d2.toScreen)(X3, K3))}`
            ];
          };
        }
        C("max", H3("max"), {
          sort: U2,
          values: B3 ? J3() : {}
        });
        let V4 = "min-screens";
        for (let K3 of z3)
          P3(K3.name, `@media ${(0, s2.default)(K3)}`, {
            id: V4,
            sort: B3 && N3 ? j3 : undefined,
            value: K3
          });
        C("min", H3("min"), {
          id: V4,
          sort: j3
        });
      },
      supportsVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("supports", (R3 = "") => {
          let $3 = (0, x2.normalize)(R3), B3 = /^\w*\s*\(/.test($3);
          return $3 = B3 ? $3.replace(/\b(and|or|not)\b/g, " $1 ") : $3, B3 ? `@supports ${$3}` : ($3.includes(":") || ($3 = `${$3}: var(--tw)`), $3.startsWith("(") && $3.endsWith(")") || ($3 = `(${$3})`), `@supports ${$3}`);
        }, {
          values: (C = P3("supports")) !== null && C !== undefined ? C : {}
        });
      },
      hasVariants: ({ matchVariant: S3, prefix: P3 }) => {
        S3("has", (C) => `&:has(${(0, x2.normalize)(C)})`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("group-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".group")}\\/${R3}):has(${(0, x2.normalize)(C)}) &` : `:merge(${P3(".group")}):has(${(0, x2.normalize)(C)}) &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        }), S3("peer-has", (C, { modifier: R3 }) => R3 ? `:merge(${P3(".peer")}\\/${R3}):has(${(0, x2.normalize)(C)}) ~ &` : `:merge(${P3(".peer")}):has(${(0, x2.normalize)(C)}) ~ &`, {
          values: {},
          [g2.INTERNAL_FEATURES]: {
            respectPrefix: false
          }
        });
      },
      ariaVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("aria", (B3) => `&[aria-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}]`, {
          values: (C = P3("aria")) !== null && C !== undefined ? C : {}
        });
        var R3;
        S3("group-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[aria-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] &` : `:merge(.group)[aria-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] &`, {
          values: (R3 = P3("aria")) !== null && R3 !== undefined ? R3 : {}
        });
        var $3;
        S3("peer-aria", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[aria-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] ~ &` : `:merge(.peer)[aria-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] ~ &`, {
          values: ($3 = P3("aria")) !== null && $3 !== undefined ? $3 : {}
        });
      },
      dataVariants: ({ matchVariant: S3, theme: P3 }) => {
        var C;
        S3("data", (B3) => `&[data-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}]`, {
          values: (C = P3("data")) !== null && C !== undefined ? C : {}
        });
        var R3;
        S3("group-data", (B3, { modifier: z3 }) => z3 ? `:merge(.group\\/${z3})[data-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] &` : `:merge(.group)[data-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] &`, {
          values: (R3 = P3("data")) !== null && R3 !== undefined ? R3 : {}
        });
        var $3;
        S3("peer-data", (B3, { modifier: z3 }) => z3 ? `:merge(.peer\\/${z3})[data-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] ~ &` : `:merge(.peer)[data-${(0, x2.normalizeAttributeSelectors)((0, x2.normalize)(B3))}] ~ &`, {
          values: ($3 = P3("data")) !== null && $3 !== undefined ? $3 : {}
        });
      },
      orientationVariants: ({ addVariant: S3 }) => {
        S3("portrait", "@media (orientation: portrait)"), S3("landscape", "@media (orientation: landscape)");
      },
      prefersContrastVariants: ({ addVariant: S3 }) => {
        S3("contrast-more", "@media (prefers-contrast: more)"), S3("contrast-less", "@media (prefers-contrast: less)");
      },
      forcedColorsVariants: ({ addVariant: S3 }) => {
        S3("forced-colors", "@media (forced-colors: active)");
      }
    }, k4 = [
      "translate(var(--tw-translate-x), var(--tw-translate-y))",
      "rotate(var(--tw-rotate))",
      "skewX(var(--tw-skew-x))",
      "skewY(var(--tw-skew-y))",
      "scaleX(var(--tw-scale-x))",
      "scaleY(var(--tw-scale-y))"
    ].join(" "), q2 = [
      "var(--tw-blur)",
      "var(--tw-brightness)",
      "var(--tw-contrast)",
      "var(--tw-grayscale)",
      "var(--tw-hue-rotate)",
      "var(--tw-invert)",
      "var(--tw-saturate)",
      "var(--tw-sepia)",
      "var(--tw-drop-shadow)"
    ].join(" "), M2 = [
      "var(--tw-backdrop-blur)",
      "var(--tw-backdrop-brightness)",
      "var(--tw-backdrop-contrast)",
      "var(--tw-backdrop-grayscale)",
      "var(--tw-backdrop-hue-rotate)",
      "var(--tw-backdrop-invert)",
      "var(--tw-backdrop-opacity)",
      "var(--tw-backdrop-saturate)",
      "var(--tw-backdrop-sepia)"
    ].join(" "), W3 = {
      preflight: ({ addBase: S3 }) => {
        let P3 = l3.default.parse(h2.default.readFileSync(p.join(__dirname, "./css/preflight.css"), "utf8"));
        S3([
          l3.default.comment({
            text: `! tailwindcss v${m.version} | MIT License | https://tailwindcss.com`
          }),
          ...P3.nodes
        ]);
      },
      container: /* @__PURE__ */ (() => {
        function S3(C = []) {
          return C.flatMap((R3) => R3.values.map(($3) => $3.min)).filter((R3) => R3 !== undefined);
        }
        function P3(C, R3, $3) {
          if (typeof $3 > "u")
            return [];
          if (!(typeof $3 == "object" && $3 !== null))
            return [
              {
                screen: "DEFAULT",
                minWidth: 0,
                padding: $3
              }
            ];
          let B3 = [];
          $3.DEFAULT && B3.push({
            screen: "DEFAULT",
            minWidth: 0,
            padding: $3.DEFAULT
          });
          for (let z3 of C)
            for (let L3 of R3)
              for (let { min: F } of L3.values)
                F === z3 && B3.push({
                  minWidth: z3,
                  padding: $3[L3.name]
                });
          return B3;
        }
        return function({ addComponents: C, theme: R3 }) {
          let $3 = (0, d2.normalizeScreens)(R3("container.screens", R3("screens"))), B3 = S3($3), z3 = P3(B3, $3, R3("container.padding")), L3 = (D) => {
            let I3 = z3.find((N3) => N3.minWidth === D);
            return I3 ? {
              paddingRight: I3.padding,
              paddingLeft: I3.padding
            } : {};
          }, F = Array.from(new Set(B3.slice().sort((D, I3) => parseInt(D) - parseInt(I3)))).map((D) => ({
            [`@media (min-width: ${D})`]: {
              ".container": {
                "max-width": D,
                ...L3(D)
              }
            }
          }));
          C([
            {
              ".container": Object.assign({
                width: "100%"
              }, R3("container.center", false) ? {
                marginRight: "auto",
                marginLeft: "auto"
              } : {}, L3(0))
            },
            ...F
          ]);
        };
      })(),
      accessibility: ({ addUtilities: S3 }) => {
        S3({
          ".sr-only": {
            position: "absolute",
            width: "1px",
            height: "1px",
            padding: "0",
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0"
          },
          ".not-sr-only": {
            position: "static",
            width: "auto",
            height: "auto",
            padding: "0",
            margin: "0",
            overflow: "visible",
            clip: "auto",
            whiteSpace: "normal"
          }
        });
      },
      pointerEvents: ({ addUtilities: S3 }) => {
        S3({
          ".pointer-events-none": {
            "pointer-events": "none"
          },
          ".pointer-events-auto": {
            "pointer-events": "auto"
          }
        });
      },
      visibility: ({ addUtilities: S3 }) => {
        S3({
          ".visible": {
            visibility: "visible"
          },
          ".invisible": {
            visibility: "hidden"
          },
          ".collapse": {
            visibility: "collapse"
          }
        });
      },
      position: ({ addUtilities: S3 }) => {
        S3({
          ".static": {
            position: "static"
          },
          ".fixed": {
            position: "fixed"
          },
          ".absolute": {
            position: "absolute"
          },
          ".relative": {
            position: "relative"
          },
          ".sticky": {
            position: "sticky"
          }
        });
      },
      inset: (0, f.default)("inset", [
        [
          "inset",
          [
            "inset"
          ]
        ],
        [
          [
            "inset-x",
            [
              "left",
              "right"
            ]
          ],
          [
            "inset-y",
            [
              "top",
              "bottom"
            ]
          ]
        ],
        [
          [
            "start",
            [
              "inset-inline-start"
            ]
          ],
          [
            "end",
            [
              "inset-inline-end"
            ]
          ],
          [
            "top",
            [
              "top"
            ]
          ],
          [
            "right",
            [
              "right"
            ]
          ],
          [
            "bottom",
            [
              "bottom"
            ]
          ],
          [
            "left",
            [
              "left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      isolation: ({ addUtilities: S3 }) => {
        S3({
          ".isolate": {
            isolation: "isolate"
          },
          ".isolation-auto": {
            isolation: "auto"
          }
        });
      },
      zIndex: (0, f.default)("zIndex", [
        [
          "z",
          [
            "zIndex"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      order: (0, f.default)("order", undefined, {
        supportsNegativeValues: true
      }),
      gridColumn: (0, f.default)("gridColumn", [
        [
          "col",
          [
            "gridColumn"
          ]
        ]
      ]),
      gridColumnStart: (0, f.default)("gridColumnStart", [
        [
          "col-start",
          [
            "gridColumnStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridColumnEnd: (0, f.default)("gridColumnEnd", [
        [
          "col-end",
          [
            "gridColumnEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRow: (0, f.default)("gridRow", [
        [
          "row",
          [
            "gridRow"
          ]
        ]
      ]),
      gridRowStart: (0, f.default)("gridRowStart", [
        [
          "row-start",
          [
            "gridRowStart"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      gridRowEnd: (0, f.default)("gridRowEnd", [
        [
          "row-end",
          [
            "gridRowEnd"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      float: ({ addUtilities: S3 }) => {
        S3({
          ".float-start": {
            float: "inline-start"
          },
          ".float-end": {
            float: "inline-end"
          },
          ".float-right": {
            float: "right"
          },
          ".float-left": {
            float: "left"
          },
          ".float-none": {
            float: "none"
          }
        });
      },
      clear: ({ addUtilities: S3 }) => {
        S3({
          ".clear-start": {
            clear: "inline-start"
          },
          ".clear-end": {
            clear: "inline-end"
          },
          ".clear-left": {
            clear: "left"
          },
          ".clear-right": {
            clear: "right"
          },
          ".clear-both": {
            clear: "both"
          },
          ".clear-none": {
            clear: "none"
          }
        });
      },
      margin: (0, f.default)("margin", [
        [
          "m",
          [
            "margin"
          ]
        ],
        [
          [
            "mx",
            [
              "margin-left",
              "margin-right"
            ]
          ],
          [
            "my",
            [
              "margin-top",
              "margin-bottom"
            ]
          ]
        ],
        [
          [
            "ms",
            [
              "margin-inline-start"
            ]
          ],
          [
            "me",
            [
              "margin-inline-end"
            ]
          ],
          [
            "mt",
            [
              "margin-top"
            ]
          ],
          [
            "mr",
            [
              "margin-right"
            ]
          ],
          [
            "mb",
            [
              "margin-bottom"
            ]
          ],
          [
            "ml",
            [
              "margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      boxSizing: ({ addUtilities: S3 }) => {
        S3({
          ".box-border": {
            "box-sizing": "border-box"
          },
          ".box-content": {
            "box-sizing": "content-box"
          }
        });
      },
      lineClamp: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "line-clamp": (R3) => ({
            overflow: "hidden",
            display: "-webkit-box",
            "-webkit-box-orient": "vertical",
            "-webkit-line-clamp": `${R3}`
          })
        }, {
          values: C("lineClamp")
        }), P3({
          ".line-clamp-none": {
            overflow: "visible",
            display: "block",
            "-webkit-box-orient": "horizontal",
            "-webkit-line-clamp": "none"
          }
        });
      },
      display: ({ addUtilities: S3 }) => {
        S3({
          ".block": {
            display: "block"
          },
          ".inline-block": {
            display: "inline-block"
          },
          ".inline": {
            display: "inline"
          },
          ".flex": {
            display: "flex"
          },
          ".inline-flex": {
            display: "inline-flex"
          },
          ".table": {
            display: "table"
          },
          ".inline-table": {
            display: "inline-table"
          },
          ".table-caption": {
            display: "table-caption"
          },
          ".table-cell": {
            display: "table-cell"
          },
          ".table-column": {
            display: "table-column"
          },
          ".table-column-group": {
            display: "table-column-group"
          },
          ".table-footer-group": {
            display: "table-footer-group"
          },
          ".table-header-group": {
            display: "table-header-group"
          },
          ".table-row-group": {
            display: "table-row-group"
          },
          ".table-row": {
            display: "table-row"
          },
          ".flow-root": {
            display: "flow-root"
          },
          ".grid": {
            display: "grid"
          },
          ".inline-grid": {
            display: "inline-grid"
          },
          ".contents": {
            display: "contents"
          },
          ".list-item": {
            display: "list-item"
          },
          ".hidden": {
            display: "none"
          }
        });
      },
      aspectRatio: (0, f.default)("aspectRatio", [
        [
          "aspect",
          [
            "aspect-ratio"
          ]
        ]
      ]),
      size: (0, f.default)("size", [
        [
          "size",
          [
            "width",
            "height"
          ]
        ]
      ]),
      height: (0, f.default)("height", [
        [
          "h",
          [
            "height"
          ]
        ]
      ]),
      maxHeight: (0, f.default)("maxHeight", [
        [
          "max-h",
          [
            "maxHeight"
          ]
        ]
      ]),
      minHeight: (0, f.default)("minHeight", [
        [
          "min-h",
          [
            "minHeight"
          ]
        ]
      ]),
      width: (0, f.default)("width", [
        [
          "w",
          [
            "width"
          ]
        ]
      ]),
      minWidth: (0, f.default)("minWidth", [
        [
          "min-w",
          [
            "minWidth"
          ]
        ]
      ]),
      maxWidth: (0, f.default)("maxWidth", [
        [
          "max-w",
          [
            "maxWidth"
          ]
        ]
      ]),
      flex: (0, f.default)("flex"),
      flexShrink: (0, f.default)("flexShrink", [
        [
          "flex-shrink",
          [
            "flex-shrink"
          ]
        ],
        [
          "shrink",
          [
            "flex-shrink"
          ]
        ]
      ]),
      flexGrow: (0, f.default)("flexGrow", [
        [
          "flex-grow",
          [
            "flex-grow"
          ]
        ],
        [
          "grow",
          [
            "flex-grow"
          ]
        ]
      ]),
      flexBasis: (0, f.default)("flexBasis", [
        [
          "basis",
          [
            "flex-basis"
          ]
        ]
      ]),
      tableLayout: ({ addUtilities: S3 }) => {
        S3({
          ".table-auto": {
            "table-layout": "auto"
          },
          ".table-fixed": {
            "table-layout": "fixed"
          }
        });
      },
      captionSide: ({ addUtilities: S3 }) => {
        S3({
          ".caption-top": {
            "caption-side": "top"
          },
          ".caption-bottom": {
            "caption-side": "bottom"
          }
        });
      },
      borderCollapse: ({ addUtilities: S3 }) => {
        S3({
          ".border-collapse": {
            "border-collapse": "collapse"
          },
          ".border-separate": {
            "border-collapse": "separate"
          }
        });
      },
      borderSpacing: ({ addDefaults: S3, matchUtilities: P3, theme: C }) => {
        S3("border-spacing", {
          "--tw-border-spacing-x": 0,
          "--tw-border-spacing-y": 0
        }), P3({
          "border-spacing": (R3) => ({
            "--tw-border-spacing-x": R3,
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-x": (R3) => ({
            "--tw-border-spacing-x": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          }),
          "border-spacing-y": (R3) => ({
            "--tw-border-spacing-y": R3,
            "@defaults border-spacing": {},
            "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)"
          })
        }, {
          values: C("borderSpacing")
        });
      },
      transformOrigin: (0, f.default)("transformOrigin", [
        [
          "origin",
          [
            "transformOrigin"
          ]
        ]
      ]),
      translate: (0, f.default)("translate", [
        [
          [
            "translate-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-x",
              [
                "transform",
                k4
              ]
            ]
          ],
          [
            "translate-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-translate-y",
              [
                "transform",
                k4
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      rotate: (0, f.default)("rotate", [
        [
          "rotate",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-rotate",
            [
              "transform",
              k4
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      skew: (0, f.default)("skew", [
        [
          [
            "skew-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-x",
              [
                "transform",
                k4
              ]
            ]
          ],
          [
            "skew-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-skew-y",
              [
                "transform",
                k4
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scale: (0, f.default)("scale", [
        [
          "scale",
          [
            [
              "@defaults transform",
              {}
            ],
            "--tw-scale-x",
            "--tw-scale-y",
            [
              "transform",
              k4
            ]
          ]
        ],
        [
          [
            "scale-x",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-x",
              [
                "transform",
                k4
              ]
            ]
          ],
          [
            "scale-y",
            [
              [
                "@defaults transform",
                {}
              ],
              "--tw-scale-y",
              [
                "transform",
                k4
              ]
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      transform: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("transform", {
          "--tw-translate-x": "0",
          "--tw-translate-y": "0",
          "--tw-rotate": "0",
          "--tw-skew-x": "0",
          "--tw-skew-y": "0",
          "--tw-scale-x": "1",
          "--tw-scale-y": "1"
        }), P3({
          ".transform": {
            "@defaults transform": {},
            transform: k4
          },
          ".transform-cpu": {
            transform: k4
          },
          ".transform-gpu": {
            transform: k4.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)")
          },
          ".transform-none": {
            transform: "none"
          }
        });
      },
      animation: ({ matchUtilities: S3, theme: P3, config: C }) => {
        let R3 = (z3) => (0, c2.default)(C("prefix") + z3);
        var $3;
        let B3 = Object.fromEntries(Object.entries(($3 = P3("keyframes")) !== null && $3 !== undefined ? $3 : {}).map(([z3, L3]) => [
          z3,
          {
            [`@keyframes ${R3(z3)}`]: L3
          }
        ]));
        S3({
          animate: (z3) => {
            let L3 = (0, t10.default)(z3);
            return [
              ...L3.flatMap((F) => B3[F.name]),
              {
                animation: L3.map(({ name: F, value: D }) => F === undefined || B3[F] === undefined ? D : D.replace(F, R3(F))).join(", ")
              }
            ];
          }
        }, {
          values: P3("animation")
        });
      },
      cursor: (0, f.default)("cursor"),
      touchAction: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("touch-action", {
          "--tw-pan-x": " ",
          "--tw-pan-y": " ",
          "--tw-pinch-zoom": " "
        });
        let C = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
        P3({
          ".touch-auto": {
            "touch-action": "auto"
          },
          ".touch-none": {
            "touch-action": "none"
          },
          ".touch-pan-x": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-x",
            "touch-action": C
          },
          ".touch-pan-left": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-left",
            "touch-action": C
          },
          ".touch-pan-right": {
            "@defaults touch-action": {},
            "--tw-pan-x": "pan-right",
            "touch-action": C
          },
          ".touch-pan-y": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-y",
            "touch-action": C
          },
          ".touch-pan-up": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-up",
            "touch-action": C
          },
          ".touch-pan-down": {
            "@defaults touch-action": {},
            "--tw-pan-y": "pan-down",
            "touch-action": C
          },
          ".touch-pinch-zoom": {
            "@defaults touch-action": {},
            "--tw-pinch-zoom": "pinch-zoom",
            "touch-action": C
          },
          ".touch-manipulation": {
            "touch-action": "manipulation"
          }
        });
      },
      userSelect: ({ addUtilities: S3 }) => {
        S3({
          ".select-none": {
            "user-select": "none"
          },
          ".select-text": {
            "user-select": "text"
          },
          ".select-all": {
            "user-select": "all"
          },
          ".select-auto": {
            "user-select": "auto"
          }
        });
      },
      resize: ({ addUtilities: S3 }) => {
        S3({
          ".resize-none": {
            resize: "none"
          },
          ".resize-y": {
            resize: "vertical"
          },
          ".resize-x": {
            resize: "horizontal"
          },
          ".resize": {
            resize: "both"
          }
        });
      },
      scrollSnapType: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("scroll-snap-type", {
          "--tw-scroll-snap-strictness": "proximity"
        }), P3({
          ".snap-none": {
            "scroll-snap-type": "none"
          },
          ".snap-x": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "x var(--tw-scroll-snap-strictness)"
          },
          ".snap-y": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "y var(--tw-scroll-snap-strictness)"
          },
          ".snap-both": {
            "@defaults scroll-snap-type": {},
            "scroll-snap-type": "both var(--tw-scroll-snap-strictness)"
          },
          ".snap-mandatory": {
            "--tw-scroll-snap-strictness": "mandatory"
          },
          ".snap-proximity": {
            "--tw-scroll-snap-strictness": "proximity"
          }
        });
      },
      scrollSnapAlign: ({ addUtilities: S3 }) => {
        S3({
          ".snap-start": {
            "scroll-snap-align": "start"
          },
          ".snap-end": {
            "scroll-snap-align": "end"
          },
          ".snap-center": {
            "scroll-snap-align": "center"
          },
          ".snap-align-none": {
            "scroll-snap-align": "none"
          }
        });
      },
      scrollSnapStop: ({ addUtilities: S3 }) => {
        S3({
          ".snap-normal": {
            "scroll-snap-stop": "normal"
          },
          ".snap-always": {
            "scroll-snap-stop": "always"
          }
        });
      },
      scrollMargin: (0, f.default)("scrollMargin", [
        [
          "scroll-m",
          [
            "scroll-margin"
          ]
        ],
        [
          [
            "scroll-mx",
            [
              "scroll-margin-left",
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-my",
            [
              "scroll-margin-top",
              "scroll-margin-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ms",
            [
              "scroll-margin-inline-start"
            ]
          ],
          [
            "scroll-me",
            [
              "scroll-margin-inline-end"
            ]
          ],
          [
            "scroll-mt",
            [
              "scroll-margin-top"
            ]
          ],
          [
            "scroll-mr",
            [
              "scroll-margin-right"
            ]
          ],
          [
            "scroll-mb",
            [
              "scroll-margin-bottom"
            ]
          ],
          [
            "scroll-ml",
            [
              "scroll-margin-left"
            ]
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      scrollPadding: (0, f.default)("scrollPadding", [
        [
          "scroll-p",
          [
            "scroll-padding"
          ]
        ],
        [
          [
            "scroll-px",
            [
              "scroll-padding-left",
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-py",
            [
              "scroll-padding-top",
              "scroll-padding-bottom"
            ]
          ]
        ],
        [
          [
            "scroll-ps",
            [
              "scroll-padding-inline-start"
            ]
          ],
          [
            "scroll-pe",
            [
              "scroll-padding-inline-end"
            ]
          ],
          [
            "scroll-pt",
            [
              "scroll-padding-top"
            ]
          ],
          [
            "scroll-pr",
            [
              "scroll-padding-right"
            ]
          ],
          [
            "scroll-pb",
            [
              "scroll-padding-bottom"
            ]
          ],
          [
            "scroll-pl",
            [
              "scroll-padding-left"
            ]
          ]
        ]
      ]),
      listStylePosition: ({ addUtilities: S3 }) => {
        S3({
          ".list-inside": {
            "list-style-position": "inside"
          },
          ".list-outside": {
            "list-style-position": "outside"
          }
        });
      },
      listStyleType: (0, f.default)("listStyleType", [
        [
          "list",
          [
            "listStyleType"
          ]
        ]
      ]),
      listStyleImage: (0, f.default)("listStyleImage", [
        [
          "list-image",
          [
            "listStyleImage"
          ]
        ]
      ]),
      appearance: ({ addUtilities: S3 }) => {
        S3({
          ".appearance-none": {
            appearance: "none"
          },
          ".appearance-auto": {
            appearance: "auto"
          }
        });
      },
      columns: (0, f.default)("columns", [
        [
          "columns",
          [
            "columns"
          ]
        ]
      ]),
      breakBefore: ({ addUtilities: S3 }) => {
        S3({
          ".break-before-auto": {
            "break-before": "auto"
          },
          ".break-before-avoid": {
            "break-before": "avoid"
          },
          ".break-before-all": {
            "break-before": "all"
          },
          ".break-before-avoid-page": {
            "break-before": "avoid-page"
          },
          ".break-before-page": {
            "break-before": "page"
          },
          ".break-before-left": {
            "break-before": "left"
          },
          ".break-before-right": {
            "break-before": "right"
          },
          ".break-before-column": {
            "break-before": "column"
          }
        });
      },
      breakInside: ({ addUtilities: S3 }) => {
        S3({
          ".break-inside-auto": {
            "break-inside": "auto"
          },
          ".break-inside-avoid": {
            "break-inside": "avoid"
          },
          ".break-inside-avoid-page": {
            "break-inside": "avoid-page"
          },
          ".break-inside-avoid-column": {
            "break-inside": "avoid-column"
          }
        });
      },
      breakAfter: ({ addUtilities: S3 }) => {
        S3({
          ".break-after-auto": {
            "break-after": "auto"
          },
          ".break-after-avoid": {
            "break-after": "avoid"
          },
          ".break-after-all": {
            "break-after": "all"
          },
          ".break-after-avoid-page": {
            "break-after": "avoid-page"
          },
          ".break-after-page": {
            "break-after": "page"
          },
          ".break-after-left": {
            "break-after": "left"
          },
          ".break-after-right": {
            "break-after": "right"
          },
          ".break-after-column": {
            "break-after": "column"
          }
        });
      },
      gridAutoColumns: (0, f.default)("gridAutoColumns", [
        [
          "auto-cols",
          [
            "gridAutoColumns"
          ]
        ]
      ]),
      gridAutoFlow: ({ addUtilities: S3 }) => {
        S3({
          ".grid-flow-row": {
            gridAutoFlow: "row"
          },
          ".grid-flow-col": {
            gridAutoFlow: "column"
          },
          ".grid-flow-dense": {
            gridAutoFlow: "dense"
          },
          ".grid-flow-row-dense": {
            gridAutoFlow: "row dense"
          },
          ".grid-flow-col-dense": {
            gridAutoFlow: "column dense"
          }
        });
      },
      gridAutoRows: (0, f.default)("gridAutoRows", [
        [
          "auto-rows",
          [
            "gridAutoRows"
          ]
        ]
      ]),
      gridTemplateColumns: (0, f.default)("gridTemplateColumns", [
        [
          "grid-cols",
          [
            "gridTemplateColumns"
          ]
        ]
      ]),
      gridTemplateRows: (0, f.default)("gridTemplateRows", [
        [
          "grid-rows",
          [
            "gridTemplateRows"
          ]
        ]
      ]),
      flexDirection: ({ addUtilities: S3 }) => {
        S3({
          ".flex-row": {
            "flex-direction": "row"
          },
          ".flex-row-reverse": {
            "flex-direction": "row-reverse"
          },
          ".flex-col": {
            "flex-direction": "column"
          },
          ".flex-col-reverse": {
            "flex-direction": "column-reverse"
          }
        });
      },
      flexWrap: ({ addUtilities: S3 }) => {
        S3({
          ".flex-wrap": {
            "flex-wrap": "wrap"
          },
          ".flex-wrap-reverse": {
            "flex-wrap": "wrap-reverse"
          },
          ".flex-nowrap": {
            "flex-wrap": "nowrap"
          }
        });
      },
      placeContent: ({ addUtilities: S3 }) => {
        S3({
          ".place-content-center": {
            "place-content": "center"
          },
          ".place-content-start": {
            "place-content": "start"
          },
          ".place-content-end": {
            "place-content": "end"
          },
          ".place-content-between": {
            "place-content": "space-between"
          },
          ".place-content-around": {
            "place-content": "space-around"
          },
          ".place-content-evenly": {
            "place-content": "space-evenly"
          },
          ".place-content-baseline": {
            "place-content": "baseline"
          },
          ".place-content-stretch": {
            "place-content": "stretch"
          }
        });
      },
      placeItems: ({ addUtilities: S3 }) => {
        S3({
          ".place-items-start": {
            "place-items": "start"
          },
          ".place-items-end": {
            "place-items": "end"
          },
          ".place-items-center": {
            "place-items": "center"
          },
          ".place-items-baseline": {
            "place-items": "baseline"
          },
          ".place-items-stretch": {
            "place-items": "stretch"
          }
        });
      },
      alignContent: ({ addUtilities: S3 }) => {
        S3({
          ".content-normal": {
            "align-content": "normal"
          },
          ".content-center": {
            "align-content": "center"
          },
          ".content-start": {
            "align-content": "flex-start"
          },
          ".content-end": {
            "align-content": "flex-end"
          },
          ".content-between": {
            "align-content": "space-between"
          },
          ".content-around": {
            "align-content": "space-around"
          },
          ".content-evenly": {
            "align-content": "space-evenly"
          },
          ".content-baseline": {
            "align-content": "baseline"
          },
          ".content-stretch": {
            "align-content": "stretch"
          }
        });
      },
      alignItems: ({ addUtilities: S3 }) => {
        S3({
          ".items-start": {
            "align-items": "flex-start"
          },
          ".items-end": {
            "align-items": "flex-end"
          },
          ".items-center": {
            "align-items": "center"
          },
          ".items-baseline": {
            "align-items": "baseline"
          },
          ".items-stretch": {
            "align-items": "stretch"
          }
        });
      },
      justifyContent: ({ addUtilities: S3 }) => {
        S3({
          ".justify-normal": {
            "justify-content": "normal"
          },
          ".justify-start": {
            "justify-content": "flex-start"
          },
          ".justify-end": {
            "justify-content": "flex-end"
          },
          ".justify-center": {
            "justify-content": "center"
          },
          ".justify-between": {
            "justify-content": "space-between"
          },
          ".justify-around": {
            "justify-content": "space-around"
          },
          ".justify-evenly": {
            "justify-content": "space-evenly"
          },
          ".justify-stretch": {
            "justify-content": "stretch"
          }
        });
      },
      justifyItems: ({ addUtilities: S3 }) => {
        S3({
          ".justify-items-start": {
            "justify-items": "start"
          },
          ".justify-items-end": {
            "justify-items": "end"
          },
          ".justify-items-center": {
            "justify-items": "center"
          },
          ".justify-items-stretch": {
            "justify-items": "stretch"
          }
        });
      },
      gap: (0, f.default)("gap", [
        [
          "gap",
          [
            "gap"
          ]
        ],
        [
          [
            "gap-x",
            [
              "columnGap"
            ]
          ],
          [
            "gap-y",
            [
              "rowGap"
            ]
          ]
        ]
      ]),
      space: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "space-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-x-reverse": "0",
              "margin-right": `calc(${R3} * var(--tw-space-x-reverse))`,
              "margin-left": `calc(${R3} * calc(1 - var(--tw-space-x-reverse)))`
            }
          }),
          "space-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-space-y-reverse": "0",
              "margin-top": `calc(${R3} * calc(1 - var(--tw-space-y-reverse)))`,
              "margin-bottom": `calc(${R3} * var(--tw-space-y-reverse))`
            }
          })
        }, {
          values: C("space"),
          supportsNegativeValues: true
        }), P3({
          ".space-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-y-reverse": "1"
          },
          ".space-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "--tw-space-x-reverse": "1"
          }
        });
      },
      divideWidth: ({ matchUtilities: S3, addUtilities: P3, theme: C }) => {
        S3({
          "divide-x": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-x-reverse": "0",
              "border-right-width": `calc(${R3} * var(--tw-divide-x-reverse))`,
              "border-left-width": `calc(${R3} * calc(1 - var(--tw-divide-x-reverse)))`
            }
          }),
          "divide-y": (R3) => (R3 = R3 === "0" ? "0px" : R3, {
            "& > :not([hidden]) ~ :not([hidden])": {
              "@defaults border-width": {},
              "--tw-divide-y-reverse": "0",
              "border-top-width": `calc(${R3} * calc(1 - var(--tw-divide-y-reverse)))`,
              "border-bottom-width": `calc(${R3} * var(--tw-divide-y-reverse))`
            }
          })
        }, {
          values: C("divideWidth"),
          type: [
            "line-width",
            "length",
            "any"
          ]
        }), P3({
          ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-y-reverse": "1"
          },
          ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": {
            "@defaults border-width": {},
            "--tw-divide-x-reverse": "1"
          }
        });
      },
      divideStyle: ({ addUtilities: S3 }) => {
        S3({
          ".divide-solid > :not([hidden]) ~ :not([hidden])": {
            "border-style": "solid"
          },
          ".divide-dashed > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dashed"
          },
          ".divide-dotted > :not([hidden]) ~ :not([hidden])": {
            "border-style": "dotted"
          },
          ".divide-double > :not([hidden]) ~ :not([hidden])": {
            "border-style": "double"
          },
          ".divide-none > :not([hidden]) ~ :not([hidden])": {
            "border-style": "none"
          }
        });
      },
      divideColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          divide: (R3) => C("divideOpacity") ? {
            "& > :not([hidden]) ~ :not([hidden])": (0, r2.default)({
              color: R3,
              property: "border-color",
              variable: "--tw-divide-opacity"
            })
          } : {
            "& > :not([hidden]) ~ :not([hidden])": {
              "border-color": (0, i2.default)(R3)
            }
          }
        }, {
          values: (({ DEFAULT: R3, ...$3 }) => $3)((0, e2.default)(P3("divideColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      divideOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "divide-opacity": (C) => ({
            "& > :not([hidden]) ~ :not([hidden])": {
              "--tw-divide-opacity": C
            }
          })
        }, {
          values: P3("divideOpacity")
        });
      },
      placeSelf: ({ addUtilities: S3 }) => {
        S3({
          ".place-self-auto": {
            "place-self": "auto"
          },
          ".place-self-start": {
            "place-self": "start"
          },
          ".place-self-end": {
            "place-self": "end"
          },
          ".place-self-center": {
            "place-self": "center"
          },
          ".place-self-stretch": {
            "place-self": "stretch"
          }
        });
      },
      alignSelf: ({ addUtilities: S3 }) => {
        S3({
          ".self-auto": {
            "align-self": "auto"
          },
          ".self-start": {
            "align-self": "flex-start"
          },
          ".self-end": {
            "align-self": "flex-end"
          },
          ".self-center": {
            "align-self": "center"
          },
          ".self-stretch": {
            "align-self": "stretch"
          },
          ".self-baseline": {
            "align-self": "baseline"
          }
        });
      },
      justifySelf: ({ addUtilities: S3 }) => {
        S3({
          ".justify-self-auto": {
            "justify-self": "auto"
          },
          ".justify-self-start": {
            "justify-self": "start"
          },
          ".justify-self-end": {
            "justify-self": "end"
          },
          ".justify-self-center": {
            "justify-self": "center"
          },
          ".justify-self-stretch": {
            "justify-self": "stretch"
          }
        });
      },
      overflow: ({ addUtilities: S3 }) => {
        S3({
          ".overflow-auto": {
            overflow: "auto"
          },
          ".overflow-hidden": {
            overflow: "hidden"
          },
          ".overflow-clip": {
            overflow: "clip"
          },
          ".overflow-visible": {
            overflow: "visible"
          },
          ".overflow-scroll": {
            overflow: "scroll"
          },
          ".overflow-x-auto": {
            "overflow-x": "auto"
          },
          ".overflow-y-auto": {
            "overflow-y": "auto"
          },
          ".overflow-x-hidden": {
            "overflow-x": "hidden"
          },
          ".overflow-y-hidden": {
            "overflow-y": "hidden"
          },
          ".overflow-x-clip": {
            "overflow-x": "clip"
          },
          ".overflow-y-clip": {
            "overflow-y": "clip"
          },
          ".overflow-x-visible": {
            "overflow-x": "visible"
          },
          ".overflow-y-visible": {
            "overflow-y": "visible"
          },
          ".overflow-x-scroll": {
            "overflow-x": "scroll"
          },
          ".overflow-y-scroll": {
            "overflow-y": "scroll"
          }
        });
      },
      overscrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".overscroll-auto": {
            "overscroll-behavior": "auto"
          },
          ".overscroll-contain": {
            "overscroll-behavior": "contain"
          },
          ".overscroll-none": {
            "overscroll-behavior": "none"
          },
          ".overscroll-y-auto": {
            "overscroll-behavior-y": "auto"
          },
          ".overscroll-y-contain": {
            "overscroll-behavior-y": "contain"
          },
          ".overscroll-y-none": {
            "overscroll-behavior-y": "none"
          },
          ".overscroll-x-auto": {
            "overscroll-behavior-x": "auto"
          },
          ".overscroll-x-contain": {
            "overscroll-behavior-x": "contain"
          },
          ".overscroll-x-none": {
            "overscroll-behavior-x": "none"
          }
        });
      },
      scrollBehavior: ({ addUtilities: S3 }) => {
        S3({
          ".scroll-auto": {
            "scroll-behavior": "auto"
          },
          ".scroll-smooth": {
            "scroll-behavior": "smooth"
          }
        });
      },
      textOverflow: ({ addUtilities: S3 }) => {
        S3({
          ".truncate": {
            overflow: "hidden",
            "text-overflow": "ellipsis",
            "white-space": "nowrap"
          },
          ".overflow-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-ellipsis": {
            "text-overflow": "ellipsis"
          },
          ".text-clip": {
            "text-overflow": "clip"
          }
        });
      },
      hyphens: ({ addUtilities: S3 }) => {
        S3({
          ".hyphens-none": {
            hyphens: "none"
          },
          ".hyphens-manual": {
            hyphens: "manual"
          },
          ".hyphens-auto": {
            hyphens: "auto"
          }
        });
      },
      whitespace: ({ addUtilities: S3 }) => {
        S3({
          ".whitespace-normal": {
            "white-space": "normal"
          },
          ".whitespace-nowrap": {
            "white-space": "nowrap"
          },
          ".whitespace-pre": {
            "white-space": "pre"
          },
          ".whitespace-pre-line": {
            "white-space": "pre-line"
          },
          ".whitespace-pre-wrap": {
            "white-space": "pre-wrap"
          },
          ".whitespace-break-spaces": {
            "white-space": "break-spaces"
          }
        });
      },
      textWrap: ({ addUtilities: S3 }) => {
        S3({
          ".text-wrap": {
            "text-wrap": "wrap"
          },
          ".text-nowrap": {
            "text-wrap": "nowrap"
          },
          ".text-balance": {
            "text-wrap": "balance"
          },
          ".text-pretty": {
            "text-wrap": "pretty"
          }
        });
      },
      wordBreak: ({ addUtilities: S3 }) => {
        S3({
          ".break-normal": {
            "overflow-wrap": "normal",
            "word-break": "normal"
          },
          ".break-words": {
            "overflow-wrap": "break-word"
          },
          ".break-all": {
            "word-break": "break-all"
          },
          ".break-keep": {
            "word-break": "keep-all"
          }
        });
      },
      borderRadius: (0, f.default)("borderRadius", [
        [
          "rounded",
          [
            "border-radius"
          ]
        ],
        [
          [
            "rounded-s",
            [
              "border-start-start-radius",
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-e",
            [
              "border-start-end-radius",
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-t",
            [
              "border-top-left-radius",
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-r",
            [
              "border-top-right-radius",
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-b",
            [
              "border-bottom-right-radius",
              "border-bottom-left-radius"
            ]
          ],
          [
            "rounded-l",
            [
              "border-top-left-radius",
              "border-bottom-left-radius"
            ]
          ]
        ],
        [
          [
            "rounded-ss",
            [
              "border-start-start-radius"
            ]
          ],
          [
            "rounded-se",
            [
              "border-start-end-radius"
            ]
          ],
          [
            "rounded-ee",
            [
              "border-end-end-radius"
            ]
          ],
          [
            "rounded-es",
            [
              "border-end-start-radius"
            ]
          ],
          [
            "rounded-tl",
            [
              "border-top-left-radius"
            ]
          ],
          [
            "rounded-tr",
            [
              "border-top-right-radius"
            ]
          ],
          [
            "rounded-br",
            [
              "border-bottom-right-radius"
            ]
          ],
          [
            "rounded-bl",
            [
              "border-bottom-left-radius"
            ]
          ]
        ]
      ]),
      borderWidth: (0, f.default)("borderWidth", [
        [
          "border",
          [
            [
              "@defaults border-width",
              {}
            ],
            "border-width"
          ]
        ],
        [
          [
            "border-x",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width",
              "border-right-width"
            ]
          ],
          [
            "border-y",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width",
              "border-bottom-width"
            ]
          ]
        ],
        [
          [
            "border-s",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-start-width"
            ]
          ],
          [
            "border-e",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-inline-end-width"
            ]
          ],
          [
            "border-t",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-top-width"
            ]
          ],
          [
            "border-r",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-right-width"
            ]
          ],
          [
            "border-b",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-bottom-width"
            ]
          ],
          [
            "border-l",
            [
              [
                "@defaults border-width",
                {}
              ],
              "border-left-width"
            ]
          ]
        ]
      ], {
        type: [
          "line-width",
          "length"
        ]
      }),
      borderStyle: ({ addUtilities: S3 }) => {
        S3({
          ".border-solid": {
            "border-style": "solid"
          },
          ".border-dashed": {
            "border-style": "dashed"
          },
          ".border-dotted": {
            "border-style": "dotted"
          },
          ".border-double": {
            "border-style": "double"
          },
          ".border-hidden": {
            "border-style": "hidden"
          },
          ".border-none": {
            "border-style": "none"
          }
        });
      },
      borderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          border: (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-color": (0, i2.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$3 }) => $3)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-x": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-left-color",
              "border-right-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i2.default)(R3),
            "border-right-color": (0, i2.default)(R3)
          },
          "border-y": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: [
              "border-top-color",
              "border-bottom-color"
            ],
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i2.default)(R3),
            "border-bottom-color": (0, i2.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$3 }) => $3)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        }), S3({
          "border-s": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-start-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-start-color": (0, i2.default)(R3)
          },
          "border-e": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-inline-end-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-inline-end-color": (0, i2.default)(R3)
          },
          "border-t": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-top-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-top-color": (0, i2.default)(R3)
          },
          "border-r": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-right-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-right-color": (0, i2.default)(R3)
          },
          "border-b": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-bottom-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-bottom-color": (0, i2.default)(R3)
          },
          "border-l": (R3) => C("borderOpacity") ? (0, r2.default)({
            color: R3,
            property: "border-left-color",
            variable: "--tw-border-opacity"
          }) : {
            "border-left-color": (0, i2.default)(R3)
          }
        }, {
          values: (({ DEFAULT: R3, ...$3 }) => $3)((0, e2.default)(P3("borderColor"))),
          type: [
            "color",
            "any"
          ]
        });
      },
      borderOpacity: (0, f.default)("borderOpacity", [
        [
          "border-opacity",
          [
            "--tw-border-opacity"
          ]
        ]
      ]),
      backgroundColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          bg: (R3) => C("backgroundOpacity") ? (0, r2.default)({
            color: R3,
            property: "background-color",
            variable: "--tw-bg-opacity"
          }) : {
            "background-color": (0, i2.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("backgroundColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      backgroundOpacity: (0, f.default)("backgroundOpacity", [
        [
          "bg-opacity",
          [
            "--tw-bg-opacity"
          ]
        ]
      ]),
      backgroundImage: (0, f.default)("backgroundImage", [
        [
          "bg",
          [
            "background-image"
          ]
        ]
      ], {
        type: [
          "lookup",
          "image",
          "url"
        ]
      }),
      gradientColorStops: /* @__PURE__ */ (() => {
        function S3(P3) {
          return (0, r2.withAlphaValue)(P3, 0, "rgb(255 255 255 / 0)");
        }
        return function({ matchUtilities: P3, theme: C, addDefaults: R3 }) {
          R3("gradient-color-stops", {
            "--tw-gradient-from-position": " ",
            "--tw-gradient-via-position": " ",
            "--tw-gradient-to-position": " "
          });
          let $3 = {
            values: (0, e2.default)(C("gradientColorStops")),
            type: [
              "color",
              "any"
            ]
          }, B3 = {
            values: C("gradientColorStopPositions"),
            type: [
              "length",
              "percentage"
            ]
          };
          P3({
            from: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-from": `${(0, i2.default)(z3)} var(--tw-gradient-from-position)`,
                "--tw-gradient-to": `${L3} var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)"
              };
            }
          }, $3), P3({
            from: (z3) => ({
              "--tw-gradient-from-position": z3
            })
          }, B3), P3({
            via: (z3) => {
              let L3 = S3(z3);
              return {
                "@defaults gradient-color-stops": {},
                "--tw-gradient-to": `${L3}  var(--tw-gradient-to-position)`,
                "--tw-gradient-stops": `var(--tw-gradient-from), ${(0, i2.default)(z3)} var(--tw-gradient-via-position), var(--tw-gradient-to)`
              };
            }
          }, $3), P3({
            via: (z3) => ({
              "--tw-gradient-via-position": z3
            })
          }, B3), P3({
            to: (z3) => ({
              "@defaults gradient-color-stops": {},
              "--tw-gradient-to": `${(0, i2.default)(z3)} var(--tw-gradient-to-position)`
            })
          }, $3), P3({
            to: (z3) => ({
              "--tw-gradient-to-position": z3
            })
          }, B3);
        };
      })(),
      boxDecorationBreak: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".decoration-clone": {
            "box-decoration-break": "clone"
          },
          ".box-decoration-slice": {
            "box-decoration-break": "slice"
          },
          ".box-decoration-clone": {
            "box-decoration-break": "clone"
          }
        });
      },
      backgroundSize: (0, f.default)("backgroundSize", [
        [
          "bg",
          [
            "background-size"
          ]
        ]
      ], {
        type: [
          "lookup",
          "length",
          "percentage",
          "size"
        ]
      }),
      backgroundAttachment: ({ addUtilities: S3 }) => {
        S3({
          ".bg-fixed": {
            "background-attachment": "fixed"
          },
          ".bg-local": {
            "background-attachment": "local"
          },
          ".bg-scroll": {
            "background-attachment": "scroll"
          }
        });
      },
      backgroundClip: ({ addUtilities: S3 }) => {
        S3({
          ".bg-clip-border": {
            "background-clip": "border-box"
          },
          ".bg-clip-padding": {
            "background-clip": "padding-box"
          },
          ".bg-clip-content": {
            "background-clip": "content-box"
          },
          ".bg-clip-text": {
            "background-clip": "text"
          }
        });
      },
      backgroundPosition: (0, f.default)("backgroundPosition", [
        [
          "bg",
          [
            "background-position"
          ]
        ]
      ], {
        type: [
          "lookup",
          [
            "position",
            {
              preferOnConflict: true
            }
          ]
        ]
      }),
      backgroundRepeat: ({ addUtilities: S3 }) => {
        S3({
          ".bg-repeat": {
            "background-repeat": "repeat"
          },
          ".bg-no-repeat": {
            "background-repeat": "no-repeat"
          },
          ".bg-repeat-x": {
            "background-repeat": "repeat-x"
          },
          ".bg-repeat-y": {
            "background-repeat": "repeat-y"
          },
          ".bg-repeat-round": {
            "background-repeat": "round"
          },
          ".bg-repeat-space": {
            "background-repeat": "space"
          }
        });
      },
      backgroundOrigin: ({ addUtilities: S3 }) => {
        S3({
          ".bg-origin-border": {
            "background-origin": "border-box"
          },
          ".bg-origin-padding": {
            "background-origin": "padding-box"
          },
          ".bg-origin-content": {
            "background-origin": "content-box"
          }
        });
      },
      fill: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          fill: (C) => ({
            fill: (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("fill")),
          type: [
            "color",
            "any"
          ]
        });
      },
      stroke: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          stroke: (C) => ({
            stroke: (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("stroke")),
          type: [
            "color",
            "url",
            "any"
          ]
        });
      },
      strokeWidth: (0, f.default)("strokeWidth", [
        [
          "stroke",
          [
            "stroke-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      objectFit: ({ addUtilities: S3 }) => {
        S3({
          ".object-contain": {
            "object-fit": "contain"
          },
          ".object-cover": {
            "object-fit": "cover"
          },
          ".object-fill": {
            "object-fit": "fill"
          },
          ".object-none": {
            "object-fit": "none"
          },
          ".object-scale-down": {
            "object-fit": "scale-down"
          }
        });
      },
      objectPosition: (0, f.default)("objectPosition", [
        [
          "object",
          [
            "object-position"
          ]
        ]
      ]),
      padding: (0, f.default)("padding", [
        [
          "p",
          [
            "padding"
          ]
        ],
        [
          [
            "px",
            [
              "padding-left",
              "padding-right"
            ]
          ],
          [
            "py",
            [
              "padding-top",
              "padding-bottom"
            ]
          ]
        ],
        [
          [
            "ps",
            [
              "padding-inline-start"
            ]
          ],
          [
            "pe",
            [
              "padding-inline-end"
            ]
          ],
          [
            "pt",
            [
              "padding-top"
            ]
          ],
          [
            "pr",
            [
              "padding-right"
            ]
          ],
          [
            "pb",
            [
              "padding-bottom"
            ]
          ],
          [
            "pl",
            [
              "padding-left"
            ]
          ]
        ]
      ]),
      textAlign: ({ addUtilities: S3 }) => {
        S3({
          ".text-left": {
            "text-align": "left"
          },
          ".text-center": {
            "text-align": "center"
          },
          ".text-right": {
            "text-align": "right"
          },
          ".text-justify": {
            "text-align": "justify"
          },
          ".text-start": {
            "text-align": "start"
          },
          ".text-end": {
            "text-align": "end"
          }
        });
      },
      textIndent: (0, f.default)("textIndent", [
        [
          "indent",
          [
            "text-indent"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      verticalAlign: ({ addUtilities: S3, matchUtilities: P3 }) => {
        S3({
          ".align-baseline": {
            "vertical-align": "baseline"
          },
          ".align-top": {
            "vertical-align": "top"
          },
          ".align-middle": {
            "vertical-align": "middle"
          },
          ".align-bottom": {
            "vertical-align": "bottom"
          },
          ".align-text-top": {
            "vertical-align": "text-top"
          },
          ".align-text-bottom": {
            "vertical-align": "text-bottom"
          },
          ".align-sub": {
            "vertical-align": "sub"
          },
          ".align-super": {
            "vertical-align": "super"
          }
        }), P3({
          align: (C) => ({
            "vertical-align": C
          })
        });
      },
      fontFamily: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          font: (C) => {
            let [R3, $3 = {}] = Array.isArray(C) && (0, o2.default)(C[1]) ? C : [
              C
            ], { fontFeatureSettings: B3, fontVariationSettings: z3 } = $3;
            return {
              "font-family": Array.isArray(R3) ? R3.join(", ") : R3,
              ...B3 === undefined ? {} : {
                "font-feature-settings": B3
              },
              ...z3 === undefined ? {} : {
                "font-variation-settings": z3
              }
            };
          }
        }, {
          values: P3("fontFamily"),
          type: [
            "lookup",
            "generic-name",
            "family-name"
          ]
        });
      },
      fontSize: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          text: (C, { modifier: R3 }) => {
            let [$3, B3] = Array.isArray(C) ? C : [
              C
            ];
            if (R3)
              return {
                "font-size": $3,
                "line-height": R3
              };
            let { lineHeight: z3, letterSpacing: L3, fontWeight: F } = (0, o2.default)(B3) ? B3 : {
              lineHeight: B3
            };
            return {
              "font-size": $3,
              ...z3 === undefined ? {} : {
                "line-height": z3
              },
              ...L3 === undefined ? {} : {
                "letter-spacing": L3
              },
              ...F === undefined ? {} : {
                "font-weight": F
              }
            };
          }
        }, {
          values: P3("fontSize"),
          modifiers: P3("lineHeight"),
          type: [
            "absolute-size",
            "relative-size",
            "length",
            "percentage"
          ]
        });
      },
      fontWeight: (0, f.default)("fontWeight", [
        [
          "font",
          [
            "fontWeight"
          ]
        ]
      ], {
        type: [
          "lookup",
          "number",
          "any"
        ]
      }),
      textTransform: ({ addUtilities: S3 }) => {
        S3({
          ".uppercase": {
            "text-transform": "uppercase"
          },
          ".lowercase": {
            "text-transform": "lowercase"
          },
          ".capitalize": {
            "text-transform": "capitalize"
          },
          ".normal-case": {
            "text-transform": "none"
          }
        });
      },
      fontStyle: ({ addUtilities: S3 }) => {
        S3({
          ".italic": {
            "font-style": "italic"
          },
          ".not-italic": {
            "font-style": "normal"
          }
        });
      },
      fontVariantNumeric: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
        S3("font-variant-numeric", {
          "--tw-ordinal": " ",
          "--tw-slashed-zero": " ",
          "--tw-numeric-figure": " ",
          "--tw-numeric-spacing": " ",
          "--tw-numeric-fraction": " "
        }), P3({
          ".normal-nums": {
            "font-variant-numeric": "normal"
          },
          ".ordinal": {
            "@defaults font-variant-numeric": {},
            "--tw-ordinal": "ordinal",
            "font-variant-numeric": C
          },
          ".slashed-zero": {
            "@defaults font-variant-numeric": {},
            "--tw-slashed-zero": "slashed-zero",
            "font-variant-numeric": C
          },
          ".lining-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "lining-nums",
            "font-variant-numeric": C
          },
          ".oldstyle-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-figure": "oldstyle-nums",
            "font-variant-numeric": C
          },
          ".proportional-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "proportional-nums",
            "font-variant-numeric": C
          },
          ".tabular-nums": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-spacing": "tabular-nums",
            "font-variant-numeric": C
          },
          ".diagonal-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "diagonal-fractions",
            "font-variant-numeric": C
          },
          ".stacked-fractions": {
            "@defaults font-variant-numeric": {},
            "--tw-numeric-fraction": "stacked-fractions",
            "font-variant-numeric": C
          }
        });
      },
      lineHeight: (0, f.default)("lineHeight", [
        [
          "leading",
          [
            "lineHeight"
          ]
        ]
      ]),
      letterSpacing: (0, f.default)("letterSpacing", [
        [
          "tracking",
          [
            "letterSpacing"
          ]
        ]
      ], {
        supportsNegativeValues: true
      }),
      textColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          text: (R3) => C("textOpacity") ? (0, r2.default)({
            color: R3,
            property: "color",
            variable: "--tw-text-opacity"
          }) : {
            color: (0, i2.default)(R3)
          }
        }, {
          values: (0, e2.default)(P3("textColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textOpacity: (0, f.default)("textOpacity", [
        [
          "text-opacity",
          [
            "--tw-text-opacity"
          ]
        ]
      ]),
      textDecoration: ({ addUtilities: S3 }) => {
        S3({
          ".underline": {
            "text-decoration-line": "underline"
          },
          ".overline": {
            "text-decoration-line": "overline"
          },
          ".line-through": {
            "text-decoration-line": "line-through"
          },
          ".no-underline": {
            "text-decoration-line": "none"
          }
        });
      },
      textDecorationColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          decoration: (C) => ({
            "text-decoration-color": (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("textDecorationColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      textDecorationStyle: ({ addUtilities: S3 }) => {
        S3({
          ".decoration-solid": {
            "text-decoration-style": "solid"
          },
          ".decoration-double": {
            "text-decoration-style": "double"
          },
          ".decoration-dotted": {
            "text-decoration-style": "dotted"
          },
          ".decoration-dashed": {
            "text-decoration-style": "dashed"
          },
          ".decoration-wavy": {
            "text-decoration-style": "wavy"
          }
        });
      },
      textDecorationThickness: (0, f.default)("textDecorationThickness", [
        [
          "decoration",
          [
            "text-decoration-thickness"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage"
        ]
      }),
      textUnderlineOffset: (0, f.default)("textUnderlineOffset", [
        [
          "underline-offset",
          [
            "text-underline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "percentage",
          "any"
        ]
      }),
      fontSmoothing: ({ addUtilities: S3 }) => {
        S3({
          ".antialiased": {
            "-webkit-font-smoothing": "antialiased",
            "-moz-osx-font-smoothing": "grayscale"
          },
          ".subpixel-antialiased": {
            "-webkit-font-smoothing": "auto",
            "-moz-osx-font-smoothing": "auto"
          }
        });
      },
      placeholderColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          placeholder: (R3) => C("placeholderOpacity") ? {
            "&::placeholder": (0, r2.default)({
              color: R3,
              property: "color",
              variable: "--tw-placeholder-opacity"
            })
          } : {
            "&::placeholder": {
              color: (0, i2.default)(R3)
            }
          }
        }, {
          values: (0, e2.default)(P3("placeholderColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      placeholderOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "placeholder-opacity": (C) => ({
            "&::placeholder": {
              "--tw-placeholder-opacity": C
            }
          })
        }, {
          values: P3("placeholderOpacity")
        });
      },
      caretColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          caret: (C) => ({
            "caret-color": (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("caretColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      accentColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          accent: (C) => ({
            "accent-color": (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("accentColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      opacity: (0, f.default)("opacity", [
        [
          "opacity",
          [
            "opacity"
          ]
        ]
      ]),
      backgroundBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".bg-blend-normal": {
            "background-blend-mode": "normal"
          },
          ".bg-blend-multiply": {
            "background-blend-mode": "multiply"
          },
          ".bg-blend-screen": {
            "background-blend-mode": "screen"
          },
          ".bg-blend-overlay": {
            "background-blend-mode": "overlay"
          },
          ".bg-blend-darken": {
            "background-blend-mode": "darken"
          },
          ".bg-blend-lighten": {
            "background-blend-mode": "lighten"
          },
          ".bg-blend-color-dodge": {
            "background-blend-mode": "color-dodge"
          },
          ".bg-blend-color-burn": {
            "background-blend-mode": "color-burn"
          },
          ".bg-blend-hard-light": {
            "background-blend-mode": "hard-light"
          },
          ".bg-blend-soft-light": {
            "background-blend-mode": "soft-light"
          },
          ".bg-blend-difference": {
            "background-blend-mode": "difference"
          },
          ".bg-blend-exclusion": {
            "background-blend-mode": "exclusion"
          },
          ".bg-blend-hue": {
            "background-blend-mode": "hue"
          },
          ".bg-blend-saturation": {
            "background-blend-mode": "saturation"
          },
          ".bg-blend-color": {
            "background-blend-mode": "color"
          },
          ".bg-blend-luminosity": {
            "background-blend-mode": "luminosity"
          }
        });
      },
      mixBlendMode: ({ addUtilities: S3 }) => {
        S3({
          ".mix-blend-normal": {
            "mix-blend-mode": "normal"
          },
          ".mix-blend-multiply": {
            "mix-blend-mode": "multiply"
          },
          ".mix-blend-screen": {
            "mix-blend-mode": "screen"
          },
          ".mix-blend-overlay": {
            "mix-blend-mode": "overlay"
          },
          ".mix-blend-darken": {
            "mix-blend-mode": "darken"
          },
          ".mix-blend-lighten": {
            "mix-blend-mode": "lighten"
          },
          ".mix-blend-color-dodge": {
            "mix-blend-mode": "color-dodge"
          },
          ".mix-blend-color-burn": {
            "mix-blend-mode": "color-burn"
          },
          ".mix-blend-hard-light": {
            "mix-blend-mode": "hard-light"
          },
          ".mix-blend-soft-light": {
            "mix-blend-mode": "soft-light"
          },
          ".mix-blend-difference": {
            "mix-blend-mode": "difference"
          },
          ".mix-blend-exclusion": {
            "mix-blend-mode": "exclusion"
          },
          ".mix-blend-hue": {
            "mix-blend-mode": "hue"
          },
          ".mix-blend-saturation": {
            "mix-blend-mode": "saturation"
          },
          ".mix-blend-color": {
            "mix-blend-mode": "color"
          },
          ".mix-blend-luminosity": {
            "mix-blend-mode": "luminosity"
          },
          ".mix-blend-plus-darker": {
            "mix-blend-mode": "plus-darker"
          },
          ".mix-blend-plus-lighter": {
            "mix-blend-mode": "plus-lighter"
          }
        });
      },
      boxShadow: (() => {
        let S3 = (0, v3.default)("boxShadow"), P3 = [
          "var(--tw-ring-offset-shadow, 0 0 #0000)",
          "var(--tw-ring-shadow, 0 0 #0000)",
          "var(--tw-shadow)"
        ].join(", ");
        return function({ matchUtilities: C, addDefaults: R3, theme: $3 }) {
          R3("box-shadow", {
            "--tw-ring-offset-shadow": "0 0 #0000",
            "--tw-ring-shadow": "0 0 #0000",
            "--tw-shadow": "0 0 #0000",
            "--tw-shadow-colored": "0 0 #0000"
          }), C({
            shadow: (B3) => {
              B3 = S3(B3);
              let z3 = (0, _4.parseBoxShadowValue)(B3);
              for (let L3 of z3)
                L3.valid && (L3.color = "var(--tw-shadow-color)");
              return {
                "@defaults box-shadow": {},
                "--tw-shadow": B3 === "none" ? "0 0 #0000" : B3,
                "--tw-shadow-colored": B3 === "none" ? "0 0 #0000" : (0, _4.formatBoxShadowValue)(z3),
                "box-shadow": P3
              };
            }
          }, {
            values: $3("boxShadow"),
            type: [
              "shadow"
            ]
          });
        };
      })(),
      boxShadowColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          shadow: (C) => ({
            "--tw-shadow-color": (0, i2.default)(C),
            "--tw-shadow": "var(--tw-shadow-colored)"
          })
        }, {
          values: (0, e2.default)(P3("boxShadowColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      outlineStyle: ({ addUtilities: S3 }) => {
        S3({
          ".outline-none": {
            outline: "2px solid transparent",
            "outline-offset": "2px"
          },
          ".outline": {
            "outline-style": "solid"
          },
          ".outline-dashed": {
            "outline-style": "dashed"
          },
          ".outline-dotted": {
            "outline-style": "dotted"
          },
          ".outline-double": {
            "outline-style": "double"
          }
        });
      },
      outlineWidth: (0, f.default)("outlineWidth", [
        [
          "outline",
          [
            "outline-width"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage"
        ]
      }),
      outlineOffset: (0, f.default)("outlineOffset", [
        [
          "outline-offset",
          [
            "outline-offset"
          ]
        ]
      ], {
        type: [
          "length",
          "number",
          "percentage",
          "any"
        ],
        supportsNegativeValues: true
      }),
      outlineColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          outline: (C) => ({
            "outline-color": (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("outlineColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringWidth: ({ matchUtilities: S3, addDefaults: P3, addUtilities: C, theme: R3, config: $3 }) => {
        let B3 = (() => {
          var z3, L3;
          if ((0, y2.flagEnabled)($3(), "respectDefaultRingColorOpacity"))
            return R3("ringColor.DEFAULT");
          let F = R3("ringOpacity.DEFAULT", "0.5");
          return !((z3 = R3("ringColor")) === null || z3 === undefined) && z3.DEFAULT ? (0, r2.withAlphaValue)((L3 = R3("ringColor")) === null || L3 === undefined ? undefined : L3.DEFAULT, F, `rgb(147 197 253 / ${F})`) : `rgb(147 197 253 / ${F})`;
        })();
        P3("ring-width", {
          "--tw-ring-inset": " ",
          "--tw-ring-offset-width": R3("ringOffsetWidth.DEFAULT", "0px"),
          "--tw-ring-offset-color": R3("ringOffsetColor.DEFAULT", "#fff"),
          "--tw-ring-color": B3,
          "--tw-ring-offset-shadow": "0 0 #0000",
          "--tw-ring-shadow": "0 0 #0000",
          "--tw-shadow": "0 0 #0000",
          "--tw-shadow-colored": "0 0 #0000"
        }), S3({
          ring: (z3) => ({
            "@defaults ring-width": {},
            "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)",
            "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${z3} + var(--tw-ring-offset-width)) var(--tw-ring-color)`,
            "box-shadow": [
              "var(--tw-ring-offset-shadow)",
              "var(--tw-ring-shadow)",
              "var(--tw-shadow, 0 0 #0000)"
            ].join(", ")
          })
        }, {
          values: R3("ringWidth"),
          type: "length"
        }), C({
          ".ring-inset": {
            "@defaults ring-width": {},
            "--tw-ring-inset": "inset"
          }
        });
      },
      ringColor: ({ matchUtilities: S3, theme: P3, corePlugins: C }) => {
        S3({
          ring: (R3) => C("ringOpacity") ? (0, r2.default)({
            color: R3,
            property: "--tw-ring-color",
            variable: "--tw-ring-opacity"
          }) : {
            "--tw-ring-color": (0, i2.default)(R3)
          }
        }, {
          values: Object.fromEntries(Object.entries((0, e2.default)(P3("ringColor"))).filter(([R3]) => R3 !== "DEFAULT")),
          type: [
            "color",
            "any"
          ]
        });
      },
      ringOpacity: (S3) => {
        let { config: P3 } = S3;
        return (0, f.default)("ringOpacity", [
          [
            "ring-opacity",
            [
              "--tw-ring-opacity"
            ]
          ]
        ], {
          filterDefault: !(0, y2.flagEnabled)(P3(), "respectDefaultRingColorOpacity")
        })(S3);
      },
      ringOffsetWidth: (0, f.default)("ringOffsetWidth", [
        [
          "ring-offset",
          [
            "--tw-ring-offset-width"
          ]
        ]
      ], {
        type: "length"
      }),
      ringOffsetColor: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "ring-offset": (C) => ({
            "--tw-ring-offset-color": (0, i2.default)(C)
          })
        }, {
          values: (0, e2.default)(P3("ringOffsetColor")),
          type: [
            "color",
            "any"
          ]
        });
      },
      blur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          blur: (C) => ({
            "--tw-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("blur")
        });
      },
      brightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          brightness: (C) => ({
            "--tw-brightness": `brightness(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("brightness")
        });
      },
      contrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          contrast: (C) => ({
            "--tw-contrast": `contrast(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("contrast")
        });
      },
      dropShadow: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "drop-shadow": (C) => ({
            "--tw-drop-shadow": Array.isArray(C) ? C.map((R3) => `drop-shadow(${R3})`).join(" ") : `drop-shadow(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("dropShadow")
        });
      },
      grayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          grayscale: (C) => ({
            "--tw-grayscale": `grayscale(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("grayscale")
        });
      },
      hueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "hue-rotate": (C) => ({
            "--tw-hue-rotate": `hue-rotate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("hueRotate"),
          supportsNegativeValues: true
        });
      },
      invert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          invert: (C) => ({
            "--tw-invert": `invert(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("invert")
        });
      },
      saturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          saturate: (C) => ({
            "--tw-saturate": `saturate(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("saturate")
        });
      },
      sepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          sepia: (C) => ({
            "--tw-sepia": `sepia(${C})`,
            "@defaults filter": {},
            filter: q2
          })
        }, {
          values: P3("sepia")
        });
      },
      filter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("filter", {
          "--tw-blur": " ",
          "--tw-brightness": " ",
          "--tw-contrast": " ",
          "--tw-grayscale": " ",
          "--tw-hue-rotate": " ",
          "--tw-invert": " ",
          "--tw-saturate": " ",
          "--tw-sepia": " ",
          "--tw-drop-shadow": " "
        }), P3({
          ".filter": {
            "@defaults filter": {},
            filter: q2
          },
          ".filter-none": {
            filter: "none"
          }
        });
      },
      backdropBlur: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-blur": (C) => ({
            "--tw-backdrop-blur": C.trim() === "" ? " " : `blur(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBlur")
        });
      },
      backdropBrightness: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-brightness": (C) => ({
            "--tw-backdrop-brightness": `brightness(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropBrightness")
        });
      },
      backdropContrast: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-contrast": (C) => ({
            "--tw-backdrop-contrast": `contrast(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropContrast")
        });
      },
      backdropGrayscale: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-grayscale": (C) => ({
            "--tw-backdrop-grayscale": `grayscale(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropGrayscale")
        });
      },
      backdropHueRotate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-hue-rotate": (C) => ({
            "--tw-backdrop-hue-rotate": `hue-rotate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropHueRotate"),
          supportsNegativeValues: true
        });
      },
      backdropInvert: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-invert": (C) => ({
            "--tw-backdrop-invert": `invert(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropInvert")
        });
      },
      backdropOpacity: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-opacity": (C) => ({
            "--tw-backdrop-opacity": `opacity(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropOpacity")
        });
      },
      backdropSaturate: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-saturate": (C) => ({
            "--tw-backdrop-saturate": `saturate(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSaturate")
        });
      },
      backdropSepia: ({ matchUtilities: S3, theme: P3 }) => {
        S3({
          "backdrop-sepia": (C) => ({
            "--tw-backdrop-sepia": `sepia(${C})`,
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          })
        }, {
          values: P3("backdropSepia")
        });
      },
      backdropFilter: ({ addDefaults: S3, addUtilities: P3 }) => {
        S3("backdrop-filter", {
          "--tw-backdrop-blur": " ",
          "--tw-backdrop-brightness": " ",
          "--tw-backdrop-contrast": " ",
          "--tw-backdrop-grayscale": " ",
          "--tw-backdrop-hue-rotate": " ",
          "--tw-backdrop-invert": " ",
          "--tw-backdrop-opacity": " ",
          "--tw-backdrop-saturate": " ",
          "--tw-backdrop-sepia": " "
        }), P3({
          ".backdrop-filter": {
            "@defaults backdrop-filter": {},
            "-webkit-backdrop-filter": M2,
            "backdrop-filter": M2
          },
          ".backdrop-filter-none": {
            "-webkit-backdrop-filter": "none",
            "backdrop-filter": "none"
          }
        });
      },
      transitionProperty: ({ matchUtilities: S3, theme: P3 }) => {
        let C = P3("transitionTimingFunction.DEFAULT"), R3 = P3("transitionDuration.DEFAULT");
        S3({
          transition: ($3) => ({
            "transition-property": $3,
            ...$3 === "none" ? {} : {
              "transition-timing-function": C,
              "transition-duration": R3
            }
          })
        }, {
          values: P3("transitionProperty")
        });
      },
      transitionDelay: (0, f.default)("transitionDelay", [
        [
          "delay",
          [
            "transitionDelay"
          ]
        ]
      ]),
      transitionDuration: (0, f.default)("transitionDuration", [
        [
          "duration",
          [
            "transitionDuration"
          ]
        ]
      ], {
        filterDefault: true
      }),
      transitionTimingFunction: (0, f.default)("transitionTimingFunction", [
        [
          "ease",
          [
            "transitionTimingFunction"
          ]
        ]
      ], {
        filterDefault: true
      }),
      willChange: (0, f.default)("willChange", [
        [
          "will-change",
          [
            "will-change"
          ]
        ]
      ]),
      contain: ({ addDefaults: S3, addUtilities: P3 }) => {
        let C = "var(--tw-contain-size) var(--tw-contain-layout) var(--tw-contain-paint) var(--tw-contain-style)";
        S3("contain", {
          "--tw-contain-size": " ",
          "--tw-contain-layout": " ",
          "--tw-contain-paint": " ",
          "--tw-contain-style": " "
        }), P3({
          ".contain-none": {
            contain: "none"
          },
          ".contain-content": {
            contain: "content"
          },
          ".contain-strict": {
            contain: "strict"
          },
          ".contain-size": {
            "@defaults contain": {},
            "--tw-contain-size": "size",
            contain: C
          },
          ".contain-inline-size": {
            "@defaults contain": {},
            "--tw-contain-size": "inline-size",
            contain: C
          },
          ".contain-layout": {
            "@defaults contain": {},
            "--tw-contain-layout": "layout",
            contain: C
          },
          ".contain-paint": {
            "@defaults contain": {},
            "--tw-contain-paint": "paint",
            contain: C
          },
          ".contain-style": {
            "@defaults contain": {},
            "--tw-contain-style": "style",
            contain: C
          }
        });
      },
      content: (0, f.default)("content", [
        [
          "content",
          [
            "--tw-content",
            [
              "content",
              "var(--tw-content)"
            ]
          ]
        ]
      ]),
      forcedColorAdjust: ({ addUtilities: S3 }) => {
        S3({
          ".forced-color-adjust-auto": {
            "forced-color-adjust": "auto"
          },
          ".forced-color-adjust-none": {
            "forced-color-adjust": "none"
          }
        });
      }
    };
  }(Kn3)), Kn3;
}
var ni3 = {};
var No2;
function au3() {
  return No2 || (No2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    let a = /* @__PURE__ */ new Map([
      [
        "{",
        "}"
      ],
      [
        "[",
        "]"
      ],
      [
        "(",
        ")"
      ]
    ]), h2 = new Map(Array.from(a.entries()).map(([f, s2]) => [
      s2,
      f
    ])), p = /* @__PURE__ */ new Set([
      '"',
      "'",
      "`"
    ]);
    function l3(f) {
      let s2 = [], c2 = false;
      for (let t10 = 0;t10 < f.length; t10++) {
        let e2 = f[t10];
        if (e2 === ":" && !c2 && s2.length === 0)
          return false;
        if (p.has(e2) && f[t10 - 1] !== "\\" && (c2 = !c2), !c2 && f[t10 - 1] !== "\\") {
          if (a.has(e2))
            s2.push(e2);
          else if (h2.has(e2)) {
            let r2 = h2.get(e2);
            if (s2.length <= 0 || s2.pop() !== r2)
              return false;
          }
        }
      }
      return !(s2.length > 0);
    }
  }(ni3)), ni3;
}
var ii2 = {};
var Fo2;
function Mf() {
  return Fo2 || (Fo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "hasContentChanged", {
      enumerable: true,
      get: function() {
        return c2;
      }
    });
    const a = /* @__PURE__ */ p(Ne3), h2 = /* @__PURE__ */ f(yr3());
    function p(t10) {
      return t10 && t10.__esModule ? t10 : {
        default: t10
      };
    }
    function l3(t10) {
      if (typeof WeakMap != "function")
        return null;
      var e2 = /* @__PURE__ */ new WeakMap, r2 = /* @__PURE__ */ new WeakMap;
      return (l3 = function(i2) {
        return i2 ? r2 : e2;
      })(t10);
    }
    function f(t10, e2) {
      if (t10 && t10.__esModule)
        return t10;
      if (t10 === null || typeof t10 != "object" && typeof t10 != "function")
        return {
          default: t10
        };
      var r2 = l3(e2);
      if (r2 && r2.has(t10))
        return r2.get(t10);
      var i2 = {}, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var v3 in t10)
        if (v3 !== "default" && Object.prototype.hasOwnProperty.call(t10, v3)) {
          var m = o2 ? Object.getOwnPropertyDescriptor(t10, v3) : null;
          m && (m.get || m.set) ? Object.defineProperty(i2, v3, m) : i2[v3] = t10[v3];
        }
      return i2.default = t10, r2 && r2.set(t10, i2), i2;
    }
    function s2(t10) {
      try {
        return a.default.createHash("md5").update(t10, "utf-8").digest("binary");
      } catch {
        return "";
      }
    }
    function c2(t10, e2) {
      let r2 = e2.toString();
      if (!r2.includes("@tailwind"))
        return false;
      let i2 = h2.sourceHashMap.get(t10), o2 = s2(r2), v3 = i2 !== o2;
      return h2.sourceHashMap.set(t10, o2), v3;
    }
  }(ii2)), ii2;
}
var ai = {};
var si2 = {};
var $o3;
function Df() {
  return $o3 || ($o3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return (h2 > 0n) - (h2 < 0n);
    }
  }(si2)), si2;
}
var oi = {};
var Uo3;
function qf() {
  return Uo3 || (Uo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "remapBitfield", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      let l3 = 0n, f = 0n;
      for (let [s2, c2] of p)
        h2 & s2 && (l3 = l3 | s2, f = f | c2);
      return h2 & ~l3 | f;
    }
  }(oi)), oi;
}
var zo3;
function Lf() {
  return zo3 || (zo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "Offsets", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(Df()), h2 = qf();
    function p(c2) {
      return c2 && c2.__esModule ? c2 : {
        default: c2
      };
    }

    class l3 {
      constructor() {
        this.offsets = {
          defaults: 0n,
          base: 0n,
          components: 0n,
          utilities: 0n,
          variants: 0n,
          user: 0n
        }, this.layerPositions = {
          defaults: 0n,
          base: 1n,
          components: 2n,
          utilities: 3n,
          user: 4n,
          variants: 5n
        }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map;
      }
      create(t10) {
        return {
          layer: t10,
          parentLayer: t10,
          arbitrary: 0n,
          variants: 0n,
          parallelIndex: 0n,
          index: this.offsets[t10]++,
          propertyOffset: 0n,
          property: "",
          options: []
        };
      }
      arbitraryProperty(t10) {
        return {
          ...this.create("utilities"),
          arbitrary: 1n,
          property: t10
        };
      }
      forVariant(t10, e2 = 0) {
        let r2 = this.variantOffsets.get(t10);
        if (r2 === undefined)
          throw new Error(`Cannot find offset for unknown variant ${t10}`);
        return {
          ...this.create("variants"),
          variants: r2 << BigInt(e2)
        };
      }
      applyVariantOffset(t10, e2, r2) {
        return r2.variant = e2.variants, {
          ...t10,
          layer: "variants",
          parentLayer: t10.layer === "variants" ? t10.parentLayer : t10.layer,
          variants: t10.variants | e2.variants,
          options: r2.sort ? [].concat(r2, t10.options) : t10.options,
          parallelIndex: f([
            t10.parallelIndex,
            e2.parallelIndex
          ])
        };
      }
      applyParallelOffset(t10, e2) {
        return {
          ...t10,
          parallelIndex: BigInt(e2)
        };
      }
      recordVariants(t10, e2) {
        for (let r2 of t10)
          this.recordVariant(r2, e2(r2));
      }
      recordVariant(t10, e2 = 1) {
        return this.variantOffsets.set(t10, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(e2), {
          ...this.create("variants"),
          variants: this.variantOffsets.get(t10)
        };
      }
      compare(t10, e2) {
        if (t10.layer !== e2.layer)
          return this.layerPositions[t10.layer] - this.layerPositions[e2.layer];
        if (t10.parentLayer !== e2.parentLayer)
          return this.layerPositions[t10.parentLayer] - this.layerPositions[e2.parentLayer];
        for (let i2 of t10.options)
          for (let o2 of e2.options) {
            if (i2.id !== o2.id || !i2.sort || !o2.sort)
              continue;
            var r2;
            let v3 = (r2 = f([
              i2.variant,
              o2.variant
            ])) !== null && r2 !== undefined ? r2 : 0n, m = ~(v3 | v3 - 1n), n2 = t10.variants & m, d2 = e2.variants & m;
            if (n2 !== d2)
              continue;
            let _4 = i2.sort({
              value: i2.value,
              modifier: i2.modifier
            }, {
              value: o2.value,
              modifier: o2.modifier
            });
            if (_4 !== 0)
              return _4;
          }
        return t10.variants !== e2.variants ? t10.variants - e2.variants : t10.parallelIndex !== e2.parallelIndex ? t10.parallelIndex - e2.parallelIndex : t10.arbitrary !== e2.arbitrary ? t10.arbitrary - e2.arbitrary : t10.propertyOffset !== e2.propertyOffset ? t10.propertyOffset - e2.propertyOffset : t10.index - e2.index;
      }
      recalculateVariantOffsets() {
        let t10 = Array.from(this.variantOffsets.entries()).filter(([i2]) => i2.startsWith("[")).sort(([i2], [o2]) => s2(i2, o2)), e2 = t10.map(([, i2]) => i2).sort((i2, o2) => (0, a.default)(i2 - o2));
        return t10.map(([, i2], o2) => [
          i2,
          e2[o2]
        ]).filter(([i2, o2]) => i2 !== o2);
      }
      remapArbitraryVariantOffsets(t10) {
        let e2 = this.recalculateVariantOffsets();
        return e2.length === 0 ? t10 : t10.map((r2) => {
          let [i2, o2] = r2;
          return i2 = {
            ...i2,
            variants: (0, h2.remapBitfield)(i2.variants, e2)
          }, [
            i2,
            o2
          ];
        });
      }
      sortArbitraryProperties(t10) {
        let e2 = /* @__PURE__ */ new Set;
        for (let [v3] of t10)
          v3.arbitrary === 1n && e2.add(v3.property);
        if (e2.size === 0)
          return t10;
        let r2 = Array.from(e2).sort(), i2 = /* @__PURE__ */ new Map, o2 = 1n;
        for (let v3 of r2)
          i2.set(v3, o2++);
        return t10.map((v3) => {
          let [m, n2] = v3;
          var d2;
          return m = {
            ...m,
            propertyOffset: (d2 = i2.get(m.property)) !== null && d2 !== undefined ? d2 : 0n
          }, [
            m,
            n2
          ];
        });
      }
      sort(t10) {
        return t10 = this.remapArbitraryVariantOffsets(t10), t10 = this.sortArbitraryProperties(t10), t10.sort(([e2], [r2]) => (0, a.default)(this.compare(e2, r2)));
      }
    }
    function f(c2) {
      let t10 = null;
      for (const e2 of c2)
        t10 = t10 ?? e2, t10 = t10 > e2 ? t10 : e2;
      return t10;
    }
    function s2(c2, t10) {
      let e2 = c2.length, r2 = t10.length, i2 = e2 < r2 ? e2 : r2;
      for (let o2 = 0;o2 < i2; o2++) {
        let v3 = c2.charCodeAt(o2) - t10.charCodeAt(o2);
        if (v3 !== 0)
          return v3;
      }
      return e2 - r2;
    }
  }(ai)), ai;
}
var Wo3;
function Ki2() {
  return Wo3 || (Wo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(Y4, G3) {
      for (var te2 in G3)
        Object.defineProperty(Y4, te2, {
          enumerable: true,
          get: G3[te2]
        });
    }
    a(u, {
      INTERNAL_FEATURES: function() {
        return M2;
      },
      isValidVariantFormatString: function() {
        return I3;
      },
      parseVariant: function() {
        return N3;
      },
      getFileModifiedMap: function() {
        return U2;
      },
      createContext: function() {
        return de3;
      },
      getContext: function() {
        return ke3;
      }
    });
    const h2 = /* @__PURE__ */ b5(Ne3), p = /* @__PURE__ */ b5(Ne3), l3 = /* @__PURE__ */ b5(Be2()), f = /* @__PURE__ */ b5(Nl()), s2 = /* @__PURE__ */ b5(Ke3()), c2 = /* @__PURE__ */ b5(pr3()), t10 = /* @__PURE__ */ b5(tu3()), e2 = /* @__PURE__ */ b5(Hi2()), r2 = /* @__PURE__ */ b5(ut3()), i2 = /* @__PURE__ */ b5(ft3()), o2 = /* @__PURE__ */ q2(nu3()), v3 = gr3(), m = If(), n2 = /* @__PURE__ */ q2(yr3()), d2 = Wi2(), _4 = /* @__PURE__ */ b5(tt3()), w3 = /* @__PURE__ */ b5(ji2()), y2 = /* @__PURE__ */ b5(au3()), x2 = wr3(), g2 = Mf(), O3 = Lf(), A = it3(), E2 = ru3();
    function b5(Y4) {
      return Y4 && Y4.__esModule ? Y4 : {
        default: Y4
      };
    }
    function k4(Y4) {
      if (typeof WeakMap != "function")
        return null;
      var G3 = /* @__PURE__ */ new WeakMap, te2 = /* @__PURE__ */ new WeakMap;
      return (k4 = function(Z3) {
        return Z3 ? te2 : G3;
      })(Y4);
    }
    function q2(Y4, G3) {
      if (Y4 && Y4.__esModule)
        return Y4;
      if (Y4 === null || typeof Y4 != "object" && typeof Y4 != "function")
        return {
          default: Y4
        };
      var te2 = k4(G3);
      if (te2 && te2.has(Y4))
        return te2.get(Y4);
      var Z3 = {}, ee3 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var se3 in Y4)
        if (se3 !== "default" && Object.prototype.hasOwnProperty.call(Y4, se3)) {
          var ue = ee3 ? Object.getOwnPropertyDescriptor(Y4, se3) : null;
          ue && (ue.get || ue.set) ? Object.defineProperty(Z3, se3, ue) : Z3[se3] = Y4[se3];
        }
      return Z3.default = Y4, te2 && te2.set(Y4, Z3), Z3;
    }
    const M2 = Symbol(), W3 = {
      MatchVariant: Symbol.for("MATCH_VARIANT")
    }, S3 = {
      Base: 1,
      Dynamic: 2
    };
    function P3(Y4, G3) {
      let te2 = Y4.tailwindConfig.prefix;
      return typeof te2 == "function" ? te2(G3) : te2 + G3;
    }
    function C({ type: Y4 = "any", ...G3 }) {
      let te2 = [].concat(Y4);
      return {
        ...G3,
        types: te2.map((Z3) => Array.isArray(Z3) ? {
          type: Z3[0],
          ...Z3[1]
        } : {
          type: Z3,
          preferOnConflict: false
        })
      };
    }
    function R3(Y4) {
      let G3 = [], te2 = "", Z3 = 0;
      for (let ee3 = 0;ee3 < Y4.length; ee3++) {
        let se3 = Y4[ee3];
        if (se3 === "\\")
          te2 += "\\" + Y4[++ee3];
        else if (se3 === "{")
          ++Z3, G3.push(te2.trim()), te2 = "";
        else if (se3 === "}") {
          if (--Z3 < 0)
            throw new Error("Your { and } are unbalanced.");
          G3.push(te2.trim()), te2 = "";
        } else
          te2 += se3;
      }
      return te2.length > 0 && G3.push(te2.trim()), G3 = G3.filter((ee3) => ee3 !== ""), G3;
    }
    function $3(Y4, G3, { before: te2 = [] } = {}) {
      if (te2 = [].concat(te2), te2.length <= 0) {
        Y4.push(G3);
        return;
      }
      let Z3 = Y4.length - 1;
      for (let ee3 of te2) {
        let se3 = Y4.indexOf(ee3);
        se3 !== -1 && (Z3 = Math.min(Z3, se3));
      }
      Y4.splice(Z3, 0, G3);
    }
    function B3(Y4) {
      return Array.isArray(Y4) ? Y4.flatMap((G3) => !Array.isArray(G3) && !(0, r2.default)(G3) ? G3 : (0, t10.default)(G3)) : B3([
        Y4
      ]);
    }
    function z3(Y4, G3) {
      return (0, s2.default)((Z3) => {
        let ee3 = [];
        return G3 && G3(Z3), Z3.walkClasses((se3) => {
          ee3.push(se3.value);
        }), ee3;
      }).transformSync(Y4);
    }
    function L3(Y4) {
      Y4.walkPseudos((G3) => {
        G3.value === ":not" && G3.remove();
      });
    }
    function F(Y4, G3 = {
      containsNonOnDemandable: false
    }, te2 = 0) {
      let Z3 = [], ee3 = [];
      Y4.type === "rule" ? ee3.push(...Y4.selectors) : Y4.type === "atrule" && Y4.walkRules((se3) => ee3.push(...se3.selectors));
      for (let se3 of ee3) {
        let ue = z3(se3, L3);
        ue.length === 0 && (G3.containsNonOnDemandable = true);
        for (let xe3 of ue)
          Z3.push(xe3);
      }
      return te2 === 0 ? [
        G3.containsNonOnDemandable || Z3.length === 0,
        Z3
      ] : Z3;
    }
    function D(Y4) {
      return B3(Y4).flatMap((G3) => {
        let te2 = /* @__PURE__ */ new Map, [Z3, ee3] = F(G3);
        return Z3 && ee3.unshift(n2.NOT_ON_DEMAND), ee3.map((se3) => (te2.has(G3) || te2.set(G3, G3), [
          se3,
          te2.get(G3)
        ]));
      });
    }
    function I3(Y4) {
      return Y4.startsWith("@") || Y4.includes("&");
    }
    function N3(Y4) {
      Y4 = Y4.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
      let G3 = R3(Y4).map((te2) => {
        if (!te2.startsWith("@"))
          return ({ format: ue }) => ue(te2);
        let [, Z3, ee3] = /@(\S*)( .+|[({].*)?/g.exec(te2);
        var se3;
        return ({ wrap: ue }) => ue(l3.default.atRule({
          name: Z3,
          params: (se3 = ee3 == null ? undefined : ee3.trim()) !== null && se3 !== undefined ? se3 : ""
        }));
      }).reverse();
      return (te2) => {
        for (let Z3 of G3)
          Z3(te2);
      };
    }
    function J3(Y4, G3, { variantList: te2, variantMap: Z3, offsets: ee3, classList: se3 }) {
      function ue(ae3, re3) {
        return ae3 ? (0, f.default)(Y4, ae3, re3) : Y4;
      }
      function xe3(ae3) {
        return (0, e2.default)(Y4.prefix, ae3);
      }
      function ce3(ae3, re3) {
        return ae3 === n2.NOT_ON_DEMAND ? n2.NOT_ON_DEMAND : re3.respectPrefix ? G3.tailwindConfig.prefix + ae3 : ae3;
      }
      function Te3(ae3, re3, fe3 = {}) {
        let we3 = (0, d2.toPath)(ae3), ye2 = ue([
          "theme",
          ...we3
        ], re3);
        return (0, c2.default)(we3[0])(ye2, fe3);
      }
      let ve3 = 0, Ae3 = {
        postcss: l3.default,
        prefix: xe3,
        e: i2.default,
        config: ue,
        theme: Te3,
        corePlugins: (ae3) => Array.isArray(Y4.corePlugins) ? Y4.corePlugins.includes(ae3) : ue([
          "corePlugins",
          ae3
        ], true),
        variants: () => [],
        addBase(ae3) {
          for (let [re3, fe3] of D(ae3)) {
            let we3 = ce3(re3, {}), ye2 = ee3.create("base");
            G3.candidateRuleMap.has(we3) || G3.candidateRuleMap.set(we3, []), G3.candidateRuleMap.get(we3).push([
              {
                sort: ye2,
                layer: "base"
              },
              fe3
            ]);
          }
        },
        addDefaults(ae3, re3) {
          const fe3 = {
            [`@defaults ${ae3}`]: re3
          };
          for (let [we3, ye2] of D(fe3)) {
            let he3 = ce3(we3, {});
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("defaults"),
                layer: "defaults"
              },
              ye2
            ]);
          }
        },
        addComponents(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: false
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("components"),
                layer: "components",
                options: re3
              },
              ye2
            ]);
          }
        },
        addUtilities(ae3, re3) {
          re3 = Object.assign({}, {
            preserveSource: false,
            respectPrefix: true,
            respectImportant: true
          }, Array.isArray(re3) ? {} : re3);
          for (let [we3, ye2] of D(ae3)) {
            let he3 = ce3(we3, re3);
            se3.add(he3), G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push([
              {
                sort: ee3.create("utilities"),
                layer: "utilities",
                options: re3
              },
              ye2
            ]);
          }
        },
        matchUtilities: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: true,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("utilities");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y4);
              if (pe3 === undefined)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _4.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _4.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y4, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "utilities",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        matchComponents: function(ae3, re3) {
          re3 = C({
            ...{
              respectPrefix: true,
              respectImportant: false,
              modifiers: false
            },
            ...re3
          });
          let we3 = ee3.create("components");
          for (let ye2 in ae3) {
            let qe3 = function(Se3, { isOnlyPlugin: me3 }) {
              let [pe3, Oe3, Ue3] = (0, v3.coerceValue)(re3.types, Se3, re3, Y4);
              if (pe3 === undefined)
                return [];
              if (!re3.types.some(({ type: We2 }) => We2 === Oe3))
                if (me3)
                  _4.default.warn([
                    `Unnecessary typehint \`${Oe3}\` in \`${ye2}-${Se3}\`.`,
                    `You can safely update it to \`${ye2}-${Se3.replace(Oe3 + ":", "")}\`.`
                  ]);
                else
                  return [];
              if (!(0, y2.default)(pe3))
                return [];
              let Xe3 = {
                get modifier() {
                  return re3.modifiers || _4.default.warn(`modifier-used-without-options-for-${ye2}`, [
                    "Your plugin must set `modifiers: true` in its options to support modifiers."
                  ]), Ue3;
                }
              }, ze3 = (0, A.flagEnabled)(Y4, "generalizedModifiers");
              return [].concat(ze3 ? Ce3(pe3, Xe3) : Ce3(pe3)).filter(Boolean).map((We2) => ({
                [(0, o2.default)(ye2, Se3)]: We2
              }));
            }, he3 = ce3(ye2, re3), Ce3 = ae3[ye2];
            se3.add([
              he3,
              re3
            ]);
            let ge3 = [
              {
                sort: we3,
                layer: "components",
                options: re3
              },
              qe3
            ];
            G3.candidateRuleMap.has(he3) || G3.candidateRuleMap.set(he3, []), G3.candidateRuleMap.get(he3).push(ge3);
          }
        },
        addVariant(ae3, re3, fe3 = {}) {
          re3 = [].concat(re3).map((we3) => {
            if (typeof we3 != "string")
              return (ye2 = {}) => {
                let { args: he3, modifySelectors: Ce3, container: qe3, separator: ge3, wrap: Se3, format: me3 } = ye2, pe3 = we3(Object.assign({
                  modifySelectors: Ce3,
                  container: qe3,
                  separator: ge3
                }, fe3.type === W3.MatchVariant && {
                  args: he3,
                  wrap: Se3,
                  format: me3
                }));
                if (typeof pe3 == "string" && !I3(pe3))
                  throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
                return Array.isArray(pe3) ? pe3.filter((Oe3) => typeof Oe3 == "string").map((Oe3) => N3(Oe3)) : pe3 && typeof pe3 == "string" && N3(pe3)(ye2);
              };
            if (!I3(we3))
              throw new Error(`Your custom variant \`${ae3}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
            return N3(we3);
          }), $3(te2, ae3, fe3), Z3.set(ae3, re3), G3.variantOptions.set(ae3, fe3);
        },
        matchVariant(ae3, re3, fe3) {
          var we3;
          let ye2 = (we3 = fe3 == null ? undefined : fe3.id) !== null && we3 !== undefined ? we3 : ++ve3, he3 = ae3 === "@", Ce3 = (0, A.flagEnabled)(Y4, "generalizedModifiers");
          var qe3;
          for (let [me3, pe3] of Object.entries((qe3 = fe3 == null ? undefined : fe3.values) !== null && qe3 !== undefined ? qe3 : {}))
            me3 !== "DEFAULT" && Ae3.addVariant(he3 ? `${ae3}${me3}` : `${ae3}-${me3}`, ({ args: Oe3, container: Ue3 }) => re3(pe3, Ce3 ? {
              modifier: Oe3 == null ? undefined : Oe3.modifier,
              container: Ue3
            } : {
              container: Ue3
            }), {
              ...fe3,
              value: pe3,
              id: ye2,
              type: W3.MatchVariant,
              variantInfo: S3.Base
            });
          var ge3;
          let Se3 = "DEFAULT" in ((ge3 = fe3 == null ? undefined : fe3.values) !== null && ge3 !== undefined ? ge3 : {});
          Ae3.addVariant(ae3, ({ args: me3, container: pe3 }) => {
            if ((me3 == null ? undefined : me3.value) === n2.NONE && !Se3)
              return null;
            var Oe3;
            return re3((me3 == null ? undefined : me3.value) === n2.NONE ? fe3.values.DEFAULT : (Oe3 = me3 == null ? undefined : me3.value) !== null && Oe3 !== undefined ? Oe3 : typeof me3 == "string" ? me3 : "", Ce3 ? {
              modifier: me3 == null ? undefined : me3.modifier,
              container: pe3
            } : {
              container: pe3
            });
          }, {
            ...fe3,
            id: ye2,
            type: W3.MatchVariant,
            variantInfo: S3.Dynamic
          });
        }
      };
      return Ae3;
    }
    let T4 = /* @__PURE__ */ new WeakMap;
    function U2(Y4) {
      return T4.has(Y4) || T4.set(Y4, /* @__PURE__ */ new Map), T4.get(Y4);
    }
    function j3(Y4, G3) {
      let te2 = false, Z3 = /* @__PURE__ */ new Map;
      for (let se3 of Y4) {
        var ee3;
        if (!se3)
          continue;
        let ue = p.default.parse(se3), xe3 = ue.hash ? ue.href.replace(ue.hash, "") : ue.href;
        xe3 = ue.search ? xe3.replace(ue.search, "") : xe3;
        let ce3 = (ee3 = h2.default.statSync(decodeURIComponent(xe3), {
          throwIfNoEntry: false
        })) === null || ee3 === undefined ? undefined : ee3.mtimeMs;
        ce3 && ((!G3.has(se3) || ce3 > G3.get(se3)) && (te2 = true), Z3.set(se3, ce3));
      }
      return [
        te2,
        Z3
      ];
    }
    function H3(Y4) {
      Y4.walkAtRules((G3) => {
        [
          "responsive",
          "variants"
        ].includes(G3.name) && (H3(G3), G3.before(G3.nodes), G3.remove());
      });
    }
    function V4(Y4) {
      let G3 = [];
      return Y4.each((te2) => {
        te2.type === "atrule" && [
          "responsive",
          "variants"
        ].includes(te2.name) && (te2.name = "layer", te2.params = "utilities");
      }), Y4.walkAtRules("layer", (te2) => {
        if (H3(te2), te2.params === "base") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addBase: ee3 }) {
              ee3(Z3, {
                respectPrefix: false
              });
            });
          te2.remove();
        } else if (te2.params === "components") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addComponents: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        } else if (te2.params === "utilities") {
          for (let Z3 of te2.nodes)
            G3.push(function({ addUtilities: ee3 }) {
              ee3(Z3, {
                respectPrefix: false,
                preserveSource: true
              });
            });
          te2.remove();
        }
      }), G3;
    }
    function K3(Y4, G3) {
      let te2 = Object.entries({
        ...m.variantPlugins,
        ...m.corePlugins
      }).map(([ce3, Te3]) => Y4.tailwindConfig.corePlugins.includes(ce3) ? Te3 : null).filter(Boolean), Z3 = Y4.tailwindConfig.plugins.map((ce3) => (ce3.__isOptionsFunction && (ce3 = ce3()), typeof ce3 == "function" ? ce3 : ce3.handler)), ee3 = V4(G3), se3 = [
        m.variantPlugins.childVariant,
        m.variantPlugins.pseudoElementVariants,
        m.variantPlugins.pseudoClassVariants,
        m.variantPlugins.hasVariants,
        m.variantPlugins.ariaVariants,
        m.variantPlugins.dataVariants
      ], ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ];
      return (Y4.tailwindConfig.darkMode === "class" || Array.isArray(Y4.tailwindConfig.darkMode) && Y4.tailwindConfig.darkMode[0] === "class") && (ue = [
        m.variantPlugins.supportsVariants,
        m.variantPlugins.reducedMotionVariants,
        m.variantPlugins.prefersContrastVariants,
        m.variantPlugins.darkVariants,
        m.variantPlugins.screenVariants,
        m.variantPlugins.orientationVariants,
        m.variantPlugins.directionVariants,
        m.variantPlugins.forcedColorsVariants,
        m.variantPlugins.printVariant
      ]), [
        ...te2,
        ...se3,
        ...Z3,
        ...ue,
        ...ee3
      ];
    }
    function X3(Y4, G3) {
      let te2 = [], Z3 = /* @__PURE__ */ new Map;
      G3.variantMap = Z3;
      let ee3 = new O3.Offsets;
      G3.offsets = ee3;
      let se3 = /* @__PURE__ */ new Set, ue = J3(G3.tailwindConfig, G3, {
        variantList: te2,
        variantMap: Z3,
        offsets: ee3,
        classList: se3
      });
      for (let re3 of Y4)
        if (Array.isArray(re3))
          for (let fe3 of re3)
            fe3(ue);
        else
          re3 == null || re3(ue);
      ee3.recordVariants(te2, (re3) => Z3.get(re3).length);
      for (let [re3, fe3] of Z3.entries())
        G3.variantMap.set(re3, fe3.map((we3, ye2) => [
          ee3.forVariant(re3, ye2),
          we3
        ]));
      var xe3;
      let ce3 = ((xe3 = G3.tailwindConfig.safelist) !== null && xe3 !== undefined ? xe3 : []).filter(Boolean);
      if (ce3.length > 0) {
        let re3 = [];
        for (let fe3 of ce3) {
          if (typeof fe3 == "string") {
            G3.changedContent.push({
              content: fe3,
              extension: "html"
            });
            continue;
          }
          if (fe3 instanceof RegExp) {
            _4.default.warn("root-regex", [
              "Regular expressions in `safelist` work differently in Tailwind CSS v3.0.",
              "Update your `safelist` configuration to eliminate this warning.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
            continue;
          }
          re3.push(fe3);
        }
        if (re3.length > 0) {
          let fe3 = /* @__PURE__ */ new Map, we3 = G3.tailwindConfig.prefix.length, ye2 = re3.some((he3) => he3.pattern.source.includes("!"));
          for (let he3 of se3) {
            let Ce3 = Array.isArray(he3) ? (() => {
              let [qe3, ge3] = he3;
              var Se3;
              let pe3 = Object.keys((Se3 = ge3 == null ? undefined : ge3.values) !== null && Se3 !== undefined ? Se3 : {}).map((Oe3) => (0, o2.formatClass)(qe3, Oe3));
              return ge3 != null && ge3.supportsNegativeValues && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "-" + Oe3)
              ], pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => Oe3.slice(0, we3) + "-" + Oe3.slice(we3))
              ]), ge3.types.some(({ type: Oe3 }) => Oe3 === "color") && (pe3 = [
                ...pe3,
                ...pe3.flatMap((Oe3) => Object.keys(G3.tailwindConfig.theme.opacity).map((Ue3) => `${Oe3}/${Ue3}`))
              ]), ye2 && (ge3 != null && ge3.respectImportant) && (pe3 = [
                ...pe3,
                ...pe3.map((Oe3) => "!" + Oe3)
              ]), pe3;
            })() : [
              he3
            ];
            for (let qe3 of Ce3)
              for (let { pattern: ge3, variants: Se3 = [] } of re3)
                if (ge3.lastIndex = 0, fe3.has(ge3) || fe3.set(ge3, 0), !!ge3.test(qe3)) {
                  fe3.set(ge3, fe3.get(ge3) + 1), G3.changedContent.push({
                    content: qe3,
                    extension: "html"
                  });
                  for (let me3 of Se3)
                    G3.changedContent.push({
                      content: me3 + G3.tailwindConfig.separator + qe3,
                      extension: "html"
                    });
                }
          }
          for (let [he3, Ce3] of fe3.entries())
            Ce3 === 0 && _4.default.warn([
              `The safelist pattern \`${he3}\` doesn't match any Tailwind CSS classes.`,
              "Fix this pattern or remove it from your `safelist` configuration.",
              "https://tailwindcss.com/docs/content-configuration#safelisting-classes"
            ]);
        }
      }
      var Te3, ve3;
      let Ae3 = (ve3 = [].concat((Te3 = G3.tailwindConfig.darkMode) !== null && Te3 !== undefined ? Te3 : "media")[1]) !== null && ve3 !== undefined ? ve3 : "dark", ae3 = [
        P3(G3, Ae3),
        P3(G3, "group"),
        P3(G3, "peer")
      ];
      G3.getClassOrder = function(fe3) {
        let we3 = [
          ...fe3
        ].sort((ge3, Se3) => ge3 === Se3 ? 0 : ge3 < Se3 ? -1 : 1), ye2 = new Map(we3.map((ge3) => [
          ge3,
          null
        ])), he3 = (0, x2.generateRules)(new Set(we3), G3, true);
        he3 = G3.offsets.sort(he3);
        let Ce3 = BigInt(ae3.length);
        for (const [, ge3] of he3) {
          let Se3 = ge3.raws.tailwind.candidate;
          var qe3;
          ye2.set(Se3, (qe3 = ye2.get(Se3)) !== null && qe3 !== undefined ? qe3 : Ce3++);
        }
        return fe3.map((ge3) => {
          var Se3;
          let me3 = (Se3 = ye2.get(ge3)) !== null && Se3 !== undefined ? Se3 : null, pe3 = ae3.indexOf(ge3);
          return me3 === null && pe3 !== -1 && (me3 = BigInt(pe3)), [
            ge3,
            me3
          ];
        });
      }, G3.getClassList = function(fe3 = {}) {
        let we3 = [];
        for (let ge3 of se3)
          if (Array.isArray(ge3)) {
            var ye2;
            let [Se3, me3] = ge3, pe3 = [];
            var he3;
            let Oe3 = Object.keys((he3 = me3 == null ? undefined : me3.modifiers) !== null && he3 !== undefined ? he3 : {});
            if (!(me3 == null || (ye2 = me3.types) === null || ye2 === undefined) && ye2.some(({ type: ze3 }) => ze3 === "color")) {
              var Ce3;
              Oe3.push(...Object.keys((Ce3 = G3.tailwindConfig.theme.opacity) !== null && Ce3 !== undefined ? Ce3 : {}));
            }
            let Ue3 = {
              modifiers: Oe3
            }, Xe3 = fe3.includeMetadata && Oe3.length > 0;
            var qe3;
            for (let [ze3, Ze3] of Object.entries((qe3 = me3 == null ? undefined : me3.values) !== null && qe3 !== undefined ? qe3 : {})) {
              if (Ze3 == null)
                continue;
              let We2 = (0, o2.formatClass)(Se3, ze3);
              if (we3.push(Xe3 ? [
                We2,
                Ue3
              ] : We2), me3 != null && me3.supportsNegativeValues && (0, w3.default)(Ze3)) {
                let Je3 = (0, o2.formatClass)(Se3, `-${ze3}`);
                pe3.push(Xe3 ? [
                  Je3,
                  Ue3
                ] : Je3);
              }
            }
            we3.push(...pe3);
          } else
            we3.push(ge3);
        return we3;
      }, G3.getVariants = function() {
        let fe3 = Math.random().toString(36).substring(7).toUpperCase(), we3 = [];
        for (let [he3, Ce3] of G3.variantOptions.entries())
          if (Ce3.variantInfo !== S3.Base) {
            var ye2;
            we3.push({
              name: he3,
              isArbitrary: Ce3.type === Symbol.for("MATCH_VARIANT"),
              values: Object.keys((ye2 = Ce3.values) !== null && ye2 !== undefined ? ye2 : {}),
              hasDash: he3 !== "@",
              selectors({ modifier: qe3, value: ge3 } = {}) {
                let Se3 = `TAILWINDPLACEHOLDER${fe3}`, me3 = l3.default.rule({
                  selector: `.${Se3}`
                }), pe3 = l3.default.root({
                  nodes: [
                    me3.clone()
                  ]
                }), Oe3 = pe3.toString();
                var Ue3;
                let Xe3 = ((Ue3 = G3.variantMap.get(he3)) !== null && Ue3 !== undefined ? Ue3 : []).flatMap(([Ve3, je3]) => je3), ze3 = [];
                for (let Ve3 of Xe3) {
                  var Ze3;
                  let je3 = [];
                  var We2;
                  let ct3 = {
                    args: {
                      modifier: qe3,
                      value: (We2 = (Ze3 = Ce3.values) === null || Ze3 === undefined ? undefined : Ze3[ge3]) !== null && We2 !== undefined ? We2 : ge3
                    },
                    separator: G3.tailwindConfig.separator,
                    modifySelectors(Ge4) {
                      return pe3.each((xr3) => {
                        xr3.type === "rule" && (xr3.selectors = xr3.selectors.map((ea2) => Ge4({
                          get className() {
                            return (0, x2.getClassNameFromSelector)(ea2);
                          },
                          selector: ea2
                        })));
                      }), pe3;
                    },
                    format(Ge4) {
                      je3.push(Ge4);
                    },
                    wrap(Ge4) {
                      je3.push(`@${Ge4.name} ${Ge4.params} { & }`);
                    },
                    container: pe3
                  }, dt2 = Ve3(ct3);
                  if (je3.length > 0 && ze3.push(je3), Array.isArray(dt2))
                    for (let Ge4 of dt2)
                      je3 = [], Ge4(ct3), ze3.push(je3);
                }
                let Je3 = [], ou3 = pe3.toString();
                Oe3 !== ou3 && (pe3.walkRules((Ve3) => {
                  let je3 = Ve3.selector, ct3 = (0, s2.default)((dt2) => {
                    dt2.walkClasses((Ge4) => {
                      Ge4.value = `${he3}${G3.tailwindConfig.separator}${Ge4.value}`;
                    });
                  }).processSync(je3);
                  Je3.push(je3.replace(ct3, "&").replace(Se3, "&"));
                }), pe3.walkAtRules((Ve3) => {
                  Je3.push(`@${Ve3.name} (${Ve3.params}) { & }`);
                }));
                var br3;
                let lu = !(ge3 in ((br3 = Ce3.values) !== null && br3 !== undefined ? br3 : {}));
                var _r3;
                let uu3 = (_r3 = Ce3[M2]) !== null && _r3 !== undefined ? _r3 : {}, Xi2 = !(lu || uu3.respectPrefix === false);
                ze3 = ze3.map((Ve3) => Ve3.map((je3) => ({
                  format: je3,
                  respectPrefix: Xi2
                }))), Je3 = Je3.map((Ve3) => ({
                  format: Ve3,
                  respectPrefix: Xi2
                }));
                let Sr3 = {
                  candidate: Se3,
                  context: G3
                }, Zi2 = ze3.map((Ve3) => (0, E2.finalizeSelector)(`.${Se3}`, (0, E2.formatVariantSelector)(Ve3, Sr3), Sr3).replace(`.${Se3}`, "&").replace("{ & }", "").trim());
                return Je3.length > 0 && Zi2.push((0, E2.formatVariantSelector)(Je3, Sr3).toString().replace(`.${Se3}`, "&")), Zi2;
              }
            });
          }
        return we3;
      };
    }
    function Q3(Y4, G3) {
      Y4.classCache.has(G3) && (Y4.notClassCache.add(G3), Y4.classCache.delete(G3), Y4.applyClassCache.delete(G3), Y4.candidateRuleMap.delete(G3), Y4.candidateRuleCache.delete(G3), Y4.stylesheetCache = null);
    }
    function ne4(Y4, G3) {
      let te2 = G3.raws.tailwind.candidate;
      if (te2) {
        for (const Z3 of Y4.ruleCache)
          Z3[1].raws.tailwind.candidate === te2 && Y4.ruleCache.delete(Z3);
        Q3(Y4, te2);
      }
    }
    function de3(Y4, G3 = [], te2 = l3.default.root()) {
      var Z3;
      let ee3 = {
        disposables: [],
        ruleCache: /* @__PURE__ */ new Set,
        candidateRuleCache: /* @__PURE__ */ new Map,
        classCache: /* @__PURE__ */ new Map,
        applyClassCache: /* @__PURE__ */ new Map,
        notClassCache: new Set((Z3 = Y4.blocklist) !== null && Z3 !== undefined ? Z3 : []),
        postCssNodeCache: /* @__PURE__ */ new Map,
        candidateRuleMap: /* @__PURE__ */ new Map,
        tailwindConfig: Y4,
        changedContent: G3,
        variantMap: /* @__PURE__ */ new Map,
        stylesheetCache: null,
        variantOptions: /* @__PURE__ */ new Map,
        markInvalidUtilityCandidate: (ue) => Q3(ee3, ue),
        markInvalidUtilityNode: (ue) => ne4(ee3, ue)
      }, se3 = K3(ee3, te2);
      return X3(se3, ee3), ee3;
    }
    let { contextMap: _e3, configContextMap: be3, contextSourcesMap: ie3 } = n2;
    function ke3(Y4, G3, te2, Z3, ee3, se3) {
      let ue = G3.opts.from, xe3 = Z3 !== null;
      n2.env.DEBUG && console.log("Source path:", ue);
      let ce3;
      if (xe3 && _e3.has(ue))
        ce3 = _e3.get(ue);
      else if (be3.has(ee3)) {
        let ae3 = be3.get(ee3);
        ie3.get(ae3).add(ue), _e3.set(ue, ae3), ce3 = ae3;
      }
      let Te3 = (0, g2.hasContentChanged)(ue, Y4);
      if (ce3) {
        let [ae3, re3] = j3([
          ...se3
        ], U2(ce3));
        if (!ae3 && !Te3)
          return [
            ce3,
            false,
            re3
          ];
      }
      if (_e3.has(ue)) {
        let ae3 = _e3.get(ue);
        if (ie3.has(ae3) && (ie3.get(ae3).delete(ue), ie3.get(ae3).size === 0)) {
          ie3.delete(ae3);
          for (let [re3, fe3] of be3)
            fe3 === ae3 && be3.delete(re3);
          for (let re3 of ae3.disposables.splice(0))
            re3(ae3);
        }
      }
      n2.env.DEBUG && console.log("Setting up new context...");
      let ve3 = de3(te2, [], Y4);
      Object.assign(ve3, {
        userConfigPath: Z3
      });
      let [, Ae3] = j3([
        ...se3
      ], U2(ve3));
      return be3.set(ee3, ve3), _e3.set(ue, ve3), ie3.has(ve3) || ie3.set(ve3, /* @__PURE__ */ new Set), ie3.get(ve3).add(ue), [
        ve3,
        true,
        Ae3
      ];
    }
  }(Jn3)), Jn3;
}
var li2 = {};
var Vo3;
function su3() {
  return Vo3 || (Vo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "applyImportantSelector", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(Ke3()), h2 = Ji2();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3(f, s2) {
      let c2 = (0, a.default)().astSync(f);
      return c2.each((t10) => {
        t10.nodes.some((r2) => r2.type === "combinator") && (t10.nodes = [
          a.default.pseudo({
            value: ":is",
            nodes: [
              t10.clone()
            ]
          })
        ]), (0, h2.movePseudos)(t10);
      }), `${s2} ${c2.toString()}`;
    }
  }(li2)), li2;
}
var jo3;
function wr3() {
  return jo3 || (jo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(T4, U2) {
      for (var j3 in U2)
        Object.defineProperty(T4, j3, {
          enumerable: true,
          get: U2[j3]
        });
    }
    a(u, {
      getClassNameFromSelector: function() {
        return O3;
      },
      resolveMatches: function() {
        return L3;
      },
      generateRules: function() {
        return N3;
      }
    });
    const h2 = /* @__PURE__ */ w3(Be2()), p = /* @__PURE__ */ w3(Ke3()), l3 = /* @__PURE__ */ w3(tu3()), f = /* @__PURE__ */ w3(ut3()), s2 = /* @__PURE__ */ w3(Hi2()), c2 = gr3(), t10 = /* @__PURE__ */ w3(tt3()), e2 = /* @__PURE__ */ x2(yr3()), r2 = ru3(), i2 = nu3(), o2 = vr3(), v3 = Ki2(), m = /* @__PURE__ */ w3(au3()), n2 = st3(), d2 = it3(), _4 = su3();
    function w3(T4) {
      return T4 && T4.__esModule ? T4 : {
        default: T4
      };
    }
    function y2(T4) {
      if (typeof WeakMap != "function")
        return null;
      var U2 = /* @__PURE__ */ new WeakMap, j3 = /* @__PURE__ */ new WeakMap;
      return (y2 = function(H3) {
        return H3 ? j3 : U2;
      })(T4);
    }
    function x2(T4, U2) {
      if (T4 && T4.__esModule)
        return T4;
      if (T4 === null || typeof T4 != "object" && typeof T4 != "function")
        return {
          default: T4
        };
      var j3 = y2(U2);
      if (j3 && j3.has(T4))
        return j3.get(T4);
      var H3 = {}, V4 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var K3 in T4)
        if (K3 !== "default" && Object.prototype.hasOwnProperty.call(T4, K3)) {
          var X3 = V4 ? Object.getOwnPropertyDescriptor(T4, K3) : null;
          X3 && (X3.get || X3.set) ? Object.defineProperty(H3, K3, X3) : H3[K3] = T4[K3];
        }
      return H3.default = T4, j3 && j3.set(T4, H3), H3;
    }
    let g2 = (0, p.default)((T4) => T4.first.filter(({ type: U2 }) => U2 === "class").pop().value);
    function O3(T4) {
      return g2.transformSync(T4);
    }
    function* A(T4) {
      let U2 = 1 / 0;
      for (;U2 >= 0; ) {
        let j3, H3 = false;
        if (U2 === 1 / 0 && T4.endsWith("]")) {
          let X3 = T4.indexOf("[");
          T4[X3 - 1] === "-" ? j3 = X3 - 1 : T4[X3 - 1] === "/" ? (j3 = X3 - 1, H3 = true) : j3 = -1;
        } else
          U2 === 1 / 0 && T4.includes("/") ? (j3 = T4.lastIndexOf("/"), H3 = true) : j3 = T4.lastIndexOf("-", U2);
        if (j3 < 0)
          break;
        let V4 = T4.slice(0, j3), K3 = T4.slice(H3 ? j3 : j3 + 1);
        U2 = j3 - 1, !(V4 === "" || K3 === "/") && (yield [
          V4,
          K3
        ]);
      }
    }
    function E2(T4, U2) {
      if (T4.length === 0 || U2.tailwindConfig.prefix === "")
        return T4;
      for (let j3 of T4) {
        let [H3] = j3;
        if (H3.options.respectPrefix) {
          let V4 = h2.default.root({
            nodes: [
              j3[1].clone()
            ]
          }), K3 = j3[1].raws.tailwind.classCandidate;
          V4.walkRules((X3) => {
            let Q3 = K3.startsWith("-");
            X3.selector = (0, s2.default)(U2.tailwindConfig.prefix, X3.selector, Q3);
          }), j3[1] = V4.nodes[0];
        }
      }
      return T4;
    }
    function b5(T4, U2) {
      if (T4.length === 0)
        return T4;
      let j3 = [];
      function H3(V4) {
        return V4.parent && V4.parent.type === "atrule" && V4.parent.name === "keyframes";
      }
      for (let [V4, K3] of T4) {
        let X3 = h2.default.root({
          nodes: [
            K3.clone()
          ]
        });
        X3.walkRules((Q3) => {
          if (H3(Q3))
            return;
          let ne4 = (0, p.default)().astSync(Q3.selector);
          ne4.each((de3) => (0, r2.eliminateIrrelevantSelectors)(de3, U2)), (0, c2.updateAllClasses)(ne4, (de3) => de3 === U2 ? `!${de3}` : de3), Q3.selector = ne4.toString(), Q3.walkDecls((de3) => de3.important = true);
        }), j3.push([
          {
            ...V4,
            important: true
          },
          X3.nodes[0]
        ]);
      }
      return j3;
    }
    function k4(T4, U2, j3) {
      if (U2.length === 0)
        return U2;
      let H3 = {
        modifier: null,
        value: e2.NONE
      };
      {
        let [Q3, ...ne4] = (0, n2.splitAtTopLevelOnly)(T4, "/");
        if (ne4.length > 1 && (Q3 = Q3 + "/" + ne4.slice(0, -1).join("/"), ne4 = ne4.slice(-1)), ne4.length && !j3.variantMap.has(T4) && (T4 = Q3, H3.modifier = ne4[0], !(0, d2.flagEnabled)(j3.tailwindConfig, "generalizedModifiers")))
          return [];
      }
      if (T4.endsWith("]") && !T4.startsWith("[")) {
        let Q3 = /(.)(-?)\[(.*)\]/g.exec(T4);
        if (Q3) {
          let [, ne4, de3, _e3] = Q3;
          if (ne4 === "@" && de3 === "-")
            return [];
          if (ne4 !== "@" && de3 === "")
            return [];
          T4 = T4.replace(`${de3}[${_e3}]`, ""), H3.value = _e3;
        }
      }
      if (J3(T4) && !j3.variantMap.has(T4)) {
        let Q3 = j3.offsets.recordVariant(T4), ne4 = (0, o2.normalize)(T4.slice(1, -1)), de3 = (0, n2.splitAtTopLevelOnly)(ne4, ",");
        if (de3.length > 1)
          return [];
        if (!de3.every(v3.isValidVariantFormatString))
          return [];
        let _e3 = de3.map((be3, ie3) => [
          j3.offsets.applyParallelOffset(Q3, ie3),
          (0, v3.parseVariant)(be3.trim())
        ]);
        j3.variantMap.set(T4, _e3);
      }
      if (j3.variantMap.has(T4)) {
        var V4;
        let Q3 = J3(T4);
        var K3;
        let ne4 = (K3 = (V4 = j3.variantOptions.get(T4)) === null || V4 === undefined ? undefined : V4[v3.INTERNAL_FEATURES]) !== null && K3 !== undefined ? K3 : {}, de3 = j3.variantMap.get(T4).slice(), _e3 = [], be3 = !(Q3 || ne4.respectPrefix === false);
        for (let [ie3, ke3] of U2) {
          if (ie3.layer === "user")
            continue;
          let Y4 = h2.default.root({
            nodes: [
              ke3.clone()
            ]
          });
          for (let [G3, te2, Z3] of de3) {
            let ue = function() {
              ee3.raws.neededBackup || (ee3.raws.neededBackup = true, ee3.walkRules((ve3) => ve3.raws.originalSelector = ve3.selector));
            }, xe3 = function(ve3) {
              return ue(), ee3.each((Ae3) => {
                Ae3.type === "rule" && (Ae3.selectors = Ae3.selectors.map((ae3) => ve3({
                  get className() {
                    return O3(ae3);
                  },
                  selector: ae3
                })));
              }), ee3;
            }, ee3 = (Z3 ?? Y4).clone(), se3 = [], ce3 = te2({
              get container() {
                return ue(), ee3;
              },
              separator: j3.tailwindConfig.separator,
              modifySelectors: xe3,
              wrap(ve3) {
                let Ae3 = ee3.nodes;
                ee3.removeAll(), ve3.append(Ae3), ee3.append(ve3);
              },
              format(ve3) {
                se3.push({
                  format: ve3,
                  respectPrefix: be3
                });
              },
              args: H3
            });
            if (Array.isArray(ce3)) {
              for (let [ve3, Ae3] of ce3.entries())
                de3.push([
                  j3.offsets.applyParallelOffset(G3, ve3),
                  Ae3,
                  ee3.clone()
                ]);
              continue;
            }
            if (typeof ce3 == "string" && se3.push({
              format: ce3,
              respectPrefix: be3
            }), ce3 === null)
              continue;
            ee3.raws.neededBackup && (delete ee3.raws.neededBackup, ee3.walkRules((ve3) => {
              let Ae3 = ve3.raws.originalSelector;
              if (!Ae3 || (delete ve3.raws.originalSelector, Ae3 === ve3.selector))
                return;
              let ae3 = ve3.selector, re3 = (0, p.default)((fe3) => {
                fe3.walkClasses((we3) => {
                  we3.value = `${T4}${j3.tailwindConfig.separator}${we3.value}`;
                });
              }).processSync(Ae3);
              se3.push({
                format: ae3.replace(re3, "&"),
                respectPrefix: be3
              }), ve3.selector = Ae3;
            })), ee3.nodes[0].raws.tailwind = {
              ...ee3.nodes[0].raws.tailwind,
              parentLayer: ie3.layer
            };
            var X3;
            let Te3 = [
              {
                ...ie3,
                sort: j3.offsets.applyVariantOffset(ie3.sort, G3, Object.assign(H3, j3.variantOptions.get(T4))),
                collectedFormats: ((X3 = ie3.collectedFormats) !== null && X3 !== undefined ? X3 : []).concat(se3)
              },
              ee3.nodes[0]
            ];
            _e3.push(Te3);
          }
        }
        return _e3;
      }
      return [];
    }
    function q2(T4, U2, j3 = {}) {
      return !(0, f.default)(T4) && !Array.isArray(T4) ? [
        [
          T4
        ],
        j3
      ] : Array.isArray(T4) ? q2(T4[0], U2, T4[1]) : (U2.has(T4) || U2.set(T4, (0, l3.default)(T4)), [
        U2.get(T4),
        j3
      ]);
    }
    const M2 = /^[a-z_-]/;
    function W3(T4) {
      return M2.test(T4);
    }
    function S3(T4) {
      if (!T4.includes("://"))
        return false;
      try {
        const U2 = new URL(T4);
        return U2.scheme !== "" && U2.host !== "";
      } catch {
        return false;
      }
    }
    function P3(T4) {
      let U2 = true;
      return T4.walkDecls((j3) => {
        if (!C(j3.prop, j3.value))
          return U2 = false, false;
      }), U2;
    }
    function C(T4, U2) {
      if (S3(`${T4}:${U2}`))
        return false;
      try {
        return h2.default.parse(`a{${T4}:${U2}}`).toResult(), true;
      } catch {
        return false;
      }
    }
    function R3(T4, U2) {
      var j3;
      let [, H3, V4] = (j3 = T4.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && j3 !== undefined ? j3 : [];
      if (V4 === undefined || !W3(H3) || !(0, m.default)(V4))
        return null;
      let K3 = (0, o2.normalize)(V4, {
        property: H3
      });
      return C(H3, K3) ? [
        [
          {
            sort: U2.offsets.arbitraryProperty(T4),
            layer: "utilities",
            options: {
              respectImportant: true
            }
          },
          () => ({
            [(0, i2.asClass)(T4)]: {
              [H3]: K3
            }
          })
        ]
      ] : null;
    }
    function* $3(T4, U2) {
      U2.candidateRuleMap.has(T4) && (yield [
        U2.candidateRuleMap.get(T4),
        "DEFAULT"
      ]), yield* function* (Q3) {
        Q3 !== null && (yield [
          Q3,
          "DEFAULT"
        ]);
      }(R3(T4, U2));
      let j3 = T4, H3 = false;
      const V4 = U2.tailwindConfig.prefix, K3 = V4.length, X3 = j3.startsWith(V4) || j3.startsWith(`-${V4}`);
      j3[K3] === "-" && X3 && (H3 = true, j3 = V4 + j3.slice(K3 + 1)), H3 && U2.candidateRuleMap.has(j3) && (yield [
        U2.candidateRuleMap.get(j3),
        "-DEFAULT"
      ]);
      for (let [Q3, ne4] of A(j3))
        U2.candidateRuleMap.has(Q3) && (yield [
          U2.candidateRuleMap.get(Q3),
          H3 ? `-${ne4}` : ne4
        ]);
    }
    function B3(T4, U2) {
      return T4 === e2.NOT_ON_DEMAND ? [
        e2.NOT_ON_DEMAND
      ] : (0, n2.splitAtTopLevelOnly)(T4, U2);
    }
    function* z3(T4, U2) {
      for (const V4 of T4) {
        var j3, H3;
        V4[1].raws.tailwind = {
          ...V4[1].raws.tailwind,
          classCandidate: U2,
          preserveSource: (H3 = (j3 = V4[0].options) === null || j3 === undefined ? undefined : j3.preserveSource) !== null && H3 !== undefined ? H3 : false
        }, yield V4;
      }
    }
    function* L3(T4, U2) {
      let j3 = U2.tailwindConfig.separator, [H3, ...V4] = B3(T4, j3).reverse(), K3 = false;
      H3.startsWith("!") && (K3 = true, H3 = H3.slice(1));
      for (let be3 of $3(H3, U2)) {
        let ie3 = [], ke3 = /* @__PURE__ */ new Map, [Y4, G3] = be3, te2 = Y4.length === 1;
        for (let [Z3, ee3] of Y4) {
          let se3 = [];
          if (typeof ee3 == "function")
            for (let ue of [].concat(ee3(G3, {
              isOnlyPlugin: te2
            }))) {
              let [xe3, ce3] = q2(ue, U2.postCssNodeCache);
              for (let Te3 of xe3)
                se3.push([
                  {
                    ...Z3,
                    options: {
                      ...Z3.options,
                      ...ce3
                    }
                  },
                  Te3
                ]);
            }
          else if (G3 === "DEFAULT" || G3 === "-DEFAULT") {
            let ue = ee3, [xe3, ce3] = q2(ue, U2.postCssNodeCache);
            for (let Te3 of xe3)
              se3.push([
                {
                  ...Z3,
                  options: {
                    ...Z3.options,
                    ...ce3
                  }
                },
                Te3
              ]);
          }
          if (se3.length > 0) {
            var X3, Q3, ne4;
            let ue = Array.from((0, c2.getMatchingTypes)((Q3 = (X3 = Z3.options) === null || X3 === undefined ? undefined : X3.types) !== null && Q3 !== undefined ? Q3 : [], G3, (ne4 = Z3.options) !== null && ne4 !== undefined ? ne4 : {}, U2.tailwindConfig)).map(([xe3, ce3]) => ce3);
            ue.length > 0 && ke3.set(se3, ue), ie3.push(se3);
          }
        }
        if (J3(G3)) {
          if (ie3.length > 1) {
            let se3 = function(xe3) {
              return xe3.length === 1 ? xe3[0] : xe3.find((ce3) => {
                let Te3 = ke3.get(ce3);
                return ce3.some(([{ options: ve3 }, Ae3]) => P3(Ae3) ? ve3.types.some(({ type: ae3, preferOnConflict: re3 }) => Te3.includes(ae3) && re3) : false);
              });
            }, [Z3, ee3] = ie3.reduce((xe3, ce3) => (ce3.some(([{ options: ve3 }]) => ve3.types.some(({ type: Ae3 }) => Ae3 === "any")) ? xe3[0].push(ce3) : xe3[1].push(ce3), xe3), [
              [],
              []
            ]);
            var de3;
            let ue = (de3 = se3(ee3)) !== null && de3 !== undefined ? de3 : se3(Z3);
            if (ue)
              ie3 = [
                ue
              ];
            else {
              var _e3;
              let xe3 = ie3.map((Te3) => /* @__PURE__ */ new Set([
                ...(_e3 = ke3.get(Te3)) !== null && _e3 !== undefined ? _e3 : []
              ]));
              for (let Te3 of xe3)
                for (let ve3 of Te3) {
                  let Ae3 = false;
                  for (let ae3 of xe3)
                    Te3 !== ae3 && ae3.has(ve3) && (ae3.delete(ve3), Ae3 = true);
                  Ae3 && Te3.delete(ve3);
                }
              let ce3 = [];
              for (let [Te3, ve3] of xe3.entries())
                for (let Ae3 of ve3) {
                  let ae3 = ie3[Te3].map(([, re3]) => re3).flat().map((re3) => re3.toString().split(`
`).slice(1, -1).map((fe3) => fe3.trim()).map((fe3) => `      ${fe3}`).join(`
`)).join(`

`);
                  ce3.push(`  Use \`${T4.replace("[", `[${Ae3}:`)}\` for \`${ae3.trim()}\``);
                  break;
                }
              t10.default.warn([
                `The class \`${T4}\` is ambiguous and matches multiple utilities.`,
                ...ce3,
                `If this is content and not a class, replace it with \`${T4.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`
              ]);
              continue;
            }
          }
          ie3 = ie3.map((Z3) => Z3.filter((ee3) => P3(ee3[1])));
        }
        ie3 = ie3.flat(), ie3 = Array.from(z3(ie3, H3)), ie3 = E2(ie3, U2), K3 && (ie3 = b5(ie3, H3));
        for (let Z3 of V4)
          ie3 = k4(Z3, ie3, U2);
        for (let Z3 of ie3)
          Z3[1].raws.tailwind = {
            ...Z3[1].raws.tailwind,
            candidate: T4
          }, Z3 = F(Z3, {
            context: U2,
            candidate: T4
          }), Z3 !== null && (yield Z3);
      }
    }
    function F(T4, { context: U2, candidate: j3 }) {
      if (!T4[0].collectedFormats)
        return T4;
      let H3 = true, V4;
      try {
        V4 = (0, r2.formatVariantSelector)(T4[0].collectedFormats, {
          context: U2,
          candidate: j3
        });
      } catch {
        return null;
      }
      let K3 = h2.default.root({
        nodes: [
          T4[1].clone()
        ]
      });
      return K3.walkRules((X3) => {
        if (!D(X3))
          try {
            let Q3 = (0, r2.finalizeSelector)(X3.selector, V4, {
              candidate: j3,
              context: U2
            });
            if (Q3 === null) {
              X3.remove();
              return;
            }
            X3.selector = Q3;
          } catch {
            return H3 = false, false;
          }
      }), !H3 || K3.nodes.length === 0 ? null : (T4[1] = K3.nodes[0], T4);
    }
    function D(T4) {
      return T4.parent && T4.parent.type === "atrule" && T4.parent.name === "keyframes";
    }
    function I3(T4) {
      if (T4 === true)
        return (U2) => {
          D(U2) || U2.walkDecls((j3) => {
            j3.parent.type === "rule" && !D(j3.parent) && (j3.important = true);
          });
        };
      if (typeof T4 == "string")
        return (U2) => {
          D(U2) || (U2.selectors = U2.selectors.map((j3) => (0, _4.applyImportantSelector)(j3, T4)));
        };
    }
    function N3(T4, U2, j3 = false) {
      let H3 = [], V4 = I3(U2.tailwindConfig.important);
      for (let X3 of T4) {
        if (U2.notClassCache.has(X3))
          continue;
        if (U2.candidateRuleCache.has(X3)) {
          H3 = H3.concat(Array.from(U2.candidateRuleCache.get(X3)));
          continue;
        }
        let Q3 = Array.from(L3(X3, U2));
        if (Q3.length === 0) {
          U2.notClassCache.add(X3);
          continue;
        }
        U2.classCache.set(X3, Q3);
        var K3;
        let ne4 = (K3 = U2.candidateRuleCache.get(X3)) !== null && K3 !== undefined ? K3 : /* @__PURE__ */ new Set;
        U2.candidateRuleCache.set(X3, ne4);
        for (const de3 of Q3) {
          let [{ sort: _e3, options: be3 }, ie3] = de3;
          if (be3.respectImportant && V4) {
            let Y4 = h2.default.root({
              nodes: [
                ie3.clone()
              ]
            });
            Y4.walkRules(V4), ie3 = Y4.nodes[0];
          }
          let ke3 = [
            _e3,
            j3 ? ie3.clone() : ie3
          ];
          ne4.add(ke3), U2.ruleCache.add(ke3), H3.push(ke3);
        }
      }
      return H3;
    }
    function J3(T4) {
      return T4.startsWith("[") && T4.endsWith("]");
    }
  }(qn3)), qn3;
}
var Bo2;
function Nf() {
  return Bo2 || (Bo2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return O3;
      }
    });
    const a = /* @__PURE__ */ c2(Be2()), h2 = /* @__PURE__ */ c2(Ke3()), p = wr3(), l3 = /* @__PURE__ */ c2(ft3()), f = su3(), s2 = Ji2();
    function c2(A) {
      return A && A.__esModule ? A : {
        default: A
      };
    }
    function t10(A) {
      let E2 = /* @__PURE__ */ new Map;
      a.default.root({
        nodes: [
          A.clone()
        ]
      }).walkRules((M2) => {
        (0, h2.default)((W3) => {
          W3.walkClasses((S3) => {
            let P3 = S3.parent.toString(), C = E2.get(P3);
            C || E2.set(P3, C = /* @__PURE__ */ new Set), C.add(S3.value);
          });
        }).processSync(M2.selector);
      });
      let k4 = Array.from(E2.values(), (M2) => Array.from(M2)), q2 = k4.flat();
      return Object.assign(q2, {
        groups: k4
      });
    }
    let e2 = (0, h2.default)();
    function r2(A) {
      return e2.astSync(A);
    }
    function i2(A, E2) {
      let b5 = /* @__PURE__ */ new Set;
      for (let k4 of A)
        b5.add(k4.split(E2).pop());
      return Array.from(b5);
    }
    function o2(A, E2) {
      let b5 = A.tailwindConfig.prefix;
      return typeof b5 == "function" ? b5(E2) : b5 + E2;
    }
    function* v3(A) {
      for (yield A;A.parent; )
        yield A.parent, A = A.parent;
    }
    function m(A, E2 = {}) {
      let b5 = A.nodes;
      A.nodes = [];
      let k4 = A.clone(E2);
      return A.nodes = b5, k4;
    }
    function n2(A) {
      for (let E2 of v3(A))
        if (A !== E2) {
          if (E2.type === "root")
            break;
          A = m(E2, {
            nodes: [
              A
            ]
          });
        }
      return A;
    }
    function d2(A, E2) {
      let b5 = /* @__PURE__ */ new Map;
      return A.walkRules((k4) => {
        for (let S3 of v3(k4)) {
          var q2;
          if (((q2 = S3.raws.tailwind) === null || q2 === undefined ? undefined : q2.layer) !== undefined)
            return;
        }
        let M2 = n2(k4), W3 = E2.offsets.create("user");
        for (let S3 of t10(k4)) {
          let P3 = b5.get(S3) || [];
          b5.set(S3, P3), P3.push([
            {
              layer: "user",
              sort: W3,
              important: false
            },
            M2
          ]);
        }
      }), b5;
    }
    function _4(A, E2) {
      for (let b5 of A) {
        if (E2.notClassCache.has(b5) || E2.applyClassCache.has(b5))
          continue;
        if (E2.classCache.has(b5)) {
          E2.applyClassCache.set(b5, E2.classCache.get(b5).map(([q2, M2]) => [
            q2,
            M2.clone()
          ]));
          continue;
        }
        let k4 = Array.from((0, p.resolveMatches)(b5, E2));
        if (k4.length === 0) {
          E2.notClassCache.add(b5);
          continue;
        }
        E2.applyClassCache.set(b5, k4);
      }
      return E2.applyClassCache;
    }
    function w3(A) {
      let E2 = null;
      return {
        get: (b5) => (E2 = E2 || A(), E2.get(b5)),
        has: (b5) => (E2 = E2 || A(), E2.has(b5))
      };
    }
    function y2(A) {
      return {
        get: (E2) => A.flatMap((b5) => b5.get(E2) || []),
        has: (E2) => A.some((b5) => b5.has(E2))
      };
    }
    function x2(A) {
      let E2 = A.split(/[\s\t\n]+/g);
      return E2[E2.length - 1] === "!important" ? [
        E2.slice(0, -1),
        true
      ] : [
        E2,
        false
      ];
    }
    function g2(A, E2, b5) {
      let k4 = /* @__PURE__ */ new Set, q2 = [];
      if (A.walkAtRules("apply", (P3) => {
        let [C] = x2(P3.params);
        for (let R3 of C)
          k4.add(R3);
        q2.push(P3);
      }), q2.length === 0)
        return;
      let M2 = y2([
        b5,
        _4(k4, E2)
      ]);
      function W3(P3, C, R3) {
        let $3 = r2(P3), B3 = r2(C), L3 = r2(`.${(0, l3.default)(R3)}`).nodes[0].nodes[0];
        return $3.each((F) => {
          let D = /* @__PURE__ */ new Set;
          B3.each((I3) => {
            let N3 = false;
            I3 = I3.clone(), I3.walkClasses((J3) => {
              J3.value === L3.value && (N3 || (J3.replaceWith(...F.nodes.map((T4) => T4.clone())), D.add(I3), N3 = true));
            });
          });
          for (let I3 of D) {
            let N3 = [
              []
            ];
            for (let J3 of I3.nodes)
              J3.type === "combinator" ? (N3.push(J3), N3.push([])) : N3[N3.length - 1].push(J3);
            I3.nodes = [];
            for (let J3 of N3)
              Array.isArray(J3) && J3.sort((T4, U2) => T4.type === "tag" && U2.type === "class" ? -1 : T4.type === "class" && U2.type === "tag" ? 1 : T4.type === "class" && U2.type === "pseudo" && U2.value.startsWith("::") ? -1 : T4.type === "pseudo" && T4.value.startsWith("::") && U2.type === "class" ? 1 : 0), I3.nodes = I3.nodes.concat(J3);
          }
          F.replaceWith(...D);
        }), $3.toString();
      }
      let S3 = /* @__PURE__ */ new Map;
      for (let P3 of q2) {
        let [C] = S3.get(P3.parent) || [
          [],
          P3.source
        ];
        S3.set(P3.parent, [
          C,
          P3.source
        ]);
        let [R3, $3] = x2(P3.params);
        if (P3.parent.type === "atrule") {
          if (P3.parent.name === "screen") {
            let B3 = P3.parent.params;
            throw P3.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${R3.map((z3) => `${B3}:${z3}`).join(" ")} instead.`);
          }
          throw P3.error(`@apply is not supported within nested at-rules like @${P3.parent.name}. You can fix this by un-nesting @${P3.parent.name}.`);
        }
        for (let B3 of R3) {
          if ([
            o2(E2, "group"),
            o2(E2, "peer")
          ].includes(B3))
            throw P3.error(`@apply should not be used with the '${B3}' utility`);
          if (!M2.has(B3))
            throw P3.error(`The \`${B3}\` class does not exist. If \`${B3}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
          let z3 = M2.get(B3);
          for (let [, L3] of z3)
            L3.type !== "atrule" && L3.walkRules(() => {
              throw P3.error([
                `The \`${B3}\` class cannot be used with \`@apply\` because \`@apply\` does not currently support nested CSS.`,
                "Rewrite the selector without nesting or configure the `tailwindcss/nesting` plugin:",
                "https://tailwindcss.com/docs/using-with-preprocessors#nesting"
              ].join(`
`));
            });
          C.push([
            B3,
            $3,
            z3
          ]);
        }
      }
      for (let [P3, [C, R3]] of S3) {
        let $3 = [];
        for (let [z3, L3, F] of C) {
          let D = [
            z3,
            ...i2([
              z3
            ], E2.tailwindConfig.separator)
          ];
          for (let [I3, N3] of F) {
            let J3 = t10(P3), T4 = t10(N3);
            if (T4 = T4.groups.filter((V4) => V4.some((K3) => D.includes(K3))).flat(), T4 = T4.concat(i2(T4, E2.tailwindConfig.separator)), J3.some((V4) => T4.includes(V4)))
              throw N3.error(`You cannot \`@apply\` the \`${z3}\` utility here because it creates a circular dependency.`);
            let j3 = a.default.root({
              nodes: [
                N3.clone()
              ]
            });
            j3.walk((V4) => {
              V4.source = R3;
            }), (N3.type !== "atrule" || N3.type === "atrule" && N3.name !== "keyframes") && j3.walkRules((V4) => {
              if (!t10(V4).some((de3) => de3 === z3)) {
                V4.remove();
                return;
              }
              let K3 = typeof E2.tailwindConfig.important == "string" ? E2.tailwindConfig.important : null, Q3 = P3.raws.tailwind !== undefined && K3 && P3.selector.indexOf(K3) === 0 ? P3.selector.slice(K3.length) : P3.selector;
              Q3 === "" && (Q3 = P3.selector), V4.selector = W3(Q3, V4.selector, z3), K3 && Q3 !== P3.selector && (V4.selector = (0, f.applyImportantSelector)(V4.selector, K3)), V4.walkDecls((de3) => {
                de3.important = I3.important || L3;
              });
              let ne4 = (0, h2.default)().astSync(V4.selector);
              ne4.each((de3) => (0, s2.movePseudos)(de3)), V4.selector = ne4.toString();
            }), j3.nodes[0] && $3.push([
              I3.sort,
              j3.nodes[0]
            ]);
          }
        }
        let B3 = E2.offsets.sort($3).map((z3) => z3[1]);
        P3.after(B3);
      }
      for (let P3 of q2)
        P3.parent.nodes.length > 1 ? P3.remove() : P3.parent.remove();
      g2(A, E2, b5);
    }
    function O3(A) {
      return (E2) => {
        let b5 = w3(() => d2(E2, A));
        g2(E2, A, b5);
      };
    }
  }(Rn3)), Rn3;
}
var Ff = Nf();
var $f = /* @__PURE__ */ He3(Ff);
var ui2 = {};
var fi2;
var Go3;
function Uf() {
  if (Go3)
    return fi2;
  Go3 = 1;

  class u {
    constructor(h2 = {}) {
      if (!(h2.maxSize && h2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof h2.maxAge == "number" && h2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = h2.maxSize, this.maxAge = h2.maxAge || 1 / 0, this.onEviction = h2.onEviction, this.cache = /* @__PURE__ */ new Map, this.oldCache = /* @__PURE__ */ new Map, this._size = 0;
    }
    _emitEvictions(h2) {
      if (typeof this.onEviction == "function")
        for (const [p, l3] of h2)
          this.onEviction(p, l3.value);
    }
    _deleteIfExpired(h2, p) {
      return typeof p.expiry == "number" && p.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(h2, p.value), this.delete(h2)) : false;
    }
    _getOrDeleteIfExpired(h2, p) {
      if (this._deleteIfExpired(h2, p) === false)
        return p.value;
    }
    _getItemValue(h2, p) {
      return p.expiry ? this._getOrDeleteIfExpired(h2, p) : p.value;
    }
    _peek(h2, p) {
      const l3 = p.get(h2);
      return this._getItemValue(h2, l3);
    }
    _set(h2, p) {
      this.cache.set(h2, p), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map);
    }
    _moveToRecent(h2, p) {
      this.oldCache.delete(h2), this._set(h2, p);
    }
    *_entriesAscending() {
      for (const h2 of this.oldCache) {
        const [p, l3] = h2;
        this.cache.has(p) || this._deleteIfExpired(p, l3) === false && (yield h2);
      }
      for (const h2 of this.cache) {
        const [p, l3] = h2;
        this._deleteIfExpired(p, l3) === false && (yield h2);
      }
    }
    get(h2) {
      if (this.cache.has(h2)) {
        const p = this.cache.get(h2);
        return this._getItemValue(h2, p);
      }
      if (this.oldCache.has(h2)) {
        const p = this.oldCache.get(h2);
        if (this._deleteIfExpired(h2, p) === false)
          return this._moveToRecent(h2, p), p.value;
      }
    }
    set(h2, p, { maxAge: l3 = this.maxAge === 1 / 0 ? undefined : Date.now() + this.maxAge } = {}) {
      this.cache.has(h2) ? this.cache.set(h2, {
        value: p,
        maxAge: l3
      }) : this._set(h2, { value: p, expiry: l3 });
    }
    has(h2) {
      return this.cache.has(h2) ? !this._deleteIfExpired(h2, this.cache.get(h2)) : this.oldCache.has(h2) ? !this._deleteIfExpired(h2, this.oldCache.get(h2)) : false;
    }
    peek(h2) {
      if (this.cache.has(h2))
        return this._peek(h2, this.cache);
      if (this.oldCache.has(h2))
        return this._peek(h2, this.oldCache);
    }
    delete(h2) {
      const p = this.cache.delete(h2);
      return p && this._size--, this.oldCache.delete(h2) || p;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(h2) {
      if (!(h2 && h2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      const p = [...this._entriesAscending()], l3 = p.length - h2;
      l3 < 0 ? (this.cache = new Map(p), this.oldCache = /* @__PURE__ */ new Map, this._size = p.length) : (l3 > 0 && this._emitEvictions(p.slice(0, l3)), this.oldCache = new Map(p.slice(l3)), this.cache = /* @__PURE__ */ new Map, this._size = 0), this.maxSize = h2;
    }
    *keys() {
      for (const [h2] of this)
        yield h2;
    }
    *values() {
      for (const [, h2] of this)
        yield h2;
    }
    *[Symbol.iterator]() {
      for (const h2 of this.cache) {
        const [p, l3] = h2;
        this._deleteIfExpired(p, l3) === false && (yield [p, l3.value]);
      }
      for (const h2 of this.oldCache) {
        const [p, l3] = h2;
        this.cache.has(p) || this._deleteIfExpired(p, l3) === false && (yield [p, l3.value]);
      }
    }
    *entriesDescending() {
      let h2 = [...this.cache];
      for (let p = h2.length - 1;p >= 0; --p) {
        const l3 = h2[p], [f, s2] = l3;
        this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
      h2 = [...this.oldCache];
      for (let p = h2.length - 1;p >= 0; --p) {
        const l3 = h2[p], [f, s2] = l3;
        this.cache.has(f) || this._deleteIfExpired(f, s2) === false && (yield [f, s2.value]);
      }
    }
    *entriesAscending() {
      for (const [h2, p] of this._entriesAscending())
        yield [h2, p.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let h2 = 0;
      for (const p of this.oldCache.keys())
        this.cache.has(p) || h2++;
      return Math.min(this._size + h2, this.maxSize);
    }
  }
  return fi2 = u, fi2;
}
var ci2 = {};
var Yo3;
function zf() {
  return Yo3 || (Yo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(p, l3 = undefined, f = undefined) {
      return p.map((s2) => {
        let c2 = s2.clone();
        return f !== undefined && (c2.raws.tailwind = {
          ...c2.raws.tailwind,
          ...f
        }), l3 !== undefined && h2(c2, (t10) => {
          var e2;
          if (((e2 = t10.raws.tailwind) === null || e2 === undefined ? undefined : e2.preserveSource) === true && t10.source)
            return false;
          t10.source = l3;
        }), c2;
      });
    }
    function h2(p, l3) {
      if (l3(p) !== false) {
        var f;
        (f = p.each) === null || f === undefined || f.call(p, (s2) => h2(s2, l3));
      }
    }
  }(ci2)), ci2;
}
var di2 = {};
var pi2 = {};
var Qo3;
function Wf() {
  return Qo3 || (Qo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3)
        Object.defineProperty(o2, m, {
          enumerable: true,
          get: v3[m]
        });
    }
    a(u, {
      pattern: function() {
        return f;
      },
      withoutCapturing: function() {
        return s2;
      },
      any: function() {
        return c2;
      },
      optional: function() {
        return t10;
      },
      zeroOrMore: function() {
        return e2;
      },
      nestedBrackets: function() {
        return r2;
      },
      escape: function() {
        return i2;
      }
    });
    const h2 = /[\\^$.*+?()[\]{}|]/g, p = RegExp(h2.source);
    function l3(o2) {
      return o2 = Array.isArray(o2) ? o2 : [
        o2
      ], o2 = o2.map((v3) => v3 instanceof RegExp ? v3.source : v3), o2.join("");
    }
    function f(o2) {
      return new RegExp(l3(o2), "g");
    }
    function s2(o2) {
      return new RegExp(`(?:${l3(o2)})`, "g");
    }
    function c2(o2) {
      return `(?:${o2.map(l3).join("|")})`;
    }
    function t10(o2) {
      return `(?:${l3(o2)})?`;
    }
    function e2(o2) {
      return `(?:${l3(o2)})*`;
    }
    function r2(o2, v3, m = 1) {
      return s2([
        i2(o2),
        /[^\s]*/,
        m === 1 ? `[^${i2(o2)}${i2(v3)}s]*` : c2([
          `[^${i2(o2)}${i2(v3)}s]*`,
          r2(o2, v3, m - 1)
        ]),
        /[^\s]*/,
        i2(v3)
      ]);
    }
    function i2(o2) {
      return o2 && p.test(o2) ? o2.replace(h2, "\\$&") : o2 || "";
    }
  }(pi2)), pi2;
}
var Ho3;
function Vf() {
  return Ho3 || (Ho3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaultExtractor", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = /* @__PURE__ */ l3(Wf()), h2 = st3();
    function p(r2) {
      if (typeof WeakMap != "function")
        return null;
      var i2 = /* @__PURE__ */ new WeakMap, o2 = /* @__PURE__ */ new WeakMap;
      return (p = function(v3) {
        return v3 ? o2 : i2;
      })(r2);
    }
    function l3(r2, i2) {
      if (r2 && r2.__esModule)
        return r2;
      if (r2 === null || typeof r2 != "object" && typeof r2 != "function")
        return {
          default: r2
        };
      var o2 = p(i2);
      if (o2 && o2.has(r2))
        return o2.get(r2);
      var v3 = {}, m = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var n2 in r2)
        if (n2 !== "default" && Object.prototype.hasOwnProperty.call(r2, n2)) {
          var d2 = m ? Object.getOwnPropertyDescriptor(r2, n2) : null;
          d2 && (d2.get || d2.set) ? Object.defineProperty(v3, n2, d2) : v3[n2] = r2[n2];
        }
      return v3.default = r2, o2 && o2.set(r2, v3), v3;
    }
    function f(r2) {
      let i2 = Array.from(s2(r2));
      return (o2) => {
        let v3 = [];
        for (let n2 of i2) {
          var m;
          for (let d2 of (m = o2.match(n2)) !== null && m !== undefined ? m : [])
            v3.push(e2(d2));
        }
        for (let n2 of v3.slice()) {
          let d2 = (0, h2.splitAtTopLevelOnly)(n2, ".");
          for (let _4 = 0;_4 < d2.length; _4++) {
            let w3 = d2[_4];
            if (_4 >= d2.length - 1) {
              v3.push(w3);
              continue;
            }
            let y2 = Number(d2[_4 + 1]);
            isNaN(y2) ? v3.push(w3) : _4++;
          }
        }
        return v3;
      };
    }
    function* s2(r2) {
      let i2 = r2.tailwindConfig.separator, o2 = r2.tailwindConfig.prefix !== "" ? a.optional(a.pattern([
        /-?/,
        a.escape(r2.tailwindConfig.prefix)
      ])) : "", v3 = a.any([
        /\[[^\s:'"`]+:[^\s\[\]]+\]/,
        /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/,
        a.pattern([
          a.any([
            /-?(?:\w+)/,
            /@(?:\w+)/
          ]),
          a.optional(a.any([
            a.pattern([
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s:\[\]]+\]/
              ]),
              /(?![{([]])/,
              /(?:\/[^\s'"`\\><$]*)?/
            ]),
            a.pattern([
              a.any([
                /-(?:\w+-)*\['[^\s]+'\]/,
                /-(?:\w+-)*\["[^\s]+"\]/,
                /-(?:\w+-)*\[`[^\s]+`\]/,
                /-(?:\w+-)*\[(?:[^\s\[\]]+\[[^\s\[\]]+\])*[^\s\[\]]+\]/
              ]),
              /(?![{([]])/,
              /(?:\/[^\s'"`\\$]*)?/
            ]),
            /[-\/][^\s'"`\\$={><]*/
          ]))
        ])
      ]), m = [
        a.any([
          a.pattern([
            /@\[[^\s"'`]+\](\/[^\s"'`]+)?/,
            i2
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/[\w_-]+/,
            i2
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/,
            i2
          ]),
          a.pattern([
            /[^\s"'`\[\\]+/,
            i2
          ])
        ]),
        a.any([
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]\/[\w_-]+/,
            i2
          ]),
          a.pattern([
            /([^\s"'`\[\\]+-)?\[[^\s`]+\]/,
            i2
          ]),
          a.pattern([
            /[^\s`\[\\]+/,
            i2
          ])
        ])
      ];
      for (const n2 of m)
        yield a.pattern([
          "((?=((",
          n2,
          ")+))\\2)?",
          /!?/,
          o2,
          v3
        ]);
      yield /[^<>"'`\s.(){}[\]#=%$][^<>"'`\s(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
    }
    let c2 = /([\[\]'"`])([^\[\]'"`])?/g, t10 = /[^"'`\s<>\]]+/;
    function e2(r2) {
      if (!r2.includes("-["))
        return r2;
      let i2 = 0, o2 = [], v3 = r2.matchAll(c2);
      v3 = Array.from(v3).flatMap((m) => {
        const [, ...n2] = m;
        return n2.map((d2, _4) => Object.assign([], m, {
          index: m.index + _4,
          0: d2
        }));
      });
      for (let m of v3) {
        let n2 = m[0], d2 = o2[o2.length - 1];
        if (n2 === d2 ? o2.pop() : (n2 === "'" || n2 === '"' || n2 === "`") && o2.push(n2), !d2) {
          if (n2 === "[") {
            i2++;
            continue;
          } else if (n2 === "]") {
            i2--;
            continue;
          }
          if (i2 < 0)
            return r2.substring(0, m.index - 1);
          if (i2 === 0 && !t10.test(n2))
            return r2.substring(0, m.index);
        }
      }
      return r2;
    }
  }(di2)), di2;
}
var Jo3;
function jf() {
  return Jo3 || (Jo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return y2;
      }
    });
    const a = /* @__PURE__ */ t10(Ne3), h2 = /* @__PURE__ */ t10(Uf()), p = /* @__PURE__ */ r2(yr3()), l3 = wr3(), f = /* @__PURE__ */ t10(tt3()), s2 = /* @__PURE__ */ t10(zf()), c2 = Vf();
    function t10(x2) {
      return x2 && x2.__esModule ? x2 : {
        default: x2
      };
    }
    function e2(x2) {
      if (typeof WeakMap != "function")
        return null;
      var g2 = /* @__PURE__ */ new WeakMap, O3 = /* @__PURE__ */ new WeakMap;
      return (e2 = function(A) {
        return A ? O3 : g2;
      })(x2);
    }
    function r2(x2, g2) {
      if (x2 && x2.__esModule)
        return x2;
      if (x2 === null || typeof x2 != "object" && typeof x2 != "function")
        return {
          default: x2
        };
      var O3 = e2(g2);
      if (O3 && O3.has(x2))
        return O3.get(x2);
      var A = {}, E2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var b5 in x2)
        if (b5 !== "default" && Object.prototype.hasOwnProperty.call(x2, b5)) {
          var k4 = E2 ? Object.getOwnPropertyDescriptor(x2, b5) : null;
          k4 && (k4.get || k4.set) ? Object.defineProperty(A, b5, k4) : A[b5] = x2[b5];
        }
      return A.default = x2, O3 && O3.set(x2, A), A;
    }
    let i2 = p.env;
    const o2 = {
      DEFAULT: c2.defaultExtractor
    }, v3 = {
      DEFAULT: (x2) => x2,
      svelte: (x2) => x2.replace(/(?:^|\s)class:/g, " ")
    };
    function m(x2, g2) {
      let O3 = x2.tailwindConfig.content.extract;
      return O3[g2] || O3.DEFAULT || o2[g2] || o2.DEFAULT(x2);
    }
    function n2(x2, g2) {
      let O3 = x2.content.transform;
      return O3[g2] || O3.DEFAULT || v3[g2] || v3.DEFAULT;
    }
    let d2 = /* @__PURE__ */ new WeakMap;
    function _4(x2, g2, O3, A) {
      d2.has(g2) || d2.set(g2, new h2.default({
        maxSize: 25000
      }));
      for (let E2 of x2.split(`
`))
        if (E2 = E2.trim(), !A.has(E2))
          if (A.add(E2), d2.get(g2).has(E2))
            for (let b5 of d2.get(g2).get(E2))
              O3.add(b5);
          else {
            let b5 = g2(E2).filter((q2) => q2 !== "!*"), k4 = new Set(b5);
            for (let q2 of k4)
              O3.add(q2);
            d2.get(g2).set(E2, k4);
          }
    }
    function w3(x2, g2) {
      let O3 = g2.offsets.sort(x2), A = {
        base: /* @__PURE__ */ new Set,
        defaults: /* @__PURE__ */ new Set,
        components: /* @__PURE__ */ new Set,
        utilities: /* @__PURE__ */ new Set,
        variants: /* @__PURE__ */ new Set
      };
      for (let [E2, b5] of O3)
        A[E2.layer].add(b5);
      return A;
    }
    function y2(x2) {
      return async (g2) => {
        let O3 = {
          base: null,
          components: null,
          utilities: null,
          variants: null
        };
        if (g2.walkAtRules((F) => {
          F.name === "tailwind" && Object.keys(O3).includes(F.params) && (O3[F.params] = F);
        }), Object.values(O3).every((F) => F === null))
          return g2;
        var A;
        let E2 = /* @__PURE__ */ new Set([
          ...(A = x2.candidates) !== null && A !== undefined ? A : [],
          p.NOT_ON_DEMAND
        ]), b5 = /* @__PURE__ */ new Set;
        i2.DEBUG && console.time("Reading changed files");
        let k4 = [];
        for (let F of x2.changedContent) {
          let D = n2(x2.tailwindConfig, F.extension), I3 = m(x2, F.extension);
          k4.push([
            F,
            {
              transformer: D,
              extractor: I3
            }
          ]);
        }
        const q2 = 500;
        for (let F = 0;F < k4.length; F += q2) {
          let D = k4.slice(F, F + q2);
          await Promise.all(D.map(async ([{ file: I3, content: N3 }, { transformer: J3, extractor: T4 }]) => {
            N3 = I3 ? await a.default.promises.readFile(I3, "utf8") : N3, _4(J3(N3), T4, E2, b5);
          }));
        }
        i2.DEBUG && console.timeEnd("Reading changed files");
        let M2 = x2.classCache.size;
        i2.DEBUG && console.time("Generate rules"), i2.DEBUG && console.time("Sorting candidates");
        let W3 = new Set([
          ...E2
        ].sort((F, D) => F === D ? 0 : F < D ? -1 : 1));
        i2.DEBUG && console.timeEnd("Sorting candidates"), (0, l3.generateRules)(W3, x2), i2.DEBUG && console.timeEnd("Generate rules"), i2.DEBUG && console.time("Build stylesheet"), (x2.stylesheetCache === null || x2.classCache.size !== M2) && (x2.stylesheetCache = w3([
          ...x2.ruleCache
        ], x2)), i2.DEBUG && console.timeEnd("Build stylesheet");
        let { defaults: S3, base: P3, components: C, utilities: R3, variants: $3 } = x2.stylesheetCache;
        O3.base && (O3.base.before((0, s2.default)([
          ...P3,
          ...S3
        ], O3.base.source, {
          layer: "base"
        })), O3.base.remove()), O3.components && (O3.components.before((0, s2.default)([
          ...C
        ], O3.components.source, {
          layer: "components"
        })), O3.components.remove()), O3.utilities && (O3.utilities.before((0, s2.default)([
          ...R3
        ], O3.utilities.source, {
          layer: "utilities"
        })), O3.utilities.remove());
        const B3 = Array.from($3).filter((F) => {
          var D;
          const I3 = (D = F.raws.tailwind) === null || D === undefined ? undefined : D.parentLayer;
          return I3 === "components" ? O3.components !== null : I3 === "utilities" ? O3.utilities !== null : true;
        });
        O3.variants ? (O3.variants.before((0, s2.default)(B3, O3.variants.source, {
          layer: "variants"
        })), O3.variants.remove()) : B3.length > 0 && g2.append((0, s2.default)(B3, g2.source, {
          layer: "variants"
        }));
        var z3;
        g2.source.end = (z3 = g2.source.end) !== null && z3 !== undefined ? z3 : g2.source.start;
        const L3 = B3.some((F) => {
          var D;
          return ((D = F.raws.tailwind) === null || D === undefined ? undefined : D.parentLayer) === "utilities";
        });
        O3.utilities && R3.size === 0 && !L3 && f.default.warn("content-problems", [
          "No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.",
          "https://tailwindcss.com/docs/content-configuration"
        ]), i2.DEBUG && (console.log("Potential classes: ", E2.size), console.log("Active contexts: ", p.contextSourcesMap.size)), x2.changedContent = [], g2.walkAtRules("layer", (F) => {
          Object.keys(O3).includes(F.params) && F.remove();
        });
      };
    }
  }(ui2)), ui2;
}
var Bf = jf();
var Gf = /* @__PURE__ */ He3(Bf);
var Yf = wr3();
var hi2 = {};
var Ko3;
function Qf() {
  return Ko3 || (Ko3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return h2;
      }
    });
    function a(p) {
      if (!p.walkAtRules)
        return;
      let l3 = /* @__PURE__ */ new Set;
      if (p.walkAtRules("apply", (f) => {
        l3.add(f.parent);
      }), l3.size !== 0)
        for (let f of l3) {
          let s2 = [], c2 = [];
          for (let t10 of f.nodes)
            t10.type === "atrule" && t10.name === "apply" ? (c2.length > 0 && (s2.push(c2), c2 = []), s2.push([
              t10
            ])) : c2.push(t10);
          if (c2.length > 0 && s2.push(c2), s2.length !== 1) {
            for (let t10 of [
              ...s2
            ].reverse()) {
              let e2 = f.clone({
                nodes: []
              });
              e2.append(t10), f.after(e2);
            }
            f.remove();
          }
        }
    }
    function h2() {
      return (p) => {
        a(p);
      };
    }
  }(hi2)), hi2;
}
var Hf = Qf();
var Xo3 = /* @__PURE__ */ He3(Hf);
var vi2 = {};
var Zo3;
function Jf() {
  return Zo3 || (Zo3 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    });
    function a(o2, v3) {
      for (var m in v3)
        Object.defineProperty(o2, m, {
          enumerable: true,
          get: v3[m]
        });
    }
    a(u, {
      elementSelectorParser: function() {
        return t10;
      },
      default: function() {
        return i2;
      }
    });
    const h2 = /* @__PURE__ */ f(Be2()), p = /* @__PURE__ */ f(Ke3()), l3 = it3();
    function f(o2) {
      return o2 && o2.__esModule ? o2 : {
        default: o2
      };
    }
    let s2 = {
      id(o2) {
        return p.default.attribute({
          attribute: "id",
          operator: "=",
          value: o2.value,
          quoteMark: '"'
        });
      }
    };
    function c2(o2) {
      let v3 = o2.filter((y2) => y2.type !== "pseudo" || y2.nodes.length > 0 ? true : y2.value.startsWith("::") || [
        ":before",
        ":after",
        ":first-line",
        ":first-letter"
      ].includes(y2.value)).reverse(), m = /* @__PURE__ */ new Set([
        "tag",
        "class",
        "id",
        "attribute"
      ]), n2 = v3.findIndex((y2) => m.has(y2.type));
      if (n2 === -1)
        return v3.reverse().join("").trim();
      let d2 = v3[n2], _4 = s2[d2.type] ? s2[d2.type](d2) : d2;
      v3 = v3.slice(0, n2);
      let w3 = v3.findIndex((y2) => y2.type === "combinator" && y2.value === ">");
      return w3 !== -1 && (v3.splice(0, w3), v3.unshift(p.default.universal())), [
        _4,
        ...v3.reverse()
      ].join("").trim();
    }
    let t10 = (0, p.default)((o2) => o2.map((v3) => {
      let m = v3.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
      return c2(m);
    })), e2 = /* @__PURE__ */ new Map;
    function r2(o2) {
      return e2.has(o2) || e2.set(o2, t10.transformSync(o2)), e2.get(o2);
    }
    function i2({ tailwindConfig: o2 }) {
      return (v3) => {
        let m = /* @__PURE__ */ new Map, n2 = /* @__PURE__ */ new Set;
        if (v3.walkAtRules("defaults", (w3) => {
          if (w3.nodes && w3.nodes.length > 0) {
            n2.add(w3);
            return;
          }
          let y2 = w3.params;
          m.has(y2) || m.set(y2, /* @__PURE__ */ new Set), m.get(y2).add(w3.parent), w3.remove();
        }), (0, l3.flagEnabled)(o2, "optimizeUniversalDefaults"))
          for (let w3 of n2) {
            let y2 = /* @__PURE__ */ new Map;
            var d2;
            let x2 = (d2 = m.get(w3.params)) !== null && d2 !== undefined ? d2 : [];
            for (let g2 of x2)
              for (let O3 of r2(g2.selector)) {
                let A = O3.includes(":-") || O3.includes("::-") || O3.includes(":has") ? O3 : "__DEFAULT__";
                var _4;
                let E2 = (_4 = y2.get(A)) !== null && _4 !== undefined ? _4 : /* @__PURE__ */ new Set;
                y2.set(A, E2), E2.add(O3);
              }
            if ((0, l3.flagEnabled)(o2, "optimizeUniversalDefaults")) {
              if (y2.size === 0) {
                w3.remove();
                continue;
              }
              for (let [, g2] of y2) {
                let O3 = h2.default.rule({
                  source: w3.source
                });
                O3.selectors = [
                  ...g2
                ], O3.append(w3.nodes.map((A) => A.clone())), w3.before(O3);
              }
            }
            w3.remove();
          }
        else if (n2.size) {
          let w3 = h2.default.rule({
            selectors: [
              "*",
              "::before",
              "::after"
            ]
          });
          for (let x2 of n2)
            w3.append(x2.nodes), w3.parent || x2.before(w3), w3.source || (w3.source = x2.source), x2.remove();
          let y2 = w3.clone({
            selectors: [
              "::backdrop"
            ]
          });
          w3.after(y2);
        }
      };
    }
  }(vi2)), vi2;
}
var Kf = Jf();
var Xf = /* @__PURE__ */ He3(Kf);
var gi2 = {};
var el;
function Zf() {
  return el || (el = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = Ui2(), h2 = /* @__PURE__ */ p(zi2());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3({ tailwindConfig: { theme: f } }) {
      return function(s2) {
        s2.walkAtRules("screen", (c2) => {
          let t10 = c2.params, r2 = (0, a.normalizeScreens)(f.screens).find(({ name: i2 }) => i2 === t10);
          if (!r2)
            throw c2.error(`No \`${t10}\` screen found.`);
          c2.name = "media", c2.params = (0, h2.default)(r2);
        });
      };
    }
  }(gi2)), gi2;
}
var ec2 = Zf();
var tc = /* @__PURE__ */ He3(ec2);
var rc = (u, a) => u instanceof Ra2 && a instanceof Ra2 ? u.selector === a.selector || a.selector.includes("*") || a.selector.includes(":root") : u === a;
var nc = (u) => (u.walkRules((a) => {
  const h2 = /* @__PURE__ */ new Map, p = /* @__PURE__ */ new Set;
  a.walkDecls((l3) => {
    if (/var\(--[^\s)]+\)/.test(l3.value)) {
      const f = [
        ...l3.value.matchAll(/var\(--[^\s)]+\)/gm)
      ].map((s2) => s2.toString());
      u.walkDecls((s2) => {
        var c2;
        if (/--[^\s]+/.test(s2.prop)) {
          const t10 = `var(${s2.prop})`;
          if (f != null && f.includes(t10) && rc(l3.parent, s2.parent)) {
            if (((c2 = s2.parent) == null ? undefined : c2.parent) instanceof wl && s2.parent !== l3.parent) {
              const e2 = s2.parent.parent, r2 = xu2();
              r2.prop = l3.prop, r2.value = l3.value.replaceAll(t10, s2.value), r2.important = l3.important;
              const i2 = h2.get(e2);
              i2 ? i2.add(r2) : h2.set(s2.parent.parent, /* @__PURE__ */ new Set([r2]));
              return;
            }
            p.add({
              declaration: l3,
              replacing: t10,
              replacement: s2.value
            });
          }
        }
      });
    }
  });
  for (const {
    declaration: l3,
    replacing: f,
    replacement: s2
  } of p)
    l3.value = l3.value.replaceAll(f, s2);
  for (const [l3, f] of h2.entries()) {
    const s2 = Su2();
    s2.selector = a.selector, s2.append(...f), l3.append(s2);
  }
}), u.walkDecls((a) => {
  if (/--[^\s]+/.test(a.prop)) {
    const h2 = a.parent;
    a.remove(), h2 && Li2(h2);
  }
}), u);
var ic = Ki2();
var mi2 = {};
var yi2 = {};
var wi2 = {};
var tl;
function ac() {
  return tl || (tl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    const a = [
      "preflight",
      "container",
      "accessibility",
      "pointerEvents",
      "visibility",
      "position",
      "inset",
      "isolation",
      "zIndex",
      "order",
      "gridColumn",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRow",
      "gridRowStart",
      "gridRowEnd",
      "float",
      "clear",
      "margin",
      "boxSizing",
      "lineClamp",
      "display",
      "aspectRatio",
      "size",
      "height",
      "maxHeight",
      "minHeight",
      "width",
      "minWidth",
      "maxWidth",
      "flex",
      "flexShrink",
      "flexGrow",
      "flexBasis",
      "tableLayout",
      "captionSide",
      "borderCollapse",
      "borderSpacing",
      "transformOrigin",
      "translate",
      "rotate",
      "skew",
      "scale",
      "transform",
      "animation",
      "cursor",
      "touchAction",
      "userSelect",
      "resize",
      "scrollSnapType",
      "scrollSnapAlign",
      "scrollSnapStop",
      "scrollMargin",
      "scrollPadding",
      "listStylePosition",
      "listStyleType",
      "listStyleImage",
      "appearance",
      "columns",
      "breakBefore",
      "breakInside",
      "breakAfter",
      "gridAutoColumns",
      "gridAutoFlow",
      "gridAutoRows",
      "gridTemplateColumns",
      "gridTemplateRows",
      "flexDirection",
      "flexWrap",
      "placeContent",
      "placeItems",
      "alignContent",
      "alignItems",
      "justifyContent",
      "justifyItems",
      "gap",
      "space",
      "divideWidth",
      "divideStyle",
      "divideColor",
      "divideOpacity",
      "placeSelf",
      "alignSelf",
      "justifySelf",
      "overflow",
      "overscrollBehavior",
      "scrollBehavior",
      "textOverflow",
      "hyphens",
      "whitespace",
      "textWrap",
      "wordBreak",
      "borderRadius",
      "borderWidth",
      "borderStyle",
      "borderColor",
      "borderOpacity",
      "backgroundColor",
      "backgroundOpacity",
      "backgroundImage",
      "gradientColorStops",
      "boxDecorationBreak",
      "backgroundSize",
      "backgroundAttachment",
      "backgroundClip",
      "backgroundPosition",
      "backgroundRepeat",
      "backgroundOrigin",
      "fill",
      "stroke",
      "strokeWidth",
      "objectFit",
      "objectPosition",
      "padding",
      "textAlign",
      "textIndent",
      "verticalAlign",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "textTransform",
      "fontStyle",
      "fontVariantNumeric",
      "lineHeight",
      "letterSpacing",
      "textColor",
      "textOpacity",
      "textDecoration",
      "textDecorationColor",
      "textDecorationStyle",
      "textDecorationThickness",
      "textUnderlineOffset",
      "fontSmoothing",
      "placeholderColor",
      "placeholderOpacity",
      "caretColor",
      "accentColor",
      "opacity",
      "backgroundBlendMode",
      "mixBlendMode",
      "boxShadow",
      "boxShadowColor",
      "outlineStyle",
      "outlineWidth",
      "outlineOffset",
      "outlineColor",
      "ringWidth",
      "ringColor",
      "ringOpacity",
      "ringOffsetWidth",
      "ringOffsetColor",
      "blur",
      "brightness",
      "contrast",
      "dropShadow",
      "grayscale",
      "hueRotate",
      "invert",
      "saturate",
      "sepia",
      "filter",
      "backdropBlur",
      "backdropBrightness",
      "backdropContrast",
      "backdropGrayscale",
      "backdropHueRotate",
      "backdropInvert",
      "backdropOpacity",
      "backdropSaturate",
      "backdropSepia",
      "backdropFilter",
      "transitionProperty",
      "transitionDelay",
      "transitionDuration",
      "transitionTimingFunction",
      "willChange",
      "contain",
      "content",
      "forcedColorAdjust"
    ];
  }(wi2)), wi2;
}
var bi2 = {};
var rl;
function sc() {
  return rl || (rl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, p) {
      return h2 === undefined ? p : Array.isArray(h2) ? h2 : [
        ...new Set(p.filter((f) => h2 !== false && h2[f] !== false).concat(Object.keys(h2).filter((f) => h2[f] !== false)))
      ];
    }
  }(bi2)), bi2;
}
var _i2 = {};
var nl2;
function oc() {
  return nl2 || (nl2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ h2(tt3());
    function h2(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function p({ version: f, from: s2, to: c2 }) {
      a.default.warn(`${s2}-color-renamed`, [
        `As of Tailwind CSS ${f}, \`${s2}\` has been renamed to \`${c2}\`.`,
        "Update your configuration file to silence this warning."
      ]);
    }
    const l3 = {
      inherit: "inherit",
      current: "currentColor",
      transparent: "transparent",
      black: "#000",
      white: "#fff",
      slate: {
        50: "#f8fafc",
        100: "#f1f5f9",
        200: "#e2e8f0",
        300: "#cbd5e1",
        400: "#94a3b8",
        500: "#64748b",
        600: "#475569",
        700: "#334155",
        800: "#1e293b",
        900: "#0f172a",
        950: "#020617"
      },
      gray: {
        50: "#f9fafb",
        100: "#f3f4f6",
        200: "#e5e7eb",
        300: "#d1d5db",
        400: "#9ca3af",
        500: "#6b7280",
        600: "#4b5563",
        700: "#374151",
        800: "#1f2937",
        900: "#111827",
        950: "#030712"
      },
      zinc: {
        50: "#fafafa",
        100: "#f4f4f5",
        200: "#e4e4e7",
        300: "#d4d4d8",
        400: "#a1a1aa",
        500: "#71717a",
        600: "#52525b",
        700: "#3f3f46",
        800: "#27272a",
        900: "#18181b",
        950: "#09090b"
      },
      neutral: {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#e5e5e5",
        300: "#d4d4d4",
        400: "#a3a3a3",
        500: "#737373",
        600: "#525252",
        700: "#404040",
        800: "#262626",
        900: "#171717",
        950: "#0a0a0a"
      },
      stone: {
        50: "#fafaf9",
        100: "#f5f5f4",
        200: "#e7e5e4",
        300: "#d6d3d1",
        400: "#a8a29e",
        500: "#78716c",
        600: "#57534e",
        700: "#44403c",
        800: "#292524",
        900: "#1c1917",
        950: "#0c0a09"
      },
      red: {
        50: "#fef2f2",
        100: "#fee2e2",
        200: "#fecaca",
        300: "#fca5a5",
        400: "#f87171",
        500: "#ef4444",
        600: "#dc2626",
        700: "#b91c1c",
        800: "#991b1b",
        900: "#7f1d1d",
        950: "#450a0a"
      },
      orange: {
        50: "#fff7ed",
        100: "#ffedd5",
        200: "#fed7aa",
        300: "#fdba74",
        400: "#fb923c",
        500: "#f97316",
        600: "#ea580c",
        700: "#c2410c",
        800: "#9a3412",
        900: "#7c2d12",
        950: "#431407"
      },
      amber: {
        50: "#fffbeb",
        100: "#fef3c7",
        200: "#fde68a",
        300: "#fcd34d",
        400: "#fbbf24",
        500: "#f59e0b",
        600: "#d97706",
        700: "#b45309",
        800: "#92400e",
        900: "#78350f",
        950: "#451a03"
      },
      yellow: {
        50: "#fefce8",
        100: "#fef9c3",
        200: "#fef08a",
        300: "#fde047",
        400: "#facc15",
        500: "#eab308",
        600: "#ca8a04",
        700: "#a16207",
        800: "#854d0e",
        900: "#713f12",
        950: "#422006"
      },
      lime: {
        50: "#f7fee7",
        100: "#ecfccb",
        200: "#d9f99d",
        300: "#bef264",
        400: "#a3e635",
        500: "#84cc16",
        600: "#65a30d",
        700: "#4d7c0f",
        800: "#3f6212",
        900: "#365314",
        950: "#1a2e05"
      },
      green: {
        50: "#f0fdf4",
        100: "#dcfce7",
        200: "#bbf7d0",
        300: "#86efac",
        400: "#4ade80",
        500: "#22c55e",
        600: "#16a34a",
        700: "#15803d",
        800: "#166534",
        900: "#14532d",
        950: "#052e16"
      },
      emerald: {
        50: "#ecfdf5",
        100: "#d1fae5",
        200: "#a7f3d0",
        300: "#6ee7b7",
        400: "#34d399",
        500: "#10b981",
        600: "#059669",
        700: "#047857",
        800: "#065f46",
        900: "#064e3b",
        950: "#022c22"
      },
      teal: {
        50: "#f0fdfa",
        100: "#ccfbf1",
        200: "#99f6e4",
        300: "#5eead4",
        400: "#2dd4bf",
        500: "#14b8a6",
        600: "#0d9488",
        700: "#0f766e",
        800: "#115e59",
        900: "#134e4a",
        950: "#042f2e"
      },
      cyan: {
        50: "#ecfeff",
        100: "#cffafe",
        200: "#a5f3fc",
        300: "#67e8f9",
        400: "#22d3ee",
        500: "#06b6d4",
        600: "#0891b2",
        700: "#0e7490",
        800: "#155e75",
        900: "#164e63",
        950: "#083344"
      },
      sky: {
        50: "#f0f9ff",
        100: "#e0f2fe",
        200: "#bae6fd",
        300: "#7dd3fc",
        400: "#38bdf8",
        500: "#0ea5e9",
        600: "#0284c7",
        700: "#0369a1",
        800: "#075985",
        900: "#0c4a6e",
        950: "#082f49"
      },
      blue: {
        50: "#eff6ff",
        100: "#dbeafe",
        200: "#bfdbfe",
        300: "#93c5fd",
        400: "#60a5fa",
        500: "#3b82f6",
        600: "#2563eb",
        700: "#1d4ed8",
        800: "#1e40af",
        900: "#1e3a8a",
        950: "#172554"
      },
      indigo: {
        50: "#eef2ff",
        100: "#e0e7ff",
        200: "#c7d2fe",
        300: "#a5b4fc",
        400: "#818cf8",
        500: "#6366f1",
        600: "#4f46e5",
        700: "#4338ca",
        800: "#3730a3",
        900: "#312e81",
        950: "#1e1b4b"
      },
      violet: {
        50: "#f5f3ff",
        100: "#ede9fe",
        200: "#ddd6fe",
        300: "#c4b5fd",
        400: "#a78bfa",
        500: "#8b5cf6",
        600: "#7c3aed",
        700: "#6d28d9",
        800: "#5b21b6",
        900: "#4c1d95",
        950: "#2e1065"
      },
      purple: {
        50: "#faf5ff",
        100: "#f3e8ff",
        200: "#e9d5ff",
        300: "#d8b4fe",
        400: "#c084fc",
        500: "#a855f7",
        600: "#9333ea",
        700: "#7e22ce",
        800: "#6b21a8",
        900: "#581c87",
        950: "#3b0764"
      },
      fuchsia: {
        50: "#fdf4ff",
        100: "#fae8ff",
        200: "#f5d0fe",
        300: "#f0abfc",
        400: "#e879f9",
        500: "#d946ef",
        600: "#c026d3",
        700: "#a21caf",
        800: "#86198f",
        900: "#701a75",
        950: "#4a044e"
      },
      pink: {
        50: "#fdf2f8",
        100: "#fce7f3",
        200: "#fbcfe8",
        300: "#f9a8d4",
        400: "#f472b6",
        500: "#ec4899",
        600: "#db2777",
        700: "#be185d",
        800: "#9d174d",
        900: "#831843",
        950: "#500724"
      },
      rose: {
        50: "#fff1f2",
        100: "#ffe4e6",
        200: "#fecdd3",
        300: "#fda4af",
        400: "#fb7185",
        500: "#f43f5e",
        600: "#e11d48",
        700: "#be123c",
        800: "#9f1239",
        900: "#881337",
        950: "#4c0519"
      },
      get lightBlue() {
        return p({
          version: "v2.2",
          from: "lightBlue",
          to: "sky"
        }), this.sky;
      },
      get warmGray() {
        return p({
          version: "v3.0",
          from: "warmGray",
          to: "stone"
        }), this.stone;
      },
      get trueGray() {
        return p({
          version: "v3.0",
          from: "trueGray",
          to: "neutral"
        }), this.neutral;
      },
      get coolGray() {
        return p({
          version: "v3.0",
          from: "coolGray",
          to: "gray"
        }), this.gray;
      },
      get blueGray() {
        return p({
          version: "v3.0",
          from: "blueGray",
          to: "slate"
        }), this.slate;
      }
    };
  }(_i2)), _i2;
}
var Si2 = {};
var il;
function lc() {
  return il || (il = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "defaults", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2, ...p) {
      for (let s2 of p) {
        for (let c2 in s2) {
          var l3;
          !(h2 == null || (l3 = h2.hasOwnProperty) === null || l3 === undefined) && l3.call(h2, c2) || (h2[c2] = s2[c2]);
        }
        for (let c2 of Object.getOwnPropertySymbols(s2)) {
          var f;
          !(h2 == null || (f = h2.hasOwnProperty) === null || f === undefined) && f.call(h2, c2) || (h2[c2] = s2[c2]);
        }
      }
      return h2;
    }
  }(Si2)), Si2;
}
var xi2 = {};
var al;
function uc() {
  return al || (al = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "normalizeConfig", {
      enumerable: true,
      get: function() {
        return f;
      }
    });
    const a = it3(), h2 = /* @__PURE__ */ l3(tt3());
    function p(s2) {
      if (typeof WeakMap != "function")
        return null;
      var c2 = /* @__PURE__ */ new WeakMap, t10 = /* @__PURE__ */ new WeakMap;
      return (p = function(e2) {
        return e2 ? t10 : c2;
      })(s2);
    }
    function l3(s2, c2) {
      if (s2 && s2.__esModule)
        return s2;
      if (s2 === null || typeof s2 != "object" && typeof s2 != "function")
        return {
          default: s2
        };
      var t10 = p(c2);
      if (t10 && t10.has(s2))
        return t10.get(s2);
      var e2 = {}, r2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var i2 in s2)
        if (i2 !== "default" && Object.prototype.hasOwnProperty.call(s2, i2)) {
          var o2 = r2 ? Object.getOwnPropertyDescriptor(s2, i2) : null;
          o2 && (o2.get || o2.set) ? Object.defineProperty(e2, i2, o2) : e2[i2] = s2[i2];
        }
      return e2.default = s2, t10 && t10.set(s2, e2), e2;
    }
    function f(s2) {
      if ((() => {
        if (s2.purge || !s2.content || !Array.isArray(s2.content) && !(typeof s2.content == "object" && s2.content !== null))
          return false;
        if (Array.isArray(s2.content))
          return s2.content.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? undefined : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? undefined : e2.extension) != "string"));
        if (typeof s2.content == "object" && s2.content !== null) {
          if (Object.keys(s2.content).some((e2) => ![
            "files",
            "relative",
            "extract",
            "transform"
          ].includes(e2)))
            return false;
          if (Array.isArray(s2.content.files)) {
            if (!s2.content.files.every((e2) => typeof e2 == "string" ? true : !(typeof (e2 == null ? undefined : e2.raw) != "string" || e2 != null && e2.extension && typeof (e2 == null ? undefined : e2.extension) != "string")))
              return false;
            if (typeof s2.content.extract == "object") {
              for (let e2 of Object.values(s2.content.extract))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.extract === undefined || typeof s2.content.extract == "function"))
              return false;
            if (typeof s2.content.transform == "object") {
              for (let e2 of Object.values(s2.content.transform))
                if (typeof e2 != "function")
                  return false;
            } else if (!(s2.content.transform === undefined || typeof s2.content.transform == "function"))
              return false;
            if (typeof s2.content.relative != "boolean" && typeof s2.content.relative < "u")
              return false;
          }
          return true;
        }
        return false;
      })() || h2.default.warn("purge-deprecation", [
        "The `purge`/`content` options have changed in Tailwind CSS v3.0.",
        "Update your configuration file to eliminate this warning.",
        "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"
      ]), s2.safelist = (() => {
        var e2;
        let { content: r2, purge: i2, safelist: o2 } = s2;
        return Array.isArray(o2) ? o2 : Array.isArray(r2 == null ? undefined : r2.safelist) ? r2.safelist : Array.isArray(i2 == null ? undefined : i2.safelist) ? i2.safelist : Array.isArray(i2 == null || (e2 = i2.options) === null || e2 === undefined ? undefined : e2.safelist) ? i2.options.safelist : [];
      })(), s2.blocklist = (() => {
        let { blocklist: e2 } = s2;
        if (Array.isArray(e2)) {
          if (e2.every((r2) => typeof r2 == "string"))
            return e2;
          h2.default.warn("blocklist-invalid", [
            "The `blocklist` option must be an array of strings.",
            "https://tailwindcss.com/docs/content-configuration#discarding-classes"
          ]);
        }
        return [];
      })(), typeof s2.prefix == "function")
        h2.default.warn("prefix-function", [
          "As of Tailwind CSS v3.0, `prefix` cannot be a function.",
          "Update `prefix` in your configuration to be a string to eliminate this warning.",
          "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"
        ]), s2.prefix = "";
      else {
        var t10;
        s2.prefix = (t10 = s2.prefix) !== null && t10 !== undefined ? t10 : "";
      }
      s2.content = {
        relative: (() => {
          let { content: e2 } = s2;
          return e2 != null && e2.relative ? e2.relative : (0, a.flagEnabled)(s2, "relativeContentPathsByDefault");
        })(),
        files: (() => {
          let { content: e2, purge: r2 } = s2;
          return Array.isArray(r2) ? r2 : Array.isArray(r2 == null ? undefined : r2.content) ? r2.content : Array.isArray(e2) ? e2 : Array.isArray(e2 == null ? undefined : e2.content) ? e2.content : Array.isArray(e2 == null ? undefined : e2.files) ? e2.files : [];
        })(),
        extract: (() => {
          let e2 = (() => {
            var o2, v3, m, n2, d2, _4, w3, y2, x2, g2;
            return !((o2 = s2.purge) === null || o2 === undefined) && o2.extract ? s2.purge.extract : !((v3 = s2.content) === null || v3 === undefined) && v3.extract ? s2.content.extract : !((m = s2.purge) === null || m === undefined || (n2 = m.extract) === null || n2 === undefined) && n2.DEFAULT ? s2.purge.extract.DEFAULT : !((d2 = s2.content) === null || d2 === undefined || (_4 = d2.extract) === null || _4 === undefined) && _4.DEFAULT ? s2.content.extract.DEFAULT : !((w3 = s2.purge) === null || w3 === undefined || (y2 = w3.options) === null || y2 === undefined) && y2.extractors ? s2.purge.options.extractors : !((x2 = s2.content) === null || x2 === undefined || (g2 = x2.options) === null || g2 === undefined) && g2.extractors ? s2.content.options.extractors : {};
          })(), r2 = {}, i2 = (() => {
            var o2, v3, m, n2;
            if (!((o2 = s2.purge) === null || o2 === undefined || (v3 = o2.options) === null || v3 === undefined) && v3.defaultExtractor)
              return s2.purge.options.defaultExtractor;
            if (!((m = s2.content) === null || m === undefined || (n2 = m.options) === null || n2 === undefined) && n2.defaultExtractor)
              return s2.content.options.defaultExtractor;
          })();
          if (i2 !== undefined && (r2.DEFAULT = i2), typeof e2 == "function")
            r2.DEFAULT = e2;
          else if (Array.isArray(e2))
            for (let { extensions: o2, extractor: v3 } of e2 ?? [])
              for (let m of o2)
                r2[m] = v3;
          else
            typeof e2 == "object" && e2 !== null && Object.assign(r2, e2);
          return r2;
        })(),
        transform: (() => {
          let e2 = (() => {
            var i2, o2, v3, m, n2, d2;
            return !((i2 = s2.purge) === null || i2 === undefined) && i2.transform ? s2.purge.transform : !((o2 = s2.content) === null || o2 === undefined) && o2.transform ? s2.content.transform : !((v3 = s2.purge) === null || v3 === undefined || (m = v3.transform) === null || m === undefined) && m.DEFAULT ? s2.purge.transform.DEFAULT : !((n2 = s2.content) === null || n2 === undefined || (d2 = n2.transform) === null || d2 === undefined) && d2.DEFAULT ? s2.content.transform.DEFAULT : {};
          })(), r2 = {};
          return typeof e2 == "function" ? r2.DEFAULT = e2 : typeof e2 == "object" && e2 !== null && Object.assign(r2, e2), r2;
        })()
      };
      for (let e2 of s2.content.files)
        if (typeof e2 == "string" && /{([^,]*?)}/g.test(e2)) {
          h2.default.warn("invalid-glob-braces", [
            `The glob pattern ${(0, h2.dim)(e2)} in your Tailwind CSS configuration is invalid.`,
            `Update it to ${(0, h2.dim)(e2.replace(/{([^,]*?)}/g, "$1"))} to silence this warning.`
          ]);
          break;
        }
      return s2;
    }
  }(xi2)), xi2;
}
var Oi2 = {};
var sl;
function fc() {
  return sl || (sl = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "cloneDeep", {
      enumerable: true,
      get: function() {
        return a;
      }
    });
    function a(h2) {
      return Array.isArray(h2) ? h2.map((p) => a(p)) : typeof h2 == "object" && h2 !== null ? Object.fromEntries(Object.entries(h2).map(([p, l3]) => [
        p,
        a(l3)
      ])) : h2;
    }
  }(Oi2)), Oi2;
}
var ol;
function cc() {
  return ol || (ol = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return q2;
      }
    });
    const a = /* @__PURE__ */ v3(ji2()), h2 = /* @__PURE__ */ v3(ac()), p = /* @__PURE__ */ v3(sc()), l3 = /* @__PURE__ */ v3(oc()), f = lc(), s2 = Wi2(), c2 = uc(), t10 = /* @__PURE__ */ v3(ut3()), e2 = fc(), r2 = gr3(), i2 = hr3(), o2 = /* @__PURE__ */ v3(iu3());
    function v3(M2) {
      return M2 && M2.__esModule ? M2 : {
        default: M2
      };
    }
    function m(M2) {
      return typeof M2 == "function";
    }
    function n2(M2, ...W3) {
      let S3 = W3.pop();
      for (let P3 of W3)
        for (let C in P3) {
          let R3 = S3(M2[C], P3[C]);
          R3 === undefined ? (0, t10.default)(M2[C]) && (0, t10.default)(P3[C]) ? M2[C] = n2({}, M2[C], P3[C], S3) : M2[C] = P3[C] : M2[C] = R3;
        }
      return M2;
    }
    const d2 = {
      colors: l3.default,
      negative(M2) {
        return Object.keys(M2).filter((W3) => M2[W3] !== "0").reduce((W3, S3) => {
          let P3 = (0, a.default)(M2[S3]);
          return P3 !== undefined && (W3[`-${S3}`] = P3), W3;
        }, {});
      },
      breakpoints(M2) {
        return Object.keys(M2).filter((W3) => typeof M2[W3] == "string").reduce((W3, S3) => ({
          ...W3,
          [`screen-${S3}`]: M2[S3]
        }), {});
      }
    };
    function _4(M2, ...W3) {
      return m(M2) ? M2(...W3) : M2;
    }
    function w3(M2) {
      return M2.reduce((W3, { extend: S3 }) => n2(W3, S3, (P3, C) => P3 === undefined ? [
        C
      ] : Array.isArray(P3) ? [
        C,
        ...P3
      ] : [
        C,
        P3
      ]), {});
    }
    function y2(M2) {
      return {
        ...M2.reduce((W3, S3) => (0, f.defaults)(W3, S3), {}),
        extend: w3(M2)
      };
    }
    function x2(M2, W3) {
      if (Array.isArray(M2) && (0, t10.default)(M2[0]))
        return M2.concat(W3);
      if (Array.isArray(W3) && (0, t10.default)(W3[0]) && (0, t10.default)(M2))
        return [
          M2,
          ...W3
        ];
      if (Array.isArray(W3))
        return W3;
    }
    function g2({ extend: M2, ...W3 }) {
      return n2(W3, M2, (S3, P3) => !m(S3) && !P3.some(m) ? n2({}, S3, ...P3, x2) : (C, R3) => n2({}, ...[
        S3,
        ...P3
      ].map(($3) => _4($3, C, R3)), x2));
    }
    function* O3(M2) {
      let W3 = (0, s2.toPath)(M2);
      if (W3.length === 0 || (yield W3, Array.isArray(M2)))
        return;
      let S3 = /^(.*?)\s*\/\s*([^/]+)$/, P3 = M2.match(S3);
      if (P3 !== null) {
        let [, C, R3] = P3, $3 = (0, s2.toPath)(C);
        $3.alpha = R3, yield $3;
      }
    }
    function A(M2) {
      const W3 = (S3, P3) => {
        for (const C of O3(S3)) {
          let R3 = 0, $3 = M2;
          for (;$3 != null && R3 < C.length; )
            $3 = $3[C[R3++]], $3 = m($3) && (C.alpha === undefined || R3 <= C.length - 1) ? $3(W3, d2) : $3;
          if ($3 !== undefined) {
            if (C.alpha !== undefined) {
              let B3 = (0, r2.parseColorFormat)($3);
              return (0, i2.withAlphaValue)(B3, C.alpha, (0, o2.default)(B3));
            }
            return (0, t10.default)($3) ? (0, e2.cloneDeep)($3) : $3;
          }
        }
        return P3;
      };
      return Object.assign(W3, {
        theme: W3,
        ...d2
      }), Object.keys(M2).reduce((S3, P3) => (S3[P3] = m(M2[P3]) ? M2[P3](W3, d2) : M2[P3], S3), {});
    }
    function E2(M2) {
      let W3 = [];
      return M2.forEach((S3) => {
        W3 = [
          ...W3,
          S3
        ];
        var P3;
        const C = (P3 = S3 == null ? undefined : S3.plugins) !== null && P3 !== undefined ? P3 : [];
        C.length !== 0 && C.forEach((R3) => {
          R3.__isOptionsFunction && (R3 = R3());
          var $3;
          W3 = [
            ...W3,
            ...E2([
              ($3 = R3 == null ? undefined : R3.config) !== null && $3 !== undefined ? $3 : {}
            ])
          ];
        });
      }), W3;
    }
    function b5(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => m(P3) ? P3({
        corePlugins: S3
      }) : (0, p.default)(P3, S3), h2.default);
    }
    function k4(M2) {
      return [
        ...M2
      ].reduceRight((S3, P3) => [
        ...S3,
        ...P3
      ], []);
    }
    function q2(M2) {
      let W3 = [
        ...E2(M2),
        {
          prefix: "",
          important: false,
          separator: ":"
        }
      ];
      var S3, P3;
      return (0, c2.normalizeConfig)((0, f.defaults)({
        theme: A(g2(y2(W3.map((C) => (S3 = C == null ? undefined : C.theme) !== null && S3 !== undefined ? S3 : {})))),
        corePlugins: b5(W3.map((C) => C.corePlugins)),
        plugins: k4(M2.map((C) => (P3 = C == null ? undefined : C.plugins) !== null && P3 !== undefined ? P3 : []))
      }, ...W3));
    }
  }(yi2)), yi2;
}
var ki2 = {};
var Pi2;
var ll;
function dc() {
  return ll || (ll = 1, Pi2 = {
    content: [],
    presets: [],
    darkMode: "media",
    theme: {
      accentColor: ({ theme: u }) => ({
        ...u("colors"),
        auto: "auto"
      }),
      animation: {
        none: "none",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite"
      },
      aria: {
        busy: 'busy="true"',
        checked: 'checked="true"',
        disabled: 'disabled="true"',
        expanded: 'expanded="true"',
        hidden: 'hidden="true"',
        pressed: 'pressed="true"',
        readonly: 'readonly="true"',
        required: 'required="true"',
        selected: 'selected="true"'
      },
      aspectRatio: {
        auto: "auto",
        square: "1 / 1",
        video: "16 / 9"
      },
      backdropBlur: ({ theme: u }) => u("blur"),
      backdropBrightness: ({ theme: u }) => u("brightness"),
      backdropContrast: ({ theme: u }) => u("contrast"),
      backdropGrayscale: ({ theme: u }) => u("grayscale"),
      backdropHueRotate: ({ theme: u }) => u("hueRotate"),
      backdropInvert: ({ theme: u }) => u("invert"),
      backdropOpacity: ({ theme: u }) => u("opacity"),
      backdropSaturate: ({ theme: u }) => u("saturate"),
      backdropSepia: ({ theme: u }) => u("sepia"),
      backgroundColor: ({ theme: u }) => u("colors"),
      backgroundImage: {
        none: "none",
        "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))",
        "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))",
        "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))",
        "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))",
        "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))",
        "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))",
        "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))",
        "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))"
      },
      backgroundOpacity: ({ theme: u }) => u("opacity"),
      backgroundPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      backgroundSize: {
        auto: "auto",
        cover: "cover",
        contain: "contain"
      },
      blur: {
        0: "0",
        none: "",
        sm: "4px",
        DEFAULT: "8px",
        md: "12px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px"
      },
      borderColor: ({ theme: u }) => ({
        ...u("colors"),
        DEFAULT: u("colors.gray.200", "currentColor")
      }),
      borderOpacity: ({ theme: u }) => u("opacity"),
      borderRadius: {
        none: "0px",
        sm: "0.125rem",
        DEFAULT: "0.25rem",
        md: "0.375rem",
        lg: "0.5rem",
        xl: "0.75rem",
        "2xl": "1rem",
        "3xl": "1.5rem",
        full: "9999px"
      },
      borderSpacing: ({ theme: u }) => ({
        ...u("spacing")
      }),
      borderWidth: {
        DEFAULT: "1px",
        0: "0px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      boxShadow: {
        sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)",
        DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
        md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)",
        lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)",
        xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)",
        "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)",
        inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)",
        none: "none"
      },
      boxShadowColor: ({ theme: u }) => u("colors"),
      brightness: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      caretColor: ({ theme: u }) => u("colors"),
      colors: ({ colors: u }) => ({
        inherit: u.inherit,
        current: u.current,
        transparent: u.transparent,
        black: u.black,
        white: u.white,
        slate: u.slate,
        gray: u.gray,
        zinc: u.zinc,
        neutral: u.neutral,
        stone: u.stone,
        red: u.red,
        orange: u.orange,
        amber: u.amber,
        yellow: u.yellow,
        lime: u.lime,
        green: u.green,
        emerald: u.emerald,
        teal: u.teal,
        cyan: u.cyan,
        sky: u.sky,
        blue: u.blue,
        indigo: u.indigo,
        violet: u.violet,
        purple: u.purple,
        fuchsia: u.fuchsia,
        pink: u.pink,
        rose: u.rose
      }),
      columns: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        "3xs": "16rem",
        "2xs": "18rem",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem"
      },
      container: {},
      content: {
        none: "none"
      },
      contrast: {
        0: "0",
        50: ".5",
        75: ".75",
        100: "1",
        125: "1.25",
        150: "1.5",
        200: "2"
      },
      cursor: {
        auto: "auto",
        default: "default",
        pointer: "pointer",
        wait: "wait",
        text: "text",
        move: "move",
        help: "help",
        "not-allowed": "not-allowed",
        none: "none",
        "context-menu": "context-menu",
        progress: "progress",
        cell: "cell",
        crosshair: "crosshair",
        "vertical-text": "vertical-text",
        alias: "alias",
        copy: "copy",
        "no-drop": "no-drop",
        grab: "grab",
        grabbing: "grabbing",
        "all-scroll": "all-scroll",
        "col-resize": "col-resize",
        "row-resize": "row-resize",
        "n-resize": "n-resize",
        "e-resize": "e-resize",
        "s-resize": "s-resize",
        "w-resize": "w-resize",
        "ne-resize": "ne-resize",
        "nw-resize": "nw-resize",
        "se-resize": "se-resize",
        "sw-resize": "sw-resize",
        "ew-resize": "ew-resize",
        "ns-resize": "ns-resize",
        "nesw-resize": "nesw-resize",
        "nwse-resize": "nwse-resize",
        "zoom-in": "zoom-in",
        "zoom-out": "zoom-out"
      },
      divideColor: ({ theme: u }) => u("borderColor"),
      divideOpacity: ({ theme: u }) => u("borderOpacity"),
      divideWidth: ({ theme: u }) => u("borderWidth"),
      dropShadow: {
        sm: "0 1px 1px rgb(0 0 0 / 0.05)",
        DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"],
        md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"],
        lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"],
        xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"],
        "2xl": "0 25px 25px rgb(0 0 0 / 0.15)",
        none: "0 0 #0000"
      },
      fill: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      flex: {
        1: "1 1 0%",
        auto: "1 1 auto",
        initial: "0 1 auto",
        none: "none"
      },
      flexBasis: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%"
      }),
      flexGrow: {
        0: "0",
        DEFAULT: "1"
      },
      flexShrink: {
        0: "0",
        DEFAULT: "1"
      },
      fontFamily: {
        sans: [
          "ui-sans-serif",
          "system-ui",
          "sans-serif",
          '"Apple Color Emoji"',
          '"Segoe UI Emoji"',
          '"Segoe UI Symbol"',
          '"Noto Color Emoji"'
        ],
        serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"],
        mono: [
          "ui-monospace",
          "SFMono-Regular",
          "Menlo",
          "Monaco",
          "Consolas",
          '"Liberation Mono"',
          '"Courier New"',
          "monospace"
        ]
      },
      fontSize: {
        xs: ["0.75rem", { lineHeight: "1rem" }],
        sm: ["0.875rem", { lineHeight: "1.25rem" }],
        base: ["1rem", { lineHeight: "1.5rem" }],
        lg: ["1.125rem", { lineHeight: "1.75rem" }],
        xl: ["1.25rem", { lineHeight: "1.75rem" }],
        "2xl": ["1.5rem", { lineHeight: "2rem" }],
        "3xl": ["1.875rem", { lineHeight: "2.25rem" }],
        "4xl": ["2.25rem", { lineHeight: "2.5rem" }],
        "5xl": ["3rem", { lineHeight: "1" }],
        "6xl": ["3.75rem", { lineHeight: "1" }],
        "7xl": ["4.5rem", { lineHeight: "1" }],
        "8xl": ["6rem", { lineHeight: "1" }],
        "9xl": ["8rem", { lineHeight: "1" }]
      },
      fontWeight: {
        thin: "100",
        extralight: "200",
        light: "300",
        normal: "400",
        medium: "500",
        semibold: "600",
        bold: "700",
        extrabold: "800",
        black: "900"
      },
      gap: ({ theme: u }) => u("spacing"),
      gradientColorStops: ({ theme: u }) => u("colors"),
      gradientColorStopPositions: {
        "0%": "0%",
        "5%": "5%",
        "10%": "10%",
        "15%": "15%",
        "20%": "20%",
        "25%": "25%",
        "30%": "30%",
        "35%": "35%",
        "40%": "40%",
        "45%": "45%",
        "50%": "50%",
        "55%": "55%",
        "60%": "60%",
        "65%": "65%",
        "70%": "70%",
        "75%": "75%",
        "80%": "80%",
        "85%": "85%",
        "90%": "90%",
        "95%": "95%",
        "100%": "100%"
      },
      grayscale: {
        0: "0",
        DEFAULT: "100%"
      },
      gridAutoColumns: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridAutoRows: {
        auto: "auto",
        min: "min-content",
        max: "max-content",
        fr: "minmax(0, 1fr)"
      },
      gridColumn: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridColumnEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridColumnStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRow: {
        auto: "auto",
        "span-1": "span 1 / span 1",
        "span-2": "span 2 / span 2",
        "span-3": "span 3 / span 3",
        "span-4": "span 4 / span 4",
        "span-5": "span 5 / span 5",
        "span-6": "span 6 / span 6",
        "span-7": "span 7 / span 7",
        "span-8": "span 8 / span 8",
        "span-9": "span 9 / span 9",
        "span-10": "span 10 / span 10",
        "span-11": "span 11 / span 11",
        "span-12": "span 12 / span 12",
        "span-full": "1 / -1"
      },
      gridRowEnd: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridRowStart: {
        auto: "auto",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12",
        13: "13"
      },
      gridTemplateColumns: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      gridTemplateRows: {
        none: "none",
        subgrid: "subgrid",
        1: "repeat(1, minmax(0, 1fr))",
        2: "repeat(2, minmax(0, 1fr))",
        3: "repeat(3, minmax(0, 1fr))",
        4: "repeat(4, minmax(0, 1fr))",
        5: "repeat(5, minmax(0, 1fr))",
        6: "repeat(6, minmax(0, 1fr))",
        7: "repeat(7, minmax(0, 1fr))",
        8: "repeat(8, minmax(0, 1fr))",
        9: "repeat(9, minmax(0, 1fr))",
        10: "repeat(10, minmax(0, 1fr))",
        11: "repeat(11, minmax(0, 1fr))",
        12: "repeat(12, minmax(0, 1fr))"
      },
      height: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      hueRotate: {
        0: "0deg",
        15: "15deg",
        30: "30deg",
        60: "60deg",
        90: "90deg",
        180: "180deg"
      },
      inset: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      invert: {
        0: "0",
        DEFAULT: "100%"
      },
      keyframes: {
        spin: {
          to: {
            transform: "rotate(360deg)"
          }
        },
        ping: {
          "75%, 100%": {
            transform: "scale(2)",
            opacity: "0"
          }
        },
        pulse: {
          "50%": {
            opacity: ".5"
          }
        },
        bounce: {
          "0%, 100%": {
            transform: "translateY(-25%)",
            animationTimingFunction: "cubic-bezier(0.8,0,1,1)"
          },
          "50%": {
            transform: "none",
            animationTimingFunction: "cubic-bezier(0,0,0.2,1)"
          }
        }
      },
      letterSpacing: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0em",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
      },
      lineHeight: {
        none: "1",
        tight: "1.25",
        snug: "1.375",
        normal: "1.5",
        relaxed: "1.625",
        loose: "2",
        3: ".75rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem"
      },
      listStyleType: {
        none: "none",
        disc: "disc",
        decimal: "decimal"
      },
      listStyleImage: {
        none: "none"
      },
      margin: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing")
      }),
      lineClamp: {
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6"
      },
      maxHeight: ({ theme: u }) => ({
        ...u("spacing"),
        none: "none",
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      maxWidth: ({ theme: u, breakpoints: a }) => ({
        ...u("spacing"),
        none: "none",
        xs: "20rem",
        sm: "24rem",
        md: "28rem",
        lg: "32rem",
        xl: "36rem",
        "2xl": "42rem",
        "3xl": "48rem",
        "4xl": "56rem",
        "5xl": "64rem",
        "6xl": "72rem",
        "7xl": "80rem",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content",
        prose: "65ch",
        ...a(u("screens"))
      }),
      minHeight: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        screen: "100vh",
        svh: "100svh",
        lvh: "100lvh",
        dvh: "100dvh",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      minWidth: ({ theme: u }) => ({
        ...u("spacing"),
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      objectPosition: {
        bottom: "bottom",
        center: "center",
        left: "left",
        "left-bottom": "left bottom",
        "left-top": "left top",
        right: "right",
        "right-bottom": "right bottom",
        "right-top": "right top",
        top: "top"
      },
      opacity: {
        0: "0",
        5: "0.05",
        10: "0.1",
        15: "0.15",
        20: "0.2",
        25: "0.25",
        30: "0.3",
        35: "0.35",
        40: "0.4",
        45: "0.45",
        50: "0.5",
        55: "0.55",
        60: "0.6",
        65: "0.65",
        70: "0.7",
        75: "0.75",
        80: "0.8",
        85: "0.85",
        90: "0.9",
        95: "0.95",
        100: "1"
      },
      order: {
        first: "-9999",
        last: "9999",
        none: "0",
        1: "1",
        2: "2",
        3: "3",
        4: "4",
        5: "5",
        6: "6",
        7: "7",
        8: "8",
        9: "9",
        10: "10",
        11: "11",
        12: "12"
      },
      outlineColor: ({ theme: u }) => u("colors"),
      outlineOffset: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      outlineWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      padding: ({ theme: u }) => u("spacing"),
      placeholderColor: ({ theme: u }) => u("colors"),
      placeholderOpacity: ({ theme: u }) => u("opacity"),
      ringColor: ({ theme: u }) => ({
        DEFAULT: u("colors.blue.500", "#3b82f6"),
        ...u("colors")
      }),
      ringOffsetColor: ({ theme: u }) => u("colors"),
      ringOffsetWidth: {
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      ringOpacity: ({ theme: u }) => ({
        DEFAULT: "0.5",
        ...u("opacity")
      }),
      ringWidth: {
        DEFAULT: "3px",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      rotate: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg",
        45: "45deg",
        90: "90deg",
        180: "180deg"
      },
      saturate: {
        0: "0",
        50: ".5",
        100: "1",
        150: "1.5",
        200: "2"
      },
      scale: {
        0: "0",
        50: ".5",
        75: ".75",
        90: ".9",
        95: ".95",
        100: "1",
        105: "1.05",
        110: "1.1",
        125: "1.25",
        150: "1.5"
      },
      screens: {
        sm: "640px",
        md: "768px",
        lg: "1024px",
        xl: "1280px",
        "2xl": "1536px"
      },
      scrollMargin: ({ theme: u }) => ({
        ...u("spacing")
      }),
      scrollPadding: ({ theme: u }) => u("spacing"),
      sepia: {
        0: "0",
        DEFAULT: "100%"
      },
      skew: {
        0: "0deg",
        1: "1deg",
        2: "2deg",
        3: "3deg",
        6: "6deg",
        12: "12deg"
      },
      space: ({ theme: u }) => ({
        ...u("spacing")
      }),
      spacing: {
        px: "1px",
        0: "0px",
        0.5: "0.125rem",
        1: "0.25rem",
        1.5: "0.375rem",
        2: "0.5rem",
        2.5: "0.625rem",
        3: "0.75rem",
        3.5: "0.875rem",
        4: "1rem",
        5: "1.25rem",
        6: "1.5rem",
        7: "1.75rem",
        8: "2rem",
        9: "2.25rem",
        10: "2.5rem",
        11: "2.75rem",
        12: "3rem",
        14: "3.5rem",
        16: "4rem",
        20: "5rem",
        24: "6rem",
        28: "7rem",
        32: "8rem",
        36: "9rem",
        40: "10rem",
        44: "11rem",
        48: "12rem",
        52: "13rem",
        56: "14rem",
        60: "15rem",
        64: "16rem",
        72: "18rem",
        80: "20rem",
        96: "24rem"
      },
      stroke: ({ theme: u }) => ({
        none: "none",
        ...u("colors")
      }),
      strokeWidth: {
        0: "0",
        1: "1",
        2: "2"
      },
      supports: {},
      data: {},
      textColor: ({ theme: u }) => u("colors"),
      textDecorationColor: ({ theme: u }) => u("colors"),
      textDecorationThickness: {
        auto: "auto",
        "from-font": "from-font",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      textIndent: ({ theme: u }) => ({
        ...u("spacing")
      }),
      textOpacity: ({ theme: u }) => u("opacity"),
      textUnderlineOffset: {
        auto: "auto",
        0: "0px",
        1: "1px",
        2: "2px",
        4: "4px",
        8: "8px"
      },
      transformOrigin: {
        center: "center",
        top: "top",
        "top-right": "top right",
        right: "right",
        "bottom-right": "bottom right",
        bottom: "bottom",
        "bottom-left": "bottom left",
        left: "left",
        "top-left": "top left"
      },
      transitionDelay: {
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1000: "1000ms"
      },
      transitionDuration: {
        DEFAULT: "150ms",
        0: "0s",
        75: "75ms",
        100: "100ms",
        150: "150ms",
        200: "200ms",
        300: "300ms",
        500: "500ms",
        700: "700ms",
        1000: "1000ms"
      },
      transitionProperty: {
        none: "none",
        all: "all",
        DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter",
        colors: "color, background-color, border-color, text-decoration-color, fill, stroke",
        opacity: "opacity",
        shadow: "box-shadow",
        transform: "transform"
      },
      transitionTimingFunction: {
        DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)",
        linear: "linear",
        in: "cubic-bezier(0.4, 0, 1, 1)",
        out: "cubic-bezier(0, 0, 0.2, 1)",
        "in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
      },
      translate: ({ theme: u }) => ({
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        full: "100%"
      }),
      size: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      width: ({ theme: u }) => ({
        auto: "auto",
        ...u("spacing"),
        "1/2": "50%",
        "1/3": "33.333333%",
        "2/3": "66.666667%",
        "1/4": "25%",
        "2/4": "50%",
        "3/4": "75%",
        "1/5": "20%",
        "2/5": "40%",
        "3/5": "60%",
        "4/5": "80%",
        "1/6": "16.666667%",
        "2/6": "33.333333%",
        "3/6": "50%",
        "4/6": "66.666667%",
        "5/6": "83.333333%",
        "1/12": "8.333333%",
        "2/12": "16.666667%",
        "3/12": "25%",
        "4/12": "33.333333%",
        "5/12": "41.666667%",
        "6/12": "50%",
        "7/12": "58.333333%",
        "8/12": "66.666667%",
        "9/12": "75%",
        "10/12": "83.333333%",
        "11/12": "91.666667%",
        full: "100%",
        screen: "100vw",
        svw: "100svw",
        lvw: "100lvw",
        dvw: "100dvw",
        min: "min-content",
        max: "max-content",
        fit: "fit-content"
      }),
      willChange: {
        auto: "auto",
        scroll: "scroll-position",
        contents: "contents",
        transform: "transform"
      },
      zIndex: {
        auto: "auto",
        0: "0",
        10: "10",
        20: "20",
        30: "30",
        40: "40",
        50: "50"
      }
    },
    plugins: []
  }), Pi2;
}
var ul;
function pc() {
  return ul || (ul = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(dc()), h2 = it3();
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3(f) {
      var s2;
      const c2 = ((s2 = f == null ? undefined : f.presets) !== null && s2 !== undefined ? s2 : [
        a.default
      ]).slice().reverse().flatMap((r2) => l3(r2 instanceof Function ? r2() : r2)), t10 = {
        respectDefaultRingColorOpacity: {
          theme: {
            ringColor: ({ theme: r2 }) => ({
              DEFAULT: "#3b82f67f",
              ...r2("colors")
            })
          }
        },
        disableColorOpacityUtilitiesByDefault: {
          corePlugins: {
            backgroundOpacity: false,
            borderOpacity: false,
            divideOpacity: false,
            placeholderOpacity: false,
            ringOpacity: false,
            textOpacity: false
          }
        }
      }, e2 = Object.keys(t10).filter((r2) => (0, h2.flagEnabled)(f, r2)).map((r2) => t10[r2]);
      return [
        f,
        ...e2,
        ...c2
      ];
    }
  }(ki2)), ki2;
}
var fl2;
function hc() {
  return fl2 || (fl2 = 1, function(u) {
    Object.defineProperty(u, "__esModule", {
      value: true
    }), Object.defineProperty(u, "default", {
      enumerable: true,
      get: function() {
        return l3;
      }
    });
    const a = /* @__PURE__ */ p(cc()), h2 = /* @__PURE__ */ p(pc());
    function p(f) {
      return f && f.__esModule ? f : {
        default: f
      };
    }
    function l3(...f) {
      let [, ...s2] = (0, h2.default)(f[0]);
      return (0, a.default)([
        ...f,
        ...s2
      ]);
    }
  }(mi2)), mi2;
}
var Ei;
var cl;
function vc() {
  if (cl)
    return Ei;
  cl = 1;
  let u = hc();
  return Ei = (u.__esModule ? u : { default: u }).default, Ei;
}
var gc = vc();
var mc = /* @__PURE__ */ He3(gc);
var yc = (u) => ic.createContext(mc({
  ...u,
  content: [],
  corePlugins: {
    preflight: false
  }
}));
var wc = _u2(`
  @tailwind base;
  @tailwind components;
`).root();
function bc(u) {
  "safelist" in u && (console.warn("The `safelist` option is not supported in the `Tailwind` component, it will not change any behavior."), delete u.safelist);
  const a = yc(u);
  return {
    generateRootForClasses: (h2) => {
      a.candidateRuleCache = /* @__PURE__ */ new Map;
      const p = Yf.generateRules(new Set(h2), a), l3 = wc.clone().append(...p.map(([, f]) => f));
      return Xo3()(l3), Gf(a)(l3), Xo3()(l3), $f(a)(l3), ff(a)(l3), tc(a)(l3), Xf(a)(l3), Hu2()(l3), Xu2()(l3), nc(l3), l3;
    }
  };
}
var Oc = ({ children: u, config: a }) => {
  const h2 = bc(a ?? {}), p = new Ou2;
  let l3 = [], f = false, s2 = sr3(u, (c2) => {
    if (Or5.isValidElement(c2)) {
      const {
        elementWithInlinedStyles: t10,
        nonInlinableClasses: e2,
        nonInlineStyleNodes: r2
      } = Gu2(c2, h2);
      return l3 = l3.concat(e2), p.append(r2), e2.length > 0 && !f && (f = true), t10;
    }
    return c2;
  });
  if (Pu2(p), f) {
    let c2 = false;
    if (s2 = sr3(s2, (t10) => {
      if (c2)
        return t10;
      if (Or5.isValidElement(t10) && t10.type === "head") {
        c2 = true;
        const e2 = /* @__PURE__ */ import_jsx_runtime7.jsx("style", { children: ku2(p.toString().trim()) });
        return Or5.cloneElement(t10, t10.props, t10.props.children, e2);
      }
      return t10;
    }), !c2)
      throw new Error(`You are trying to use the following Tailwind classes that cannot be inlined: ${l3.join(" ")}.
For the media queries to work properly on rendering, they need to be added into a <style> tag inside of a <head> tag,
the Tailwind component tried finding a <head> element but just wasn't able to find it.

Make sure that you have a <head> element at some point inside of the <Tailwind> component at any depth. 
This can also be our <Head> component.

If you do already have a <head> element at some depth, 
please file a bug https://github.com/resend/react-email/issues/new?assignees=&labels=Type%3A+Bug&projects=&template=1.bug_report.yml.`);
  }
  return s2;
};

// node_modules/@react-email/text/dist/index.mjs
var React7 = __toESM(require_react(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var __defProp9 = Object.defineProperty;
var __defProps6 = Object.defineProperties;
var __getOwnPropDescs6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols6 = Object.getOwnPropertySymbols;
var __hasOwnProp8 = Object.prototype.hasOwnProperty;
var __propIsEnum6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp6 = (obj, key, value) => (key in obj) ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues6 = (a, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp8.call(b5, prop))
      __defNormalProp6(a, prop, b5[prop]);
  if (__getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(b5)) {
      if (__propIsEnum6.call(b5, prop))
        __defNormalProp6(a, prop, b5[prop]);
    }
  return a;
};
var __spreadProps6 = (a, b5) => __defProps6(a, __getOwnPropDescs6(b5));
var __objRest6 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp8.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols6)
    for (var prop of __getOwnPropSymbols6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function parseMarginValue(value) {
  if (typeof value === "number")
    return {
      marginTop: value,
      marginBottom: value,
      marginLeft: value,
      marginRight: value
    };
  if (typeof value === "string") {
    const values2 = value.toString().trim().split(/\s+/);
    if (values2.length === 1) {
      return {
        marginTop: values2[0],
        marginBottom: values2[0],
        marginLeft: values2[0],
        marginRight: values2[0]
      };
    }
    if (values2.length === 2) {
      return {
        marginTop: values2[0],
        marginRight: values2[1],
        marginBottom: values2[0],
        marginLeft: values2[1]
      };
    }
    if (values2.length === 3) {
      return {
        marginTop: values2[0],
        marginRight: values2[1],
        marginBottom: values2[2],
        marginLeft: values2[1]
      };
    }
    if (values2.length === 4) {
      return {
        marginTop: values2[0],
        marginRight: values2[1],
        marginBottom: values2[2],
        marginLeft: values2[3]
      };
    }
  }
  return {
    marginTop: undefined,
    marginBottom: undefined,
    marginLeft: undefined,
    marginRight: undefined
  };
}
function computeMargins(properties) {
  let result = {
    marginTop: undefined,
    marginRight: undefined,
    marginBottom: undefined,
    marginLeft: undefined
  };
  for (const [key, value] of Object.entries(properties)) {
    if (key === "margin") {
      result = parseMarginValue(value);
    } else if (key === "marginTop") {
      result.marginTop = value;
    } else if (key === "marginRight") {
      result.marginRight = value;
    } else if (key === "marginBottom") {
      result.marginBottom = value;
    } else if (key === "marginLeft") {
      result.marginLeft = value;
    }
  }
  return result;
}
var Text3 = React7.forwardRef((_a5, ref) => {
  var _b2 = _a5, { style } = _b2, props = __objRest6(_b2, ["style"]);
  const defaultMargins = {};
  if ((style == null ? undefined : style.marginTop) === undefined) {
    defaultMargins.marginTop = "16px";
  }
  if ((style == null ? undefined : style.marginBottom) === undefined) {
    defaultMargins.marginBottom = "16px";
  }
  const margins = computeMargins(__spreadValues6(__spreadValues6({}, defaultMargins), style));
  return /* @__PURE__ */ import_jsx_runtime8.jsx("p", __spreadProps6(__spreadValues6({}, props), {
    ref,
    style: __spreadValues6(__spreadValues6({
      fontSize: "14px",
      lineHeight: "24px"
    }, style), margins)
  }));
});
Text3.displayName = "Text";

// src/emails/otp.tsx
function OTPEmail({
  otp,
  username,
  verifyUrl,
  supportEmail,
  brandName,
  expiresInMin
}) {
  const digits = [...otp.toString()];
  return /* @__PURE__ */ React8.createElement(Oc, null, /* @__PURE__ */ React8.createElement(Section, {
    className: "bg-slate-100 py-8"
  }, /* @__PURE__ */ React8.createElement(Container, {
    className: "mx-auto w-full max-w-[560px] px-4"
  }, /* @__PURE__ */ React8.createElement(Section, {
    className: "overflow-hidden rounded-2xl bg-white shadow-sm ring-1 ring-slate-200"
  }, /* @__PURE__ */ React8.createElement(Section, {
    className: "bg-gradient-to-r from-indigo-600 to-violet-600 px-6 py-5"
  }, /* @__PURE__ */ React8.createElement(Row, null, /* @__PURE__ */ React8.createElement(Column2, null, /* @__PURE__ */ React8.createElement("div", {
    className: "flex items-center gap-3 text-white"
  }, /* @__PURE__ */ React8.createElement("div", {
    className: "flex h-9 w-9 items-center justify-center rounded-xl bg-white/10"
  }, /* @__PURE__ */ React8.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    className: "h-5 w-5"
  }, /* @__PURE__ */ React8.createElement("path", {
    d: "M12 3l8.66 5v8L12 21l-8.66-5V8L12 3zm0 2.309L5.34 9 12 12.691 18.66 9 12 5.309z"
  }))), /* @__PURE__ */ React8.createElement("div", null, /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-[11px] uppercase tracking-wider text-white/70"
  }, "Keamanan Akun"), /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-base font-semibold text-white"
  }, "Verifikasi Kode OTP")))))), /* @__PURE__ */ React8.createElement(Section, {
    className: "px-6 py-6"
  }, /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-slate-700"
  }, "Halo, ", username), /* @__PURE__ */ React8.createElement(Text3, {
    className: "mt-3 text-slate-700"
  }, "Kami menerima permintaan untuk memverifikasi akun Anda. Masukkan kode OTP berikut pada aplikasi atau situs kami:"), /* @__PURE__ */ React8.createElement("div", {
    className: "mt-5 flex justify-center gap-2"
  }, digits.map((d2, i2) => /* @__PURE__ */ React8.createElement("span", {
    key: `${d2}-${i2}`,
    className: "flex h-12 w-10 items-center justify-center rounded-xl border border-slate-200 bg-slate-50 text-xl font-semibold tracking-widest text-slate-800"
  }, d2))), /* @__PURE__ */ React8.createElement(Text3, {
    className: "mt-4 text-sm text-slate-600"
  }, "Kode berlaku selama", " ", /* @__PURE__ */ React8.createElement("span", {
    className: "font-semibold text-slate-800"
  }, expiresInMin, " menit"), ". Jangan bagikan OTP kepada siapa pun."), /* @__PURE__ */ React8.createElement("div", {
    className: "mt-6 text-center"
  }, /* @__PURE__ */ React8.createElement(Button, {
    href: verifyUrl,
    className: "inline-block rounded-xl bg-indigo-600 px-5 py-3 text-center text-sm font-semibold text-white no-underline shadow"
  }, "Verifikasi Sekarang")), /* @__PURE__ */ React8.createElement("div", {
    className: "mt-6 rounded-xl bg-slate-50 p-4 ring-1 ring-slate-200"
  }, /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-sm text-slate-700"
  }, "Tidak meminta verifikasi? Abaikan email ini. Jika Anda punya pertanyaan, hubungi", " ", /* @__PURE__ */ React8.createElement("a", {
    href: `mailto:${supportEmail}`,
    className: "text-indigo-600 underline"
  }, supportEmail), ".")), /* @__PURE__ */ React8.createElement("div", {
    className: "mt-6"
  }, /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-[12px] text-slate-500"
  }, "Jika tombol tidak berfungsi, salin dan tempel kode ini:"), /* @__PURE__ */ React8.createElement("code", {
    className: "mt-1 inline-block rounded-lg bg-slate-100 px-2 py-1 text-sm font-semibold text-slate-800"
  }, otp))), /* @__PURE__ */ React8.createElement(Section, {
    className: "border-t border-slate-200 bg-white px-6 py-5"
  }, /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 text-[12px] text-slate-500"
  }, "Anda menerima email ini karena ada aktivitas masuk atau pendaftaran pada akun Anda."), /* @__PURE__ */ React8.createElement(Text3, {
    className: "m-0 mt-1 text-[12px] text-slate-500"
  }, "\xA9 2025 ", brandName, ", All rights reserved."))), /* @__PURE__ */ React8.createElement(Text3, {
    className: "mt-4 text-center text-[11px] leading-5 text-slate-500"
  }, "Harap jangan membalas email ini. Kotak masuk ini tidak dipantau."))));
}
OTPEmail.PreviewProps = {
  otp: "832374",
  username: "Budi",
  verifyUrl: "https://example.com/verify",
  supportEmail: "support@example.com",
  brandName: "Desa Harmoni",
  expiresInMin: 10
};

// node_modules/resend/dist/index.mjs
var import_svix = __toESM(require_dist3(), 1);
var __defProp10 = Object.defineProperty;
var __defProps7 = Object.defineProperties;
var __getOwnPropDescs7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols7 = Object.getOwnPropertySymbols;
var __hasOwnProp9 = Object.prototype.hasOwnProperty;
var __propIsEnum7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp7 = (obj, key, value) => (key in obj) ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues7 = (a, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp9.call(b5, prop))
      __defNormalProp7(a, prop, b5[prop]);
  if (__getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(b5)) {
      if (__propIsEnum7.call(b5, prop))
        __defNormalProp7(a, prop, b5[prop]);
    }
  return a;
};
var __spreadProps7 = (a, b5) => __defProps7(a, __getOwnPropDescs7(b5));
var __objRest7 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols7)
    for (var prop of __getOwnPropSymbols7(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum7.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var version4 = "6.2.1";
function buildPaginationQuery(options) {
  const searchParams = new URLSearchParams;
  if (options.limit !== undefined) {
    searchParams.set("limit", options.limit.toString());
  }
  if ("after" in options && options.after !== undefined) {
    searchParams.set("after", options.after);
  }
  if ("before" in options && options.before !== undefined) {
    searchParams.set("before", options.before);
  }
  return searchParams.toString();
}
var ApiKeys = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/api-keys", payload, options);
      return data;
    });
  }
  list() {
    return __async(this, arguments, function* (options = {}) {
      const queryString = buildPaginationQuery(options);
      const url2 = queryString ? `/api-keys?${queryString}` : "/api-keys";
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  remove(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.delete(`/api-keys/${id}`);
      return data;
    });
  }
};
var Audiences = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/audiences", payload, options);
      return data;
    });
  }
  list() {
    return __async(this, arguments, function* (options = {}) {
      const queryString = buildPaginationQuery(options);
      const url2 = queryString ? `/audiences?${queryString}` : "/audiences";
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.get(`/audiences/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.delete(`/audiences/${id}`);
      return data;
    });
  }
};
function parseAttachments(attachments) {
  return attachments == null ? undefined : attachments.map((attachment) => ({
    content: attachment.content,
    filename: attachment.filename,
    path: attachment.path,
    content_type: attachment.contentType,
    content_id: attachment.contentId
  }));
}
function parseEmailToApiOptions(email3) {
  return {
    attachments: parseAttachments(email3.attachments),
    bcc: email3.bcc,
    cc: email3.cc,
    from: email3.from,
    headers: email3.headers,
    html: email3.html,
    reply_to: email3.replyTo,
    scheduled_at: email3.scheduledAt,
    subject: email3.subject,
    tags: email3.tags,
    text: email3.text,
    to: email3.to
  };
}
function render3(node2) {
  return new Promise((resolve, reject) => {
    Promise.resolve().then(() => (init_node2(), exports_node)).then(({ render: render22 }) => {
      resolve(render22(node2));
    }).catch(() => {
      reject(Error("Failed to render React component. Make sure to install `@react-email/render` or `@react-email/components`."));
    });
  });
}
var Batch = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(payload, options) {
    return __async(this, null, function* () {
      return this.create(payload, options);
    });
  }
  create(payload, options) {
    return __async(this, null, function* () {
      var _a5;
      const emails = [];
      for (const email3 of payload) {
        if (email3.react) {
          email3.html = yield render3(email3.react);
          email3.react = undefined;
        }
        emails.push(parseEmailToApiOptions(email3));
      }
      const data = yield this.resend.post("/emails/batch", emails, __spreadProps7(__spreadValues7({}, options), {
        headers: __spreadValues7({
          "x-batch-validation": (_a5 = options == null ? undefined : options.batchValidation) != null ? _a5 : "strict"
        }, options == null ? undefined : options.headers)
      }));
      return data;
    });
  }
};
var Broadcasts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        payload.html = yield render3(payload.react);
      }
      const data = yield this.resend.post("/broadcasts", {
        name: payload.name,
        audience_id: payload.audienceId,
        preview_text: payload.previewText,
        from: payload.from,
        html: payload.html,
        reply_to: payload.replyTo,
        subject: payload.subject,
        text: payload.text
      }, options);
      return data;
    });
  }
  send(id, payload) {
    return __async(this, null, function* () {
      const data = yield this.resend.post(`/broadcasts/${id}/send`, { scheduled_at: payload == null ? undefined : payload.scheduledAt });
      return data;
    });
  }
  list() {
    return __async(this, arguments, function* (options = {}) {
      const queryString = buildPaginationQuery(options);
      const url2 = queryString ? `/broadcasts?${queryString}` : "/broadcasts";
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.get(`/broadcasts/${id}`);
      return data;
    });
  }
  remove(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.delete(`/broadcasts/${id}`);
      return data;
    });
  }
  update(id, payload) {
    return __async(this, null, function* () {
      if (payload.react) {
        payload.html = yield render3(payload.react);
      }
      const data = yield this.resend.patch(`/broadcasts/${id}`, {
        name: payload.name,
        audience_id: payload.audienceId,
        from: payload.from,
        html: payload.html,
        text: payload.text,
        subject: payload.subject,
        reply_to: payload.replyTo,
        preview_text: payload.previewText
      });
      return data;
    });
  }
};
var Contacts = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post(`/audiences/${payload.audienceId}/contacts`, {
        unsubscribed: payload.unsubscribed,
        email: payload.email,
        first_name: payload.firstName,
        last_name: payload.lastName
      }, options);
      return data;
    });
  }
  list(options) {
    return __async(this, null, function* () {
      const _a5 = options, { audienceId } = _a5, paginationOptions = __objRest7(_a5, ["audienceId"]);
      const queryString = buildPaginationQuery(paginationOptions);
      const url2 = queryString ? `/audiences/${audienceId}/contacts?${queryString}` : `/audiences/${audienceId}/contacts`;
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  get(options) {
    return __async(this, null, function* () {
      if (!options.id && !options.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            statusCode: null,
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.get(`/audiences/${options.audienceId}/contacts/${(options == null ? undefined : options.email) ? options == null ? undefined : options.email : options == null ? undefined : options.id}`);
      return data;
    });
  }
  update(options) {
    return __async(this, null, function* () {
      if (!options.id && !options.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            statusCode: null,
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.patch(`/audiences/${options.audienceId}/contacts/${(options == null ? undefined : options.email) ? options == null ? undefined : options.email : options == null ? undefined : options.id}`, {
        unsubscribed: options.unsubscribed,
        first_name: options.firstName,
        last_name: options.lastName
      });
      return data;
    });
  }
  remove(payload) {
    return __async(this, null, function* () {
      if (!payload.id && !payload.email) {
        return {
          data: null,
          error: {
            message: "Missing `id` or `email` field.",
            statusCode: null,
            name: "missing_required_field"
          }
        };
      }
      const data = yield this.resend.delete(`/audiences/${payload.audienceId}/contacts/${(payload == null ? undefined : payload.email) ? payload == null ? undefined : payload.email : payload == null ? undefined : payload.id}`);
      return data;
    });
  }
};
function parseDomainToApiOptions(domain2) {
  return {
    name: domain2.name,
    region: domain2.region,
    custom_return_path: domain2.customReturnPath
  };
}
var Domains = class {
  constructor(resend) {
    this.resend = resend;
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      const data = yield this.resend.post("/domains", parseDomainToApiOptions(payload), options);
      return data;
    });
  }
  list() {
    return __async(this, arguments, function* (options = {}) {
      const queryString = buildPaginationQuery(options);
      const url2 = queryString ? `/domains?${queryString}` : "/domains";
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.get(`/domains/${id}`);
      return data;
    });
  }
  update(payload) {
    return __async(this, null, function* () {
      const data = yield this.resend.patch(`/domains/${payload.id}`, {
        click_tracking: payload.clickTracking,
        open_tracking: payload.openTracking,
        tls: payload.tls
      });
      return data;
    });
  }
  remove(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.delete(`/domains/${id}`);
      return data;
    });
  }
  verify(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.post(`/domains/${id}/verify`);
      return data;
    });
  }
};
var Emails = class {
  constructor(resend) {
    this.resend = resend;
  }
  send(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      return this.create(payload, options);
    });
  }
  create(_0) {
    return __async(this, arguments, function* (payload, options = {}) {
      if (payload.react) {
        payload.html = yield render3(payload.react);
      }
      const data = yield this.resend.post("/emails", parseEmailToApiOptions(payload), options);
      return data;
    });
  }
  get(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.get(`/emails/${id}`);
      return data;
    });
  }
  list() {
    return __async(this, arguments, function* (options = {}) {
      const queryString = buildPaginationQuery(options);
      const url2 = queryString ? `/emails?${queryString}` : "/emails";
      const data = yield this.resend.get(url2);
      return data;
    });
  }
  update(payload) {
    return __async(this, null, function* () {
      const data = yield this.resend.patch(`/emails/${payload.id}`, {
        scheduled_at: payload.scheduledAt
      });
      return data;
    });
  }
  cancel(id) {
    return __async(this, null, function* () {
      const data = yield this.resend.post(`/emails/${id}/cancel`);
      return data;
    });
  }
};
var Webhooks = class {
  verify(payload) {
    const webhook = new import_svix.Webhook(payload.webhookSecret);
    return webhook.verify(payload.payload, {
      "svix-id": payload.headers.id,
      "svix-timestamp": payload.headers.timestamp,
      "svix-signature": payload.headers.signature
    });
  }
};
var defaultBaseUrl = "https://api.resend.com";
var defaultUserAgent = `resend-node:${version4}`;
var baseUrl = typeof process !== "undefined" && process.env ? process.env.RESEND_BASE_URL || defaultBaseUrl : defaultBaseUrl;
var userAgent = typeof process !== "undefined" && process.env ? process.env.RESEND_USER_AGENT || defaultUserAgent : defaultUserAgent;
var Resend = class {
  constructor(key) {
    this.key = key;
    this.apiKeys = new ApiKeys(this);
    this.audiences = new Audiences(this);
    this.batch = new Batch(this);
    this.broadcasts = new Broadcasts(this);
    this.contacts = new Contacts(this);
    this.domains = new Domains(this);
    this.emails = new Emails(this);
    this.webhooks = new Webhooks;
    if (!key) {
      if (typeof process !== "undefined" && process.env) {
        this.key = process.env.RESEND_API_KEY;
      }
      if (!this.key) {
        throw new Error('Missing API key. Pass it to the constructor `new Resend("re_123")`');
      }
    }
    this.headers = new Headers({
      Authorization: `Bearer ${this.key}`,
      "User-Agent": userAgent,
      "Content-Type": "application/json"
    });
  }
  fetchRequest(_0) {
    return __async(this, arguments, function* (path, options = {}) {
      try {
        const response = yield fetch(`${baseUrl}${path}`, options);
        if (!response.ok) {
          try {
            const rawError = yield response.text();
            return { data: null, error: JSON.parse(rawError) };
          } catch (err2) {
            if (err2 instanceof SyntaxError) {
              return {
                data: null,
                error: {
                  name: "application_error",
                  statusCode: response.status,
                  message: "Internal server error. We are unable to process your request right now, please try again later."
                }
              };
            }
            const error40 = {
              message: response.statusText,
              statusCode: response.status,
              name: "application_error"
            };
            if (err2 instanceof Error) {
              return { data: null, error: __spreadProps7(__spreadValues7({}, error40), { message: err2.message }) };
            }
            return { data: null, error: error40 };
          }
        }
        const data = yield response.json();
        return { data, error: null };
      } catch (e2) {
        return {
          data: null,
          error: {
            name: "application_error",
            statusCode: null,
            message: "Unable to fetch data. The request could not be resolved."
          }
        };
      }
    });
  }
  post(_0, _1) {
    return __async(this, arguments, function* (path, entity, options = {}) {
      const headers = new Headers(this.headers);
      if (options.headers) {
        for (const [key, value] of new Headers(options.headers).entries()) {
          headers.set(key, value);
        }
      }
      if (options.idempotencyKey) {
        headers.set("Idempotency-Key", options.idempotencyKey);
      }
      const requestOptions = __spreadProps7(__spreadValues7({
        method: "POST",
        body: JSON.stringify(entity)
      }, options), {
        headers
      });
      return this.fetchRequest(path, requestOptions);
    });
  }
  get(_0) {
    return __async(this, arguments, function* (path, options = {}) {
      const headers = new Headers(this.headers);
      if (options.headers) {
        for (const [key, value] of new Headers(options.headers).entries()) {
          headers.set(key, value);
        }
      }
      const requestOptions = __spreadProps7(__spreadValues7({
        method: "GET"
      }, options), {
        headers
      });
      return this.fetchRequest(path, requestOptions);
    });
  }
  put(_0, _1) {
    return __async(this, arguments, function* (path, entity, options = {}) {
      const headers = new Headers(this.headers);
      if (options.headers) {
        for (const [key, value] of new Headers(options.headers).entries()) {
          headers.set(key, value);
        }
      }
      const requestOptions = __spreadProps7(__spreadValues7({
        method: "PUT",
        body: JSON.stringify(entity)
      }, options), {
        headers
      });
      return this.fetchRequest(path, requestOptions);
    });
  }
  patch(_0, _1) {
    return __async(this, arguments, function* (path, entity, options = {}) {
      const headers = new Headers(this.headers);
      if (options.headers) {
        for (const [key, value] of new Headers(options.headers).entries()) {
          headers.set(key, value);
        }
      }
      const requestOptions = __spreadProps7(__spreadValues7({
        method: "PATCH",
        body: JSON.stringify(entity)
      }, options), {
        headers
      });
      return this.fetchRequest(path, requestOptions);
    });
  }
  delete(path, query) {
    return __async(this, null, function* () {
      const requestOptions = {
        method: "DELETE",
        body: JSON.stringify(query),
        headers: this.headers
      };
      return this.fetchRequest(path, requestOptions);
    });
  }
};

// src/modules/profiles/index.ts
var resend = new Resend(process.env.RESEND_API_KEY);
var otpStore = new Map;
var profileController = new Elysia({ prefix: "/profile" }).get("/otp", async ({ query, server }) => {
  const to4 = query.to;
  const baseURL = server.url.origin;
  const otp = (Math.floor(Math.random() * 900000) + 1e5).toString();
  const expiresAt = Date.now() + 10 * 60 * 1000;
  otpStore.set(to4, { otp, expiresAt });
  const html = $renderToStaticMarkup(React9.createElement(OTPEmail, {
    otp,
    verifyUrl: `${baseURL}/api/v1/profile/otp/verify?email=${to4}`,
    supportEmail: "surajidk12@gmail.com",
    brandName: "Todo List",
    expiresInMin: 10
  }));
  await resend.emails.send({
    from: "onboarding@resend.dev",
    to: to4,
    subject: "Your verification code",
    html
  });
  return { success: true, message: "OTP sent" };
}, {
  query: t.Object({ to: t.String({ format: "email" }) })
}).get("/otp/verify", async ({ query, status: status2 }) => {
  const email3 = query.email;
  const user = await verifyEmail(email3?.toString() || "");
  if (!user) {
    return status2(400), { error: "Email not registered" };
  }
  return status2(200), { message: `Verify email: ${email3}` };
}).post("/otp/verify", async ({ body }) => {
  const { to: to4, otp: otpInput } = body;
  const record2 = otpStore.get(to4);
  if (!record2) {
    return { success: false, error: "OTP not found or expired" };
  }
  const isExpired = Date.now() > record2.expiresAt;
  if (isExpired) {
    otpStore.delete(to4);
    return { success: false, error: "OTP expired" };
  }
  if (record2.otp !== otpInput) {
    return { success: false, error: "Invalid OTP" };
  }
  const user = await verifyEmail(to4);
  if (!user) {
    return { success: false, error: "Email not registered" };
  }
  otpStore.delete(to4);
  return { success: true, message: "OTP verified" };
}, {
  body: t.Object({
    to: t.String({ format: "email" }),
    otp: t.String()
  })
});

// src/server.ts
new Elysia().use(index_default3()).use(index_default()).get("/", () => {
  console.log("Elysia API accessed");
  return "Elysia API is running!";
}).group("/api/v1", (app) => app.use(authController).guard(authGuard).use(profileController).get("/me", async ({ jwt: jwt3, status: status2, bearer: bearer2 }) => {
  const verifyToken = await jwt3.verify(bearer2);
  if (!verifyToken)
    return status2(401), { error: "Unauthorized" };
  return { message: "Authenticated", user: verifyToken };
})).listen(3000);
console.log("\uD83D\uDE80 Server running on http://localhost:3000");
